This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: docs
- Files matching these patterns are excluded: **/*.svg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  ai-coding/
    overview.mdx
  api/
    subgraph/
      guides/
        _category_.json
        v3-subgraph-example.md
        v4-subgraph-example.md
      subgraphs-devs/
        contracts/
          _category_.json
          factory.md
          nonfungiblepositionmanager.md
          pool.md
        functions-n-handlers/
          mappings/
            _category_.json
            core.ts.md
            factory.ts.md
            position-manager.ts.md
          utils/
            _category_.json
            backfill.ts.md
            constants.ts.md
            index.ts.md
            intervalUpdates.ts.md
            pricing.ts.md
            staticTokenDefinition.ts.md
            tick.ts.md
            token.ts.md
          _category_.json
          poolMapping.ts.md
        schemas/
          _category_.json
          bundle.md
          burn.md
          collect.md
          factory.md
          flash.md
          mint.md
          pool.md
          pooldaydata.md
          poolhourdata.md
          position.md
          positionsnapshot.md
          swap.md
          tick.md
          tickdaydata.md
          tickhourdata.md
          token.md
          tokendaydata.md
          tokenhourdata.md
          transaction.md
          uniswapdaydata.md
        _category_.json
        all-entities.md
        events.md
        intro.md
        links-n-resources.md
        subgraph-configs.md
      _category_.json
      overview.md
    overview.md
  archived/
    07-changelog.md
  builder-support/
    get-funded.mdx
    security-resources.mdx
    uf-ambassadors.mdx
  concepts/
    governance/
      images/
        Delegate_Button.png
        Delegate_Selection.png
        Delegate_To_Self.png
        Proposal_Active.png
        Proposal_Flow.png
        Proposals_Overview.png
        Vote_Confirmation.png
      _category_.json
      adversarial-circumstances.md
      glossary.md
      guide-to-voting.md
      overview.md
      process.md
    protocol/
      images/
        AddLiquidity.gif
        AllowandApprove.gif
        Approve.gif
        DepositAmounts.gif
        Migrate.gif
        RangeOrder1.png
        RangeOrder2.png
        SelectaPair.gif
        SelectFeeTier.gif
        SelectFeeTierMigrate.gif
        SetPriceRange.gif
        SetRange.gif
      _category_.json
      concentrated-liquidity.md
      fees.md
      hooks.md
      integration-issues.md
      oracle.md
      range-orders.md
      swaps.md
    glossary.md
    research.md
    resources.md
    uniswap-protocol.md
    what-is-uniswap.md
  contracts/
    liquidity-launchpad/
      images/
        exitBidDiagram.png
        TokenLauncherOverview.png
      _category_.json
      01-introduction.md
      05-auction-mechanism.md
    permit2/
      reference/
        _category_.json
        allowance-transfer.md
        signature-transfer.md
      _category_.json
      overview.md
    protocol-fee/
      guides/
        _category_.json
        best-practices.mdx
        getting-started.mdx
        read-asset-balance.mdx
      technical-reference/
        _category_.json
        ArrayLib.md
        Deployer.md
        ExchangeReleaser.md
        Firepit.md
        FirepitDestination.md
        FirepitSource.md
        IFirepitDestination.md
        IL1CrossDomainMessenger.md
        INonce.md
        IOwned.md
        IReleaser.md
        IResourceManager.md
        ITokenJar.md
        IUniswapV3FactoryOwnerActions.md
        IUniswapV3PoolOwnerActions.md
        IV3FeeAdapter.md
        Nonce.md
        OPStackFirepitSource.md
        ResourceManager.md
        TokenJar.md
        UnauthorizedCall.md
        V3FeeAdapter.md
        V4FeeAdapter.md
      _category_.json
      deployments.mdx
      fee-setting-rational.mdx
      overview.mdx
    smart-wallet/
      advanced-usage/
        _category_.json
        01-alternative-signer.md
        02-hooks.md
        03-erc-7739.md
        04-erc-7914.md
      concepts/
        _category_.json
        01-delegation.md
        02-batched-transactions.md
        03-gas-transactions.md
      _category_.json
      01-overview.md
      02-deployments.md
      03-technical-reference.md
    the-compact/
      reference/
        _category_.json
        allocators.md
        arbiters.md
        compacts-eip712.md
        core-interfaces.md
        periphery-contracts.md
        resource-locks.md
      _category_.json
      overview.md
      resources.md
    uniswapx/
      fillers/
        arbitrum/
          _category_.json
          arbitrumfiller.md
        mainnet/
          _category_.json
          becomeQuoter.md
          createFiller.md
          uniswapXrfq.md
        priority/
          _category_.json
          priorityorderreactor.md
        _category_.json
        filleroverview.md
        webhooks.md
      images/
        cosigner.png
        mainnet_flowchart.png
        Uniswapx_graph.png
        UniswapX.png
        v1-flow.png
        v2-flow.png
      _category_.json
      01-overview.md
      02-architecture.md
      03-auction-types.md
      04-deployments.md
    universal-router/
      _category_.json
      01-overview.md
      02-technical-reference.md
    v1/
      guides/
        _category_.json
        01-connect-to-uniswap.md
        02-pool-liquidity.md
        03-trade-tokens.md
        04-custom-linking.md
        05-iframe-integration.md
        06-token-listing.md
      reference/
        _category_.json
        01-factory.md
        02-exchange.md
        03-interfaces.md
      _category_.json
      overview.md
    v2/
      concepts/
        01-protocol-overview/
          images/
            anatomy.jpg
            how-works.jpg
            lp.jpg
            participants.jpg
            trade.jpg
          _category_.json
          01-how-uniswap-works.md
          02-ecosystem-participants.md
          03-smart-contracts.md
          04-glossary.md
        02-core-concepts/
          images/
            anatomy.jpg
            how-works.jpg
            lp.jpg
            pool.jpg
            trade.jpg
            v2_onchain_price_data.png
            v2_twap.png
          _category_.json
          01-swaps.md
          02-pools.md
          03-flash-swaps.md
          04-oracles.md
        03-advanced-topics/
          _category_.json
          01-fees.md
          02-pricing.md
          03-understanding-returns.md
          04-security.md
          05-math.md
          06-research.md
        _category_.json
      guides/
        interface-integration/
          _category_.json
          01-using-the-api.md
          02-custom-interface-linking.md
          03-iframe-integration.mdx
        smart-contract-integration/
          _category_.json
          01-quick-start.md
          02-trading-from-a-smart-contract.md
          03-providing-liquidity.md
          04-building-an-oracle.md
          05-using-flash-swaps.md
          06-getting-pair-addresses.md
          07-supporting-meta-transactions.md
        _category_.json
      reference/
        API/
          _category_.json
          01-overview.md
          02-entities.md
          03-queries.md
        Governance/
          images/
            Delegate_To_Address.png
            gov_diagram-1.png
            Proposal_Active.png
            Proposal_Executed.png
            Proposals_Overview.png
            Submitting_Vote.png
            Unlock_Voting.png
            Unlocking_Votes.png
            Voting.png
          _category_.json
          governance-reference.md
        smart-contracts/
          _category_.json
          01-factory.md
          02-pair.md
          03-pair-erc-20.md
          04-library.md
          05-router01.md
          06-router02.md
          07-common-errors.md
          08-deployment-addresses.md
        _category_.json
      _category_.json
      overview.md
    v3/
      concepts/
        _category_.json
        security.md
      guides/
        flash-integrations/
          _category_.json
          calling-flash.md
          final-contract.md
          flash-callback.md
          Inheritance-constructors.md
        governance/
          _category_.json
          license-modifications.md
        liquidity-mining/
          _category_.json
          overview.md
        providing-liquidity/
          _category_.json
          collect-fees.md
          decrease-liquidity.md
          increase-liquidity.md
          mint-a-new-position.md
          setting-up-your-contract.md
          the-full-contract.md
        swaps/
          _category_.json
          multihop-swaps.md
          single-swaps.md
        _category_.json
        local-environment.mdx
      reference/
        core/
          interfaces/
            callback/
              IUniswapV3FlashCallback.md
              IUniswapV3MintCallback.md
              IUniswapV3SwapCallback.md
            pool/
              _category_.json
              IUniswapV3PoolActions.md
              IUniswapV3PoolDerivedState.md
              IUniswapV3PoolEvents.md
              IUniswapV3PoolImmutables.md
              IUniswapV3PoolOwnerActions.md
              IUniswapV3PoolState.md
            _category_.json
            IERC20Minimal.md
            IUniswapV3Factory.md
            IUniswapV3Pool.md
            IUniswapV3PoolDeployer.md
          libraries/
            _category_.json
            BitMath.md
            FixedPoint128.md
            FixedPoint96.md
            FullMath.md
            LiquidityMath.md
            LowGasSafeMath.md
            Oracle.md
            Position.md
            SafeCast.md
            SecondsOutside.md
            SqrtPriceMath.md
            SwapMath.md
            Tick.md
            TickBitmap.md
            TickMath.md
            TransferHelper.md
            UnsafeMath.md
          _category_.json
          UniswapV3Factory.md
          UniswapV3Pool.md
          UniswapV3PoolDeployer.md
        deployments/
          _category_.json
          Arbitrum-Deployments.md
          AVAX-Deployments.md
          Base-Deployments.md
          Blast-Deployments.md
          BNB-Binance-Deployments.md
          Celo-Deployments.md
          deployments.md
          Ethereum-Deployments.md
          Optimism-Deployments.md
          Polygon-Deployments.md
          Unichain-Deployments.md
          WorldChain-Deployments.md
          ZKsync-Deployments.md
          Zora-Deployments.md
        governance/
          images/
            gov_diagram-1.png
          _category_.json
          overview.md
        periphery/
          base/
            _category_.json
            BlockTimestamp.md
            ERC721Permit.md
            LiquidityManagement.md
            Multicall.md
            PeripheryImmutableState.md
            PeripheryPayments.md
            PeripheryPaymentsWithFee.md
            PoolInitializer.md
            SelfPermit.md
          interfaces/
            external/
              IERC1271.md
              IERC20PermitAllowed.md
              IWETH9.md
            _category_.json
            IERC20Metadata.md
            IERC721Permit.md
            IMulticall.md
            INonfungiblePositionManager.md
            INonfungibleTokenPositionDescriptor.md
            IPeripheryImmutableState.md
            IPeripheryPayments.md
            IPeripheryPaymentsWithFee.md
            IPoolInitializer.md
            IQuoter.md
            IQuoterV2.md
            ISelfPermit.md
            ISwapRouter.md
            ITickLens.md
            IV3Migrator.md
          lens/
            _category_.json
            Quoter.md
            QuoterV2.md
            TickLens.md
          libraries/
            _category_.json
            Base64.md
            BytesLib.md
            CallbackValidation.md
            ChainId.md
            HexStrings.md
            LiquidityAmounts.md
            NFTDescriptor.md
            NFTSVG.md
            OracleLibrary.md
            Path.md
            PoolAddress.md
            PoolTicksCounter.md
            PositionKey.md
            TokenRatioSortOrder.md
            TransferHelper.md
            WeightedOracleLibrary.md
          staker/
            interfaces/
              _category_.json
              IUniswapV3Staker.md
            libraries/
              _category_.json
              IncentiveId.md
              NFTPositionInfo.md
              RewardMath.md
            _category_.json
            Design.md
            UniswapV3Staker.md
          test/
            _category_.json
            Base64Test.md
            LiquidityAmountsTest.md
            MockTimeNonfungiblePositionManager.md
            MockTimeSwapRouter.md
            NFTDescriptorTest.md
            PathTest.md
            PeripheryImmutableStateTest.md
            PoolAddressTest.md
            SelfPermitTest.md
            TestCallbackValidation.md
            TestERC20.md
            TestERC20Metadata.md
            TestERC20PermitAllowed.md
            TestMulticall.md
            TestPositionNFTOwner.md
            TestUniswapV3Callee.md
            TickLensTest.md
          _category_.json
          NonfungiblePositionManager.md
          NonfungibleTokenPositionDescriptor.md
          SwapRouter.md
          V3Migrator.md
        _category_.json
        error-codes.md
        overview.md
      _category_.json
      overview.md
    v4/
      concepts/
        images/
          Uniswap_V4_Dynamic_Fees_Step_1.jpg
          Uniswap_V4_Dynamic_Fees_Step_2.jpg
          Uniswap_V4_Flash_Accounting_Step_1.png
          Uniswap_V4_Flash_Accounting_Step_2.png
          Uniswap_V4_Locking_Mechanism_Step_1.png
          Uniswap_V4_Locking_Mechanism_Step_2.png
          Uniswap_V4_Locking_Mechanism_Step_3.png
          Uniswap_V4_Multihop_Swaps.png
        _category_.json
        dynamic-fees.mdx
        erc6909.mdx
        fee-structure.mdx
        flash-accounting.mdx
        hooks.mdx
        integrated-routing-uniswap-x.mdx
        PoolManager.mdx
        security.mdx
        subscribers.mdx
        v4-vs-v3.mdx
      guides/
        hooks/
          _category_.json
          hook-deployment.mdx
          your-first-hook.md
        _category_.json
        15-calculate-lp-fees.mdx
        16-subscriber.mdx
        accessing-msg.sender-using-hook.mdx
        custom-accounting.mdx
        ERC-6909.mdx
        flash-accounting.mdx
        position-manager.mdx
        read-pool-state.mdx
        state-view.mdx
        swap-routing.mdx
        unlock-callback.mdx
      quickstart/
        hooks/
          _category_.json
          async-swap.mdx
          liquidity.mdx
          setup.mdx
          swap.mdx
        manage-liquidity/
          _category_.json
          batch-liquidity.mdx
          burn-liquidity.mdx
          collect.mdx
          decrease-liquidity.mdx
          increase-liquidity.mdx
          mint-position.mdx
          setup-liquidity.mdx
        _category_.json
        create-pool.mdx
        subscriber.mdx
        swap.mdx
      reference/
        core/
          interfaces/
            IERC20Minimal.md
            IERC6909Claims.md
            IExtsload.md
            IExttload.md
            IHooks.md
            IPoolManager.md
            IProtocolFees.md
            IUnlockCallback.md
          libraries/
            _category_.json
            BitMath.md
            CurrencyDelta.md
            CurrencyReserves.md
            CustomRevert.md
            FixedPoint128.md
            FixedPoint96.md
            FullMath.md
            Hooks.md
            liquidity-amounts.mdx
            LiquidityMath.md
            Lock.md
            LPFeeLibrary.md
            NonzeroDeltaCount.md
            ParseBytes.md
            Pool.md
            Position.md
            ProtocolFeeLibrary.md
            SafeCast.md
            SqrtPriceMath.md
            StateLibrary.md
            SwapMath.md
            TickBitmap.md
            TickMath.md
            transient-state-library.mdx
            TransientStateLibrary.md
            UnsafeMath.md
          test/
            ActionsRouter.md
            BaseTestHooks.md
            CurrencyTest.md
            CustomCurveHook.md
            DeltaReturningHook.md
            DynamicFeesTestHook.md
            DynamicReturnFeeTestHook.md
            EmptyRevertContract.md
            EmptyTestHooks.md
            FeeTakingHook.md
            Fuzzers.md
            HooksTest.md
            LiquidityMathTest.md
            LPFeeTakingHook.md
            MockContract.md
            MockERC6909Claims.md
            MockHooks.md
            NativeERC20.md
            NoDelegateCallTest.md
            PoolClaimsTest.md
            PoolDonateTest.md
            PoolEmptyUnlockTest.md
            PoolModifyLiquidityTest.md
            PoolModifyLiquidityTestNoChecks.md
            PoolNestedActionsTest.md
            PoolSwapTest.md
            PoolTakeTest.md
            PoolTestBase.md
            ProtocolFeesImplementation.md
            ProxyPoolManager.md
            SkipCallsTestHook.md
            SqrtPriceMathEchidnaTest.md
            SwapRouterNoChecks.md
            TestERC20.md
            TestInvalidERC20.md
            TickMathEchidnaTest.md
            TickMathTest.md
            TickOverflowSafetyEchidnaTest.md
          types/
            _category_.json
            balancedelta-guide.mdx
            BalanceDelta.md
            beforeswapdelta-guide.mdx
            BeforeSwapDelta.md
            currency-guide.mdx
            Currency.md
            PoolId.md
            poolkey-guide.mdx
            PoolKey.md
            Slot0.md
          _category_.json
          ERC6909.md
          ERC6909Claims.md
          Extsload.md
          Exttload.md
          IPoolManager.mdx
          NoDelegateCall.md
          PoolManager.md
          ProtocolFees.md
        errors/
          _category_.json
          errors.mdx
        periphery/
          base/
            BaseActionsRouter.md
            BaseV4Quoter.md
            DeltaResolver.md
            EIP712_v4.md
            ERC721Permit_v4.md
            ImmutableState.md
            Multicall_v4.md
            NativeWrapper.md
            Notifier.md
            Permit2Forwarder.md
            PoolInitializer_v4.md
            ReentrancyLock.md
            SafeCallback.md
            UnorderedNonce.md
          interfaces/
            IEIP712_v4.md
            IERC721Permit_v4.md
            IImmutableState.md
            IMulticall_v4.md
            INotifier.md
            IPermit2Forwarder.md
            IPoolInitializer_v4.md
            IPositionDescriptor.md
            IPositionManager.md
            IStateView.md
            ISubscriber.md
            IUniswapV4DeployerCompetition.md
            IUnorderedNonce.md
            IV4Quoter.md
            IV4Router.md
            IWETH9.md
          lens/
            StateView.md
            V4Quoter.md
          libraries/
            ActionConstants.md
            Actions.md
            AddressStringUtil.md
            BipsLibrary.md
            CalldataDecoder.md
            CurrencyRatioSortOrder.md
            Descriptor.md
            ERC721PermitHash.md
            HexStrings.md
            LiquidityAmounts.md
            Locker.md
            PathKey.md
            PositionConfig.md
            PositionConfigId.md
            PositionInfoLibrary.md
            QuoterRevert.md
            SafeCurrencyMetadata.md
            SlippageCheck.md
            SVG.md
            VanityAddressLib.md
          utils/
            BaseHook.md
          _category_.json
          PositionDescriptor.md
          PositionManager.md
          UniswapV4DeployerCompetition.md
          V4Router.md
        _category_.json
      _category_.json
      deployments.mdx
      overview.mdx
  llms/
    overview.md
  sdk/
    core/
      reference/
        classes/
          CurrencyAmount.md
          Ether.md
          Fraction.md
          NativeCurrency.md
          Percent.md
          Price.md
          Token.md
        enums/
          ChainId.md
          NativeCurrencyName.md
          Rounding.md
          TradeType.md
        _category_.json
        modules.md
        overview.md
        README.md
      _category_.json
      overview.md
    v1/
      guides/
        _category_.json
        getting-started.md
      reference/
        _category_.json
        02-data.md
        03-computation.md
        04-format.md
        05-orchestration.md
        06-transact.md
        07-constants.md
        08-types.md
      _category_.json
      overview.md
    v2/
      guides/
        _category_.json
        01-quick-start.md
        02-fetching-data.md
        03-pricing.md
        04-trading.md
        05-getting-pair-addresses.md
      reference/
        _category_.json
        01-getting-started.md
        02-pair.md
        03-route.md
        04-trade.md
        05-other-exports.md
      _category_.json
      overview.md
    v3/
      guides/
        advanced/
          images/
            liquidityNetComparison.png
            range-order.png
            tickBitmap_cut.png
            tickBitmap-etherscan.png
          _category_.json
          01-introduction.md
          02-pool-data.md
          03-active-liquidity.md
          04-price-oracle.md
          05-range-orders.md
        images/
          anvil-result.png
          postman-chainid-result.png
        liquidity/
          _category_.json
          01-position-data.md
          02-minting-position.md
          03-fetching-positions.md
          04-modifying-position.md
          05-collecting-fees.md
          06-swap-and-add-liquidity.md
        swaps/
          _category_.json
          01-quoting.md
          02-trading.md
          03-routing.md
        _category_.json
        01-background.md
        02-local-development.md
        03-web3-development-basics.md
      reference/
        classes/
          FullMath.md
          LiquidityMath.md
          Multicall.md
          NonfungiblePositionManager.md
          NoTickDataProvider.md
          Payments.md
          Pool.md
          Position.md
          PositionLibrary.md
          Route.md
          SelfPermit.md
          SqrtPriceMath.md
          Staker.md
          SwapMath.md
          SwapQuoter.md
          SwapRouter.md
          Tick.md
          TickLibrary.md
          TickList.md
          TickListDataProvider.md
          TickMath.md
          Trade.md
        enums/
          FeeAmount.md
        interfaces/
          AllowedPermitArguments.md
          BestTradeOptions.md
          ClaimOptions.md
          CollectOptions.md
          CommonAddLiquidityOptions.md
          FeeOptions.md
          IncentiveKey.md
          IncreaseSpecificOptions.md
          MethodParameters.md
          MintSpecificOptions.md
          NFTPermitOptions.md
          QuoteOptions.md
          RemoveLiquidityOptions.md
          SafeTransferOptions.md
          StandardPermitArguments.md
          SwapOptions.md
          TickConstructorArgs.md
          TickDataProvider.md
          WithdrawOptions.md
        _category_.json
        overview.md
      _category_.json
      overview.md
    v4/
      guides/
        advanced/
          images/
            tickBitmap_cut.png
            tickBitmap-etherscan.png
          _category_.json
          create-pool.md
          pool-data.md
        liquidity/
          _category_.json
          add-remove-liquidity.md
          collecting-fees.md
          fetching-positions.md
          minting-position.md
        swaps/
          _category_.json
          multi-hop-swapping.md
          quoting.md
          single-hop-swapping.md
        _category_.json
      reference/
        classes/
          Hook.md
          Pool.md
          Position.md
          Route.md
          Trade.md
          V4BaseActionsParser.md
          V4Planner.md
          V4PositionManager.md
          V4PositionPlanner.md
        enumerations/
          Actions.md
          HookOptions.md
          Subparser.md
        interfaces/
          AllowanceTransferPermitBatch.md
          AllowanceTransferPermitSingle.md
          BatchPermitOptions.md
          BestTradeOptions.md
          CollectSpecificOptions.md
          CommonAddLiquidityOptions.md
          CommonOptions.md
          MethodParameters.md
          MintSpecificOptions.md
          ModifyPositionSpecificOptions.md
          NFTPermitData.md
          NFTPermitOptions.md
          NFTPermitValues.md
          PermitDetails.md
          RemoveLiquiditySpecificOptions.md
          TransferOptions.md
        _category_.json
        overview.md
      _category_.json
      overview.md
    web3-react/
      guides/
        _category_.json
        connect-wallet.md
        connectors.md
        switch-chains.md
      _category_.json
      overview.md
  universal-router-legacy/
    overview.md
    technical-reference.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/ai-coding/overview.mdx">
---
title: Using LLMs.txt or LLMs-full.txt
description: Uniswap docs are LLM-ready and help developers build on Uniswap v4 faster and more efficiently.
---

## Understanding Context Windows

AI models have a context window, which is the amount of text they can process at once. This is typically the number of tokens that can be processed in a single request (more like it's memory capacity).
Once the context window fills up, parts of your conversational history may be lost.

It is exactly for this reason, providing relevant context upfront is critical.

## llms.txt and llms-full.txt

Depending on the model's context window, you can either use llms.txt or llms-full.txt. Most of the modern models have a [context window of about 100k tokens](https://codingscape.com/blog/llms-with-largest-context-windows).

For most cases we are good to go with llms.txt as it is more compact and provides the LLM with necessary information about links from the documentation and what it does.

If you are using a model with a larger context window, you can use llms-full.txt. It is a more verbose version of llms.txt and provides the LLM with more information about the documentation.

## Using llms.txt or llms-full.txt file

You can provide your code editor with a llms.txt or llms-full.txt file to use Unichain docs as a context for your code.

Here's how to do it for some common code editors:

#### Cursor
1. Navigate to Cursor Settings > Features > Docs
2. Select “Add new doc” and paste the following URL:
```
https://docs.uniswap.org/v4-llms.txt
```
or

```
https://docs.uniswap.org/v4-llms-full.txt
```
3. Use @docs -> Uniswap to reference Uniswap docs in your chat.

#### Windsurf

Windsurf doesn't have a permanent settings menu for adding documentation context, so you need to reference it in each conversation where you want to use it.
1. You can directly add it to the Cascade window (CMD+L) using:
```
@docs:https://docs.uniswap.org/v4-llms.txt
```
or

```
@docs:https://docs.uniswap.org/v4-llms-full.txt
```
</file>

<file path="docs/api/subgraph/guides/_category_.json">
{
  "label": "Guides",
  "position": 2,
  "collapsed": false
}
</file>

<file path="docs/api/subgraph/guides/v3-subgraph-example.md">
---
id: v3-examples
title: v3 Protocol Query Examples
sidebar_position: 1
---

## Subgraph Query Examples

This doc will teach you how to query Uniswap v3 analytics by writing GraphQL queries on the subgraph. You can fetch data points like :

- [collected fees for a position](#general-position-data)
- [current liquidity](#pool-data) of a pool
- [volume on a certain day](#historical-global-data)

and much more. Below are some example queries. To run a query copy and paste it into the [v3 explorer](https://thegraph.com/explorer/subgraphs/5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV?view=Query&chain=arbitrum-one) to get fresh data.

## Global Data

Global data refers to data points about the Uniswap v3 protocol as a whole. Some examples of global data points are:
- Total value locked in the protocol,
- Total pools deployed,
- Total transaction counts. 

Thus, to query global data you must pass in the Uniswap v3 Factory address `0x1F98431c8aD98523631AE4a59f267346ea31F984` and select the desired fields. Reference the full [factory schema](https://github.com/Uniswap/v3-subgraph/blob/main/src/v3/schema.graphql#L1) to see all possible fields.

### Current Global Data

An example querying total pool count, transaction count, and total volume in USD and ETH:

```
{
  factory(id: "0x1F98431c8aD98523631AE4a59f267346ea31F984" ) {
    poolCount
    txCount
    totalVolumeUSD
    totalVolumeETH
  }
}
```

### Historical Global Data

You can also query historical data by specifying a block number.

```
{
  factory(
    id: "0x1F98431c8aD98523631AE4a59f267346ea31F984", 
    block: { 
      number: 13380584 
    }
  ) {
    poolCount
    txCount
    totalVolumeUSD
    totalVolumeETH
  }
}
```

## Pool Data

To get data about a certain pool, pass in the pool address. Reference the full [pool schema](https://github.com/Uniswap/v3-subgraph/blob/main/src/v3/schema.graphql#L77) and adjust the query fields to retrieve the data points you want.

### General Pool Query

The query below returns the feeTier, spot price, and liquidity for the ETH-USDC pool.

```
{
  pool(id: "0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8") {
    tick
    token0 {
      symbol
      id
      decimals
    }
    token1 {
      symbol
      id
      decimals
    }
    feeTier
    sqrtPrice
    liquidity
  }
}
```

### All Possible Pools

The maximum items you can query at once is 1000. Thus to get all possible pools, you can iterate using the skip variable. To get pools beyond the first 1000 you can also set the skip as shown below.

### Skipping First 1000 Pools

This query sets the skip value and returns the first 10 responses after the first 1000.

```
{
  pools(first:10, skip:1000) {
    id
    token0 {
      id
      symbol
    }
    token1 {
      id
      symbol
    }
  }
}
```

### Creating a Skip Variable

This next query sets a skip variable. In your language and environment of choice you can then iterate through a loop, query to get 1000 pools each time, and continually adjust skip by 1000 until all pool responses are returned.

Check out [this example](https://github.com/Uniswap/v3-info/blob/770a05dc1a191cf229432ebc43c1f2ceb3666e3b/src/data/pools/chartData.ts#L14) from our interface for poolDayData that does something similar.

> **Note**
> This query will not work in the graph explorer and more resembles the structure of a query you'd pass to some GraphQL middleware like Apollo.

```
query pools($skip: Int!) {
  pools(
    first: 1000, 
    skip: $skip, 
    orderDirection: asc
  ) {
    id
    sqrtPrice
    token0 {
      id
    }
    token1 {
      id
    }
  }
}
```

### Most Liquid Pools

Retrieve the top 1000 most liquid pools. You can use this similar set up to orderBy other variables like number of swaps or volume.

```
{
  pools(
    first: 1000, 
    orderBy: liquidity, 
    orderDirection: desc
  ) {
    id
  }
}
```

### Pool Daily Aggregated

This query returns daily aggregated data for the first 10 days since the given timestamp for the UNI-ETH pool.

```
{
  poolDayDatas(
    first: 10, 
    orderBy: date, 
    where: {
      pool: "0x1d42064fc4beb5f8aaf85f4617ae8b3b5b8bd801", 
      date_gt: 1633642435
    }
  ) {
    date
    liquidity
    sqrtPrice
    token0Price
    token1Price
    volumeToken0
    volumeToken1
  }
}
```

## Swap Data

### General Swap Data

To query data about a particular swap, input the transaction hash + "#" + the index in the swaps the transaction array.
This is the reference for the full [swap schema](https://github.com/Uniswap/v3-subgraph/blob/main/src/v3/schema.graphql#L253).

This query fetches data about the sender, receiver, amounts, transaction data, and timestamp for a particular swap.

```
{
  swap(id: "0x000007e1111cbd97f74cfc6eea2879a5b02020f26960ac06f4af0f9395372b64#66785") {
    sender
    recipient
    amount0
    amount1
    transaction {
      id
      blockNumber
      gasUsed
      gasPrice
    }
    timestamp
    token0 {
      id
      symbol
    }
    token1 {
      id
      symbol
    }
  }
}
```

### Recent Swaps Within a Pool

You can set the `where` field to filter swap data by pool address. This example fetches data about multiple swaps for the USDC-USDT pool, ordered by timestamp.

```
{
  swaps(
    orderBy: timestamp, 
    orderDirection: desc, 
    where: { 
      pool: "0x7858e59e0c01ea06df3af3d20ac7b0003275d4bf" 
    }
  ) {
    pool {
      token0 {
        id
        symbol
      }
      token1 {
        id
        symbol
      }
    }
    sender
    recipient
    amount0
    amount1
  }
}

```

## Token Data

Input the token contract address to fetch token data. Any token that exists in at least one Uniswap v3 pool can be queried. The output will aggregate data across all v3 pools that include the token.

### General Token Data

This queries the decimals, symbol, name, pool count, and volume in USD for the UNI token. Reference the full [token schema](https://github.com/Uniswap/v3-subgraph/blob/main/src/v3/schema.graphql#L38) for all possible fields you can query.

```
{
  token(id:"0x1f9840a85d5af5bf1d1762f925bdaddc4201f984") {
    symbol
    name
    decimals
    volumeUSD
    poolCount
  }
}
```

### Token Daily Aggregated

You can fetch aggregate data about a specific token over a 24-hour period. This query gets 10-days of the 24-hour volume data for the UNI token ordered from oldest to newest.

```
{
  tokenDayDatas(
    first: 10, 
    where: {
      token: "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984"
    }, 
    orderBy: date, 
    orderDirection: asc
  ) {
    date
    token {
      id
      symbol
    }
    volumeUSD
  }
}
```

### All Tokens

Similar to retrieving all pools, you can fetch all tokens by using skip.

> **Note**
> This query will not work in the graph explorer and more resembles the structure of a query you'd pass to some GraphQL middleware like Apollo.

```
query tokens($skip: Int!) {
  tokens(first: 1000, skip: $skip) {
    id
    symbol
    name
  }
}
```

## Position Data

### General Position Data

To get data about a specific position, input the NFT tokenId. This queries the collected fees for token0 and token1 and current liquidity for the position with tokenId 3. Reference the full [position schema](https://github.com/Uniswap/v3-subgraph/blob/main/schema.graphql#L192) to see all fields.

```
{
  position(id: 3) {
    id
    collectedFeesToken0
    collectedFeesToken1
    liquidity
    token0 {
      id
      symbol
    }
    token1
    {
      id
      symbol
    }
  }
}
```

## Contribute

There are many more queries you can do with the Uniswap v3 subgraph including data related to ticks, mints, positions, and burns. Once again you can reference the full schema [here](https://github.com/Uniswap/v3-subgraph/blob/main/src/v3/schema.graphql). If you'd like to suggest more example queries to showcase, feel free to drop some suggestions in [discord](https://discord.com/invite/uniswap) under #dev-chat or [contribute](https://github.com/Uniswap/docs/blob/main/CONTRIBUTING.md) your own queries by submitting a pull request to the docs repo.
</file>

<file path="docs/api/subgraph/guides/v4-subgraph-example.md">
---
id: v4-examples
title: v4 Protocol Query Examples
sidebar_position: 2
---

## Subgraph Query Examples

This doc will teach you how to query Uniswap v4 analytics by writing GraphQL queries on the subgraph. You can fetch data points like:

- [position details](#general-position-data)
- [current liquidity](#pool-data) of a pool
- [volume on a certain day](#historical-global-data)

and much more. Below are some example queries. To run a query copy and paste it into the [v4 explorer](https://thegraph.com/explorer/subgraphs/DiYPVdygkfjDWhbxGSqAQxwBKmfKnkWQojqeM2rkLb3G?view=Query&chain=arbitrum-one) to get fresh data.

## Global Data

Global data refers to data points about the Uniswap v4 protocol as a whole. Some examples of global data points are:
- Total value locked in the protocol,
- Total pools deployed,
- Total transaction counts. 

Thus, to query global data you must pass in the PoolManager address `0x000000000004444c5dc75cb358380d2e3de08a90` and select the desired fields. Reference the full [poolManager schema](https://github.com/Uniswap/v4-subgraph/blob/main/schema.graphql#L1) to see all possible fields. PoolManager addresses for all supported chains are listed in the [Deployments](/contracts/v4/deployments) section.

### Current Global Data

An example querying total pool count, transaction count, and total volume in USD and ETH:

```
{
  poolManager(id: "0x000000000004444c5dc75cb358380d2e3de08a90") {
    poolCount
    txCount
    totalVolumeUSD
    totalVolumeETH
  }
}
```

### Historical Global Data

You can also query historical data by specifying a block number.

```
{
  poolManager(
    id: "0x000000000004444c5dc75cb358380d2e3de08a90", 
    block: {
      number: 22451931
    }
  ) {
    poolCount
    txCount
    totalVolumeUSD
    totalVolumeETH
  }
}
```

## Pool Data

To get data about a certain pool, pass in the pool address. Reference the full [pool schema](https://github.com/Uniswap/v4-subgraph/blob/main/schema.graphql#L76) and adjust the query fields to retrieve the data points you want.

### General Pool Query

The query below returns the feeTier, spot price, and liquidity for the ETH-USDC pool.

```
{
  pool(id: "0x21c67e77068de97969ba93d4aab21826d33ca12bb9f565d8496e8fda8a82ca27") {
    tick
    token0 {
      symbol
      id
      decimals
    }
    token1 {
      symbol
      id
      decimals
    }
    feeTier
    sqrtPrice
    liquidity
  }
}
```

### All Possible Pools

The maximum items you can query at once is 1000. Thus to get all possible pools, you can iterate using the skip variable. To get pools beyond the first 1000 you can also set the skip as shown below.

### Skipping First 1000 Pools

This query sets the skip value and returns the first 10 responses after the first 1000.

```
{
  pools(first: 10, skip: 1000) {
    id
    token0 {
      id
      symbol
    }
    token1 {
      id
      symbol
    }
  }
}
```

### Creating a Skip Variable

This next query sets a skip variable. In your language and environment of choice you can then iterate through a loop, query to get 1000 pools each time, and continually adjust skip by 1000 until all pool responses are returned.

Check out [this example](https://github.com/Uniswap/v3-info/blob/770a05dc1a191cf229432ebc43c1f2ceb3666e3b/src/data/pools/chartData.ts#L14) from our interface for poolDayData that does something similar.

> **Note**
> This query will not work in the graph explorer and more resembles the structure of a query you'd pass to some GraphQL middleware like Apollo.

```
query pools($skip: Int!) {
  pools(
    first: 1000
    skip: $skip
    orderDirection: asc
  ) {
    id
    sqrtPrice
    token0 {
      id
    }
    token1 {
      id
    }
  }
}
```

### Most Liquid Pools

Retrieve the top 1000 most liquid pools. You can use this similar set up to orderBy other variables like number of swaps or volume.

```
{
  pools(
    first: 1000, 
    orderBy: liquidity, 
    orderDirection: desc
  ) {
    id
  }
}
```

### Pool Daily Aggregated

This query returns daily aggregated data for the first 10 days since the given timestamp for the UNI-ETH pool. To calculate `poolId`, refer to [PoolId Library](/contracts/v4/reference/core/types/PoolId#toid).

```
{
  poolDayDatas(
    first: 10, 
    orderBy: date, 
    where: {
      pool: "0x21c67e77068de97969ba93d4aab21826d33ca12bb9f565d8496e8fda8a82ca27",
      date_gt: 1735689600
    } 
  ) {
    date
    liquidity
    sqrtPrice
    token0Price
    token1Price
    volumeToken0
    volumeToken1
  }
}
```

## Swap Data

### General Swap Data

To query data about a particular swap, input the transaction hash + "-" + the index in the swaps the transaction array. This is the reference for the full [swap schema](https://github.com/Uniswap/v4-subgraph/blob/main/schema.graphql#L186).

This query fetches data about the sender, amounts, transaction data, timestamp, and tokens for a particular swap.

```
{
   swap(id: "0x0000329e0d864d8e7c93627b76f6b5b99bd776cb18d9f8829e7da469f563e7d4-212") {
    sender
    amount0
    amount1
    transaction {
      id
      blockNumber
      gasUsed
      gasPrice
    }
    timestamp
    token0 {
      id
      symbol
    }
    token1 {
      id
      symbol
    }
   }
 }
```

### Recent Swaps Within a Pool

You can set the `where` field to filter swap data by pool address. This example fetches data about multiple swaps for the ETH-USDT pool, ordered by timestamp.

```
{
  swaps(
    orderBy: timestamp,
    orderDirection: desc,
    where: {
      pool: "0x21c67e77068de97969ba93d4aab21826d33ca12bb9f565d8496e8fda8a82ca27"
    }
  ) {
    pool {
      token0 {
        id
        symbol
      }
      token1 {
        id
        symbol
      }
    }
    sender
    amount0
    amount1
  }
}
```

## Token Data

Input the token contract address to fetch token data. Any token that exists in at least one Uniswap v4 pool can be queried. The output will aggregate data across all v4 pools that include the token.

### General Token Data

This queries the decimals, symbol, name, pool count, and volume in USD for the UNI token. Reference the full [token schema](https://github.com/Uniswap/v4-subgraph/blob/main/schema.graphql#L37) for all possible fields you can query.

```
{
  token(id:"0x1f9840a85d5af5bf1d1762f925bdaddc4201f984") {
    symbol
    name
    decimals
    volumeUSD
    poolCount
  }
}
```

### Token Daily Aggregated

You can fetch aggregate data about a specific token over a 24-hour period. This query gets 10-days of the 24-hour volume data for the UNI token ordered from oldest to newest.

```
{
  tokenDayDatas(
    first: 10, 
    where: {
      token: "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984"
    }, 
    orderBy: date, 
    orderDirection: asc
  ) {
    date
    token {
      id
      symbol
    }
    volumeUSD
  }
}
```
### All Tokens

Similar to retrieving all pools, you can fetch all tokens by using skip.

> **Note**
> This query will not work in the graph explorer and more resembles the structure of a query you'd pass to some GraphQL middleware like Apollo.

```
query tokens($skip: Int!) {
  tokens(first: 1000, skip: $skip) {
    id
    symbol
    name
  }
}
```

## Position Data

### General Position Data

To get data about a specific position, input the NFT tokenId. This queries the subscriptions, unsubscriptions, and transfers for the position with tokenId 3. Reference the full [position schema](https://github.com/Uniswap/v4-subgraph/blob/main/schema.graphql#416) to see all fields.

```
{
  position(id:3) {
    id
    subscriptions {
      id
    }
    unsubscriptions {
      id
    }
    transfers {
      id
    }
  }
}
```

## Contribute

There are many more queries you can do with the Uniswap v4 subgraph including data related to ticks, subscriptions, unsubscriptions, and more. Once again you can reference the full schema [here](https://github.com/Uniswap/v4-subgraph/blob/main/schema.graphql). If you'd like to suggest more example queries to showcase, feel free to drop some suggestions in [discord](https://discord.com/invite/uniswap) under #dev-chat or [contribute](https://github.com/Uniswap/docs/blob/main/CONTRIBUTING.md) your own queries by submitting a pull request to the docs repo.
</file>

<file path="docs/api/subgraph/subgraphs-devs/contracts/_category_.json">
{
  "label": "Contracts",
  "position": 5,
  "link": {
    "type": "generated-index",
    "description": "Details of contracts & events monitored in the subgraph"
  }
}
</file>

<file path="docs/api/subgraph/subgraphs-devs/contracts/factory.md">
---
title: Factory Contract
sidebar_position: 1
---

## Contract Details

|Chain|Address|StartBlock|
|-|-|-|
|Mainnet|0x1F98431c8aD98523631AE4a59f267346ea31F984|12369621|
|Polygon|0x1F98431c8aD98523631AE4a59f267346ea31F984|22757547|
|Arbitrum-One|0x1F98431c8aD98523631AE4a59f267346ea31F984|175|
|Optimism|0x1F98431c8aD98523631AE4a59f267346ea31F984|0|

## Events Tracked

|Event Name|Event handler|
|-|-|
|PoolCreated|[handlePoolCreated()](../functions-n-handlers/mappings/factory.ts#handlepoolcreated)|
</file>

<file path="docs/api/subgraph/subgraphs-devs/contracts/nonfungiblepositionmanager.md">
---
title: NonFungiblePositionManager Contract
sidebar_position: 2
---

## Contract Details

|Chain|Address|StartBlock|
|-|-|-|
|Mainnet|0xC36442b4a4522E871399CD717aBDD847Ab11FE88|12369651|
|Polygon|0xC36442b4a4522E871399CD717aBDD847Ab11FE88|22760586|
|Arbitrum-One|None|None|
|Optimism|0xC36442b4a4522E871399CD717aBDD847Ab11FE88|0|

## Events Tracked

|Event Name|Event handler|
|-|-|
|IncreaseLiquidity|[handleIncreaseLiquidity()](../functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity)|
|DecreaseLiquidity|[handleDecreaseLiquidity()](../functions-n-handlers/mappings/position-manager.ts#handledecreaseliquidity)|
|Collect|[handleCollect()](../functions-n-handlers/mappings/position-manager.ts#handlecollect)|
|Transfer|[handleTransfer()](../functions-n-handlers/mappings/position-manager.ts#handletransfer)|
</file>

<file path="docs/api/subgraph/subgraphs-devs/contracts/pool.md">
---
title: Pool Contract (Templatized)
sidebar_position: 3
---

## Contract Details
Pools are deployed  dynamically and the addresses cannot be pre-determined. Thus the template feature of graph protocol is used and the Pool contracts to monitor are added when a new pool is deployed using the factory. The [`handlePoolCreated()`](../functions-n-handlers/mappings/factory.ts#handlepoolcreated) event handler adds a new pool contract to monitor.

## Events Tracked

|Event Name|Event handler|
|-|-|
|Initialize|[handleInitialize()](../functions-n-handlers/mappings/core.ts#handleinitialize)|
|Swap|[handleSwap()](../functions-n-handlers/mappings/core.ts#handleswap)|
|Mint|[handleMint()](../functions-n-handlers/mappings/core.ts#handlemint)|
|Burn|[handleBurn()](../functions-n-handlers/mappings/core.ts#handleburn)|
|Flash|[handleFlash()](../functions-n-handlers/mappings/core.ts#handleflash)|
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/_category_.json">
{
  "label": "Core Functions",
  "position": 1,
  "link": {
    "type": "generated-index",
    "description": "Implementation details of functions present in the /src/mappings folder"
  }
}
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/core.ts.md">
---
sidebar_position: 1
title: core.ts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

path: [`/src/mappings/core.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/mappings/core.ts)

### handleInitialize()
```
Params:
 - event (initialize): entity of the initialize event emitted in a pool contract

ReturnType: void
```
<Tabs>
    <TabItem value="Eth Mainnet" label="Eth Mainnet">

- Handles the initialization of a new pool by setting it's `price` and current `tick` value.
- Updates the pools daily and hourly metrics using `updatePoolDayData()` and `updatePoolHourData()`.
- Updates Eth's USD price using `getEthPriceInUSD()` .
- Updates the token's prices relative to Eth using `findEthPerToken()`.

#### Entities
1. [Pool](../../schemas/pool) - Read & Write
2. [Token](../../schemas/token) - Write
3. [Bundle](../../schemas/bundle) - Write

#### Dependencies:
1. [updatePoolDayData()](../utils/intervalUpdates.ts#updatepooldaydata)
2. [updatePoolHourData()](../utils/intervalUpdates.ts#updatepoolhourdata)
3. [getEthPriceInUSD()](../utils/pricing.ts#getethpriceinusd)
4. [findEthPerToken()](../utils/pricing.ts#findethpertoken)

#### Invoked at:
1. [Initialize Event (Handler)](../../events)

</TabItem>
<TabItem value="Polygon, Optimism" label="Polygon, Optimism">

- Follows the logic of update, but doesn't save the `pool` entity.

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

- Doesn't save the pool entity
- Doesn't update the Eth's USD price, or the token prices relative to ETh.

</TabItem>
</Tabs>

### handleMint()
```
Params:
 - event (MintEvent): entity of the initialize event emitted in a pool contract

ReturnType: void
```
- updates `txCount`, `totalValueLockedETH` and `totalValueLockedUSD` metrics for `pool`, `factory` and `token` entities.
- Increases `pool.liquidity` by `event.params.amount` if the current `pool.tick` value is within the minted tick range.
- Creates a new `Mint` entity using `transaction.id` and `pool.txCount` as `mint.id`
- Creates tick entities `lowerTick` and `upperTick` if not already present using `createTick()` and updates their `liquidityGross` and `liquidityNet` fields. 
- Updates the pool and token metrics using `updateUniswapDayData()`, `updatePoolDayData()`, `updatePoolHourData()`, `updateTokenDayData()`, `updateTokenHourData()`.
- Updates the fees accumulated outside the lower/upper ticks using `updateTickFeeVarsAndSave()`

#### Entities
1. [Bundle](../../schemas/bundle) - Read
2. [Pool](../../schemas/pool) - Read & Write
3. [Token](../../schemas/token) - Read & Write
4. [Factory](../../schemas/factory) - Read & Write
5. [Tick](../../schemas/tick) - Read/Create & Write
6. [Mint](../../schemas/mint) - Create & Write

#### Dependencies:
1. [FACTORY_ADDRESS](../utils/constants.ts#factory_address)
2. [convertTokenToDecimal()](../utils/index.ts#converttokentodecimal)
3. [loadTransaction()](../utils/index.ts#loadtransaction)
4. [createTick()](../utils/tick.ts#createtick)
5. [updateUniswapDayData()](../utils/intervalUpdates.ts#updateuniswapdaydata)
6. [updatePoolDayData()](../utils/intervalUpdates.ts#updatepooldaydata)
7. [updatePoolHourData()](../utils/intervalUpdates.ts#updatepoolhourdata)
8. [updateTokenDayData()](../utils/intervalUpdates.ts#updatetokendaydata)
9. [updateTokenHourData()](../utils/intervalUpdates.ts#updatetokenhourdata)
10. [updateTickFeeVarsAndSave()](#updatetickfeevarsandsave)
11. [ONE_BI](../utils/constants.ts#one_bi)

#### Invoked at:
1. [Mint Event (Handler)](../../events)

### handleBurn()
```
Params:
 - event (BurnEvent): entity of the burn event emitted in a pool contract

ReturnType: void
```
<Tabs>
    <TabItem value="Other-Chains" label="Other-Chains">

- updates `txCount`, `totalValueLockedETH` and `totalValueLockedUSD` metrics for `pool`, `factory` and `token` entities.
- Decreases `pool.liquidity` by `event.params.amount` if the current `pool.tick` value is within the burnt tick range.
- Creates a new `Burn` entity using `transaction.id` and `pool.txCount` as `mint.id`. Sets the values from `event` parameters.
- Reduces the liquidity represented by  `liquidityGross` and `liquidityNet` fields of the LowerTick and UpperTick. 
- Updates the pool and token metrics using `updateUniswapDayData()`, `updatePoolDayData()`, `updatePoolHourData()`, `updateTokenDayData()`, `updateTokenHourData()`.
- Updates the fees accumulated outside the lower/upper ticks using `updateTickFeeVarsAndSave()`

#### Entities
1. [Bundle](../../schemas/bundle) - Read
2. [Pool](../../schemas/pool) - Read & Write
3. [Token](../../schemas/token) - Read & Write
4. [Factory](../../schemas/factory) - Read & Write
5. [Tick](../../schemas/tick) - Read & Write
6. [Burn](../../schemas/burn) - Create & Write

#### Dependencies:
1. [FACTORY_ADDRESS](../utils/constants.ts#factory_address)
2. [convertTokenToDecimal()](../utils/index.ts#converttokentodecimal)
3. [loadTransaction()](../utils/index.ts#loadtransaction)
4. [ONE_BI](../utils/constants.ts#one_bi)
5. [updateUniswapDayData()](../utils/intervalUpdates.ts#updateuniswapdaydata)
6. [updatePoolDayData()](../utils/intervalUpdates.ts#updatepooldaydata)
7. [updatePoolHourData()](../utils/intervalUpdates.ts#updatepoolhourdata)
8. [updateTokenDayData()](../utils/intervalUpdates.ts#updatetokendaydata)
9. [updateTokenHourData()](../utils/intervalUpdates.ts#updatetokenhourdata)
10. [updateTickFeeVarsAndSave()](#updatetickfeevarsandsave)

#### Invoked at:
1. [Burn Event (Handler)](../../events)

</TabItem>
<TabItem value="Optimism" label="Optimism">

Most of the logic is same as mainnet subgraph with following changes:
- While loading the `Tick` entities, if either one is not found, invokes `createTickBurn()` to create ticks and then proceeds with updating the liquidity values and metrics.

### Additional Dependencies
1. [createTickBurn()](../utils/tick.ts#createtickburn)

</TabItem>
</Tabs>

### handleSwap()
```
Params:
 - event (SwapEvent): entity of the swap event emitted in a pool contract

ReturnType: void
```
:::info Ignored Pool
The following pool address is ignored by the function: [0x9663f2ca0454accad3e094448ea6f77443880454](https://etherscan.io/address/9663f2ca0454accad3e094448ea6f77443880454) (WETH-LUSD)
:::

<Tabs>
<TabItem value="Eth Mainnet" label="Eth Mainnet">

- Calculates the tracked and untracked USD amount for the swap. `tracked` amount is the USD amount calculated only for tokens present in `WHITELIST_TOKEN` using `getTrackedAmountUSD`. `untracked` amount is calculated using `token.derivedETH * bundle.ethPriceUSD`. 
- Calculates the fee in `ETH` & `USD` using the formula `amountTracked * (pool.feeTier/1,000,000)`.
- Updates the fields for `txCount`, volume & fees (in eth & usd) and `untrackedVolumeUSD` for `pool`, `factory` & `token` entities.
- For `pool` entity, sets `liquidity`, `tick`, `sqrtPrice` from the `event` parameters.
- Sets the `pool.token0Price` and `pool.token1Price` using `sqrtPriceX96ToTokenPrices()`.
- Updates the `bundle.ethPriceUSD` using `getEthPriceInUSD()`.
- Updates the `token.derivedETH` value using `findEthPerToken()`.
- Updates the `totalValueLockedETH` and `totalValueLockedUSD` for `pool`, `factory` and `token` entities after the USD price update.
- Creates a new `Swap` entity using `transaction.id` and `pool.txCount` as `swap.id`. Sets the values from `event` parameters.
- Sets `pool.feeGrowthGlobal0X128` and `pool.feeGrowthGlobal1X128` by reading the them from pool contract's blockchain state using the ABI.
- Triggers updates to the daily and hourly metrics for pool and tokens. Uses the returned instances to set the fields for volume & fee.
- If the updated `pool.tick` is initialized, updates it's fee variables using `loadTickUpdateFeeVarsAndSave()`.
- Iterates over all the ticks crossed with the swap (oldTick to newTick) and updates their fee fields using `loadTickUpdateFeeVarsAndSave()`. If the number of ticks cross is more than 100, the updates are ignored to prevent timeouts.

#### Entities
1. [Bundle](../../schemas/bundle) - Read & Write
2. [Pool](../../schemas/pool) - Read & Write
3. [Token](../../schemas/token) - Read & Write
4. [Factory](../../schemas/factory) - Read & Write
5. [Tick](../../schemas/tick) - Read/Create & Write
6. [Swap](../../schemas/swap) - Create & Write
7. [UniswapDayData](../../schemas/uniswapdaydata) - Write
8. [PoolDayData](../../schemas/pooldaydata) - Write
9. [PoolHourData](../../schemas/poolhourdata) - Write
10. [TokenDayData](../../schemas/tokendaydata) - Write
11. [TokenHourData](../../schemas/tokenhourdata) - Write

#### ABI Dependencies:
1. pool.json

#### Dependencies:
1. [FACTORY_ADDRESS](../utils/constants.ts#factory_address)
2. [convertTokenToDecimal()](../utils/index.ts#converttokentodecimal)
3. [loadTransaction()](../utils/index.ts#loadtransaction)
4. [getTrackedAmountUSD()](../utils/pricing.ts#gettrackedamountusd)
5. [safeDiv()](../utils/index.ts#safediv)
6. [sqrtPriceX96ToTokenPrices()](../utils/pricing.ts#sqrtpricex96totokenprices)
7. [getEthPriceInUSD()](../utils/pricing.ts#getethpriceinusd)
8. [findEthPerToken()](../utils/pricing.ts#findethpertoken)
9. [updateUniswapDayData()](../utils/intervalUpdates.ts#updateuniswapdaydata)
10. [updatePoolDayData()](../utils/intervalUpdates.ts#updatepooldaydata)
11. [updatePoolHourData()](../utils/intervalUpdates.ts#updatepoolhourdata)
12. [updateTokenDayData()](../utils/intervalUpdates.ts#updatetokendaydata)
13. [updateTokenHourData()](../utils/intervalUpdates.ts#updatetokenhourdata)
14. [loadTickUpdateFeeVarsAndSave()](#loadtickupdatefeevarsandsave)
15. [feeTierToTickSpacing()](../utils/tick.ts#feetiertotickspacing)
16. [ZERO_BD](../utils/constants.ts#zero_bd)
17. [ZERO_BI](../utils/constants.ts#zero_bi)
18. [ONE_BI](../utils/constants.ts#one_bi)

#### Invoked at:
1. [Swap Event (Handler)](../../events)

</TabItem>
<TabItem value="Polygon" label="Polygon">

- Follows the logic of mainnet except doesn't save the `token0HourData`, `token1HourData` and `poolHourData` entities.

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

- Follows the logic of mainnet except doesn't save the `token0HourData`, `token1HourData` and `poolHourData` entities.
- Doesn't update the `pool.feeGrowthGlobal0X128` and `pool.feeGrowthGlobal1X128` values.

</TabItem>
</Tabs>

### handleFlash()
```
Params:
 - event (FlashEvent): entity of the flash event emitted in a pool contract

ReturnType: void
```

<Tabs>
<TabItem value="Eth Mainnet, Polygon" label="Eth Mainnet, Polygon">

- Sets `pool.feeGrowthGlobal0X128` and `pool.feeGrowthGlobal1X128` by reading the them from pool contract's blockchain state using the ABI.

#### Entities
1. [Pool](../../schemas/pool) - Read & Write

#### ABI Dependencies:
1. pool.json

#### Invoked at:
1. [Flash Event (Handler)](../../events)

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">
- Doesn't update anything. Only loads the pool entity and immediately saves it.
</TabItem>
</Tabs>

### updateTickFeeVarsAndSave()
```
Params:
 - tick (Tick): Fee Variables are updated for this tick entity
 - event (Ethereum.event): An event from the pool the tick represent is in

ReturnType: void
```

<Tabs>
<TabItem value="Eth Mainnet, Polygon" label="Eth Mainnet, Polygon">

- Sets `tick.feeGrowthOutside0X128` and `tick.feeGrowthOutside1X128` by reading the tick from pool contract's blockchain state using the ABI.
- Triggers update to tick day metrics by invoking `updateTickDayData()`.

#### Entities
1. [Tick](../../schemas/tick) - Write

#### ABI Dependencies:
1. pool.json

#### Dependencies:
1. [updateTickDayData()](../utils/intervalUpdates.ts#updatetickdaydata)

#### Invoked at:
1. [handleMint()](#handlemint)
2. [handleBurn()](#handleburn)
3. [loadTickUpdateFeeVarsAndSave](#loadtickupdatefeevarsandsave)

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">
- Doesn't update anything. Only loads the ticks from pool contract and invokes save on the tick entity passed as parameter.
</TabItem>
</Tabs>

### loadTickUpdateFeeVarsAndSave()
```
Params:
 - tickId (i32): The fee variables are updated for this tickId
 - event (ethereum.event): An event from the pool contract which the tick is a part of.

ReturnType: void
```
- Loads the tick using `event.address` and `tickId`. If found, updates the tick variables by invoking `updateTickFeeVarsAndSave()`.

#### Entities
1. [Tick](../../schemas/tick) - Read & Write

#### Dependencies:
1. [updateTickFeeVarsAndSave()](#updatetickfeevarsandsave)

#### Invoked at:
1. [handleSwap()](#handleswap)
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/factory.ts.md">
---
sidebar_position: 2
title: factory.ts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

path: [`/src/mappings/factory.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/mappings/factory.ts)

### handlePoolCreated()
```
Params:
 - event (PoolCreated): Event entity representing the Factory Contracts's Pool created event

ReturnType: void
```
<Tabs>
<TabItem value="Eth Mainnet, Polygon" label="Eth Mainnet, Polygon">

:::info Ignored Pool
The following pool address is ignored by the function: [0x8fe8d9bb8eeba3ed688069c3d6b556c9ca258248](https://etherscan.io/address/0x8fe8d9bb8eeba3ed688069c3d6b556c9ca258248) (MULAN-USDT)
:::

- Loads the factory entity at `FACTORY_ADDRESS`, or creates one if not found. Creates the bundle entity while creating factory. Initializes the new entity to `ZERO_BD`, `ZERO_BI`.
- Increment the factory's pool count. 
- Creates new `Token` entity for each of the tokens in the pool if not already present. Initializes the token parameters using `fetchTokenSymbol()`, `fetchTokenName()`, `fetchTokenTotalSupply()`, `fetchTokenDecimals()` and metrics to `ZERO_BD` or `ZERO_BI`. 
- If a token is present in the `WHITELIST_TOKENS` list, it is added to the other token's `whitelistPools` list, which is used for calculating the amount in USD.
- Creates a new `Pool` entity for the token pair. Uses the event parameters, and `token` entities to initialize the values, while sets the metrics to `ZERO_BI` or `ZERO_BD`.
- Finally, using `Pool`(Template), adds a new pool entity to listen for events from the new pool.

:::danger Token decimals mandatory
While creating either of the tokens, if the decimals value is not available, the pool entity is not created and the function returns without changing any entity. Only the bundle entity is still created if factory entity didn't exist.
:::

#### Entities:
1. [Factory](../../schemas/factory) - Read/Create & Write Entity
2. [Bundle](../../schemas/bundle) - Create Entity
3. [Pool](../../schemas/pool) - Create Entity
4. [Token](../../schemas/token) - Read/Create & Write

#### Contracts
1. [Pool (Template)](../../contracts/pool) - Create

#### Dependencies:
1. [FACTORY_ADDRESS](../utils/constants.ts#factory_address)
2. [ADDRESS_ZERO](../utils/constants.ts#address_zero)
3. [ZERO_BD](../utils/constants.ts#zero_bd)
4. [ZERO_BI](../utils/constants.ts#zero_bi)
5. [ONE_BI](../utils/constants.ts#one_bi)
6. [fetchTokenSymbol()](../utils/token.ts#fetchtokensymbol)
7. [fetchTokenName()](../utils/token.ts#fetchtokenname)
8. [fetchTokenTotalSupply()](../utils/token.ts#fetchtokentotalsupply)
9. [fetchTokenDecimals()](../utils/token.ts#fetchtokendecimals)
10. [WHITELIST_TOKENS](../utils/pricing.ts#whitelist_tokens)

#### Invoked at:
1. [PoolCreated Event (Handler)](../../events)

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

- Same logic as mainnet, but doesn't initialize `pool.feeGrowthGlobal0X128` and `pool.feeGrowthGlobal1X128` values.

</TabItem>
<TabItem value="Optimism" label="Optimism">

- If factory doesn't exists, initializes poolCount to `104` instead of `ZERO_BI` and `factory.populated` to `false`
- Before saving the pool entity, if `factory.populated` is false, invokes `populateEmptyPools()` to load the pool before regenisis and sets `factory.populated = true`.

### Additional Dependencies
1. [populateEmptyPools()](../utils/backfill.ts#populateemptypools)

</TabItem>
</Tabs>
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/mappings/position-manager.ts.md">
---
sidebar_position: 3
title: position-manager.ts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::danger File Missing
The complete file is missing for arbitrum-one
:::

path: [`/src/mappings/position-manager.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/mappings/position-manager.ts)

### getPosition()
```
Params:
 - event (ethereum.Event): An event from the NFT Position Manager contract
 - tokenId (BigInt): NFT Id for the staked position

ReturnType: Position | null
```
<Tabs>
    <TabItem value="Eth Mainnet" label="Eth Mainnet">

- Returns a `Position` entity for the given `tokenId` if found.
- If not found, retrieves a position by directly querying the `NonfungiblePositionManager` contract using the ABI. Invokes `factoryContract.getPool()` and passing it the `position`'s parameters `token0`, `token1` and `fee` to find the `pool` contract address.
- Then creates a new position entity for the tokenId and set the metadata properties using `position` read earlier from the `NonfungiblePositionManager` contract. Sets the metrics to `ZERO_BD`. 

:::info No Position for same Block Mint and burn
In certain scenarios, the position is minted and burnt within the same block. The contract call to NonfungiblePositionManager to retrieve position data reverts in such scenarios as the position no longer exists.
:::

#### Entities
1. [Position](../../schemas/position) - Read/Create Without Saving

#### ABI Dependencies:
1. NonfungiblePositionManager.json

#### Dependencies:
1. [factoryContract](../utils/constants.ts#factorycontract)
2. [ZERO_BI](../utils/constants.ts#zero_bi)
3. [ZERO_BD](../utils/constants.ts#zero_bd)
4. [ADDRESS_ZERO](../utils/constants.ts#address_zero)
5. [loadTransaction()](../utils/index.ts#loadtransaction)

#### Invoked at:
1. [handleIncreaseLiquidity()](#handleincreaseliquidity)
2. [handleDecreaseLiquidity()](#handledecreaaseliquidity)
3. [handleCollect()](#handlecollect)
4. [handleTransfer()](#handletransfer)

</TabItem>
<TabItem value="Polygon, Optimism" label="Polygon, Optimism">
In addition to mainnet:

- initializes `position.collectedToken0` and `position.collectedToken1` values.

</TabItem>
</Tabs>

### updateFeeVars()
```
Params:
 - position (Position): The position for which the fee variables are set
 - event (ethereum.Event): An event from the NFT Position Manager contract
 - tokenId (BigInt): NFT Id for the staked position

ReturnType: Position
```
- Updates the fields `position.feeGrowthInside0LastX128` and `position.feeGrowthInside1LastX128` for the position represented by `tokenId` by reading the value from the `NonfungiblePositionManager` triggering the `event`.

#### Entities
1. [Position](../../schemas/position) - Update Fields Without Saving

#### ABI Dependencies:
1. NonfungiblePositionManager.json

#### Invoked at:
1. [handleIncreaseLiquidity()](#handleincreaseliquidity)
2. [handleDecreaseLiquidity()](#handledecreaaseliquidity)
3. [handleCollect()](#handlecollect)

### savePositionSnapshot()
```
Params:
 - position (Position): Position entity for which the current state is saved as a snapshot
 - event (ethereum.Event): NonfungiblePositionManager Contract event after which the snapshot is being saved

ReturnType: void
```
- Saves the current values of a `Position` entity for future reference, including liquidity, tokens deposited and withdrawn, fee collected, feeGrowthInside.

#### Entities
1. [PositionSnapshot()](../../schemas/positionsnapshot) - Create

#### Dependencies:
1. [loadTransaction()](../utils/index.ts#loadtransaction)

#### Invoked at:
1. [handleIncreaseLiquidity()](#handleincreaseliquidity)
2. [handleDecreaseLiquidity()](#handledecreaaseliquidity)
3. [handleCollect()](#handlecollect)
4. [handleTransfer()](#handletransfer)

### handleIncreaseLiquidity()
```
Params:
 - event (IncreaseLiquidity): Entity for a IncreaseLiquidity event emitted by NonfungiblePositionManager Contract

ReturnType: void
```
<Tabs>
    <TabItem value="Eth Mainnet" label="Eth Mainnet">

:::info Ignored Blocks and Addresses
 - Block 14317993 is ignored by the function.
 - Pool address 0x8fe8d9bb8eeba3ed688069c3d6b556c9ca258248 (MULAN-USDT) is ignored by the function.
:::

- Fetches the position entity using `getPosition()`, passing `event.params.tokenId` and `event` as parameters.
- Updates fields `position.liquidity`, `position.depositedToken0` and `position.depositedToken1`.
- Triggers `updateFeeVars()` and `savePositionSnapshot()`

#### Entities
1. [Position](../../schemas/position) - Write
2. [Token](../../schemas/token) - Read

#### Dependencies:
1. [getPosition()](#getposition)
2. [convertTokenToDecimal()](../utils/index.ts#converttokentodecimal)
3. [updateFeeVars()](#updatefeevars)
4. [savePositionSnapshot()](#savepositionsnapshot)

#### Invoked at:
1. [IncreaseLiquidity Event (Handler)](../../events)

</TabItem>
<TabItem value="Polygon" label="Polygon">

Follows most of the logic of mainnet except the following points:

- No blocks ingored like mainnet.
- Updates field `position.amountDepositedUSD` by deriving `amount0` and `amount1` in their respective USD priced using `bundle.ethPriceUSD` and `token.derivedETH`.

#### Additional Entities Referenced
1. [Bundle](../../schemas/bundle) - Read

</TabItem>
<TabItem value="Optimism" label="Optimism">

Follows most of the logic of mainnet except the following points:

- No blocks ingored like mainnet.
- Returns without any changes if token0 or token1 entities are null.

#### Additional Entities Referenced
1. [Bundle](../../schemas/bundle) - Read

</TabItem>
</Tabs>

### handleDecreaseLiquidity()
```
Params:
 - event (DecreaseLiquidity): Entity for a DecreaseLiquidity event emitted by NonfungiblePositionManager Contract

ReturnType: void
```
<Tabs>
    <TabItem value="Eth Mainnet" label="Eth Mainnet">

:::info Ignored Blocks and Addresses
 - Block 14317993 is ignored by the function.
 - Pool address 0x8fe8d9bb8eeba3ed688069c3d6b556c9ca258248 (MULAN-USDT) is ignored by the function.
:::

- Fetches the position entity using `getPosition()`, passing `event.params.tokenId` and `event` as parameters.
- Updates fields `position.liquidity`, `position.withdrawnToken0` and `position.withdrawnToken1`.
- Triggers `updateFeeVars()` and `savePositionSnapshot()`

#### Entities
1. [Position](../../schemas/position) - Write
2. [Token](../../schemas/token) - Read

#### Dependencies:
1. [getPosition()](#getposition)
2. [convertTokenToDecimal()](../utils/index.ts#converttokentodecimal)
3. [updateFeeVars()](#updatefeevars)
4. [savePositionSnapshot()](#savepositionsnapshot)

#### Invoked at:
1. [DecreaseLiquidity Event (Handler)](../../events)

</TabItem>
<TabItem value="Polygon" label="Polygon">

Follows most of the logic of mainnet except the following points:

- No blocks ingored like mainnet
- Updates field `position.netWithdrawnUSD` by deriving `amount0` and `amount1` in their respective USD priced using `bundle.ethPriceUSD` and `token.derivedETH`.

#### Additional Entities
1. [Bundle](../../schemas/bundle) - Read

</TabItem>
<TabItem value="Optimism" label="Optimism">

Follows most of the logic of mainnet except the following points:

- No blocks ingored like mainnet.
- Returns without any changes if token0 or token1 entities are null.

#### Additional Entities Referenced
1. [Bundle](../../schemas/bundle) - Read

</TabItem>
</Tabs>

### handleCollect()
```
Params:
 - event (Collect): Entity for a Collect event emitted by NonfungiblePositionManager Contract

ReturnType: void
```
:::info Ignored Addresses
 - Pool address 0x8fe8d9bb8eeba3ed688069c3d6b556c9ca258248 (MULAN-USDT) is ignored by the function.
:::

<Tabs>
    <TabItem value="Eth Mainnet" label="Eth Mainnet">

- Fetches the position entity using `getPosition()`, passing `event.params.tokenId` and `event` as parameters.
- Updates fields `position.collectedFeesToken0` and `position.collectedFeesToken1` by adding the `event.params.amount0` after adjusting it with `token.decimals`.
- Triggers `updateFeeVars()` and `savePositionSnapshot()`

:::danger Incorrect Collected Fees Token1 amount
`event.params.amount0` (adjusted with `token0.decimals`) is added to both `position.collectedFeesToken0` and `position.collectedFeesToken1`. This logic needs to be validated.
:::

#### Entities
1. [Position](../../schemas/position) - Write
2. [Token](../../schemas/token) - Read

#### Dependencies:
1. [getPosition()](#getposition)
2. [convertTokenToDecimal()](../utils/index.ts#converttokentodecimal)
3. [updateFeeVars()](#updatefeevars)
4. [savePositionSnapshot()](#savepositionsnapshot)

#### Invoked at:
1. [Collect Event (Handler)](../../events)

</TabItem>
<TabItem value="Polygon" label="Polygon">

Differs from mainnet at the following areas:
- Updates fields `position.collectedToken0` and `position.collectedToken1` by adding the `event.params.amount0` and `event.params.amount1` after adjusting them with `token.decimals`.
- Updates fields `position.collectedFeesToken0` and `position.collectedFeesToken1` by subtracting `position.withdrawnToken` from `position.collectedToken`.
- Updates field `position.amountCollectedUSD` by deriving `amount0` and `amount1` in their respective USD priced using `bundle.ethPriceUSD` and `token.derivedETH` and adding to the existing value.

#### Additional Entities
1. [Bundle](../../schemas/bundle) - Read

</TabItem>
<TabItem value="Optimism" label="Optimism">

Differs from mainnet at the following areas:
- Returns without any changes if token0 or token1 entities are null.
- Updates fields `position.collectedToken0` and `position.collectedToken1` by adding the `event.params.amount0` and `event.params.amount1` after adjusting them with `token.decimals`.
- Updates fields `position.collectedFeesToken0` and `position.collectedFeesToken1` by subtracting `position.withdrawnToken` from `position.collectedToken`.

#### Additional Entities Referenced
1. [Bundle](../../schemas/bundle) - Read

</TabItem>

</Tabs>

### handleTransfer()
```
Params:
 - event (Transfer): Entity for a Transfer event emitted by NonfungiblePositionManager Contract

ReturnType: void
```
- Fetches the position entity using `getPosition()`, passing `event.params.tokenId` and `event` as parameters.
- Sets `position.owner` with `event.params.to`.
- Triggers `savePositionSnapshot()`.

#### Entities
1. [Position](../../schemas/position) - Write

#### Dependencies:
1. [getPosition()](#getposition)
2. [savePositionSnapshot()](#savepositionsnapshot)

#### Invoked at:
1. [Transfer Event (Handler)](../../events)
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/utils/_category_.json">
{
  "label": "Utility Functions",
  "position": 2,
  "link": {
    "type": "generated-index",
    "description": "Docs for /src/utils functions"
  }
}
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/utils/backfill.ts.md">
---
title: backfill.ts
---

:::info Only in Optimism
The file is present only for the optimism subgraph
:::

path: [`/src/utils/backfill.ts`](https://github.com/Uniswap/v3-subgraph/blob/ian/optimism-fix/src/utils/backfill.ts)


### populateToken()
```
Params:
 - tokenAddress (String): 

ReturnType: void
```

- Initializes a new Token Enttity for the token address if not already present.
- Initializes the token parameters using `fetchTokenSymbol()`, `fetchTokenName()`, `fetchTokenTotalSupply()`, `fetchTokenDecimals()` and metrics to `ZERO_BD` or `ZERO_BI`. 

#### Entities:
1. [Token](../../schemas/token) - Read/Create & Write

#### Dependencies:
1. [fetchTokenSymbol()](./token.ts#fetchtokensymbol)
2. [fetchTokenName()](./token.ts#fetchtokenname)
3. [fetchTokenTotalSupply()](./token.ts#fetchtokentotalsupply)
4. [fetchTokenDecimals()](./token.ts#fetchtokendecimals)
5. [ZERO_BD](../utils/constants.ts#zero_bd)
6. [ZERO_BI](../utils/constants.ts#zero_bi)

#### Invoked at:
1. [populateEmptyPools()](#populateemptypools)

### populateEmptyPools()
```
Params:
 - event (ethereum.Event): 

ReturnType: void
```

Create entities for each pool and token before regenesis of optimism chain. 
- Iterates through the pools present in `POOL_MAPPINGS` list. Fow each of the items, does the below mentioned steps.
- Using PoolABI, loads the pool contract. Creates a new `Pool` entity and sets it's `token0`, `token1` values from POOL_MAPPING and liquidity from the contract read. Iniitalizes all the metrics to `ZERO_BD` or `ZERO_BI`.
- set `pool.feeTier` by reading it from the contract.
- Invokes `populateToken()` for the two tokens.
- For each token, adds pool to `token.whitelistPool` if the other token is present in `WHITELIST_TOKENS` list.
- Sets `pool.totalValueLockedToken` and `token.totalValueLocked` by reading the ERC20 contract and invoking `balanceOf()`.
- Saves the token and pool entities.

:::danger Overwrites Token TVL
`token.tokenValueLocked` is set everytime instead of adding it to the existing balance. Thus if a token is present in multiple pools, the TVL in the from the last pool will be shown.
:::

#### Entities:
1. [Pool](../../schemas/pool) - Create & Write
2. [Token](../../schemas/token) - Read/Create & Write

#### Contracts
1. [Pool (Template)](../../contracts/pool) - Create

#### ABI Dependencies:
1. pool.json
2. ERC20.json

#### Dependencies:
1. [POOL_MAPPINGS](../poolMapping.ts#pool_mappings)
2. [ZERO_BD](./constants.ts#zero_bd)
3. [ZERO_BI](./constants.ts#zero_bi)
4. [populateToken()](#populatetoken)
5. [WHITELIST_TOKENS](./pricing.ts#whitelist_tokens)
6. [convertTokenToDecimal()](./index.ts#converttokentodecimal)

#### Invoked at:
1. [handlePoolCreated()](../mappings/factory.ts#handlepoolcreated)
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/utils/constants.ts.md">
---
sidebar_position: 1
title: constants.ts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

path: [`/src/utils/constants.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/utils/constants.ts)

### ADDRESS_ZERO
```
- type: String
- value: '0x0000000000000000000000000000000000000000'
```
Represents the null address in ethereum.

#### Referenced at:
1. [handlePoolCreated()](../mappings/factory.ts#handlepoolcreated)
2. [getPosition()](../mappings/position-manager.ts#getposition)

### FACTORY_ADDRESS
```
- type: String
- value: '0x1F98431c8aD98523631AE4a59f267346ea31F984'
```

#### Referenced at:
1. [handlePoolCreated()](../mappings/factory.ts#handlepoolcreated)
2. [factoryContract](#factorycontract)
3. [handleMint()](../mappings/core.ts#handlemint)
4. [handleBurn()](../mappings/core.ts#handleburn)
5. [handleSwap()](../mappings/core.ts#handleswap)
6. [updateUniswapDayData()](./intervalUpdates.ts#updateuniswapdaydata)

### ZERO_BI
```
- type: BigInt
- value: 0
```
<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

#### Referenced at:
1. [updatePoolDayData()](./intervalUpdates.ts#updatepooldaydata)
2. [updatePoolHourData()](./intervalUpdates.ts#updatepoolhourdata)
3. [findEthPerToken()](./pricing.ts#findethpertoken)
4. [handlePoolCreated()](../mappings/factory.ts#handlepoolcreated)
5. [exponentToBigDecimal()](./index.ts#exponenttobigdecimal)
6. [bigDecimalExponated()](./index.ts#bigdecimalexponated)
7. [tokenAmountToDecimal()](./index.ts#tokenamounttodecimal)
8. [priceToDecimal()](./index.ts#pricetodecimal)
9. [convertTokenToDecimal()](./index.ts#converttokentodecimal)
10. [createTick()](./tick.ts#createtick)
11. [getPosition()](../mappings/position-manager.ts#getposition)
12. [handleSwap()](../mappings/core.ts#handleswap)

</TabItem>
<TabItem value="Optimism" label="Optimism">

#### Additionally Invoked At:
1. [populateToken()](./backfill.ts#populatetoken)
2. [populateEmptyPools()](./backfill.ts#populateemptypools)

</TabItem>
</Tabs>

### ONE_BI
```
- type: BigInt
- value: 1
```

#### Referenced at:
1. [updatePoolDayData()](./intervalUpdates.ts#updatepooldaydata)
2. [updatePoolHourData()](./intervalUpdates.ts#updatepoolhourdata)
3. [handlePoolCreated()](../mappings/factory.ts#handlepoolcreated)
4. [exponentToBigDecimal()](./index.ts#exponenttobigdecimal)
5. [bigDecimalExponated()](./index.ts#bigdecimalexponated)
6. [handleMint()](../mappings/core.ts#handlemint)
7. [handleBurn()](../mappings/core.ts#handleburn)
8. [handleSwap()](../mappings/core.ts#handleswap)

### TWO_BI
<Tabs>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

```
- type: BigInt
- value: 2
```

#### Referenced at:
1. [bigDecimalExponated()](./index.ts#bigdecimalexponated)

</TabItem>
<TabItem value="Other Chains" label="Other-Chains">
	The Value is not present in any other chain.
</TabItem>
</Tabs>   


### ZERO_BD
```
- type: BigDecimal
- value: 0
```

<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

#### Referenced at:
1. [updatePoolDayData()](./intervalUpdates.ts#updatepooldaydata)
2. [updatePoolHourData()](./intervalUpdates.ts#updatepoolhourdata)
3. [updateTokenDayData()](./intervalUpdates.ts#updatetokendaydata)
4. [updateTokenHourData()](./intervalUpdates.ts#updatetokenhourdata)
5. [updateUniswapDayData()](./intervalUpdates.ts#updateuniswapdaydata)
6. [findEthPerToken()](./pricing.ts#findethpertoken)
7. [getTrackedAmountUSD()](./pricing.ts#gettrackedamountusd)
8. [handlePoolCreated()](../mappings/factory.ts#handlepoolcreated)
9. [safeDiv()](./index.ts#safediv)
10. [equalToZero()](./index.ts#equaltozero)
11. [createTick()](./tick.ts#createtick)
12. [getPosition()](../mappings/position-manager.ts#getposition)
13. [handleSwap()](../mappings/core.ts#handleswap)

</TabItem>
<TabItem value="Optimism" label="Optimism">

#### Additionally Invoked At:
1. [populateToken()](./backfill.ts#populatetoken)
2. [populateEmptyPools()](./backfill.ts#populateemptypools)

</TabItem>
</Tabs>

### ONE_BD
```
- type: BigDecimal
- value: 1
```

#### Referenced at:
1. [findEthPerToken()](./pricing.ts#findethpertoken)
2. [bigDecimalExponated()](./index.ts#bigdecimalexponated)
3. [createTick()](./tick.ts#createtick)

### BI_18
```
- type: BigInt
- value: 18
```

### factoryContract
An object representing a smart contract based on `abis/factory.json` abi, binded to `FACTORY_ADDRESS` to query the smart contract data.

#### Dependencies:
1. [FACTORY_ADDRESS](#factory_address)

#### Referenced at:
1. [getPosition()](../mappings/position-manager.ts#getposition)
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/utils/index.ts.md">
---
sidebar_position: 2
title: index.ts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

path: [`/src/utils/index.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/utils/index.ts)

### exponentToBigDecimal()
```
Params:
 - decimals (BigInt): The power of ten to return.

ReturnType: BigDecimal
```
Returns the number `1` followed by `decimals` number of `0s` with type BigDecimal.  
It uses a for loop to iterate between `0` and `decimals` and multiplies the previous result by `10`. Thus, only positive values are possible.

#### Dependencies:
1. [ZERO_BI](./constants.ts#zero_bi)
2. [ONE_BI](./constants.ts#one_bi)


#### Invoked at:
1. [tokenAmountToDecimal()](#tokenamounttodecimal)
2. [priceToDecimal()](#pricetodecimal)
3. [convertTokenToDecimal()](#converttokentodecimal)
4. [convertEthToDecimal](#convertethtodecimal)
5. [sqrtPriceX96ToTokenPrices](./pricing.ts#sqrtpricex96totokenprices)

### safeDiv()
```
Params:
 - amount0 (BigDecimal): Numerator for the division
 - amount1 (BigDecimal): Denominator for the division

ReturnType: BigDecimal
```
Return `0` if parameter `amount1` is equal to `ZERO_BD`. <br/>
Else returns the result of dividing `amount0` by `amount1` using `BigDecimal`'s `div()` method.

#### Dependencies:
1. [ZERO_BD](./constants.ts#zero_bd)

#### Invoked at:
1. [bigDecimalExponated()](#bigdecimalexponated)
2. [priceToDecimal()](#pricetodecimal)
3. [createTick()](./tick.ts#createtick)

### bigDecimalExponated()
```
Params:
 - value (BigDecimal): value to be raised to a certain power
 - power (BigInt): the exponent of the value to be calculated

ReturnType: BigDecimal
```
<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

If `power` is `ZERO_BI`, `ONE_BD` is returned. `value` is multipled by itself in a simple for loop executed `abs(power)` number of times. If the `power` is negative, uses `safeDiv` to divide `ONE_BD` with the result of the previous calculation. Returns the result in BigDecimal.

#### Dependencies:
1. [ZERO_BI](./constants.ts#zero_bi)
2. [ZERO_BD](./constants.ts#zero_bd)
3. [ONE_BI](./constants.ts#one_bi)
4. [ONE_BD](./constants.ts#one_bd)
5. [safeDiv()](#safediv)

#### Invoked at:
1. [createTick()](./tick.ts#createtick)

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

- Differs in logic to compute the exponent from other chains.
- Instead of looping and multiplying `value` through `power` loop iterations, performs [simple exponentiation by squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring)

#### Additional Dependencies:
1. [TWO_BI](./constants.ts#two_bi)

</TabItem>
</Tabs>   

### tokenAmountToDecimal()
```
Params:
 - tokenAmount (BigDecimal): The amount of tokens to be divided (numerator)
 - exchangeDecimals (BigInt): The power of 10 to divide the amount with

ReturnType: BigDecimal
```
If exchangeDecimals is `ZERO_BI`, returns tokenAmount after converting to BigDecimal. Else divides the BigDecimal tokenAmount using 10 raised to `exchangeDecimals` as the denominator.

#### Dependencies:
1. [ZERO_BI](./constants.ts#zero_bi)
2. [exponentToBigDecimal()](#exponenttobigdecimal)

#### Invoked at:
1. []

### priceToDecimal()
```
Params:
 - amount (BigDecimal): The amount to be divided (numerator)
 - exchangeDecimals (BigInt): The power of 10 to divide the amount with

ReturnType: BigDecimal
```
If `exchangeDecimals` is equal to `ZERO_BI` returns the amount as it is. Otherwise uses `safeDiv` to divide `amount` with `10^exchangeDecimals` in BigDecimals type.

#### Dependencies:
1. [ZERO_BI](./constants.ts#zero_bi)
2. [safeDiv()](#safediv)
3. [exponentToBigDecimal()](#exponenttobigdecimal)

#### Invoked at:
1. 

### equalToZero()
```
Params:
 - value (BigDecimal): Value to check whether zero

ReturnType: boolean
```
Converts value to string and then to float. Compares it against ZERO_BD after converting to String and then parsing as float. Returns boolean value from comparing the equality of the two float values.

#### Dependencies:
1. [ZERO_BD](./constants.ts#zero_bd)

#### Invoked at:
1. 

### isNullEthValue()
```
Params:
 - value (String) - Hex String to check for Null Eth value

ReturnType: boolean
```
Returns boolean value. True is value == '0x0000000000000000000000000000000000000000000000000000000000000001', else false.

#### Invoked at:
1. [fetchTokenSymbol()](./token.ts#fetchtokensymbol)
2. [fetchTokenName()](./token.ts#fetchtokenname)

### bigDecimalExp18()
```
ReturnType: BigDecimal
Value: 10^18
```

#### Invoked at:
1.

### convertTokenToDecimal()
```
Params:
 - tokenAmount (BigInt) - The amount of token value to be converted
 - exchangeDecimals (BigInt) - The positive power of the exponent to divide the tokenAmount with

ReturnType: BigDecimal
```
<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

If exchangeDecimals is `ZERO_BI`, returns tokenAmount after converting to BigDecimal. Else divides the BigDecimal tokenAmount using 10 raised to `exchangeDecimals` as the denominator.

#### Dependencies:
1. [ZERO_BI](./constants.ts#zero_bi)
2. [exponentToBigDecimal](#exponenttobigdecimal)

#### Invoked at:
1. [handleMint()](../mappings/core.ts#handlemint)
2. [handleBurn()](../mappings/core.ts#handleburn)
3. [handleSwap()](../mappings/core.ts#handleswap)
4. [handleIncreaseLiquidity()](../mappings/position-manager.ts#handleincreaseliquidity)
5. [handleDecreaseLiquidity()](../mappings/position-manager.ts#handledecreaseliquidity)
6. [handleCollect()](../mappings/position-manager.ts#handlecollect)

</TabItem>
<TabItem value="Optimism" label="Optimism">

#### Additionally Invoked At:
1. [populateEmptyPools()](./backfill.ts#populateemptypools)

</TabItem>
</Tabs>

### convertEthToDecimal()
```
Params:
 - eth (BigInt) - Int value representing ether amount in wei

ReturnType: BigDecimal
```
Converts the value of ether in wei from integer to big decimal representing amount in ether. It converts the eth parameter to BigDecimal and then divides it with 10^18 BigDecimal value.

#### Dependencies:
1. [exponentToBigDecimal](#exponenttobigdecimal)

#### Invoked at:
1.

### loadTransaction()
```
Params:
 - event (ethereum.Event) - Ethereum event emitted from the transaction to return.

ReturnType: Transaction
```
Returns a [Transaction](../../schemas/transaction.md) instance for the specified event. If a transaction instance doesn't already exit for the event, it's created and then returned. Uses `event.transaction.hash.toHexString()` to find the relevant transaction or to create a new transaction instance.
Uses `event` parameters `block.blockNumber`, `block.timestamp`, `transaction.gasUsed` and `transaction.gasPrice` to populate `transaction`'s fields.

#### Entites:
1. [Transaction](../../schemas/transaction.md) - Read/Create & Write

#### Invoked at:
1. [getPosition()](../mappings/position-manager.ts#getposition)
2. [savePositionSnapshot()](../mappings/position-manager.ts#savepositionsnapshot)
3. [handleMint()](../mappings/core.ts#handlemint)
4. [handleBurn()](../mappings/core.ts#handleburn)
5. [handleSwap()](../mappings/core.ts#handleswap)
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/utils/intervalUpdates.ts.md">
---
sidebar_position: 3
title: intervalUpdates.ts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

path: [`/src/utils/intervalUpdates.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/utils/intervalUpdates.ts)


### updateUniswapDayData()
```
Params:
 - event (ethereum.Event): The event used to determine dayId

ReturnType: UniswapDayData
```
Updates the `tvlUSD` and `txCount` parameters for `UniswapDayData` entity for a given day. Sets the variables to `factory` entity's `totalValueLockedUSD` and `txCount` values respectively.

Uses `event.block.timestamp.toI32() / 86400` to determine the `dayID` for `UniswapDayData`. If a `UniswapDayData` entity for the given day doesn't exist already, it is first created, with rest of the metrics initialized to `ZERO_BD`.

#### Entities:
1. [Factory](../../schemas/factory) - Read
2. [UniswapDayData](../../schemas/uniswapDayData) - Read/Create & Write

#### Dependencies:
1. [ZERO_BD](./constants.ts#zero_bd)


#### Invoked at:
1. [handleMint()](../mappings/core.ts#handlemint)
2. [handleBurn()](../mappings/core.ts#handleburn)
3. [handleSwap()](../mappings/core.ts#handleswap)

### updatePoolDayData()
```
Params:
 - event (ethereum.Event): The event used to determine pool address and dayId to get the PoolId

ReturnType: PoolDayData
```

<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

Using `event.block.timestamp.toI32()/86400` and `event.address.toHexString()` to get the `dayID` and `poolID` respectively. Together also give the `poolDayDataID`.

Creates a new `PoolDayData` entity for the day if not found. The new entity's metrics are initialized to `ZERO_BD` or `ZERO_BI`, while the `open`, `high`, `low` and `close` values are set to `pool.token0price`.

Updates the `PoolDayData` values `high` or `low` conditionally by comparing `pool.token0Price` with the existing values.

Updates the rest of the metrics using values from `Pool` entity.

Note: Currently updates `poolDayData.close` only when a new entity is created.

#### Entities:
1. [Pool](../../schemas/pool) - Read
2. [PoolDayData](../../schemas/poolDayData) - Read/Create & Write

#### Dependencies:
1. [ZERO_BD](./constants.ts#zero_bd)
2. [ZERO_BI](./constants.ts#zero_bi)

#### Invoked at:
1. [handleInitialize()](../mappings/core.ts#handleinitialize)
2. [handleMint()](../mappings/core.ts#handlemint)
3. [handleBurn()](../mappings/core.ts#handleburn)
4. [handleSwap()](../mappings/core.ts#handleswap)

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

- Uses the logic of mainnet but doesn't initialize or update `poolDayData.feeGrowthGlobal0X128` and `poolDayData.feeGrowthGlobal1X128` values.

</TabItem>
</Tabs>

### updatePoolHourData()
```
Params:
 - event (ethereum.Event): The event used to determine pool address and hourId to get the HourPoolId

ReturnType: PoolHourData
```
<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

Using `event.block.timestamp.toI32()/3600` and `event.address.toHexString()` to get the `hourIndex` and `poolID` respectively. Together also give the `hourPoolID`.

Creates a new `PoolHourData` entity for the specific hour if not found. The new entity's metrics are initialized to `ZERO_BD` or `ZERO_BI`, while the `open`, `high`, `low` and `close` values are set to `pool.token0price`.

Updates the `PoolHourData` values `high` or `low` conditionally by comparing `pool.token0Price` with the existing values.

Updates the rest of the metrics using values from `Pool` entity.

#### Entities:
1. [Pool](../../schemas/pool) - Read
2. [PoolHourData](../../schemas/poolHourData) - Read/Create & Write

#### Dependencies:
1. [ZERO_BD](./constants.ts#zero_bd)
2. [ZERO_BI](./constants.ts#zero_bi)
3. [ONE_BI](./constants.ts#one_bi)
#### Invoked at:
1. [handleInitialize()](../mappings/core.ts#handleinitialize)
2. [handleMint()](../mappings/core.ts#handlemint)
3. [handleBurn()](../mappings/core.ts#handleburn)
4. [handleSwap()](../mappings/core.ts#handleswap)

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

- Uses the logic of mainnet but doesn't initialize or update `poolHourData.feeGrowthGlobal0X128` and `poolHourData.feeGrowthGlobal1X128` values.

</TabItem>
</Tabs>

### updateTokenDayData()
```
Params:
 - token (Token): token to update the daily metrics for
 - event (ethereum.Event): The event used to determine the dayID

ReturnType: TokenDayData
```
Uses `event.block.timestamp.toI32() / 86400` to determine the `dayID`. Uses `dayId` and `token.id.toString()` to get the `tokenDayID`. 

Uses `token`'s value in terms of eth and multiplies it with eth's price in USD using `bundle.ethPriceUSD` to get `tokenPrice`. 

Creates a new `TokenDayData` entity if one for `tokenDayID` is not found. Initializes the metrics to `ZERO_BD`, while the `open`, `high`, `low` and `close` are set to `tokenPrice`.

Updates the `TokenDayData` values `high` or `low` conditionally by comparing `pool.token0Price` with the existing values.

Upadates the rest of the metrics using valus from `Token` entity.

#### Entities:
1. [Bundle](../../schemas/bundle) - Read
2. [TokenDayData](../../schemas/tokenDayData) - Read/Create & Write

#### Dependencies:
1. [ZERO_BD](./constants.ts#zero_bd)

#### Invoked at:
1. [handleMint()](../mappings/core.ts#handlemint)
2. [handleBurn()](../mappings/core.ts#handleburn)
3. [handleSwap()](../mappings/core.ts#handleswap)

### updateTokenHourData()
```
Params:
 - token (Token): token to update hourly metrics for
 - event (ethereum.Event): The event used to determine the hourIndex

ReturnType: TokenHourData
```
Using `event.block.timestamp.toI32()/3600` to get the `hourIndex`. Uses `hourIndex` and `token.id.toString()` to get the `tokenHourID`. 

Uses `token`'s value in terms of eth and multiplies it with eth's price in USD using `bundle.ethPriceUSD` to get `tokenPrice`. 

Creates a new `TokenHourData` entity for the specific hour if not found. The new entity's metrics are initialized to `ZERO_BD`, while the `open`, `high`, `low` and `close` values are set to `tokenPrice`.

Updates the `TokenHourData` values `high` or `low` conditionally by comparing `tokenPrice` with the existing values.

Updates the rest of the metrics using values from `token` entity.

#### Entities:
1. [Bundle](../../schemas/bundle) - Read
2. [TokenHourData](../../schemas/tokenHourData) - Read/Create & Write

#### Dependencies:
1. [ZERO_BD](./constants.ts#zero_bd)

#### Invoked at:
1. [handleMint()](../mappings/core.ts#handlemint)
2. [handleBurn()](../mappings/core.ts#handleburn)
3. [handleSwap()](../mappings/core.ts#handleswap)

### updateTickDayData()
```
Params:
 - tick (Tick): Tick to update daily metrics for
 - event (ethereum.Event): The event used to determine the dayId

ReturnType: TickDayData
```
<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

Uses `event.block.timestamp.toI32() / 86400` to determine the `dayID`. Uses `dayId` and `tick.id` to get the `tickDayDataID`.

Creates a new `TickDayData` entity for the specific day if not found. Initializes the fields `pool` and `tick` using `tick.pool` and `tick.id`  respectively.

Sets the `TickDayData` entity's field values using corresponding fields from `tick`.

#### Entities:
1. [TickDayData](../../schemas/tickDayData) - Read/Create & Write

#### Invoked at:
1. [updateTickFeeVarsAndSave()](../mappings/core.ts#updatetickfeevarsandsave)

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

- Uses the logic of mainnet but doesn't initialize or update `tickDayData.feeGrowthOutside0X128` and `tickDayData.feeGrowthOutside1X128` values.

</TabItem>
</Tabs>
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/utils/pricing.ts.md">
---
sidebar_position: 4
title: pricing.ts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

path: [`/src/utils/pricing.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/utils/pricing.ts)

### WETH_ADDRESS
<Tabs>
    <TabItem value="Eth Mainnet" label="Eth Mainnet">

```
- type: string
- value: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'
```
</TabItem>
<TabItem value="Polygon" label="Polygon">

```
- type: string
- value: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619'
```
</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-one">

```
- type: string
- value: '0x82af49447d8a07e3bd95bd0d56f35241523fbab1'
```
</TabItem>
<TabItem value="Optimism" label="Optimism">

```
- type: string
- value: '0x4200000000000000000000000000000000000006'
```
</TabItem>
</Tabs>
Address of wrapped-ETH (WETH) contract on ethereum mainnet.

#### Referenced at:
1. [WHITELIST_TOKENS](#whitelist_tokens)
2. [findEthPerToken()](#findethpertoken)

### USDC_WETH_03_POOL
<Tabs>
    <TabItem value="Eth Mainnet" label="Eth-Mainnet">

```
- type: string
- value: '0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8'
```

Address of Uniswap V3 pool contract between `USDC` and `WETH` `ERC-20` tokens on the specific chain.

#### Referenced at:
1. [getEthPriceInUSD](#getethpriceinusd)

</TabItem>
<TabItem value="Polygon" label="Polygon">

```
- type: string
- value: '0x0e44ceb592acfc5d3f09d996302eb4c499ff8c10'
```
</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-one">

```
- type: string
- value: '0x17c14d2c404d167802b16c450d3c99f88f2c4f4d'
```
</TabItem>
<TabItem value="Optimism" label="Optimism">

- Not present. Instead refer [DAI_WETH_03_POOL](#dai_weth_03_pool)

</TabItem>
</Tabs>

### DAI_WETH_03_POOL

<Tabs>
<TabItem value="Optimism" label="Optimism">

```
- type: string
- value: '0x03af20bdaaffb4cc0a521796a223f7d85e2aac31'
```

Address of Uniswap V3 pool contract between `DAI` and `WETH` `ERC-20` tokens on optimsim mainnet.

#### Referenced at:
1. [getEthPriceInUSD](#getethpriceinusd)

</TabItem>
<TabItem value="Other-Chains" label="Other-Chains">

- Not present. Instead refer [USDC_WETH_03_POOL](#usdc_weth_03_pool)

</TabItem>
</Tabs>


### WHITELIST_TOKENS
A list of tokens which have considerable usage and are likely to have pool pairing with other tokens. These can be used for calculating liquidity in USD by using the tokens price in USD.

The following token addresses are present in the list:

<Tabs>
    <TabItem value="Eth Mainnet" label="Eth-Mainnet">

|Symbol|Address|
|-|-|
|WETH|`WETH_ADDRESS`*|
|DAI|[0x6b175474e89094c44da98b954eedeac495271d0f](https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f)|
|USDC|[0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48](https://etherscan.io/address/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48)|
|USDT|[0xdac17f958d2ee523a2206206994597c13d831ec7](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7)|
|TUSD|[0x0000000000085d4780b73119b644ae5ecd22b376](https://etherscan.io/address/0x0000000000085d4780b73119b644ae5ecd22b376)|
|WBTC|[0x2260fac5e5542a773aa44fbcfedf7c193bc2c599](https://etherscan.io/address/0x2260fac5e5542a773aa44fbcfedf7c193bc2c599)|
|cDAI|[0x5d3a536e4d6dbd6114cc1ead35777bab948e3643](https://etherscan.io/address/0x5d3a536e4d6dbd6114cc1ead35777bab948e3643)|
|cUSDC|[0x39aa39c021dfbae8fac545936693ac917d5e7563](https://etherscan.io/address/0x39aa39c021dfbae8fac545936693ac917d5e7563)|
|EBASE|[0x86fadb80d8d2cff3c3680819e4da99c10232ba0f](https://etherscan.io/address/0x86fadb80d8d2cff3c3680819e4da99c10232ba0f)|
|sUSD|[0x57ab1ec28d129707052df4df418d58a2d46d5f51](https://etherscan.io/address/0x57ab1ec28d129707052df4df418d58a2d46d5f51)|
|MKR|[0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2](https://etherscan.io/address/0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2)|
|COMP|[0xc00e94cb662c3520282e6f5717214004a7f26888](https://etherscan.io/address/0xc00e94cb662c3520282e6f5717214004a7f26888)|
|LINK|[0x514910771af9ca656af840dff83e8264ecf986ca](https://etherscan.io/address/0x514910771af9ca656af840dff83e8264ecf986ca)|
|SNX|[0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f](https://etherscan.io/address/0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f)|
|YFI|[0x0bc529c00c6401aef6d220be8c6ea1667f6ad93e](https://etherscan.io/address/0x0bc529c00c6401aef6d220be8c6ea1667f6ad93e)|
|1INCH|[0x111111111117dc0aa78b770fa6a738034120c302](https://etherscan.io/address/0x111111111117dc0aa78b770fa6a738034120c302)|
|yCurv|[0xdf5e0e81dff6faf3a7e52ba697820c5e32d806a8](https://etherscan.io/address/0xdf5e0e81dff6faf3a7e52ba697820c5e32d806a8)|
|FEI|[0x956f47f50a910163d8bf957cf5846d573e7f87ca](https://etherscan.io/address/0x956f47f50a910163d8bf957cf5846d573e7f87ca)|
|MATIC|[0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0](https://etherscan.io/address/0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0)|
|AAVE|[0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9](https://etherscan.io/address/0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9)|
|sETH2|[0xfe2e637202056d30016725477c5da089ab0a043a](https://etherscan.io/address/0xfe2e637202056d30016725477c5da089ab0a043a)|

#### Dependencies:
1. [WETH_ADDRESS](#weth_address)

#### Referenced at:
1. [getTrackedAmountUSD](#gettrackedamountusd)
2. [handlePoolCreated()](../mappings/factory.ts#handlepoolcreated)

</TabItem>
<TabItem value="Polygon" label="Polygon">

|Symbol|Address|
|-|-|
|WETH|`WETH_ADDRESS`*|
|WMATIC|[0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270](https://polygonscan.com/address/0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270)|
|USDC|[0x2791bca1f2de4661ed88a30c99a7a9449aa84174](https://polygonscan.com/address/0x2791bca1f2de4661ed88a30c99a7a9449aa84174)|
|DAI|[0x8f3cf7ad23cd3cadbd9735aff958023239c6a063](https://polygonscan.com/address/0x8f3cf7ad23cd3cadbd9735aff958023239c6a063)|
</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-one">

|Symbol|Address|
|-|-|
|WETH|`WETH_ADDRESS`*|
|USDC|[0xff970a61a04b1ca14834a43f5de4533ebddb5cc8](https://arbiscan.io/address/0xff970a61a04b1ca14834a43f5de4533ebddb5cc8)|
|DAI|[0xda10009cbd5d07dd0cecc66161fc93d7c9000da1](https://arbiscan.io/address/0xda10009cbd5d07dd0cecc66161fc93d7c9000da1)|
|USDT|[0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9](https://arbiscan.io/address/0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9)|
</TabItem>
<TabItem value="Optimism" label="Optimism">

|Symbol|Address|
|-|-|
|WETH|`WETH_ADDRESS`*|
|DAI|[0xda10009cbd5d07dd0cecc66161fc93d7c9000da1](https://optimistic.etherscan.io/address/0xda10009cbd5d07dd0cecc66161fc93d7c9000da1)|
|OP|[0x4200000000000000000000000000000000000042](https://optimistic.etherscan.io/address/0x4200000000000000000000000000000000000042)|
|USDC|[0x7f5c764cbc14f9669b88837ca1490cca17c31607](https://optimistic.etherscan.io/address/0x7f5c764cbc14f9669b88837ca1490cca17c31607)|
|PERP|[0x9e1028f5f1d5ede59748ffcee5532509976840e0](https://optimistic.etherscan.io/address/0x9e1028f5f1d5ede59748ffcee5532509976840e0)|
|LYRA|[0x50c5725949a6f0c72e6c4a641f24049a917db0cb](https://optimistic.etherscan.io/address/0x50c5725949a6f0c72e6c4a641f24049a917db0cb)|
|USDT|[0x94b008aa00579c1307b0ef2c499ad98a8ce58e58](https://optimistic.etherscan.io/address/0x94b008aa00579c1307b0ef2c499ad98a8ce58e58)|
|WBTC|[0x68f180fcce6836688e9084f035309e29bf0a2095](https://optimistic.etherscan.io/address/0x68f180fcce6836688e9084f035309e29bf0a2095)|

#### Additional Referenced at:
1. [populateEmptyPools()](./backfill.ts#populateemptypools)

</TabItem>
</Tabs>

\* -> The value is imported from a variable and listed directly in the list declaration.

### STABLE_COINS
A list of ERC20 token contract addresses which have stable coin prices, i.e., 1 token expected to be valued at 1 USD.
<Tabs>
    <TabItem value="Eth Mainnet" label="Eth-Mainnet">

||Address|
|-|-|
|DAI|[0x6b175474e89094c44da98b954eedeac495271d0f](https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f)|
|USDC|[0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48](https://etherscan.io/address/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48)|
|USDT|[0xdac17f958d2ee523a2206206994597c13d831ec7](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7)|
|TUSD|[0x0000000000085d4780b73119b644ae5ecd22b376](https://etherscan.io/address/0x0000000000085d4780b73119b644ae5ecd22b376)|
|FEI|[0x956f47f50a910163d8bf957cf5846d573e7f87ca](https://etherscan.io/address/0x956f47f50a910163d8bf957cf5846d573e7f87ca)|
|PRINTS|[0x4dd28568d05f09b02220b09c2cb307bfd837cb95](https://etherscan.io/address/0x4dd28568d05f09b02220b09c2cb307bfd837cb95)|

#### Referenced at:
1. [findEthPertoken()](#findethpertoken)

</TabItem>
<TabItem value="Polygon" label="Polygon">

||Address|
|-|-|
|USDC|[0x2791bca1f2de4661ed88a30c99a7a9449aa84174](https://polygonscan.com/address/0x2791bca1f2de4661ed88a30c99a7a9449aa84174)|

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

- `STABLE_COINS` is not defined for arbitrum-one subgraph.

</TabItem>
<TabItem value="Optimism" label="Optimism">

- `STABLE_COINS` is not defined for optimism subgraph.

</TabItem>
</Tabs>

### MINIMUM_ETH_LOCKED
<Tabs>
    <TabItem value="Eth Mainnet" label="Eth-Mainnet">

```
 - type: BigDecimal
 - value: 60
```
While calculating token price in USD, the value of other token locked in the pool in terms of eth has to be greated than `MINIMUM_ETH_LOCKED`.

#### Referenced at:
1. [findEthPertoken()](#findethpertoken)

</TabItem>
<TabItem value="Polygon" label="Polygon">

```
 - type: BigDecimal
 - value: 5
```
</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-one">

```
 - type: BigDecimal
 - value: 4
```

#### Additionally Referenced at:
1. [getEthPriceInUSD()](#getethpriceinusd)

</TabItem>
<TabItem value="Optimism" label="Optimism">

```
 - type: BigDecimal
 - value: 10
```

</TabItem>
</Tabs>

### sqrtPriceX96ToTokenPrices()
```
Params:
 - sqrtPriceX96 (BigInt): The square root of the price of token1 in terms of token0 in Q64.96 format. Formula: sqrt(token0.price/token1.price)*(2^96)
 - token0 (Token): The first token in the pool pair to calculate the relative price for
 - token1 (Token): The second token in the pool pair to calculate the relative price for

ReturnType: BigDecimal[]
```
Find the price of `token0` and `token1` in the pool relative to each other and returns the two prices.

#### Formula:
```
    num = (sqrtPriceX96^2) # Squaring the root to get the price
    denom = 2^192 # To divide price by 96^2 to convert the Q64.96 number to BigDecimal
    price1 = ((num/denom) * (10^token0.decimals))/ (10^token1.decimals) # Calculating price1
    price0 = 1/price1
```

#### Dependencies:
1. [exponentToBigDecimal()](./index.ts#exponenttobigdecimal)
2. [safeDiv()](./index.ts#safediv)

#### Invoked at:
1. [handleSwap()](../mappings/core.ts#handleswap)


### getEthPriceInUSD()
```
Params: none

ReturnType: BigDecimal
```
<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

Returns the Price of ETH in terms of USD, based on the stable coin pools.
Currently, the `token0Price` for the `pool` represented by `USDC_WETH_03_POOL`. When `pool` entity is not found, returns `ZERO_BD`.

#### Entites:
1. [Pool](../../schemas/pool.md) - Read Entity

#### Dependencies:
1. [USDC_WETH_03_POOL](#usdc_weth_03_pool)
2. [ZERO_BD](./constants.ts#zero_bd)

#### Invoked at:
1. [handleInitialize()](../mappings/core.ts#handleinitialize)
2. [handleSwap()](../mappings/core.ts#handleSwap)

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

- Logic same as mainnet, except returns `ZERO_BD` if eth locked is not greated than `MINIMUM_ETH_LOCKED`.

#### Additional Dependencies:
1. [MINIMUM_ETH_LOCKED](#minimum_eth_locked)

</TabItem>
<TabItem value="Optimism" label="Optimism">

- Uses [DAI_WETH_03_POOL](#dai_weth_03_pool) instead of USDC

#### Differing Dependencies:
1. [DAI_WETH_03_POOL](#dai_weth_03_pool)

</TabItem>
</Tabs>

### findEthPerToken()
```
Params:
 - token (Token): Token entity to find the price in terms of ETH

ReturnType: BigDecimal
```
<Tabs>
<TabItem value="Eth Mainnet, Polygon" label="Eth Mainnet, Polygon">

If token is weth, returns 1. If token in `STABLE_COINS`, returns `1/bundle.ethPriceUSD`.

Else, iterates over all the whitelisted pools for the token using `token.whitelistPools`. Finds the pool with largest liquidity value in terms of ETH, as long as the value is atleast `MINIMUM_ETH_LOCKED`. Uses the eth value of the paired token and relative token price between the token pair to find the `token`'s' value in terms of eth.
If there's no whitelisted pool with `MINIMUM_ETH_LOCKED`, returns `ZERO_BD`.

#### Entites:
1. [Bundle](../../schemas/bundle.md) - Read Entity
2. [Pool](../../schemas/pool.md) - Read Entity
3. [Token](../../schemas/token.md) - Read Entity

#### Dependencies:
1. [WETH_ADDRESS](#weth_address)
2. [ONE_BD](./constants.ts#one_bd)
3. [ZERO_BD](./constants.ts#zero_bd)
4. [STABLE_COINS](#stable_coins)
5. [MINIMUM_ETH_LOCKED](#minimum_eth_locked)

#### Invoked at:
1. [handleInitialize()](../mappings/core.ts#handleinitialize)
2. [handleSwap()](../mappings/core.ts#handleSwap)

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">
- Doesn't check if token is present in `STABLE_COINS`. Rest of the logic is same as mainnet.
</TabItem>
</Tabs>

### getTrackedAmountUSD()
```
Params:
 - tokenAmount0 (BigDecimal):
 - token0 (Token0):
 - tokenAmount1 (BigDecimal):
 - token1 (Token):

ReturnType: BigDecimal
```
Returns the USD value equivalent to `tokenAmoun0` and `tokenAmount1` together. Calculates the USD price using `token.derviedEth*bundle.ethPriceUSD` as the multiplier if the token is present in `WHITELIST_TOKENS`. If both the tokens are present, it adds their individual USD prices. If only one is present, it uses 2X the value of that token. If neither are in the `WHITELIST_TOKENS` list, returns `ZERO_BD`.
#### Entites:
1. [Bundle](../../schemas/bundle.md) - Read Entity

#### Dependencies:
1. [WHITELIST_TOKENS](#whitelist_tokens)
2. [ZERO_BD](./constants.ts#zero_bd)

#### Invoked at:
1. [handleSwap()](../mappings/core.ts#handleSwap)
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/utils/staticTokenDefinition.ts.md">
---
sidebar_position: 5
title: staticTokenDefinition.ts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

path: [`/src/utils/staticTokenDefinition.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/utils/staticTokenDefinition.ts)


## Class StaticTokenDefinition
A utility class to represent an `ERC20` token metadata. Contains four fields:

|Field|Type|
|-|-|
|address|Address|
|symbol|string|
|name|string|
|decimals|BigInt|

It has a constructor to initialized an object:
```
constructor(address: Address, symbol: string, name: string, decimals: BigInt)
```

The class exposes two static functions:
1. [getStaticDefinitions()](#getstaticdefinitions)
2. [fromAddress()](#fromaddress)

### getStaticDefinitions()
Returns an `Array<StaticTokenDefinition>` object with the token definitions defined with the function:

<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

|Address|Symbol|Name|Decimals|
|-|-|-|-|
|0xe0b7927c4af23765cb51314a0e0521a9645f0e2a|DGD|DGD|9|
|0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9|AAVE|Aave Token|18|
|0xeb9951021698b42e4399f9cbb6267aa35f82d59d|LIF|Lif|18|
|0xbdeb4b83251fb146687fa19d1c660f99411eefe3|SVD|savedroid|18|
|0xbb9bc244d798123fde783fcc1c72d3bb8c189413|TheDAO|TheDAO|16|
|0x38c6a68304cdefb9bec48bbfaaba5c5b47818bb2|HPB|HPBCoin|18|

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

|Address|Symbol|Name|Decimals|
|-|-|-|-|
|0x82af49447d8a07e3bd95bd0d56f35241523fbab1|WETH|Wrapped Ethereum|18|
|0xff970a61a04b1ca14834a43f5de4533ebddb5cc8|USDC|USD Coin|6|

</TabItem>
<TabItem value="Optimism" label="Optimism">

|Address|Symbol|Name|Decimals|
|-|-|-|-|
|0x82af49447d8a07e3bd95bd0d56f35241523fbab1|WETH|Wrapped Ethereum|18|

</TabItem>
</Tabs>

#### Invoked at:
1. [fromAddress()](#fromaddress)

### fromAddress()
```
Params:
 - tokenAddress (Address): the ERC20 address to search for in the ERC20 symbols defined in StaticTokenDefinition class

ReturnType: StaticTokenDefinition | null
```
Get an Array of `StaticTokenDefinition` objects from static method getStaticDefinition() and iterates through them to find the `tokenAddress`, If found returns the `StaticTokenDefinition` object, else returns `null`.

#### Dependencies:
1. [getStaticDefinitions()](#getstaticdefinitions)

#### Invoked at:
1. [fetchTokenSymbol()](./token.ts#fetchtokensymbol)
2. [fetchTokenName()](./token.ts#fetchtokenname)
3. [fetchTokenDecimals()](./token.ts#fetchtokendecimals)
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/utils/tick.ts.md">
---
sidebar_position: 6
title: tick.ts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

path: [`/src/utils/tick.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/utils/tick.ts)

### createTick()
```
Params:
 - tickId (String): ID of the tick instance to create. Format: <pool address>#<tick index>
 - tickIdx (i32): Tick index
 - poolId (string): PoolId
 - event (MintEvent): The mint event where liquidity was added to the tick

ReturnType: Tick
```
<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

Initializes a new Tick to store the liquidity present at the specific tick.

Sets `tick.id`, `tick.tickIdx`, `tick.pool` and `tick.poolId` from the parametrs. Sets `tick.creatdAtTimeStamp` and `tick.createdAtBlockNumber` from `event.block.timestamp` and `event.block.number` respectively.

`tick.price0` is calcualted as `1.0001^tickIdx` and `tick.price1` as `safeDiv(ONE_BD, price0)`.

All the other parameters are initialized to `ZERO_BD` or `ZERO_BI`.

#### Entites:
1. [Tick](../../schemas/tick.md) - Create

#### Dependencies:
1. [ZERO_BI](./constants.ts#zero_bi)
2. [ONE_BD](./constants.ts#one_bd)
3. [ZERO_BD](./constants.ts#zero_bd)
4. [bigDecimalExponated()](./index.ts#bigdecimalexponated)
5. [safeDiv()](./index.ts#safediv)

#### Invoked at:
1. [handleMint()](../mappings/core.ts#handlemint)

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

- Logic same as mainnet, except doesn't initialize the variables `tick.feeGrowthOutside0X128` and  `tick.feeGrowthOutside1X128`

</TabItem>
</Tabs>   

### createTickBurn()
:::info Only in Optimism
This function exists only in optimism subgraph
:::
```
Params:
 - tickId (String): ID of the tick instance to initialize. Format: <pool address>#<tick index>
 - tickIdx (i32): Tick index
 - poolId (string): PoolId
 - event (MintEvent): The event where the liquidity from the tick is removed

ReturnType: Tick
```

Instantiate a tick that already exists from previous transactions.

- Uses the same logic as [createTick()](#createtick) to initialize a new tick entity
- Later reads the Pool contract ticks data for `tickIdx` and sets the `tick.liquidityGross`, `tick.liquidityNet`, `tick.feeGrowthOutside0X128` and `tick.feeGrowthOutside1X128` vlaues.

#### Entites:
1. [Tick](../../schemas/tick.md) - Create * Write

#### ABI Dependencies:
1. pool.json

#### Dependencies:
1. [ZERO_BI](./constants.ts#zero_bi)
2. [ONE_BD](./constants.ts#one_bd)
3. [ZERO_BD](./constants.ts#zero_bd)
4. [bigDecimalExponated()](./index.ts#bigdecimalexponated)
5. [safeDiv()](./index.ts#safediv)

#### Invoked at:
1. [handleBurn()](../mappings/core.ts#handleburn)


### feeTierToTickSpacing()
```
Params:
 - feeTier (BigInt): The fee tier specified for the pool

ReturnType: BigInt
```
<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

Given a specific fee tier, returns a BigInt value for the respective tick spacing used in the pool contract.

|Fee Tier|TickSpaceing Returned|
|--|---|
| 10000 | 200 |
| 3000 | 60 |
| 500 | 10 |
| 100 | 1 |
| Anything Else | Error: 'Unexpected fee tier'|

#### Invoked at:
1. [handleSwap()](../mappings/core.ts#handleswap)

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

- Doesn't have the Fee Tier `100`, Tick Space `1` entry.

</TabItem>
</Tabs>
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/utils/token.ts.md">
---
sidebar_position: 7
title: token.ts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

path: [`/src/utils/token.ts`](https://github.com/Uniswap/v3-subgraph/blob/main/src/utils/token.ts)

### fetchTokenSymbol()
```
Params:
 - tokenAddress (Address): The ERC20 Token Address for which the symbol is returned

ReturnType: string
```
<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

Returns the string value representing the ERC20 symbol read from the contract with address `tokenAddress` using `symbol()` method. If reverted, checks if the `tokenAddres` is present in `StaticTokenDefinition`. Returns `unknown` if not found.

#### ABI Dependencies:
1. ERC20.json
2. ERC20SymbolBytes.json

#### Dependencies:
1. [isNullEthValue()](./index.ts#isnullethvalue)
2. [StaticTokenDefintion](./staticTokenDefinition.ts#statictokendefinition)
3. [StaticTokenDefintion.fromAddress()](./staticTokenDefinition.ts#fromaddress)

#### Invoked at:
1. [handlePoolCreated()](../mappings/factory.ts#handlepoolcreated)

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

- Logic similar to mainnet except uses `StaticTokenDefition` first and proceeds to read from contract if not found.

</TabItem>
<TabItem value="Optimism" label="Optimism">

- Logic similar to mainnet except uses `StaticTokenDefition` first and proceeds to read from contract if not found.

#### Additionally Invoked At:
1. [populateToken()](./backfill.ts#populatetoken)

</TabItem>
</Tabs>   

### fetchTokenName()
```
Params:
 - tokenAddress (Address): The ERC20 Token Address for which the Name is returned

ReturnType: string
```
<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

Returns the string value representing the ERC20 name read from the contract with address `tokenAddress` using `name()` method. If reverted, checks if the `tokenAddres` is present in `StaticTokenDefinition`. Returns `unknown` if not found.

#### ABI Dependencies:
1. ERC20.json
2. ERC20NameBytes.json

#### Dependencies:
1. [isNullEthValue()](./index.ts#isnullethvalue)
2. [StaticTokenDefintion](./staticTokenDefinition.ts#statictokendefinition)
3. [StaticTokenDefintion.fromAddress()](./staticTokenDefinition.ts#fromaddress)

#### Invoked at:
1. [handlePoolCreated()](../mappings/factory.ts#handlepoolcreated)

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

- Logic similar to mainnet except uses `StaticTokenDefition` first and proceeds to read from contract if not found.

</TabItem>
<TabItem value="Optimism" label="Optimism">

- Logic similar to mainnet except uses `StaticTokenDefition` first and proceeds to read from contract if not found.

#### Additionally Invoked At:
1. [populateToken()](./backfill.ts#populatetoken)

</TabItem>
</Tabs>   

### fetchTokenTotalSupply()
```
Params:
 - tokenAddress (Address): The ERC20 Token Address for which the Total Supply is 

ReturnType: BigInt
```
<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

Queries the ERC20 contract with address `tokenAddress` and returns total token supply using `totalSupply()` method. If call reverts, typecasts `null` to i32 then to BigDecimal and returns the value.

#### ABI Dependencies:
1. ERC20.json

#### Invoked at:
1. [handlePoolCreated()](../mappings/factory.ts#handlepoolcreated)

</TabItem>
<TabItem value="Optimism" label="Optimism">

#### Additionally Invoked At:
1. [populateToken()](./backfill.ts#populatetoken)

</TabItem>
</Tabs>

### fetchTokenDecimals()
```
Params:
 - tokenAddress (Address): The ERC20 Token Address for which the number of decimals is returned

ReturnType: BigInt
```
<Tabs>
<TabItem value="Other Chains" label="Other-Chains">

Queries the ERC20 contract with address `tokenAddress` and returns the decimals value for the token `decimals()` method. If call reverts, check for `tokenAddress` in `StaticTokenDefinition`. If not found, typecasts `null` to i32 then to BigDecimal and returns the value.

#### ABI Dependencies:
1. ERC20.json

#### Dependencies:
1. [StaticTokenDefintion](./staticTokenDefinition.ts#statictokendefinition)
2. [StaticTokenDefintion.fromAddress()](./staticTokenDefinition.ts#fromaddress)

#### Invoked at:
1. [handlePoolCreated()](../mappings/factory.ts#handlepoolcreated)

</TabItem>
<TabItem value="Arbitrum-One" label="Arbitrum-One">

- Logic similar to mainnet except uses `StaticTokenDefition` first and proceeds to read from contract if not found.

</TabItem>
<TabItem value="Optimism" label="Optimism">

- Logic similar to mainnet except uses `StaticTokenDefition` first and proceeds to read from contract if not found.

#### Additionally Invoked At:
1. [populateToken()](./backfill.ts#populatetoken)

</TabItem>
</Tabs>
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/_category_.json">
{
  "label": "Functions",
  "position": 7,
  "link": {
    "type": "generated-index",
    "description": "Implementation details of functions present in the /src folder"
  }
}
</file>

<file path="docs/api/subgraph/subgraphs-devs/functions-n-handlers/poolMapping.ts.md">
---
sidebar_position: 3
title: Pool Mapping
---

:::info Only in Optimism
The file is present in Optimism only
:::


### POOL_MAPPINGS

The table captures pool addresses pre-regenesis provided by the Optimism team. This is needed as subgraph indexer has no knowledge for pre-regenesis events.

|Old Address|New Address|Token0 Address | Token1 Address |
|-|-|-|-|
|0x8c505fd76eed0945699265c7c7e5bbf756b7e5ad|0x03af20bdaaffb4cc0a521796a223f7d85e2aac31|0x4200000000000000000000000000000000000006|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x8c505fd76eed0945699265c7c7e5bbf756b7e5ad|0x827f0a2a4376bc26729f398b865f424dc8456841|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0xdd54251a35078ba39e3ad5fb059f9aa243693b9d|0x73b14a78a0d396c521f954532d43fd5ffe385216|0x4200000000000000000000000000000000000006|0x68f180fcCe6836688e9084f035309E29Bf0A2095|
|0x0ad1af4178e17d7f41dbcdf9d573701bef5eb501|0xdd0c6bae8ad5998c358b823df15a2a4181da1b80|0x4200000000000000000000000000000000000006|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0xdf42e37f057c61765fe7204642c4d2e5ff929cfe|0x815ae7bf44dda74ed9274377ed711efc8b567911|0x4200000000000000000000000000000000000006|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x6b952bfbfda057a7f288edaa9f611cd446ddbe22|0x95d9d28606ee55de7667f0f176ebfc3215cfd9c0|0x4200000000000000000000000000000000000006|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x0bec645f0373750fe0256ee0e7b06d63eae5e04d|0x2df05e4cdbd758cb1a99a34bb0d767e040d6b078|0x4200000000000000000000000000000000000006|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0x6afd8618459729da24ee36978567fb04fe5fd1bd|0x85c31ffa3706d1cce9d525a00f1c7d4a2911754c|0x4200000000000000000000000000000000000006|0x68f180fcCe6836688e9084f035309E29Bf0A2095|
|0xa61dea82c7c3e64a6a80550aacb251eed604b46b|0x37ffd11972128fd624337ebceb167c8c0a5115ff|0x4200000000000000000000000000000000000006|0x68f180fcCe6836688e9084f035309E29Bf0A2095|
|0xcf438c19332d507326210da527fb9cf792fd3e18|0xc858a329bf053be78d6239c4a4343b8fbd21472b|0x4200000000000000000000000000000000000006|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0xaddd011cb3b61d0dc4f85c2661cc9bd1bd640067|0xb29a022ff4b37bdfb21e5f1daff4af5a22aa9510|0x4200000000000000000000000000000000000006|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|
|0x47516ccba929c607e14dbd02f2ebac1e7960b1f8|0x0392b358ce4547601befa962680bede836606ae2|0x4200000000000000000000000000000000000006|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|
|0x13b2d83ec506b5c770f64ee0f564ff9719c74071|0xfea834a5c47b923add607cc5b96288d18ffb9c3f|0x4200000000000000000000000000000000000006|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|
|0xd20bf925e04933ff79274479009218dedab6657f|0xac721d2e27ca148f505b5106fc95e594c78ace5b|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0x7678f1e1ed90efec8757af161ab25bf1e8e00238|0xa13514b5444e50067f6e48c386016b211773cf9e|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x2816913eda0010af856d323724f521fb702a25a7|0xcf2aebb91fec906f51fc11cd57035a09d8b16965|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x2419a5fee0f8e0192869507ed6a301382ad9edda|0xea0f33940eb221aaad9360891cab08ef4f1f0703|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x0ccf6bf2df83d250d0f6a636215ef7d19f86dd01|0x703eb589321f3dc7408e9dde01b790e64a9fe4e9|0x68f180fcCe6836688e9084f035309E29Bf0A2095|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x1135e9ce18373238c77ff602a9b0a579ca86eb8e|0xc22662b904d98e45f89e030201355c3e372cc819|0x68f180fcCe6836688e9084f035309E29Bf0A2095|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x2f5ccaf670e9c5f4336c127a29fdd4932f238069|0x1aa9b4d9933ff96b2011fddd764240d4a16b7c07|0x68f180fcCe6836688e9084f035309E29Bf0A2095|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x0f641370eb5cb4f0b0d58140d5fb2f97ffcbfce5|0x2459023a29d3b07711b8b916d86aa7e8a14747af|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0xa14e5b3ba5dd981b536e0950390b03972b795018|0xadb35413ec50e0afe41039eac8b930d313e94fa4|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0xbdb9a8279a525bafe9be7efb9b5df79b18eeb23f|0x84eb2c5c23999b3ddc87be10f15ccec5d22c7d97|0x4200000000000000000000000000000000000006|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|
|0xa194977b416f082f71a0362041b57208c91ee1c1|0x2e80d5a7b3c613d854ee43243ff09808108561eb|0x4200000000000000000000000000000000000006|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|
|0xc3099d7fd3fc7d4feea11911fbe6eadc94c7c07a|0x3d44cc727fe2f603e4929be164c70edb3b498b5f|0x4200000000000000000000000000000000000006|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|
|0xfe901e734c8c55645731acd4eb0be963d2a85b94|0xa588c9d2884c60b098c5ad028ec2f4a1fab772b5|0x68f180fcCe6836688e9084f035309E29Bf0A2095|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|
|0xeaa5ba3ef450887e4d5a627700aef3c1a16d4090|0xc53f2be3331926d2f30ee2b10362bb45fdbe7bf6|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|
|0x263312f667279452ad44cda7971fe93f18b6dad4|0x0843e0f56b9e7fdc4fb95fabba22a01ef4088f41|0x68f180fcCe6836688e9084f035309E29Bf0A2095|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0x051580636f94b8b6ba69b879958939d324d8f650|0x8184f5cf4921558c201923ef6d7d5258a6efa31f|0x68f180fcCe6836688e9084f035309E29Bf0A2095|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0xbb8a699cbd6b45f7c31dcd14bd6d965ab4293e2c|0x8b057f0ccd9fb78f688472574cf3f9d2322f5454|0x68f180fcCe6836688e9084f035309E29Bf0A2095|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0x98fd8560e184136f482054c19a63e644240e30f4|0x9f08065dfc4817a0a56db7bcab757e86399bc51d|0x68f180fcCe6836688e9084f035309E29Bf0A2095|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|
|0xbeafe824395fff8df37c4814e8de9d455e79cdad|0x7628784d2c5d47fcd5479ba812343b1aabad6484|0x68f180fcCe6836688e9084f035309E29Bf0A2095|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|
|0xcfe7288e10994555ca97dfa2d0c50e55a4d4dc39|0xceb488e01c8e2e669c40b330bfc1440921c9ebe2|0x68f180fcCe6836688e9084f035309E29Bf0A2095|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|
|0x4cff717ff0b0a4a3578e8bbb7a5f06d32574238b|0x25e412992634b93a025e2a538c53222a8c62e2d6|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|
|0x072611197970d6a9e57680f97f177ff947f09139|0xc0f184c6c4832b3ed861bd5b05722792ffa64abd|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|
|0x380ff418bf1589b46e9660c6b2197b4ce8ae8a12|0xf046d8b7365d8abe5a8f8301c669b4b5284fc21d|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0xac8c823548f13874dcfc76029089de01f4adc1d3|0x1f2390484dfe2d8900bc91c7111d274b7b2d63a1|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x8cf0a5fdcaed0956a3221e1dd5219bb14f092595|0xa0959d2dcd9dd56bf080a10cfe29eeb401344e3d|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0xaf00e47d2fe45befc4540fe02a87cb053e252065|0x30be2fff09fcd820a1d472e646bd233dbd812133|0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0x00a0e3cd857a7e5676c901bd349ed1d6afb59fb3|0x3202c46666e774b44ba463eafaa6da9a968a058f|0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6|0x4200000000000000000000000000000000000006|
|0x90fc3f5f84fb868b7693b1f2690b91f28c1600d0|0x85e8d0fddf559a57aac6404e7695142cd53eb808|0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6|0x68f180fcCe6836688e9084f035309E29Bf0A2095|
|0xc87adb8ac31434e96b429ced522ed84a2ce707a6|0x22fc5dc36811d15fafde7cc7900ae73a538e59e0|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0x466fd9d58bdd0e246cbe9112d95d077b81b341af|0xe7ee03b72a89f87d161425e42548bd5492d06679|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x7b6467b86878b86163bcb3162d84e34ea5c7389b|0xfe1bd31a79163d6277ab8c2917d7857c225db065|0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|
|0xc24383ba6d156706864a48f50fc01e89c0bf11d7|0xbf595eb9a512b1c274125264aef84a2847158eb3|0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|
|0x93d9dfb5caf591df911b251db4d76cd95f4644b7|0x124657e5bb6afc12a15c439d08fc80070f9a1a1e|0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x36c95ae265883c2b19e61997760b110cc05e4a60|0xd6101cda1a51924e249132cbcae82bfcd0a91fbc|0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0xd515990647c39c4a0b8c03f811f9b746958a0eec|0x19ea026886cbb7a900ecb2458636d72b5cae223b|0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6|0x4200000000000000000000000000000000000006|
|0x3b6479c7748eb5b143a3a52d237c0097734b811b|0x5aacc66073cb0c3064353f1441c2e04170b4dbbf|0x4200000000000000000000000000000000000006|0xc5Db22719A06418028A40A9B5E9A7c02959D0d08|
|0x2d073707207098cc69e8e86c6a3fd12644b8a1b2|0x4284b21e76d1b3977cab8f0032867e00e6eea382|0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6|0xc5Db22719A06418028A40A9B5E9A7c02959D0d08|
|0x015986c7074ec1eeae0387a8baf485fd9d811b7d|0x2f10a1a3e640ad1615cbedf95a1749a4af88cbc0|0xB548f63D4405466B36C0c0aC3318a22fDcec711a|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x4a88e6fa2afad460befd586fc1581f322308c490|0x32846ede08688d10a9da59387707a8fbb0790fa7|0x4200000000000000000000000000000000000006|0xab7bAdEF82E9Fe11f6f33f87BC9bC2AA27F2fCB5|
|0xccf24898ca659afa8cb6a3bdb8a2e0a2debda12d|0xbdb6371fffc1753b33b87c68c827eb7978670515|0x4200000000000000000000000000000000000006|0x6fd9d7AD17242c41f7131d257212c54A0e816691|
|0x856d50c587824f84de481ea706208b03db38f6f2|0x2eee8ed7df992f23d7554b0db8835d483cce901c|0x298B9B95708152ff6968aafd889c6586e9169f1D|0x68f180fcCe6836688e9084f035309E29Bf0A2095|
|0xe3d8cfc3a0b43d2288b3da41563b1fe0623209de|0x65dc095b35679005229896566928f6852948092b|0x298B9B95708152ff6968aafd889c6586e9169f1D|0x68f180fcCe6836688e9084f035309E29Bf0A2095|
|0x62196490fcf045437e5e4cb49228bbd778b7196d|0x2d6497dd08a1620d386ce708edac50aaec332415|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|0xe405de8f52ba7559f9df3c368500b6e6ae6cee49|
|0x3b1f6287be238c9b0a4b48d85d2359d58aaa9683|0x039ae8860fbfdf61f654b1a5b55cc3aa753f5842|0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0x91e50b184ea237b3da1c005ee5d2a17a904a34c6|0x24342b5d46f69ba05c09becdd00e5324f9f0f7ca|0x298B9B95708152ff6968aafd889c6586e9169f1D|0x4200000000000000000000000000000000000006|
|0x518767d8ef1acffd978581c16789f8a2803f9bef|0xf0d0e52da1fdde512af299f3d8ea1c5e3bebb96f|0x4200000000000000000000000000000000000006|0xe3C332a5DcE0e1d9bC2cC72A68437790570C28a4|
|0xc2c0786e85ac9b0b223966d040ebc641fa44225e|0xb589969d38ce76d3d7aa319de7133bc9755fd840|0x4200000000000000000000000000000000000006|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|
|0xa2389a4ee391b4b04ae8dc664664190f3d28f2fe|0x8eda97883a1bc02cf68c6b9fb996e06ed8fdb3e5|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|
|0xf9ca53854d1ac7adb43d9447aa87f17fe1454e31|0x100bdc1431a9b09c61c0efc5776814285f8fb248|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x4893c5f29301cfd7a6527331f3e06ea82e68a952|0xe229ce1cdbea9983362ca29f0f0b2c70bb2dacdf|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0xf2e805fe3b15297e1df03b6036d01b32ab8f7998|0xd9b160620447d9a9a6ca90c0450f5490e5219257|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x6663eea65669978481bae55814cbc496acd50352|0x1179b19438a622fe36be5f9c073b700420384397|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x7bbc5726e6c2640ed0f0fda1546dc232dc5db89c|0xf3f3433c3a97f70349c138ada81da4d3554982db|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0x0d4294ae819ff83a4e2a99db8d06cdd025c19218|0x85149247691df622eaf1a8bd0cafd40bc45154a9|0x4200000000000000000000000000000000000006|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|
|0x9e845c705aba9a2ca6e97c2423797e18a98d34c0|0x6fa1ea0ccbbe9b2ad52440c88a47b5d73cd9a731|0x298B9B95708152ff6968aafd889c6586e9169f1D|0x4200000000000000000000000000000000000006|
|0x00a4dfb447a43a583d8e07eae9d4efbb3656cbcb|0xad4c666fc170b468b19988959eb931a3676f0e9f|0x4200000000000000000000000000000000000006|0x6fd9d7AD17242c41f7131d257212c54A0e816691|
|0xdeb1106b510d94df3bcc55e74f51a6f6b231d97e|0x4983691a26d55eb9e18d2e12e3b770cdd3f76a5f|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0xd2243a43813cd7c4bfb2287f32d3989b0f2f67d5|0x8e2eaef2c05ef93f424a8324b94e725eaa362f91|0x4200000000000000000000000000000000000006|0x6fd9d7AD17242c41f7131d257212c54A0e816691|
|0x0b3a6896345b68539571aab140134630151ebc68|0x8531e48a8611729185be9eaad945acbd6b32e256|0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6|0x4200000000000000000000000000000000000006|
|0x99959743247f2fa2e97b33e532337eae616beeda|0xeb1817b708415f4f78c5f0c99cbbd6a3a899fa6d|0x6fd9d7AD17242c41f7131d257212c54A0e816691|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0x94ee41af02171d6dc1e05b790de547fa50dbd7cf|0x26e7fed14a97e0c482a302237971cf1b04f6d3e9|0x6fd9d7AD17242c41f7131d257212c54A0e816691|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x7613311fbb6a4580cdd602f9978c317b2a783d5f|0x3926a81afe5c9c3d05296e4fac4728ba5411ac78|0x6fd9d7AD17242c41f7131d257212c54A0e816691|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x89fe55759966831d747669bfbda477ebf09475d6|0x7a5ea63fe3430a3b9a06fd80a4a9afaa17c1e878|0x4200000000000000000000000000000000000006|0xB27E3Eab7526bF721ea8029bFcd3fDc94c4f8b5b|
|0x1c536614fd8ed5faba94528782fbc886c426651a|0xf5a389030a565c13d6e6bbe9342ac9d31dc7521a|0x4200000000000000000000000000000000000006|0xe405de8f52ba7559f9df3c368500b6e6ae6cee49|
|0xb0e9a44258cce8ef36c87e8f252aa6bf7cd4b245|0x6168ec836d0b1f0c37381ec7ed1891a412872121|0x68f180fcCe6836688e9084f035309E29Bf0A2095|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|
|0xcd7b42cee81a3394ee58dab93bbfc87cab03adb5|0x2024c394741a5301e89a375b7bf52f865bc166fd|0x6fd9d7AD17242c41f7131d257212c54A0e816691|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|
|0x88f8cd42570f74ff3ef5acd090419070c6efe37a|0x91cca461ee9435848ac0da8fc416ad0816272786|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0xd4bbfe5b58381ba4b9ce87146ce9e5a2d1057d3e|0x865d39d66dee5719e6bee98885ef40b9a36bf56e|0x6fd9d7AD17242c41f7131d257212c54A0e816691|0x94b008aA00579c1307B0EF2c499aD98a8ce58e58|
|0x9b8ad5085af53eff13f3ddadcafa453549f7a93f|0x1fff624960ff9d0556420f3647d6aaf06389aab1|0x6fd9d7AD17242c41f7131d257212c54A0e816691|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|
|0x188530f0c09e56e6e30dd5ef76a9b3f0dc403763|0xc8c07386e29f3f239b91019d5426ae139c5bd17b|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|0x96db852D93c2feA0F447D6Ec22E146e4e09Caee6|
|0x704baee64df71741cf3029652dc99101adc846f0|0x1b19825a9e32b1039080acb1e1f9271314938b96|0x7FB688CCf682d58f86D7e38e03f9D22e7705448B|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0xe4decbe898a6b8bb79ac48e93681cd04d7b1ca1b|0x602a4d0f9e8d40ad3f620050efd1690da908dc0d|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|0x7FB688CCf682d58f86D7e38e03f9D22e7705448B|
|0x251144c131413a5f6e54001cb586f9101b447059|0x345ddb5743859efce0e6e8293ebd35373d34b6c7|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|0xe405de8f52ba7559f9df3c368500b6e6ae6cee49|
|0x4065c249115481baaec5c6a16929592935d29ec1|0x94ad9a19126ebb02dda874237e5820fd4943f5de|0x4200000000000000000000000000000000000006|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|
|0x6c66eb2798bf42455b63cff3fa3e5bcc3d31848f|0x905707e5c7a10e8351bbd03347be8b5f5de7301a|0x68f180fcCe6836688e9084f035309E29Bf0A2095|0x6fd9d7AD17242c41f7131d257212c54A0e816691|
|0xa0eed53ea02a174e4ee81d88d3970b5198580b52|0x7d1602f342787f80aef458c10e741149a1697447|0x68f180fcCe6836688e9084f035309E29Bf0A2095|0x6fd9d7AD17242c41f7131d257212c54A0e816691|
|0xb61a5a79a83ff386dbe40a1bc95578856ab2fa5f|0xa7bb0d95c6ba0ed0aca70c503b34bc7108589a47|0x68f180fcCe6836688e9084f035309E29Bf0A2095|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|
|0xc102e1de27d8467589cc65f4b4b18d534f6fdac6|0xb0eca217602b031e03956553fb510085c9f2df28|0x4200000000000000000000000000000000000006|0x8F69Ee043d52161Fd29137AeDf63f5e70cd504D5|
|0x61057f7f7c2e338c36fd29433d7977b618348cd0|0x320616dbe138aa2f3db7a5a46ba79a13032cc5f2|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|
|0x05c1d7c9b9b4f1c38859681bd7b4eebb4c373a8e|0xba213008fe93b3591e439f3b2aa51b3e4a2bd7c7|0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|
|0xbf592a3a4c64c8c28b667d060336e25480fe6c48|0x680b4eb8b9b8533d503a545adad4af9f00df5f05|0x4200000000000000000000000000000000000006|0x7C17611Ed67D562D1F00ce82eebD39Cb7B595472|
|0xb2ab739b499ff9fa019ff944135b4974942b3a95|0x296b88b607ea3a03c821ca4dc34dd9e7e4efa041|0x4200000000000000000000000000000000000006|0x7FB688CCf682d58f86D7e38e03f9D22e7705448B|
|0x3e9ef76529932226742113984e6a6c7cea7e2452|0xa99638e4ac81d4ce32c945c1415f89ab8d86bf2c|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9|
|0xcb590932a77e02aac00c83bbba4d8014efbebb89|0x9bb3267c4c3e69a961479c475f8fcc4c300af5bd|0x4200000000000000000000000000000000000006|0x7FB688CCf682d58f86D7e38e03f9D22e7705448B|
|0x3643c5840fc0ccf4f667a35a151e10302d4d0d23|0x65f8a80d8049a77619435f841055fa4c8d785c47|0x4200000000000000000000000000000000000006|0x96db852D93c2feA0F447D6Ec22E146e4e09Caee6|
|0x805b9cf595282d807adfe84a89bec85be5d07f53|0xd3265ea86af798659b4132a453e7cdb29b877e10|0x96db852D93c2feA0F447D6Ec22E146e4e09Caee6|0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1|
|0x1a718270a5b014209fb77ac2985556ee471b29af|0x8dfc59e8b119bffa5f552642028e005b1972edc4|0x6fd9d7AD17242c41f7131d257212c54A0e816691|0x96db852D93c2feA0F447D6Ec22E146e4e09Caee6|
|0xb91cf01b64c6e6540c45ae356554599cbe92831f|0xc210aeb4e84e0c3b6ee5816858984d52d04f0219|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|0x96db852D93c2feA0F447D6Ec22E146e4e09Caee6|
|0x8956827b23063c82d0c697004f0015b454a2f107|0x9aaa481a863e95168c01f23640b357b014dff09a|0x7F5c764cBc14f9669B88837ca1490cCa17c31607|0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4|
|0x86cf7e458ce79afe44924263d58ef1fd57d1b57c|0x25cc77a38f8de3b9b090fea8f0f5995c4e10a386|0x4200000000000000000000000000000000000006|0xe0BB0D3DE8c10976511e5030cA403dBf4c25165B|

#### References At:
1. [populateEmptyPools()](./utils/backfill.ts#populateemptypools)
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/_category_.json">
{
  "label": "Entity Schemas",
  "position": 6,
  "link": {
    "type": "generated-index",
    "description": "Details of the Schemas for each entity defined in the schema file"
  }
}
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/bundle.md">
---
title: Bundle
sidebar_position: 2
---

Entity to store the current Eth price in USD.

## Schema
|Field|Type|derivedFrom|Description|
|-|-|-|-|
|id | ID! |  | ID to fetch a unique entity. (Only ID='1' is used.) | 
|ethPriceUSD | BigDecimal! |  | Price of ETH in USD  | 

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[findEthPerToken()](../functions-n-handlers/utils/pricing.ts#findethpertoken)||<center>:white_check_mark:</center>|||
|[getTrackedAmountUSD()](../functions-n-handlers/utils/pricing.ts#gettrackedamountusd)||<center>:white_check_mark:</center>|||
|[handlePoolCreated()](../functions-n-handlers/mappings/factory.ts#handlepoolcreated)|<center>:white_check_mark:</center>||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleInitialize()](../functions-n-handlers/mappings/core.ts#handleinitialize)|||<center>:white_check_mark:*</center>|<center>:white_check_mark:*</center>|
|[handleMint()](../functions-n-handlers/mappings/core.ts#handlemint)||<center>:white_check_mark:</center>|||
|[handleBurn()](../functions-n-handlers/mappings/core.ts#handleburn)||<center>:white_check_mark:</center>|||
|[handleSwap()](../functions-n-handlers/mappings/core.ts#handleswap)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleIncreaseLiquidity()](../functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity)||<center>:white_check_mark:*</center>|||
|[handleDecreaseLiquidity()](../functions-n-handlers/mappings/position-manager.ts#handledecreaseliquidity)||<center>:white_check_mark:*</center>|||
|[handleCollect()](../functions-n-handlers/mappings/position-manager.ts#handlecollect)||<center>:white_check_mark:*</center>|||
|[updateTokenDayData()](../functions-n-handlers/utils/intervalupdates.ts#updatetokendaydata)||<center>:white_check_mark:</center>|||
|[updateTokenHourData()](../functions-n-handlers/utils/intervalupdates.ts#updatetokenhourdata)||<center>:white_check_mark:</center>|||

\* -> Varies across chains
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/burn.md">
---
title: Burn
sidebar_position: 10
---

Entity to stores the details of a burn event emitted while removing liquidity from a pool.

## Schema
|Field|Type|derivedFrom|Description|
|-|-|-|-|
|id | ID! | | Burn Entity ID. Format: `<transaction hash>#<index in transaction.burns array>` |
|transaction | [Transaction](./transaction)! | | [Transaction Entity](./transaction) in which the burn event was emitted |
|pool | [Pool](./pool)! | | [Pool](./pool) in which the burn event was emitted |
|token0 | [Token](./token)! | | token0 entity of the pool |
|token1 | [Token](./token)! | | token1 entity of the pool |
|timestamp | BigInt! | | Timestamp of the block in which which the burn event was emitted |
|owner | Bytes! | | owner of the position to which the liquidity was burnt |
|origin | Bytes! | | The EOA address that initiated the transaction |
|amount | BigInt! | | Amount of liquidity burnt |
|amount0 | BigDecimal! | | Amount of token0 burnt |
|amount1 | BigDecimal! | | Amount of token1 burnt |
|amountUSD | BigDecimal | | Burn value derived in USD based on available prices of tokens |
|tickLower | BigInt! | | Lower tick of the position  |
|tickUpper | BigInt! | | Upper tick of the position |
|logIndex | BigInt | | Order of the Burn event within the logs of the transaction |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[handleBurn()](../functions-n-handlers/mappings/core.ts#handleburn)|<center>:white_check_mark:</center>||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/collect.md">
---
title: Collect
sidebar_position: 12
---

Entity to store details of a collect event emitted while removing tokens from a position.

## Schema
|Field|Type|derivedFrom|Description|
|-|-|-|-|
|id | ID! | | Collect Entity ID. Format: `<transaction hash>#<index in transaction.collects array>` |
|transaction | [Transaction](./transaction)! | | [Transaction Entity](./transaction) in which the collect event was emitted |
|timestamp | BigInt! | | Timestamp of the block in which which the collect event was emitted |
|pool | [Pool](./pool)! | | [Pool](./pool) in which the collect event was emitted |
|owner | Bytes! | | owner of the position from which the tokens were collected |
|amount0 | BigDecimal! | | Amount of token0 collected |
|amount1 | BigDecimal! | | Amount of token1 collected |
|amountUSD | BigDecimal | | Collect value derived in USD based on available prices of tokens |
|tickLower | BigInt! | | Lower tick of the position  |
|tickUpper | BigInt! | | Upper tick of the position |
|logIndex | BigInt | | Order of the Collect Event within the logs of the transaction |

## Referencing Functions

:::danger 
Couldn't find any references to collect schema
:::
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/factory.md">
---
title: Factory
sidebar_position: 1
---

Entity to capture metrics for all the pools deployed by a specific [factory contract](../contracts/factory).

## Schema
|Field|Type|derivedFrom|Description|
|-|-|-|-|
|id | ID! |  | Factory Contract address | Field Missing |
|poolCount | BigInt! |  | No. of pools created using the factory |
|txCount | BigInt! |  | No. of all the transactions through pools mananged by the factory |
|totalVolumeUSD | BigDecimal! |  | Total Volume all time in derived USD |
|totalVolumeETH | BigDecimal! |  | Total Volume all time in derived ETH |
|totalFeesUSD | BigDecimal! |  | Total Swap Fees all time in derived USD |
|totalFeesETH | BigDecimal! |  | Total Swap Fees all time in derived ETH |
|untrackedVolumeUSD | BigDecimal! |  | Total Volume all time, including less reliable USD values |
|totalValueLockedUSD | BigDecimal! |  | TVL derived in USD |
|totalValueLockedETH | BigDecimal! |  | TVL derived in ETH |
|totalValueLockedUSDUntracked | BigDecimal! |  | TVL including tokens with unreliable USD prices in USD |
|totalValueLockedETHUntracked | BigDecimal! |  | TVL including tokens with unreliable USD prices in ETH |
|populated | Boolean |  | Flag capturing if the new pool is populated | All except optimism |
|owner | ID! |  | Current Owner of the factory contract |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[handlePoolCreated()](../functions-n-handlers/mappings/factory.ts#handlepoolcreated)|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleMint()](../functions-n-handlers/mappings/core.ts#handlemint)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleBurn()](../functions-n-handlers/mappings/core.ts#handleburn)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
[handleSwap()](../functions-n-handlers/mappings/core.ts#handleswap)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[updateUniswapDayData()](../functions-n-handlers/utils/intervalUpdates.ts#updateuniswapdaydata)||<center>:white_check_mark:</center>|||
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/flash.md">
---
title: Flash
sidebar_position: 13
---

Entity to store details of a flash event emitted while a flash loan was taken from a pool.

## Schema
|Field|Type|derivedFrom|Description|
|-|-|-|-|
|id | ID! | | Flash Entity ID. Format: `<transaction hash>#<index in transaction.flashed array>` |
|transaction | [Transaction](./transaction)! | | [Transaction Entity](./transaction) in which the flash event was emitted |
|timestamp | BigInt! | | Timestamp of the block in which which the flash event was emitted |
|pool | [Pool](./pool)! | | [Pool](./pool) in which the flash event was emitted |
|sender | Bytes | | the address of the sender that invoked the flash operation |
|recipient | Bytes! | | the address of the recipient that received the flash amount |
|amount0 | BigDecimal! | | Amount of token0 flashed |
|amount1 | BigDecimal! | | Amount of token1 flashed |
|amountUSD | BigDecimal | | Flash value derived in USD based on available prices of tokens |
|amount0Paid | BigDecimal! | | Amount of token0 paid for the flash operation | 
|amount1Paid | BigDecimal! | | Amount of token1 paid for the flash operation | 
|logIndex | BigInt | | Order of the Flash Event within the logs of the transaction |

## Referencing Functions

:::danger 
Couldn't find any references to collect schema
:::
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/mint.md">
---
title: Mint
sidebar_position: 9
---

Entity to store details of a mint event emitted while adding liquidity to a pool.

## Schema
|Field|Type|derivedFrom|Description|
|-|-|-|-|
|id | ID! | | Mint Entity ID. Format: `<transaction hash>#<index in transaction.mints array>` |
|transaction | [Transaction](./transaction)! | | [Transaction Entity](./transaction) in which the mint event was emitted |
|timestamp | BigInt! | | Timestamp of the block in which which the mint event was emitted |
|pool | [Pool](./pool)! | | [Pool](./pool) in which the mint event was emitted |
|token0 | [Token](./token)! | | token0 entity of the pool |
|token1 | [Token](./token)! | | token1 entity of the pool |
|owner | Bytes! | | owner of the position to which the liquidity was minted |
|sender | Bytes | | the address that minted the liquidity |
|origin | Bytes! | | The EOA address that initiated the transaction |
|amount | BigInt! | | Amount of liquidity minted |
|amount0 | BigDecimal! | | Amount of token0 minted |
|amount1 | BigDecimal! | | Amount of token1 minted |
|amountUSD | BigDecimal | | Mint value derived in USD based on available prices of tokens |
|tickLower | BigInt! | | Lower tick of the position  |
|tickUpper | BigInt! | | Upper tick of the position |
|logIndex | BigInt | | Order of the Mint Event within the logs of the transaction |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[handleMint()](../functions-n-handlers/mappings/core.ts#handlemint)|<center>:white_check_mark:</center>||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/pool.md">
---
title: Pool
sidebar_position: 4
---

Entity to store a pool's metadata, current & lifetime metrics and links to events and hourly/daily metrics and references to it's tick entities.

## Schema
|Field|Type|derivedFrom|Description|Field Missing|
|-|-|-|-|-|
|id | ID! | | Pool Contract Address |
|createdAtTimestamp | BigInt! | | BlockTime where the pool was created |
|createdAtBlockNumber | BigInt! | | Block Number where the pool was created |
|token0 | [Token](./token)! | | Token entity for token0 |
|token1 | [Token](./token)! | | Token entity for token1 |
|feeTier | BigInt! | | The percentage of token taken as fee in terms of basis points |
|liquidity | BigInt! | | Liquidity in the currently active tick range |
|sqrtPrice | BigInt! | | The current token pair price tracked in square root & Q96 format |
|feeGrowthGlobal0X128 | BigInt! | | The total fee in token0 per unit of liquidity collected by the pool | arbitrum-one |
|feeGrowthGlobal1X128 | BigInt! | | The total fee in token1 per unit of liquidity collected by the pool | arbitrum-one |
|token0Price | BigDecimal! | | Price of token0 in terms of token1 |
|token1Price | BigDecimal! | | Price of token1 in terms of token0 |
|tick | BigInt | | The current active [tick](./tick) |
|observationIndex | BigInt! | | The current observation index (used to record historic prices) |
|volumeToken0 | BigDecimal! | | Total volume of token0 swapped in the pool |
|volumeToken1 | BigDecimal! | | Total volume of token1 swapped in the pool |
|volumeUSD | BigDecimal! | | Total volume swapped in the pool in USD value |
|untrackedVolumeUSD | BigDecimal! | | Total volume swapped in the pool (including values for unreliable USD pools) in USD value |
|feesUSD | BigDecimal! | | Total fee collected in USD value |
|txCount | BigInt! | | Total no. of transactions in the pool |
|collectedFeesToken0 | BigDecimal! | | Total amount of token0 fee collected |
|collectedFeesToken1 | BigDecimal! | | Total amount of token1 fee collected |
|collectedFeesUSD | BigDecimal! | | Total amount of fee collected in USD value  |
|totalValueLockedToken0 | BigDecimal! | | Total amount of token0 locked across all ticks in the pool |
|totalValueLockedToken1 | BigDecimal! | | Total amount of token1 locked across all ticks in the pool |
|totalValueLockedETH | BigDecimal! | | Total value locked in the pool in ETH value |
|totalValueLockedUSD | BigDecimal! | | Total value locked in the pool in USD value |
|totalValueLockedUSDUntracked | BigDecimal! | | Total value locked in the pool (including tokens with unreliable USD values) in USD value |
|liquidityProviderCount | BigInt! | | Used for detecting new exchanges. (Currently not updated Anywhere) |
|poolHourData | [[PoolHourData](./poolhourdata)!]! | @derivedFrom(field: "pool") | Hourly Snapshots of Pool's data |
|poolDayData | [[PoolDayData](./pooldaydata)!]! | @derivedFrom(field: "pool") | Daily Snapshots of Pool's data |
|mints | [[Mint](./mint)!]! | @derivedFrom(field: "pool") | Mint Events emitted from the Pool |
|burns | [[Burn](./burn)!]! | @derivedFrom(field: "pool") | Burn Events emitted from the Pool |
|swaps | [[Swap](./swap)!]! | @derivedFrom(field: "pool") | Swap Events emitted from the Pool |
|collects | [[Collect](./collect)!]! | @derivedFrom(field: "pool") | Collect Events emitted from the Pool |
|ticks | [[Tick](./tick)!]! | @derivedFrom(field: "pool") | Tick entities respresenting the Pool liquidity |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[handlePoolCreated()](../functions-n-handlers/mappings/factory.ts#handlepoolcreated)|<center>:white_check_mark:</center>||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[updatePoolDayData()](../functions-n-handlers/utils/intervalUpdates.ts#updatepooldaydata)||<center>:white_check_mark:</center>|||
|[updatePoolHourData()](../functions-n-handlers/utils/intervalUpdates.ts#updatepoolhourdata)||<center>:white_check_mark:</center>|||
|[getEthPriceInUSD()](../functions-n-handlers/utils/pricing.ts#getethpriceinusd)||<center>:white_check_mark:</center>|||
|[findEthPerToken()](../functions-n-handlers/utils/pricing.ts#findethpertoken)||<center>:white_check_mark:</center>|||
|[handleInitialize()](../functions-n-handlers/mappings/core.ts#handleinitialize)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:*</center>|
|[handleMint()](../functions-n-handlers/mappings/core.ts#handlemint)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleBurn()](../functions-n-handlers/mappings/core.ts#handleburn)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleSwap()](../functions-n-handlers/mappings/core.ts#handleswap)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleFlash()](../functions-n-handlers/mappings/core.ts#handleflash)|||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[populateEmptyPools()\*](../functions-n-handlers/utils/backfill.ts#populateemptypools)|<center>:white_check_mark:</center>||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|

\* -> Different across chains
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/pooldaydata.md">
---
title: PoolDayData
sidebar_position: 15
---

Entity to store the daily metrics for each pool.

## Schema
|Field|Type|derivedFrom|Description|Field Missing|
|-|-|-|-|-|
|id | ID! | | PoolDayData Entity ID. Format: `<pool.address>-<Timestamp rounded to current day by dividing by 86400>` |
|date | Int! | | Timestamp rounded to hour by dividing by 86400 |
|pool | [Pool](./pool)! | | [Pool Entity](./pool) for which the daily metrics are tracked |
|liquidity | BigInt! | | In range Liquidity at the end of the day |
|sqrtPrice | BigInt! | | Pool Price at the end of the day |
|token0Price | BigDecimal! | | Price of token0 in terms of token1 at the end of the day |
|token1Price | BigDecimal! | | Price of token1 in terms of token0 at the end of the day |
|tick | BigInt | | Actice Tick at the end of the day |
|feeGrowthGlobal0X128 | BigInt! | | Global Fee Marker Value for token0 at the end of the day | arbitrum-one |
|feeGrowthGlobal1X128 | BigInt! | | Global Fee Marker Value for token1 at the end of the day | arbitrum-one |
|tvlUSD | BigDecimal! | | TVL available at the end of the day derived in USD |
|volumeToken0 | BigDecimal! | | Total daily volume in token0 |
|volumeToken1 | BigDecimal! | | Total daily volume in token1 |
|volumeUSD | BigDecimal! | | Total daily volume in USD |
|feesUSD | BigDecimal! | | Total swap fee taken during the day in terms of USD |
|txCount | BigInt! | | No. of transactions in pool executed during the day |
|open | BigDecimal! | | Open Price of token0 |
|high | BigDecimal! | | High Price of token0 |
|low | BigDecimal! | | Low Price of token0 |
|close | BigDecimal! | | Close Price of token0 |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[updatePoolDayData()](../functions-n-handlers/utils/intervalUpdates.ts#updatepooldaydata)|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleSwap()](../functions-n-handlers/mappings/core.ts#handleswap)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/poolhourdata.md">
---
title: PoolHourData
sidebar_position: 16
---

Entity to store the hourly stats for each pool.

## Schema
|Field|Type|derivedFrom|Description|Field Missing|
|-|-|-|-|-|
|id | ID! | | PoolHourData Entity ID. Format: `<pool.address>-<Timestamp rounded to the hour by dividing by 3600>` |
|periodStartUnix | Int! | | Timestamp rounded to hour by dividing by 3600 |
|pool | [Pool](./pool)! | | [Pool Entity](./pool) for which the hourly metrics are tracked |
|liquidity | BigInt! | | In range Liquidity at the end of the hour |
|sqrtPrice | BigInt! | | Pool Price at the end of the hour |
|token0Price | BigDecimal! | | Price of token0 in terms of token1 at the end of the hour |
|token1Price | BigDecimal! | | Price of token1 in terms of token0 at the end of the hour |
|tick | BigInt | | Actice Tick at the end of the hour |
|feeGrowthGlobal0X128 | BigInt! | | Global Fee Marker Value for token0 at the end of the hour | arbitrum-one |
|feeGrowthGlobal1X128 | BigInt! | | Global Fee Marker Value for token1 at the end of the hour | arbitrum-one |
|tvlUSD | BigDecimal! | | TVL available at the end of the hour derived in USD |
|volumeToken0 | BigDecimal! | | Total hourly volume in token0 |
|volumeToken1 | BigDecimal! | | Total hourly volume in token1 |
|volumeUSD | BigDecimal! | | Total hourly volume in USD |
|feesUSD | BigDecimal! | | Total swap fee taken during the hour in terms of USD |
|txCount | BigInt! | | No. of transactions in pool executed during the hour |
|open | BigDecimal! | | Open Price of token0 |
|high | BigDecimal! | | High Price of token0 |
|low | BigDecimal! | | Low Price of token0 |
|close | BigDecimal! | | Close Price of token0 |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[updatePoolHourData()](../functions-n-handlers/utils/intervalUpdates.ts#updatehourdaydata)|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleSwap()](../functions-n-handlers/mappings/core.ts#handleswap)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:*</center>|

\* -> Different across chains
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/position.md">
---
title: Position
sidebar_position: 6
---

Entity to store details of a position created through [NonfungiblePositionManager](../contracts/nonfungiblepositionmanager). Stores it's metadata, deposited/withdrawn tokens, fee variables and transactions where it participated.

:::caution Entity Not Defined
- Currently the entity is not defined for arbitrum-one chain
:::

## Schema
|Field|Type|derivedFrom|Description|Field Missing|
|-|-|-|-|-|
|id | ID! | | Position NFT Token ID |
|owner | Bytes! | | Position NFT owner's address |
|pool | [Pool](./pool)! | | [Pool](./pool) where the position staked the tokens |
|token0 | [Token](./token)! | | token0 entity of the pool |
|token1 | [Token](./token)! | | token1 entity of the pool |
|tickLower | [Tick](./tick)! | | Lower [Tick Entity](./tick) of the position |
|tickUpper | [Tick](./tick)! | | Upper [Tick Entity](./tick) of the position |
|liquidity | BigInt! | | Total liquidity added by the position |
|depositedToken0 | BigDecimal! | | Total amount token0 ever deposited to the position |
|depositedToken1 | BigDecimal! | | Total amount token1 ever deposited to the position |
|withdrawnToken0 | BigDecimal! | | Total amount token0 withdrawn to the position (excluding fees) |
|withdrawnToken1 | BigDecimal! | | Total amount token1 withdrawn to the position (excluding fees) |
|collectedToken0 | BigDecimal! | | Total amount of token0 collected (inclusive of burn amounts) | mainnet |
|collectedToken1 | BigDecimal! | | Total amount of token1 collected (inclusive of burn amounts) | mainnet |
|collectedFeesToken0 | BigDecimal! | | Total amount token0 fee collected |
|collectedFeesToken1 | BigDecimal! | | Total amount token1 fee collected |
|amountDepositedUSD | BigDecimal! | | Total amount deposited in terms of USD | mainnet, optimsim |
|amountWithdrawnUSD | BigDecimal! | | Total amount withdrawn in terms of USD | mainnet, optimism |
|amountCollectedUSD | BigDecimal! | | Total amount collected in terms of USD | mainnet, optimism |
|transaction | [Transaction](./transaction)! | | [Transaction entity](./transaction) in which the position was created |
|feeGrowthInside0LastX128 | BigInt! | | Tracking the amount of token0 fee accumulated by the position |
|feeGrowthInside1LastX128 | BigInt! | | Tracking the amount of token1 fee accumulated by the position |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[getPosition()](../functions-n-handlers/mappings/position-manager.ts#getposition)|<center>:white_check_mark:</center>||<center>:white_check_mark:</center>||
|[updateFeeVars()](../functions-n-handlers/mappings/position-manager.ts#updatefeevars)|||<center>:white_check_mark:</center>||
|[savePositionSnapshot()](../functions-n-handlers/mappings/position-manager.ts#savepositionsnapshot)||<center>:white_check_mark:</center>|||
|[handleIncreaseLiquidity()](../functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleDecreaseLiquidity()](../functions-n-handlers/mappings/position-manager.ts#handledecreaseliquidity)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleCollect()](../functions-n-handlers/mappings/position-manager.ts#handlecollect)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleTransfer()](../functions-n-handlers/mappings/position-manager.ts#handletransfer)|||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/positionsnapshot.md">
---
title: PositionSnapshot
sidebar_position: 7
---

Entity storing the state of a position after an action taken on the position.

:::caution Entity Not Defined
- Currently the entity is not defined for arbitrum-one chain
:::

## Schema
|Field|Type|derivedFrom|Description|
|-|-|-|-|
|id | ID! | | Position Snapshot ID. Format: `<NFT Token ID>#<Block Number>` |
|owner | Bytes! | | Position NFT's Owner's Address |
|pool | [Pool](./pool)! | | [Pool](./pool) entity to which the position belongs to |
|position | [Position](./position)! | | [Position](./position) entity for which the snapshot is taken |
|blockNumber | BigInt! | | BlockNumber in which the snapshot was created |
|timestamp | BigInt! | | Timestamp of the block in which the snapshot was created |
|liquidity | BigInt! | | Total Liquidity of the position |
|depositedToken0 | BigDecimal! | | Total amount of token0 ever deposited to the position |
|depositedToken1 | BigDecimal! | | Total amount of token1 ever deposited to the position |
|withdrawnToken0 | BigDecimal! | | Total amount of token0 withdrawn from the position (excluding the fee) |
|withdrawnToken1 | BigDecimal! | | Total amount of token1 withdrawn from the position (excluding the fee) |
|collectedFeesToken0 | BigDecimal! | | Total amount of token0 fee collected |
|collectedFeesToken1 | BigDecimal! | | Total amount of token1 fee collected |
|transaction | [Transaction](./transaction)! | | [Transaction](./transaction) in which the Snapshot was created. |
|feeGrowthInside0LastX128 | BigInt! | | Marker to compute the position's token0 fee in a pool |
|feeGrowthInside1LastX128 | BigInt! | | Marker to compute the position's token1 fee in a pool |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[savePositionSnapshot()](../functions-n-handlers/mappings/position-manager.ts#savepositionsnapshot)|<center>:white_check_mark:</center>||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/swap.md">
---
title: Swap
sidebar_position: 11
---

Entity to stores details of a swap event emitted while swapping one token for the other in a pool.

## Schema
|Field|Type|derivedFrom|Description|
|-|-|-|-|
|id | ID! | | Swap Entity ID. Format: `<transaction hash>#<index in transaction.swaps array>` |
|transaction | [Transaction](./transaction)! | | [Transaction Entity](./transaction) in which the swap event was emitted |
|timestamp | BigInt! | | Timestamp of the block in which which the swap event was emitted |
|pool | [Pool](./pool)! | | [Pool](./pool) in which the swap event was emitted |
|token0 | [Token](./token)! | | token0 entity of the pool |
|token1 | [Token](./token)! | | token1 entity of the pool |
|sender | Bytes | | the address that triggered the swap |
|recipient | Bytes! | | The address that gets their tokens swapped | 
|origin | Bytes! | | The EOA address that initiated the transaction |
|amount0 | BigDecimal! | | Amount of token0 swapped |
|amount1 | BigDecimal! | | Amount of token1 swapped |
|amountUSD | BigDecimal | | Swapped token value derived in USD based on available prices of tokens |
|sqrtPriceX96 | BigInt! | | The sqrt(price) of the pool after the swap, as a Q64.96 |
|tick | BigInt! | | The tick after the swap |
|logIndex | BigInt | | Order of the swap event within the logs of the transaction |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[handleSwap()](../functions-n-handlers/mappings/core.ts#handleswap)|<center>:white_check_mark:</center>||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/tick.md">
---
title: Tick
sidebar_position: 5
---

Entity to stores the metadata for a tick in a pool, it's lifetime metrics and current liquidity and fee variables.

## Schema
|Field|Type|derivedFrom|Description|Field Missing|
|-|-|-|-|-|
|id | ID! | | Tick ID. Format: `<pool address>#<tick address>`|
|poolAddress | String | | [Pool](./pool) contract address |
|tickIdx | BigInt! | | [Tick](./tick) Index |
|pool | [Pool](./pool)! | | [Pool](./pool) Entity |
|liquidityGross | BigInt! | | Total Liquidity the pool has at the tick with it's lower and upper range. |
|liquidityNet | BigInt! | | Liquidity change when the tick is crossed |
|price0 | BigDecimal! | | Price of token0 at this tick (constant) |
|price1 | BigDecimal! | | Price of token1 at this tick (constant) |
|volumeToken0 | BigDecimal! | | Total volume of token0 transacted with tick in active range |
|volumeToken1 | BigDecimal! | | Total volume of token1 transacted with tick in active range |
|volumeUSD | BigDecimal! | | Total transacted value with tick in active range in USD |
|untrackedVolumeUSD | BigDecimal! | | Total transacted value with tick in active range (including tokens with unreliable USD value) in USD |
|feesUSD | BigDecimal! | | Fee collected with the tick in active range in USD |
|collectedFeesToken0 | BigDecimal! | | Total amount of token0 collected as fee when this tick is active |
|collectedFeesToken1 | BigDecimal! | | Total amount of token1 collected as fee when this tick is active |
|collectedFeesUSD | BigDecimal! | | Total value of fee collected when this tick is active is USD |
|createdAtTimestamp | BigInt! | | BlockTime when the tick was initialized |
|createdAtBlockNumber | BigInt! | | BlockNumber when the tick was initialized |
|liquidityProviderCount | BigInt! | | Used for detecting new exchanges. (Not Used currently) |
|feeGrowthOutside0X128 | BigInt! | | Used for calculating token0 fee's accumulated outside a tick whenever it is crossed | arbitrum-one |
|feeGrowthOutside1X128 | BigInt! | | Used for calculating token1 fee's accumulated outside a tick whenever it is crossed | arbitrum-one |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[createTick()](../functions-n-handlers/utils/tick.ts#createtick)|<center>:white_check_mark:</center>||<center>:white_check_mark:</center>||
|[updateTickDayData()](../functions-n-handlers/utils/intervalUpdates.ts#updatetickdaydata)||<center>:white_check_mark:</center>|||
|[handleMint()](../functions-n-handlers/mappings/core.ts#handlemint)|||<center>:white_check_mark:</center>||
|[handleBurn()](../functions-n-handlers/mappings/core.ts#handleburn)|||<center>:white_check_mark:</center>||
|[updateTickFeeVarsAndSave()](../functions-n-handlers/mappings/core.ts#updatetickfeevarsandsave)|||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[loadTickUpdateFeeVarsAndSave()](../functions-n-handlers/mappings/core.ts#loadtickupdatefeevarsandsave)||<center>:white_check_mark:</center>|||
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/tickdaydata.md">
---
title: TickDayData
sidebar_position: 18
---

Entities storing the details of Liquidity available & volume of token traded at a tick on a given day.

:::info
An entity is created only if there is a change during the day
:::

## Schema
|Field|Type|derivedFrom|Description|Field Missing|
|-|-|-|-|-|
|id | ID! | | TickDayData Entity ID. Format: `<pool.address>-<Tick Index>-<Timestamp rounded to the day by dividing by 86400>` |
|date | Int! | | Timestamp rounded to the day by dividing by 86400 |
|pool | [Pool](./pool)! | | [Pool Entity](./pool) for which the daily tick metrics were recorded |
|tick | [Tick](./tick)! | | [Tick Entity](./tick) for which daily metrics were recorded |
|liquidityGross | BigInt! | | Total liquidity around the tick (1-tick range below or above) at end of the day |
|liquidityNet | BigInt! | | Change in liquidity when the tick is crossed at end of the day |
|volumeToken0 | BigDecimal! | | Daily volume of token0 with this tick in active range |
|volumeToken1 | BigDecimal! | | Daily volume of token1 with this tick in active range |
|volumeUSD | BigDecimal! | | Daily swap value with this tick in active range in derived USD |
|feesUSD | BigDecimal! | |  Daily swap fee with this tick in active range in derived USD |
|feeGrowthOutside0X128 | BigInt! | | token0 fee accumulated marker outside the tick range at the end of the day | arbitrum-one |
|feeGrowthOutside1X128 | BigInt! | | token1 fee accumulated marker outside the tick range at the end of the day | arbitrum-one |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[updateTickDayData()](../functions-n-handlers/utils/intervalUpdates.ts#updatetickdaydata)|<center>:white_check_mark:</center>||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/tickhourdata.md">
---
title: TickHourData
sidebar_position: 17
---

Entities capturing details of Liquidity available & Volume of token traded at a tick for a given hour.

:::info Not Used
The Schema is not currently populated in mainnet subgraph
:::


## Schema
|Field|Type|derivedFrom|Description|
|-|-|-|-|
|id | ID! | | TickHourData Entity ID. Format: `<pool.address>-<Tick Index>-<Timestamp rounded to the hour by dividing by 3600>` |
|periodStartUnix | Int! | | Timestamp rounded to the hour by dividing by 3600 |
|pool | [Pool](./pool)! | | [Pool Entity](./pool) for which the hourly tick metrics were recorded |
|tick | [Tick](./tick)! | | [Tick Entity](./tick) for which hourly metrics were recorded |
|liquidityGross | BigInt! | | Total liquidity around the tick (1-tick range below or above) at end of the hour |
|liquidityNet | BigInt! | | Change in liquidity when the tick is crossed at end of the hour |
|volumeToken0 | BigDecimal! | | Hourly volume of token0 with this tick in active range |
|volumeToken1 | BigDecimal! | | Hourly volume of token1 with this tick in active range |
|volumeUSD | BigDecimal! | | Hourly swap value with this tick in active range in derived USD |
|feesUSD | BigDecimal! | |  Hourly swap fee with this tick in active range in derived USD |
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/token.md">
---
title: Token
sidebar_position: 3
---

Entity to stores the metadata and token level metrics for a token present in any of the pools.

## Schema
|Field|Type|derivedFrom|Description|
|-|-|-|-|
|id | ID! | | Token Contract Address | 
|symbol | String! | | Token Symbol | 
|name | String! | | Token Name | 
|decimals | BigInt! | | No. of decimals in the token value | 
|totalSupply | BigInt! | | Total supply of the token | 
|volume | BigDecimal! | | Total token volume traded in swaps | 
|volumeUSD | BigDecimal! | | Total token value traded in swaps in USD | 
|untrackedVolumeUSD | BigDecimal! | | Total token value traded in USD, including pools with unreliable USD values | 
|feesUSD | BigDecimal! | | Amount of Fees taken from token swaps in derived in USD | 
|txCount | BigInt! | | No. of transactions across all pools that include this token  | 
|poolCount | BigInt! | | No. of pools containing this token | 
|totalValueLocked | BigDecimal! | | Liquidity across all pools for the token | 
|totalValueLockedUSD | BigDecimal! | | Liquidity across all pools for the token in terms of USD value | 
|totalValueLockedUSDUntracked | BigDecimal! | | Liquidity across all pools (including pools with unreliable USD values) for the token in terms of USD value | 
|derivedETH | BigDecimal! | | Price of token relative to ETH | 
|whitelistPools | [[Pool](./pool)!]! | | [Pool](./pool) entities which can can be used for reliable USD pricing of the token | 
|tokenDayData | [[TokenDayData](./tokendaydata)!]! | @derivedFrom(field: "token") | Link to daily stats for the token | 

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[sqrtPriceX96ToTokenPrices()](../functions-n-handlers/utils/pricing.ts#sqrtpricex96totokenprices)||<center>:white_check_mark:</center>|||
|[findEthPerToken()](../functions-n-handlers/utils/pricing.ts#findethpertoken)||<center>:white_check_mark:</center>|||
|[getTrackedAmountUSD()](../functions-n-handlers/utils/pricing.ts#gettrackedamountusd)||<center>:white_check_mark:</center>|||
|[updateTokenDayData()](../functions-n-handlers/utils/intervalUpdates.ts#updatetokendaydata)||<center>:white_check_mark:</center>|||
|[updateTokenHourData()](../functions-n-handlers/utils/intervalUpdates.ts#updatetokenhourdata)||<center>:white_check_mark:</center>|||
|[handleInitialize()](../functions-n-handlers/mappings/core.ts#handleinitialize)||<center>:white_check_mark:*</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleMint()](../functions-n-handlers/mappings/core.ts#handlemint)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleBurn()](../functions-n-handlers/mappings/core.ts#handleburn)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleSwap()](../functions-n-handlers/mappings/core.ts#handleswap)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:*</center>|
|[handlePoolCreated()](../functions-n-handlers/mappings/factory.ts#handlepoolcreated)|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleIncreaseLiquidity()](../functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity)||<center>:white_check_mark:</center>|||
|[handleDecreaseLiquidity()](../functions-n-handlers/mappings/position-manager.ts#handledecreaseliquidity)||<center>:white_check_mark:</center>|||
|[handleCollect()](../functions-n-handlers/mappings/position-manager.ts#handlecollect)||<center>:white_check_mark:</center>|||
|[populateToken()\*](../functions-n-handlers/utils/backfill.ts#populatetoken)|<center>:white_check_mark:</center>||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[populateEmptyPools()\*](../functions-n-handlers/utils/backfill.ts#populateemptypools)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|

\* -> Different across chains
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/tokendaydata.md">
---
title: TokenDayData
sidebar_position: 19
---

Entities capturing the daily stats for a token across all of Uniswap.

## Schema
|Field|Type|derivedFrom|Description|
|-|-|-|-|
|id | ID! | | TokenDayData Entity ID. Format: `<token address>-<Timestamp rounded to the day by dividing by 86400>` |
|date | Int! | | Timestamp rounded to the day by dividing by 86400 |
|token | [Token](./token)! | | [Token Entity](./token) for which the daily metric were recorded |
|volume | BigDecimal! | | Daily swap volume of the token |
|volumeUSD | BigDecimal! | | Daily swap volume of the token in derived USD |
|untrackedVolumeUSD | BigDecimal! | | Daily swap volume of the token in derived USD (including in pools with tokens with unreliable USD value) |
|totalValueLocked | BigDecimal! | | Liquidity across all pools in token units at the end of the day |
|totalValueLockedUSD | BigDecimal! | | Total value of liquidity across all pools in token units in derived USD at the end of the day|
|priceUSD | BigDecimal! | | Price of token in USD at the end of the day |
|feesUSD | BigDecimal! | | Total Fee Collected in derived USD at the end of the day |
|open | BigDecimal! | | Open Price of the token |
|high | BigDecimal! | | High Price of the token |
|low | BigDecimal! | | Low Price of the token |
|close | BigDecimal! | | Close Price of the token |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[updateTokenDayData()](../functions-n-handlers/utils/intervalUpdates.ts#updatetokendaydata)|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/tokenhourdata.md">
---
title: TokenHourData
position: 20
---

Entities capturing the hourly metrics for a token across all of Uniswap.

## Schema
|Field|Type|derivedFrom|Description|
|-|-|-|-|
|id | ID! | | TokenHourData Entity ID. Format: `<token address>-<Timestamp rounded to the hour by dividing by 3600>` |
|periodStartUnix | Int! | | Timestamp rounded to the hour by dividing by 3600 |
|token | [Token](./token)! | | [Token Entity](./token) for which the hourly metric were recorded |
|volume | BigDecimal! | | Hourly swap volume of the token |
|volumeUSD | BigDecimal! | | Hourly swap volume of the token in derived USD |
|untrackedVolumeUSD | BigDecimal! | | Hourly swap volume of the token in derived USD (including in pools with tokens with unreliable USD value) |
|totalValueLocked | BigDecimal! | | Liquidity across all pools in token units at the end of the hour |
|totalValueLockedUSD | BigDecimal! | | Total value of liquidity across all pools in token units in derived USD at the end of the hour|
|priceUSD | BigDecimal! | | Price of token in USD at the end of the hour |
|feesUSD | BigDecimal! | | Total Fee Collected in derived USD at the end of the hour |
|open | BigDecimal! | | Open Price of the token |
|high | BigDecimal! | | High Price of the token |
|low | BigDecimal! | | Low Price of the token |
|close | BigDecimal! | | Close Price of the token |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[updateTokenHourData()](../functions-n-handlers/utils/intervalUpdates.ts#updatetokenhourdata)|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/transaction.md">
---
title: Transaction
sidebar_position: 8
---

Entity capturing uniswap transaction details with a list of mint, burn, swap, flash and collects events emitted within a transaction.

## Schema
|Field|Type|derivedFrom|Description|
|-|-|-|-|
|id | ID! | | Transaction Hash |
|blockNumber | BigInt! | | Block Number where the transaction was added to the chain |
|timestamp | BigInt! | | Timestamp of the block where the transaction was added to the chain |
|gasUsed | BigInt! | | Amount of Gas Units Consumed to execute the transaction |
|gasPrice | BigInt! | | Cost of one unit Gas paid for the transaction |
|mints | [[Mint](./mint)]! | @derivedFrom(field: "transaction") | [Mint](./mint) entities created in this transaction |
|burns | [[Burn](./burn)]! | @derivedFrom(field: "transaction") | [Burn](./burn) entities created in this transaction |
|swaps | [[Swap](./swap)]! | @derivedFrom(field: "transaction") | [Swap](./swap) entities created in this transaction |
|flashed | [[Flash](./flash)]! | @derivedFrom(field: "transaction") | [Flash](./flash) entities created in this transaction |
|collects | [[Collect](./collect)]! | @derivedFrom(field: "transaction") | [Collect](./collect) entities created in this transaction |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[loadTransaction()](../functions-n-handlers/utils/index.ts#loadtransaction)|<center>:white_check_mark:</center>||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleMint()](../functions-n-handlers/mappings/core.ts#handlemint)||<center>:white_check_mark:</center>|||
|[handleBurn()](../functions-n-handlers/mappings/core.ts#handleburn)||<center>:white_check_mark:</center>|||
|[handleSwap()](../functions-n-handlers/mappings/core.ts#handleswap)||<center>:white_check_mark:</center>|||
|[getPosition()](../functions-n-handlers/mappings/position-manager.ts#getposition)||<center>:white_check_mark:</center>|||
|[savePositionSnapshot()](../functions-n-handlers/mappings/position-manager.ts#savepositionsnapshot)||<center>:white_check_mark:</center>|||
</file>

<file path="docs/api/subgraph/subgraphs-devs/schemas/uniswapdaydata.md">
---
title: UniswapDayData
sidebar_position: 14
---

Entities capturing the daily metrics for all of the Uniswap protocol.

## Schema
|Field|Type|derivedFrom|Description|
|-|-|-|-|
|id | ID! | | Timestamp rounded to current day by dividing by 86400 |
|date | Int! | | Timestamp rounded to current day by dividing by 86400 |
|volumeETH | BigDecimal! | | Total daily volume in Uniswap derived in terms of ETH |
|volumeUSD | BigDecimal! | | Total daily volume in Uniswap derived in terms of USD |
|volumeUSDUntracked | BigDecimal! | | total daily volume in Uniswap derived in terms of USD (including tokens with unreliable USD value) |
|feesUSD | BigDecimal! | | Amount of swap fee taken during the day in terms of USD |
|txCount | BigInt! | | No. of transactions that occurred during the day |
|tvlUSD | BigDecimal! | | TVL locked at the end of the day in terms of USD |

## Referencing Functions

|FunctionName|Create|Read|Update|Save|
|-|-|-|-|-|
|[updateUniswapDayData()](../functions-n-handlers/utils/intervalUpdates.ts#updateuniswapdaydata)|<center>:white_check_mark:</center>||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
|[handleSwap()](../functions-n-handlers/mappings/core.ts#handleswap)||<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|<center>:white_check_mark:</center>|
</file>

<file path="docs/api/subgraph/subgraphs-devs/_category_.json">
{
  "label": "Subgraph-Devs",
  "position": 3,
  "collapsed": false
}
</file>

<file path="docs/api/subgraph/subgraphs-devs/all-entities.md">
---
title: Entity Types
sidebar_position: 3
---

Following Entity Types are defined in the graph [schema file](https://github.com/Uniswap/v3-subgraph/blob/main/schema.graphql):


||Entity|Description|Schema differs with chain|
|-|-|-|-|
|1.|[Factory](./schemas/factory.md) | Captures metrics for all the pools deployed by a specific [factory contract](./contracts/factory). |<center>:white_check_mark:</center>|
|2.|[Bundle](./schemas/bundle) | Stores the current Eth price in USD. ||
|3.|[Token](./schemas/token) | Stores the metadata and token level metrics for a token present in any of the pools. ||
|4.|[Pool](./schemas/pool) | Stores a pool's metadata, current & lifetime metrics and links to events and hourly/daily metrics and references to it's tick entities. |<center>:white_check_mark:</center>|
|5.|[Tick](./schemas/tick) | Stores the metadata for a tick in a pool, it's lifetime metrics and current liquidity and fee variables. |<center>:white_check_mark:</center>|
|6.|[Position](./schemas/position) | Represents a position created through [NonfungiblePositionManager](../contracts/nonfungiblepositionmanager). Stores it's metadata, deposited/withdrawn tokens, fee variables and transactions where it participated. |<center>:white_check_mark:</center>|
|7|[PositionSnapshot](./schemas/positionsnapshot) | Saves the state of a position after an action taken on the position. |<center>:white_check_mark:</center>|
|8|[Transaction](./schemas/transaction) | Stores the list of mint, burn, swap, flash and collects events emitted within a transaction. ||
|9|[Mint](./schemas/mint) | Stores details of a mint event emitted while adding liquidity to a pool ||
|10|[Burn](./schemas/burn) | Stores details of a burn event emitted while removing liquidity from a pool ||
|11|[Swap](./schemas/swap) | Stores details of a swap event emitted while swapping one token for the other in a pool ||
|12|[Collect](./schemas/collect) | Stores details of a collect event emitted while removing tokens from a position ||
|13|[Flash](./schemas/flash) | Stores details of a flash event emitted while a flash loan was taken from a pool ||
|14|[UniswapDayData](./schemas/uniswapdaydata)| Daily stats for all of Uniswap. ||
|15|[PoolDayData](./schemas/pooldaydata)| Daily stats for each pool |<center>:white_check_mark:</center>|
|16|[PoolHourData](./schemas/poolhourdata)| Hourly stats for each pool |<center>:white_check_mark:</center>|
|17|[TickHourData](./schemas/tickhourdata)| Stats on Liquidity available & Volume of token traded at a tick for a given hour ||
|18|[TickDayData](./schemas/tickdaydata)| Stats on Liquidity available & Volume of token traded at a tick on a given day. <br/>(Note: this entity gets saved only if there is a change during the day) |<center>:white_check_mark:</center>|
|19|[TokenDayData](./schemas/tokendaydata) | Daily stats for a token across all of Uniswap. ||
|20|[TokenHourData](./schemas/tokenhourdata) | Hourly stats for a token across all of Uniswap. ||
</file>

<file path="docs/api/subgraph/subgraphs-devs/events.md">
---
title: Events Monitored
sidebar_position: 4
---


|Event Name|Contract Type|Event handler|Description|
|-|-|-|-|
|PoolCreated|[Factory](./contracts/factory)|[handlePoolCreated()](../functions-n-handlers/mappings/factory.ts#handlepoolcreated)|Event emitted when a new pool is deployed using the factory contract|
|Initialize|[Pool](./contracts/pool)|[handleInitialize()](../functions-n-handlers/mappings/core.ts#handleinitialize)|Event emitted when a new deployed pool is initialized with current price and is ready for adding liquidity and doing swaps|
|Swap|[Pool](./contracts/pool)|[handleSwap()](../functions-n-handlers/mappings/core.ts#handleswap)|Event emitted when a swap takes place|
|Mint|[Pool](./contracts/pool)|[handleMint()](../functions-n-handlers/mappings/core.ts#handlemint)|Event emitted when liquidity is added to the pool|
|Burn|[Pool](./contracts/pool)|[handleBurn()](../functions-n-handlers/mappings/core.ts#handleburn)|Event emitted when liquidity is removed from the pool|
|Flash|[Pool](./contracts/pool)|[handleFlash()](../functions-n-handlers/mappings/core.ts#handleflash)|Event emitted when a flash loan was taken from the pool|
|IncreaseLiquidity|[NonFungiblePositionManager](./contracts/nonfungiblepositionmanager)|[handleIncreaseLiquidity()](../functions-n-handlers/mappings/position-manager.ts#handleincreaseliquidity)|Event emitted when liquidity is added to a new/existing position|
|DecreaseLiquidity|[NonFungiblePositionManager](./contracts/nonfungiblepositionmanager)|[handleDecreaseLiquidity()](../functions-n-handlers/mappings/position-manager.ts#handledecreaseliquidity)|Event emitted when liquidity is removed from a position|
|Collect|[NonFungiblePositionManager](./contracts/nonfungiblepositionmanager)|[handleCollect()](../functions-n-handlers/mappings/position-manager.ts#handlecollect)|Event emitted when removed liquidity and it's accumulated fee collected by the position owner|
|Transfer|[NonFungiblePositionManager](./contracts/nonfungiblepositionmanager)|[handleTransfer()](../functions-n-handlers/mappings/position-manager.ts#handletransfer)|Even emitted whent the NFT representing the position ownership is transferred to a different address|
</file>

<file path="docs/api/subgraph/subgraphs-devs/intro.md">
---
sidebar_position: 1
title: Introduction
---

## Uniswap V3 SubGraph Docs 
Welcome to exploring the data of [**Uniswap**](https://uniswap.org/), the leading EVM DEX. The docs help you understand data structure in the **SubGraphs** deployed for the dex on the [graph protocol](https://thegraph.com/).

If you're completely new to the working of the V3 protocol, would recommend going through the [references](#references) below.

## Uniswap Foundation
The docs was possible as I recieved a grant from [Uniswap Foundation](https://uniswapfoundation.mirror.xyz/). The foundation publishes [grant wishlist for RFPs](https://uniswap.notion.site/Uniswap-Foundation-Grants-Wish-List-3be614ba4e504b5caeee7b0159e64a42) regularly if you wish to get involved.

## Get In Touch
For any updates or additions, you can raise a PR to the [docs repo](https://github.com/vintageplayer/uniswap-v3-subgraph-docs).

Feel free to reach out on [Twitter](https://twitter.com/artsofbaniya) to discuss about web3 or any field, or just to keep up with what I'm building.
</file>

<file path="docs/api/subgraph/subgraphs-devs/links-n-resources.md">
---
sidebar_position: 2
title: Resources
---

### Repo Links:
 - [V3 Subgraph Repo](https://github.com/Uniswap/v3-subgraph/tree/main)
 - [V3 Core Contracts Repo](https://github.com/Uniswap/v3-core) - Mainly for factory and pool contracts
 - [V3 Periphery Contract Repo](https://github.com/Uniswap/v3-periphery) - Mainly for NonFungiblePositionManager Contract

### References
 - [Uniswap V3 Core Whitepaper](https://uniswap.org/whitepaper-v3.pdf)
 - [Liquidity Math in Uniswap V3](https://atiselsts.github.io/pdfs/uniswap-v3-liquidity-math.pdf)
 - [Uniswap V3 Development Book](https://uniswapv3book.com/)
 
### Misc
 - [Uniswap Hacker Getting Started Guide](https://uniswap.notion.site/uniswap/Uniswap-Hacker-Getting-Started-Guide-781b008a16c849c8bf4d9920744e77f5)
 - [Uniswap Docs](https://docs.uniswap.org/) ([Code Repo](https://github.com/Uniswap/docs/tree/main))
 - [Uniswap Info Site](https://info.uniswap.org/#/) to see the pool and token stats using the subgraph
 - [V3 New Chain Deployment Guide](https://github.com/Uniswap/v3-new-chain-deployments) (Slightly Outdated)
</file>

<file path="docs/api/subgraph/subgraphs-devs/subgraph-configs.md">
---
sidebar_position: 8
title: Subgraph Configuration
---

### Subgraphs
:::info
The subgraphs link are picked from the clients specified in [v3-info](https://github.com/Uniswap/v3-info/blob/master/src/apollo/client.ts)
:::

|Subgraph|Code Branch Referred|Graft Base|Graft Block|NFT Position Manager Address|NFT Position Manager Start Block|
|-|-|-|-|-|-|
|[Mainnet](https://thegraph.com/hosted-service/subgraph/uniswap/uniswap-v3)|[main](https://github.com/Uniswap/v3-subgraph/tree/main)|QmS13421u6qsbVdBCrZhdRaZw2wH67drwF3urmueJvvJ5P|13591197|0xC36442b4a4522E871399CD717aBDD847Ab11FE88|12369651|
|[Polygon](https://thegraph.com/hosted-service/subgraph/ianlapham/uniswap-v3-polygon)|[polygon](https://github.com/Uniswap/v3-subgraph/tree/polygon)|QmUKRxaVLRpn18UA9mwukAwRQudH9TfBW5wiKCWEJghUS8|25459720|0xC36442b4a4522E871399CD717aBDD847Ab11FE88|22760586|
|[Arbitrum-One](https://thegraph.com/hosted-service/subgraph/ianlapham/uniswap-arbitrum-one)|[arbitrum-minimal](https://github.com/Uniswap/v3-subgraph/tree/arbitrum-minimal)|None|None|None|None|
|[Optimism](https://thegraph.com/hosted-service/subgraph/ianlapham/optimism-post-regenesis)|[ian/optimism-fix](https://github.com/Uniswap/v3-subgraph/tree/ian/optimism-fix)|Qmf9i13TJknQwcamcLbb75hEhbf3nqDi321XWhtFBj3P5s|10028767|0xC36442b4a4522E871399CD717aBDD847Ab11FE88|0|
</file>

<file path="docs/api/subgraph/_category_.json">
{
  "label": "Subgraph",
  "position": 2,
  "collapsed": false
}
</file>

<file path="docs/api/subgraph/overview.md">
---
id: overview
sidebar_position: 1
title: Overview
---

## The Uniswap Subgraph

Uniswap uses multiple [subgraphs](https://thegraph.com/docs/about/introduction#what-the-graph-is) for indexing and organizing data from the Uniswap smart contracts.
These subgraphs are hosted on The Graph and can be used to query Uniswap data.

### Versions and Production Endpoints

Each version of Uniswap for each chain has its own dedicated subgraph. As hosted subgraphs have been depreciated, you will now need to call through their decentralized subgraphs.

Each subgraph has a dedicated endpoint for querying data, as well as a page on [The Graph explorer](https://thegraph.com/explorer) that exposes the schema and available fields to query.

## Creating an API Key

API Keys can be created by users inside the [Studio](https://thegraph.com/studio/apikeys/). This key will be included into the endpoint to associate a consumers usage to their billing.  


##### v4 (Mainnet)

- [Subgraph](https://thegraph.com/explorer/subgraphs/DiYPVdygkfjDWhbxGSqAQxwBKmfKnkWQojqeM2rkLb3G?view=About&chain=arbitrum-one)
- Graphql Endpoint: `https://gateway.thegraph.com/api/<YOUR_API_KEY_HERE>/subgraphs/id/DiYPVdygkfjDWhbxGSqAQxwBKmfKnkWQojqeM2rkLb3G`
- Code: https://github.com/Uniswap/v4-subgraph

##### v3 (Mainnet)

- [Subgraph](https://thegraph.com/explorer/subgraphs/5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV?view=Query&chain=arbitrum-one)
- Graphql Endpoint: `https://gateway.thegraph.com/api/<YOUR_API_KEY_HERE>/subgraphs/id/5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV`
- Code: https://github.com/Uniswap/v3-subgraph

##### v2 (Mainnet)

- [Subgraph](https://thegraph.com/explorer/subgraphs/A3Np3RQbaBA6oKJgiwDJeo5T3zrYfGHPWFYayMwtNDum?view=Query&chain=arbitrum-one)
- Graphql Endpoint: `https://gateway.thegraph.com/api/<YOUR_API_KEY_HERE>/subgraphs/id/A3Np3RQbaBA6oKJgiwDJeo5T3zrYfGHPWFYayMwtNDum`
- Code: https://github.com/Uniswap/v2-subgraph

##### v1 (Mainnet)

- [Explorer Page](https://thegraph.com/explorer/subgraphs/ESnjgAG9NjfmHypk4Huu4PVvz55fUwpyrRqHF21thoLJ?view=Query&chain=arbitrum-one)
- Graphql Endpoint: `https://gateway.thegraph.com/api/<YOUR_API_KEY_HERE>/subgraphs/id/ESnjgAG9NjfmHypk4Huu4PVvz55fUwpyrRqHF21thoLJ`
- Code: https://github.com/graphprotocol/uniswap-subgraph

## v3 Subgraphs for other chains

| Chain | V3 |
|--|--|
| Arbitrum | [Subgraph](https://thegraph.com/explorer/subgraphs/FbCGRftH4a3yZugY7TnbYgPJVEv2LvMT6oF1fxPe9aJM?view=Query&chain=arbitrum-one) |
| Base | [Subgraph](https://thegraph.com/explorer/subgraphs/43Hwfi3dJSoGpyas9VwNoDAv55yjgGrPpNSmbQZArzMG?view=Query&chain=arbitrum-one) |
| Optimism | [Subgraph](https://thegraph.com/explorer/subgraphs/Cghf4LfVqPiFw6fp6Y5X5Ubc8UpmUhSfJL82zwiBFLaj?view=Query&chain=arbitrum-one) |
| Polygon | [Subgraph](https://thegraph.com/explorer/subgraphs/3hCPRGf4z88VC5rsBKU5AA9FBBq5nF3jbKJG7VZCbhjm?view=Query&chain=arbitrum-one) |
| BSC | [Subgraph](https://thegraph.com/explorer/subgraphs/F85MNzUGYqgSHSHRGgeVMNsdnW1KtZSVgFULumXRZTw2?view=Query&chain=arbitrum-one) |
| Avalanche | [Subgraph](https://thegraph.com/explorer/subgraphs/GVH9h9KZ9CqheUEL93qMbq7QwgoBu32QXQDPR6bev4Eo?view=Query&chain=arbitrum-one) |
| Celo | [Subgraph](https://thegraph.com/explorer/subgraphs/ESdrTJ3twMwWVoQ1hUE2u7PugEHX3QkenudD6aXCkDQ4?view=Query&chain=arbitrum-one) |
| Blast | [Subgraph](https://thegraph.com/explorer/subgraphs/2LHovKznvo8YmKC9ZprPjsYAZDCc4K5q4AYz8s3cnQn1?view=Query&chain=arbitrum-one) |
</file>

<file path="docs/api/overview.md">
---
id: overview
sidebar_position: 1
title: Overview
---

## Uniswap APIs

Welcome to the Uniswap API documentation. Uniswap provides several APIs and data sources to help developers integrate with and build on top of the Uniswap protocol.

## Available APIs

### Subgraph API
The Uniswap Subgraph provides a GraphQL API for querying historical and real-time data from the Uniswap protocol.

- **[Subgraph Documentation](./subgraph/overview)** - Learn how to query Uniswap data using GraphQL
- **[Subgraph Examples](./subgraph/guides/v4-subgraph-example)** - Practical examples and queries
- **[v3 Subgraph Guide](./subgraph/guides/v3-subgraph-example)** - Legacy v3 protocol queries

### Routing API
The Uniswap Routing API provides optimized trade routes and quotes for swaps.

- **Smart Order Routing** - Find the best prices across multiple pools
- **Gas Optimization** - Routes optimized for gas efficiency
- **Multi-hop Support** - Complex routing across token pairs

### Price APIs
Get real-time and historical price data for tokens on Uniswap.

- **Current Prices** - Real-time token prices
- **Historical Data** - Price charts and historical trends
- **Pool Information** - Liquidity and volume data

## Getting Started

### For Developers
If you're building applications that need to:
- Query historical trading data → Use the **Subgraph API**
- Get optimal swap routes → Use the **Routing API**
- Display token prices → Use the **Price APIs**

### For Data Analysis
The Subgraph API is perfect for:
- Analytics dashboards
- Trading strategy research
- Protocol metrics and insights
- DeFi research and analysis

## Rate Limits and Usage

- **Subgraph API**: Generous rate limits via The Graph
- **Routing API**: Production-ready with caching
- **Price APIs**: Real-time updates with historical data

## Support and Resources

- **Discord**: Join the Uniswap developer community
- **GitHub**: Explore code examples and integrations
- **Documentation**: Comprehensive guides and references

Ready to start building? Choose the API that fits your needs from the navigation menu.
</file>

<file path="docs/archived/07-changelog.md">
---
id: changelog
title: Changelog
hidden: true
---

| Date            | Abstract                                                 | Transaction                                                                                             | Sybil Reference                         |
| --------------- | -------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- | --------------------------------------- |
| June 12, 2021   | Reduce the UNI proposal submission threshold to 2.5M     | [Etherscan](https://etherscan.io/tx/0xacda6ebe63dfc2b34a8b3e3f6297a424e4cf25cd68add6613f902099bd7432e4) | https://sybil.org/#/proposals/uniswap/4 |
| August 26, 2021 | Upgrade Governance Contract to Compound's Governor Bravo | [Etherscan](https://etherscan.io/tx/0x505870232ebd6cefd2a59c760924664212f72759e58fd2df82d61b67ffe0dd75) | https://sybil.org/#/proposals/uniswap/8 |
</file>

<file path="docs/builder-support/get-funded.mdx">
---
title: Get Funded
description: Grants and support program for Unichain builders
---

import { Cards, Card } from '@site/src/components/Cards';

## Unichain Grant Programs

Whether you’re playing with a new prototype or scaling your next venture, the Uniswap ecosystem provides [grants and support programs](https://www.uniswapfoundation.org/build) for developers at every stage. 

[The Uniswap Foundation](https://www.uniswapfoundation.org/), alongside key ecosystem contributors, offers structured grants and support pathways to help teams grow: from idea to impact. Each program is designed to meet you where you are, with a clear path to level up as you build.

<Cards>
  <Card title="Unichain Grants" href="#unichain-grants" />
  <Card title="Uniswap Hook Incubator" href="#uniswap-hook-incubator" />
  <Card title="Hook Design Lab" href="#hook-design-lab" />
  <Card title="UFSF Audit Subsidies" href="#ufsf-audit-subsidies" />
  <Card title="Uniswap v4 Router Rebates" href="#uniswap-v4-router-rebates" />
  <Card title="OP Superchain Grants" href="#op-superchain-grants" />
</Cards>

## Before You Apply

1. **Deploy to Unichain (and/or v4).**  Some programs will consider early prototypes, but being deployed on Unichain and/or Uniswap v4 will give you an advantage. 
    
    Verify that your contract is deployed and functional on Unichain.

2. **Provide documentation.** Make sure that your application includes clear documentation including setup instructions, project goals, and demo materials.

    Ensure that your application includes a README.md and a working demo.

3. **Highlight your impact.** Measure and include metrics like user adoption, transaction volume, or community engagement.

    Share early data and qualitative user feedback to strengthen your application!

## Unichain Grants

Unichain DeFi projects with $250K+ TVL and infrastructure projects can apply for product and GTM support, with up to $7.5K in grants funding.

[Apply for Unichain Grant support](https://share.hsforms.com/18Kv3hTvDSt-x1wK9va0OYwsdca9)

**What you get:**
- Grant range: up to $7.5K USD
- Application type: DeFi or infrastructure projects

## Uniswap Hook Incubator

Ready to ship your first hook? The Uniswap Hook Incubator is an intensive, async program designed to help builders speedrun v4 expertise. Participants will learn how to create and launch high impact hooks, with the opportunity to win up to $40k in prizes for capstone projects. 

[Apply for the Uniswap Hook Incubator](https://atrium.academy/uniswap)

**Ideal candidates:**

- Are experienced Solidity developers
- Have DeFi experience
- Are passionate about exploring and building new primitives

**What you get:**

- Fully covered tuition
- Up to $40k in prizes
- Access to DeFi experts and the largest Uniswap v4 builder community

## Hook Design Lab

The Uniswap v4 Hook Design Lab is a pilot program structured to support emerging DeFi builders: helping teams bring new ecosystem primitives from idea to mainnet with technical mentorship, GTM support, and milestone-based funding. 

[Apply to the Hook Design Lab.](https://share.hsforms.com/1y57UxXGGSrKc7d8v5opZzwsdca9)

**Ideal projects:**

- Bring a unique approach to capital efficiency, LP experience, target asset classes, and/or composability
- Create public goods and infrastructure for the community to build on
- Demonstrate the potential for ecosystem-wide impact

A full list of builder requests can be found [here](https://www.uniswapfoundation.org/blog/uniswap-v4-supercharging-defi-across-chains).

**What you get:**

- Grant funding for GTM and growth campaigns
- Technical, product design, and marketing support
- Holistic integration and routing support

## UFSF Audit Subsidies

Ready to launch? The Uniswap Foundation Security Fund provides access to best-in-class security audits at reduced or no cost, streamlining the process through a vetted pool of providers with transparent pricing and quality standards.

[Apply for UFSF audit subsidies](https://areta.fillout.com/UFSF)

**What you get:**

- Access to premium audit slots with top providers
- Standardized deliverables and quality assurance
- For subsidy recipients: Up to 100% of audit costs

## Uniswap v4 Router Rebates

Calling all routers, solvers and aggregators: you can claim daily subsidies for routing flow to hooked pools. 

[Apply for Uniswap v4 router rebates](https://sdca9.share.hsforms.com/2usOunBjQSZqrsVypvYdtQQ?1)

**What you get:** 

- Daily subsidies covering up to 80% of gas fees per swap, capped at 50 gwei per transaction

## OP Superchain Grants

Already launched on Unichain? Unichain and Superchain builders are eligible for Retro Funding and Funding Missions. Retro funding rewards are delivered monthly.

[OP Grant Atlas](https://atlas.optimism.io/)

**Funding focus:**

- Onchain apps: DeFi, NFTs, gaming, and more
- Developer tooling: tools, SDKs, APIs, and Superchain infrastructure.

**What you get:** 

- Ecosystem recognition
- Up to 8M in grants funding
</file>

<file path="docs/builder-support/security-resources.mdx">
---
title: Security Resources
description: Community Security Resources for Unichain builders
---
## Uniswap community security resources

New apps can introduce new, and sometimes complex, security requirements. [The Uniswap Foundation](https://www.uniswapfoundation.org/) is committed to making security audits accessible, through grant programs like the Uniswap Foundation Security Fund. 

From audit subsidies to Safe Harbor, developers have access to a spectrum of security resources to ensure that they can ship safely.

## UFSF Audit Subsidies

The Uniswap Foundation Security Fund provides access to best-in-class security audits at reduced or no cost, streamlining the process through a vetted pool of providers with transparent pricing and quality standards.

[Apply for UFSF audit subsidies](https://areta.fillout.com/UFSF)

## Areta Market

Areta Market lets you book your audit and get fast, transparent quotes from 20+ top-tier security auditors, all in one place. Eligible projects can apply for UFSF audit subsidies. 

[Explore Areta Market](https://areta.market/uniswap/)

## SEAL 911 (Security Alliance)

Use the SEAL 911 bot during an emergency situation to automatically be connected with the best security specialists in the space.

[Send message](https://www.securityalliance.org/seal-911)

## Safe Harbor (Security Alliance)

By adopting the whitehat safe harbor agreement, whitehats can rescue your protocol correctly, without worrying about any legal repercussions.

[Adopt Safe Harbor](https://www.securityalliance.org/safe-harbor)

## Wargames (Security Alliance)

Prevent losses and mitigate threats with incident response training exercises tailored to your protocol.

[Participate in Wargames](https://www.securityalliance.org/wargames)
</file>

<file path="docs/builder-support/uf-ambassadors.mdx">
---
title: Ambassadors
description: Connect with local Uniswap Foundation ambassadors and communities around the world
---

## Get tailored support for your project

[Uniswap Foundation Ambassadors](https://github.com/uniswapfoundation/UF-Ambassadors) are exceptional builders with deep expertise and passion for DeFi. They work closely with the Foundation team to grow the ecosystem and support the Uniswap community.

UF Ambassadors represent a global volunteer network of DeFi builders and experts. They  provide ongoing local support for builders: organizing events and meetups, creating tutorials and guides, and offering 1:1 developer mentorship.

## Meet Our Ambassadors

### [Nico Acosta](https://github.com/NicoAcosta) (Buenos Aires, Argentina)

- GitHub: [@NicoAcosta](https://github.com/NicoAcosta)
- Region: South America

### [Rafa Canseco](https://x.com/0xRafaCC) (Puebla, México)

- GitHub: [@rafa-canseco](https://github.com/rafa-canseco)
- Region: North America

### [Constantino Mora](https://x.com/constacrypto) (Ciudad de México, México)

- GitHub: [@constantino](https://github.com/Constantino)
- Region: North America

### [Mohak Gupta](https://x.com/mohak_sol) (Jaipur, India)

- GitHub: [@mo-hak](https://github.com/mo-hak)
- Region: South Asia

### [Rudransh](https://x.com/rudransh190204) (Jaipur, India)

- GitHub: [@Ansh1902396](https://github.com/Ansh1902396)
- Region: South Asia

### [Nobuaki Onishi](https://twitter.com/zak3939) (Tokyo, Japan)

- GitHub: [@ZaK3939](https://github.com/ZaK3939)
- Region: Asia-Pacific

### [Longs Gotar](https://x.com/devlongs_) (Lagos, Nigeria)

- GitHub: [@devlongs](https://github.com/devlongs)
- Region: Africa

### [Ivan Volovyk](https://x.com/LisVikkk) (Warsaw, Poland)

- GitHub: [@ivanvolov](https://github.com/ivanvolov)
- Region: Europe

### [Tony Lau](https://x.com/intrepid_crypto) (Toronto, Canada)

- GitHub: [@intrepidcanadian](https://github.com/intrepidcanadian)
- Region: North America

## Meet up at Uniswap community events

The Uniswap Foundation and UF Ambassador teams regularly host global events, hackathons, workshops, and meetups. 

Explore the Uniswap Foundation event calendar [here](https://lu.ma/uniswap-foundation).
</file>

<file path="docs/concepts/governance/_category_.json">
{
  "label": "Governance",
  "position": 4
}
</file>

<file path="docs/concepts/governance/adversarial-circumstances.md">
---
id: adversarial-circumstances
title: Adversarial Circumstances
sidebar_position: 4
---

This document explores some adversarial circumstances which Uniswap Governance may encounter in the future. Its goal is to help those interested in Uniswap Governance understand the reasoning behind some of its design, its limitations, and potential avenues for growth.

## Scenario 1

A good faith proposal is brought to vote but is found to have an exploitable edge case. A bad faith actor uses a series of DeFi leveraging strategies to quickly buy enough UNI during the voting period to sway the vote in favor of the proposal, passing it and exploiting the vulnerability.

### Circumvention

UNI voting power must be delegated to an address either entirely before a proposal has been submitted or during the proposal delay period. For now, the proposal delay is set to one block, which is about 15 seconds. A proposal delay of one block leaves no opportunity for a third party to find an exploitable edge case and opportunistically purchase uni, self delegate and sway the vote.

In the future, Uniswap Governance may vote to increase the proposal delay. While there are obvious benefits to an increased proposal delay, It may introduce some potential adverse outcomes such as opportunistic edge case exploitation.

## Scenario 2

A bad faith proposal is crafted and submitted to vote, which is unambiguously not in the best interest of Uniswap Governance. Multiple parties collude ahead of time to corner the UNI market to force the proposal through, gain access to the UNI reserves, and drain the funds.

### Circumvention

Since UNI is a freely tradable asset, anyone can attempt a governance takeover via market buying. That said, to force-pass a bad faith vote would require a minimum of 40 million UNI. If not outright impossible, this amount would be prohibitively expensive and likely cost more when accounting for price fluctuation than the net gain from the attack.

If a group somehow achieved a bad faith takeover, Timelock's delay would give affected agents time to withdraw their assets from the protocol. This would also be an opportunity to fork the protocol, a path that would likely be taken by the remaining good-faith actors.

## Scenario 3

A single party uses a flash loan to push through a proposal, potentially creating a pseudo-DDOS attack by spamming governance with proposals and preventing effective use.

### Circumvention

A delegated balance of 2.5 million UNI is required to submit a vote, but the balance check is set exactly one block in the past. This prevents any flash loan proposals from being created, as flash loans cannot execute outside of a single block.

The proposer must also maintain a minimum balance of 2.5 million UNI throughout the voting period, or anyone may cancel the proposal. This balance maintenance check prevents many highly leveraged proposal techniques that may span several blocks.

## Scenario 4

A bad faith proposal is created, which will genuinely incentivize bad faith voting.

Example: &quot;The treasury will be drained. Any votes in favor will be sent the balance of the treasury. Any votes opposed will be locked from the funds of the treasury.&quot;

### Circumvention

No mechanism explicitly prevents this type of scenario, but market forces disincentivize it.

Because the treasury is comprised of UNI tokens exclusively, the market would react appropriately if a vote were to pass that would jeopardize the economic viability of Uniswap Governance and the UNI token. By the time the vote would pass, UNI's price would have fallen so low as to make the attack fruitless.

UNI acting as the only asset of the governance treasury disincentivizes this form of bad faith voting. Uniswap Governance may choose in the future to diversify governance assets. While there are many benefits to this path, some fringe possibilities such as incentivized bad faith voting may appear.
</file>

<file path="docs/concepts/governance/glossary.md">
---
id: glossary
title: Glossary
sidebar_position: 5
---

- **UNI:** An ERC-20 token that designates the weight of a user&#39;s voting rights. The more UNI a user has in their wallet, the more weight their delegation or vote on a proposal holds.

- **Delegation:** UNI holders cannot vote or create proposals until they delegate their voting rights to an address. Delegation can be given to one address at a time, including the holder&#39;s own address. Note that delegation does not lock tokens; it simply adds votes to the chosen delegation address.

- **Proposal:** A proposal is executable code that modifies the governance contract or treasury and how they work. In order to create a proposal, a user must have at least 0.25% (2.5M UNI) of all UNI delegated to their address. Proposals are stored in the &quot;proposals&quot; mapping of the Governor smart contract. All proposals are subject to a 7-day voting period. If the proposer does not maintain their vote weight balance throughout the voting period, the proposal may be canceled by anyone.

- **Quorum:** In order for a vote to pass, it must achieve quorum of 4% of all UNI (40M) voting in the affirmative. The purpose of the quorum is to ensure that the only measures that pass have adequate voter participation.

- **Voting:** Users can vote for or against single proposals once they have voting rights delegated to their address. Votes can be cast while a proposal is in the &quot;Active&quot; state. Votes can be submitted immediately using &quot;castVote&quot; or submitted later with &quot;castVoteBySig&quot; (For more info on castVoteBySig and offline signatures, see EIP-712). If the majority of votes (and a 4% quorum of UNI) vote for a proposal, the proposal may be queued in the Timelock.

- **Voting Period:** Once a proposal has been put forward, Uniswap community members will have a seven day period (the Voting Period) to cast their votes.

- **Timelock:** All governance and other administrative actions are required to sit in the Timelock for a minimum of 2 days, after which they can be implemented.
</file>

<file path="docs/concepts/governance/guide-to-voting.md">
---
id: guide-to-voting
title: Beginners' Guide to Voting
sidebar_position: 3
---

This guide contains everything you need to start voting in Uniswap Governance.

To participate you will need:

- [UNI Tokens](https://uniswap.org/blog/uni/)
- ETH for transaction costs
- A wallet that supports the Ethereum protocol and holds UNI tokens. (We suggest the [Uniswap wallet](https://wallet.uniswap.org/)).
- To [delegate](#delegation) your tokens before the vote is active.

The governance [process](./02-process.md) begins in the [Governance Forum](https://gov.uniswap.org/), where you can find proposals under consideration, gather information about community sentiment, and engage with the community.

Once a given proposal is ready for an onchain vote, it will appear in the Uniswap [voting dashboard](https://vote.uniswapfoundation.org/) - where you can view all current and former Uniswap proposals.

![](./images/Proposals_Overview.png)

Clicking a proposal will show all the necessary information, documentation, and discussion needed for a voter to make an informed decision, and help visualize how the voting transpired.

![](./images/Proposal_Active.png)

***Once a proposal has reached the voting stage it represents real, executable code which will alter the functionality of Uniswap Governance or anything under its jurisdiction. Proper care should be taken to ensure that the code represented in the proposal has been audited and is found to be in good faith.***

## Delegation

UNI is a tradable asset and functions like most other standard ERC20 tokens, except it has a deeper power as a voting mechanism. In order for UNI to be used as a vote, the owner must first go through the delegation process. Delegating UNI binds the voting power of your tokens to an address so it may be used to vote. This address could be yourself, or a trusted party who you believe will vote in the best interest of Uniswap Governance.

To submit a proposal, an address must have 1,000,000 UNI delegated to it.

For a proposal to pass, 40,000,000 UNI (from any number of addresses) must vote on it, and the majority must be in favor.

To delegate your UNI tokens, visit the [Uniswap voting dashboard](https://vote.uniswapfoundation.org/delegates). Connect your Wallet, browse delegates, and click "Delegate" on your chosen delegate.

![](./images/Delegate_Selection.png)

![](./images/Delegate_Button.png)

You can also delegate to yourself if you wish to participate in voting directly. After connecting your wallet, click your wallet address, then "view my profile." From there, you can click "Delegate" on your own profile to delegate your voting power to yourself.

Once you click this button, you will see a screen that gives you the option to self delegate, or add a delegate address. If you wish to delegate your UNI voting power to your own address, click “Self Delegate”. You can also update your delegation at any time.

![](./images/Delegate_To_Self.png)

When you click “Self Delegate”, a transaction will pop up in your wallet.  If this doesn’t happen, double check that you have connected your wallet, turn off any popup blockers, and try again. Click "Confirm". When the transaction has processed, you will see that the updated voting power on your profile. Note that delegating your voting power is an event that is captured on chain, so setting and updating your delegation costs gas.

An important note: much like voter registration in a larger democracy, for UNI to be used in a vote it must be delegated before both the voting period. This means if you want your vote to count, you must delegate it in anticipation of any proposal you may be interested in.

If you are unsure of how best to vote and are interested in delegating your UNI voting power to another party, you can visit the [Delegation Pitch](https://gov.uniswap.org/c/delegation-pitch/6) section of the Governance Forum. Here parties participating in Uniswap Governance pitch their platform and voting agenda for users to read and discuss.

## Voting

If you have self delegated and there is an active proposal, you are ready to vote in Uniswap Governance.

To cast your vote, navigate to the proposals page and click on an active proposal.

![](./images/Proposals_Overview.png)

After reviewing the attached details and deciding your opinion, choose “Vote For”, or “Vote Against”.

Once you’ve chosen, a window will pop up allowing you to execute the vote.

When you click to cast your vote, your wallet will pop up asking you to confirm your transaction. Click “submit” or "confirm", wait a bit, and check that the transaction has been confirmed. You can view your votes from your profile, or on the proposal itself.

![](./images/Vote_Confirmation.png)

That’s it! Once your transaction has been confirmed, you will have cast your vote and participated in Uniswap Governance.
</file>

<file path="docs/concepts/governance/overview.md">
---
id: overview
title: Overview
sidebar_position: 1
---

## Code

[`governance`](https://github.com/Uniswap/governance)

<!-- 

## Documentation

For reference material on the Uniswap Governance system please see [Governance Reference](../../../contracts/v3/reference/governance/overview.md).

 -->

## UNI Address

`UNI` is deployed at `0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984` on the Ethereum [mainnet](https://etherscan.io/address/0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984), and the [Ropsten](https://ropsten.etherscan.io/address/0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984), [Rinkeby](https://rinkeby.etherscan.io/address/0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984), [Görli](https://goerli.etherscan.io/address/0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984), and [Kovan](https://kovan.etherscan.io/address/0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984) testnets. It was built from commit [ab22c08](https://github.com/Uniswap/governance/commit/ab22c084bacb2636a1aebf9759890063eb6e4946).

### ABI

```typescript
import Uni from '@uniswap/governance/build/Uni.json'
```

[https://unpkg.com/@uniswap/governance@1.0.2/build/Uni.json](https://unpkg.com/@uniswap/governance@1.0.2/build/Uni.json)

## Timelock

`Timelock` is deployed at `0x1a9C8182C09F50C8318d769245beA52c32BE35BC` on the Ethereum [mainnet](https://etherscan.io/address/0x1a9C8182C09F50C8318d769245beA52c32BE35BC), and the [Ropsten](https://ropsten.etherscan.io/address/0x1a9C8182C09F50C8318d769245beA52c32BE35BC), [Rinkeby](https://rinkeby.etherscan.io/address/0x1a9C8182C09F50C8318d769245beA52c32BE35BC), [Görli](https://goerli.etherscan.io/address/0x1a9C8182C09F50C8318d769245beA52c32BE35BC), and [Kovan](https://kovan.etherscan.io/address/0x1a9C8182C09F50C8318d769245beA52c32BE35BC) testnets. It was built from commit [ab22c08](https://github.com/Uniswap/governance/commit/ab22c084bacb2636a1aebf9759890063eb6e4946).

### ABI

```typescript
import Timelock from '@uniswap/governance/build/Timelock.json'
```

[https://unpkg.com/@uniswap/governance@1.0.2/build/Timelock.json](https://unpkg.com/@uniswap/governance@1.0.2/build/Timelock.json)

## GovernorAlpha (Deprecated)

`GovernorAlpha` is deployed at `0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F` on the Ethereum [mainnet](https://etherscan.io/address/0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F), and the [Ropsten](https://ropsten.etherscan.io/address/0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F), [Rinkeby](https://rinkeby.etherscan.io/address/0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F), [Görli](https://goerli.etherscan.io/address/0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F), and [Kovan](https://kovan.etherscan.io/address/0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F) testnets. It was built from commit [ab22c08](https://github.com/Uniswap/governance/commit/ab22c084bacb2636a1aebf9759890063eb6e4946).

### ABI

The `GovernorAlpha` ABI is viewable on [Etherscan](https://etherscan.io/address/0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F), as well as via an [npm package](https://www.npmjs.com/package/@uniswap/governance).

[https://unpkg.com/@uniswap/governance@1.0.2/build/GovernorAlpha.json](https://unpkg.com/@uniswap/governance@1.0.2/build/GovernorAlpha.json)

```typescript
import GovernorAlpha from '@uniswap/governance/build/GovernorAlpha.json'
```

## GovernorAlpha v2 (Deprecated)

`GovernorAlpha v2` is deployed at `0xC4e172459f1E7939D522503B81AFAaC1014CE6F6` on the Ethereum [mainnet](https://etherscan.io/address/0xC4e172459f1E7939D522503B81AFAaC1014CE6F6).

### ABI

The `GovernorAlpha v2` ABI is viewable on [Etherscan](https://etherscan.io/address/0xC4e172459f1E7939D522503B81AFAaC1014CE6F6)

## GovernorBravo (Current)

`GovernorBravo` is deployed at `0x408ED6354d4973f66138C91495F2f2FCbd8724C3` on the Ethereum [mainnet](https://etherscan.io/address/0x408ED6354d4973f66138C91495F2f2FCbd8724C3#code).

### ABI

The Governor Bravo ABI can be found on [Etherscan](https://etherscan.io/address/0x408ED6354d4973f66138C91495F2f2FCbd8724C3#code).

## Miscellaneous Addresses

**The following addresses only exist on the Ethereum mainnet.**

The UNI merkle distributor address is `0x090D4613473dEE047c3f2706764f49E0821D256e`.

The staking rewards factory address is `0x3032Ab3Fa8C01d786D29dAdE018d7f2017918e12`.

The four staking rewards addresses are:

```js
0x6c3e4cb2e96b01f4b866965a91ed4437839a121a
0x7fba4b8dc5e7616e59622806932dbea72537a56b
0xa1484c3aa22a66c62b77e0ae78e15258bd0cb711
0xca35e32e7926b96a9988f61d510e038108d8068e
```

The four year-long vesting contract addresses are:

```js
0x4750c43867ef5f89869132eccf19b9b6c4286e1a
0xe3953d9d317b834592ab58ab2c7a6ad22b54075d
0x4b4e140d1f131fdad6fb59c13af796fd194e4135
0x3d30b1ab88d487b0f3061f40de76845bec3f1e94
```

The `feeToSetterVester` address is `0x18e433c7Bf8A2E1d0197CE5d8f9AFAda1A771360`.

The `feeTo` address is `0xDAF819c2437a82f9e01f6586207ebF961a7f0970`.
</file>

<file path="docs/concepts/governance/process.md">
---
id: process
title: Process
sidebar_position: 2
---

This is a living document which represents the current process guidelines for developing and advancing Uniswap Governance Proposals. It was last updated September 2024.

## Tools

Uniswap Governance takes place in several venues. Each serves its own particular purpose.

1.  [_Governance Forum_](https://gov.uniswap.org/)

A Discourse-hosted forum for governance-related discussion. Community members must register for an account before sharing or liking posts. New members must read 4 topics and a combined 15 posts over the course of at least 10 minutes before they may  post themselves.

2. [_Snapshot_](https://snapshot.box/#/s:uniswapgovernance.eth)

A simple voting interface that allows users to signal sentiment off-chain. Votes on Snapshot are weighted by the number of UNI delegated to the address used to vote.

3. [_Uniswap Agora_](https://vote.uniswapfoundation.org)

The [Uniswap Foundation](https://www.uniswapfoundation.org) supports this voting and delegation interface. [Tally](https://www.tally.xyz/gov/uniswap) is another excellent app that supports proposal creation, delegation, and voting.


## Process

Below we outline the current Uniswap governance process, detailing where these venues fit in. These processes are subject to change according to feedback from the Uniswap community.

### Phase 1: Request for Comment (RFC)

_Timeframe_: At least 7 days

_Form_: [Governance Forum](https://gov.uniswap.org/) Post

As a proposer, you should use the RFC phase to introduce the community to your proposal. Your post should detail exactly what you are asking delegates to vote on as well as your rationale for why it is a good idea. You should be prepared to answer questions about your proposal. Willingness to adjust based on community feedback is a hallmark of successful past proposals.

To post a RFC, label your post “RFC - [Your Title Here]”. Prior to moving to Phase 2, give the community at least 7 days to read and comment on the RFC. Please respond to questions in the comments, and take feedback into account in the next iteration of the proposal posted in Phase 2.

### Phase 2: Temperature Check

_Timeframe_: 5 days

_Quorum_: 10M UNI

_Form_: [Snapshot Poll](https://snapshot.box/#/s:uniswapgovernance.eth)

The purpose of the Temperature Check is to signal community sentiment on a proposal prior to moving towards an onchain vote.

To create a Temperature Check:

1. Incorporate the community feedback from the RFC phase into the proposal.

2. Create and post this version of the proposal in the [Governance Forum](https://gov.uniswap.org/) with the title “Temperature Check — [Your Title Here]”. Include a link to the RFC post. You will update the post to include a link to the Snapshot poll after you’ve posted that.

3. Create a [Snapshot poll](https://snapshot.box/#/s:uniswapgovernance.eth). The voting options should consist of those which have gained support in the RFC Phase. This poll can be either binary or multiple choice but must include a `No change` option. Set the poll duration to 5 days. Include a link to the Forum Temperature Check post.

4. Update the Forum post with a link to the Snapshot Poll.

At the end of 5 days, the option with the majority of votes wins. There must be at least 10M UNI `Yes` votes to move onto Phase 3. If the “No change” option wins, the proposal will not move onto the Phase 3.

### Phase 3: Governance Proposal

_Timeframe_: 2 day waiting period, 7 day voting period, 2 day timelock

 _Threshold_: 1M UNI

_Quorum_: 40M UNI votes in favor

Form: [Governance Proposal](https://vote.uniswapfoundation.org/)

![](./images/Proposal_Flow.png)

Phase 3 is the final step of the governance process. If this vote passes, then a change will be enacted onchain.

To create an onchain Governance Proposal:

1. Incorporate any last iterations to your proposal based on feedback prior to posting.

2. Create a topic in the [Governance Forum](https://gov.uniswap.org/) titled "Governance Proposal — [Your Title Here]" and link to previous forum posts and the Temperature Check Snapshot poll.

3. Create your proposal. This can be done either through an interface (e.g. [Tally](https://tally.xyz/gov/uniswap)) or through writing the calldata for more complicated proposal logic. If the proposal passed, this calldata will execute. If writing the calldata yourself, please review the logic with a qualified Uniswap community member prior to posting the proposal.

4. Ensure that at least 1 million UNI is delegated to your address in order to submit a proposal, or find a delegate who has enough delegated UNI to meet the proposal threshold to propose on your behalf.

5. Once you submit the proposal, a two-day voting delay will start. After the voting delay finishes, a ~seven-day voting period begins. If the proposal passes, a two-day timelock must pass before you can execute the proposed code.

## Changes to the Governance Process

Timeframe: 7 days

_Quorum_: 40M UNI

Form: [Snapshot Poll](https://snapshot.box/#/s:uniswapgovernance.eth)

In the future, the community governance process above may need to undergo additional changes to continue to meet the needs of the Uniswap community. While an onchain vote is not required to change the majority of this process, a clear display of community support and acceptance is important for process changes to have legitimacy.

Thus, changes to all off-chain community governance processes should be voted on through an off-chain Snapshot vote. There should be a 7-day voting period and 40M UNI quorum.
</file>

<file path="docs/concepts/protocol/_category_.json">
{
  "label": "Protocol Concepts",
  "position": 3
}
</file>

<file path="docs/concepts/protocol/concentrated-liquidity.md">
---
id: concentrated-liquidity
title: Concentrated Liquidity
sidebar_position: 6
---

  <div>
  <video width="100%" height="100%" playsInline controls loop>
  <source src="https://gateway.pinata.cloud/ipfs/QmTf6EueKk5ZJ2KQwt1ZCHxRaogYVRci2U5uKRo8NeCmoB" />
  Your browser does not support the video tag.
  </video>
  </div>

---

:::note
Concentrated liquidity, first introduced as a native feature in Uniswap v3, maintains the same core implementation in v4, ensuring consistency in how liquidity providers can focus their capital.
:::

## Introduction

The defining idea of Uniswap v3 is concentrated liquidity: liquidity that is allocated within a custom price range.
In earlier versions, liquidity was distributed uniformly along the price curve between 0 and infinity.

The previously uniform distribution allowed trading across the entire price interval (0, ∞) without any loss of liquidity. However, in many pools, the majority of the liquidity was never used.

Consider stablecoin pairs, where the relative price of the two assets stays relatively constant. The liquidity outside the typical price range of a stablecoin pair is rarely touched. For example, the v2 DAI/USDC pair utilizes ~0.50% of the total available capital for trading between $0.99 and $1.01, the price range in which LPs would expect to see the most volume - and consequently earn the most fees.

With v3, liquidity providers may concentrate their capital to smaller price intervals than (0, ∞). In a stablecoin/stablecoin pair, for example, an LP may choose to allocate capital solely to the 0.99 - 1.01 range. As a result, traders are offered deeper liquidity around the mid-price, and LPs earn more trading fees with their capital. We call liquidity concentrated to a finite interval a position. LPs may have many different positions per pool, creating individualized price curves that reflect the preferences of each LP.

## Active Liquidity

As the price of an asset rises or falls, it may exit the price bounds that LPs have set in a position. When the price exits a position's interval, the position's liquidity is no longer active and no longer earns fees.

As price moves in one direction, LPs gain more of the one asset as swappers demand the other, until their entire liquidity consists of only one asset. (In v2, we don't typically see this behavior because LPs rarely reach the upper or lower bound of the price of two assets, i.e., 0 and ∞). If the price ever reenters the interval, the liquidity becomes active again, and in-range LPs begin earning fees once more.

Importantly, LPs are free to create as many positions as they see fit, each with its own price interval. Concentrated liquidity serves as a mechanism to let the market decide what a sensible distribution of liquidity is, as rational LPs are incentivized to concentrate their liquidity while ensuring that their liquidity remains active.

## Ticks

To achieve concentrated liquidity, the once continuous spectrum of price space has been partitioned with ticks.

Ticks are the boundaries between discrete areas in price space. Ticks are spaced such that an increase or decrease of 1 tick represents a 0.01% increase or decrease in price at any point in price space.

Ticks function as boundaries for liquidity positions. When a position is created, the provider must choose the lower and upper tick that will represent their position's borders.

As the spot price changes during swapping, the pool contract will continuously exchange the outbound asset for the inbound, progressively using all the liquidity available within the current tick interval[^1] until the next tick is reached. At this point, the contract switches to a new tick and activates any dormant liquidity within a position that has a boundary at the newly active tick.

While each pool has the same number of underlying ticks, in practice only a portion of them are able to serve as active ticks. Due to the nature of the v3 smart contracts, tick spacing is directly correlated to the swap fee. Lower fee tiers allow closer potentially active ticks, and higher fees allow a relatively wider spacing of potential active ticks.

While inactive ticks have no impact on transaction cost during swaps, crossing an active tick does increase the cost of the transaction in which it is crossed, as the tick crossing will activate the liquidity within any new positions using the given tick as a border.

In areas where capital efficiency is paramount, such as stable coin pairs, narrower tick spacing increases the granularity of liquidity provisioning and will likely lower price impact when swapping - the result being significantly improved prices for stable coin swaps.

For more information on fee levels and their correlation to tick spacing, see the [whitepaper](https://uniswap.org/whitepaper-v3.pdf).

[^1]: Tick interval refers to the area of price space between two nearest active ticks
</file>

<file path="docs/concepts/protocol/fees.md">
---
id: fees
title: Fees
sidebar_position: 3
---

:::note
While v3 uses predefined fee tiers (0.01%, 0.05%, 0.3%, and 1%), v4 introduces flexible fees that can range from 0% to 100%, offering greater customization options for pools.
:::

## Swap Fees

Swap fees are distributed pro-rata to all in-range[^1] liquidity at the time of the swap. If the spot price moves out of a position’s range, the given liquidity is no longer active and does not generate any fees. If the spot price reverses and reenters the position’s range, the position’s liquidity becomes active again and will generate fees.

Swap fees are not automatically reinvested as they were in previous versions of Uniswap. Instead, they are collected separately from the pool and must be manually redeemed when the owner wishes to collect their fees.

## Pool Fees Tiers

Uniswap v3 introduces multiple pools for each token pair, each with a different swapping fee. Liquidity providers may initially create pools at three fee levels: 0.05%, 0.30%, and 1%. More fee levels may be added by UNI governance, e.g. the 0.01% fee level added by [this](https://vote.uniswapfoundation.org/proposals/9) governance proposal in December 2021, as executed [here](https://etherscan.io/tx/0x5c84f89a67237db7500538b81af61ebd827c081302dd73a1c20c8f6efaaf4f3c).

Breaking pairs into separate pools was previously untenable due to the issue of liquidity fragmentation. Any incentive alignments achieved by more fee optionality invariably resulted in a net loss to traders, due to lower pairwise liquidity and the resulting increase in price impact upon swapping.

The introduction of concentrated liquidity decouples total liquidity from price impact. With price impact concerns out of the way, breaking pairs into multiple pools becomes a feasible approach to improving the functionality of a pool for assets previously underserved by the 0.30% swap fee.

## Finding The Right Pool Fee

We anticipate that certain types of assets will gravitate towards specific fee tiers, based on where the incentives for both swappers and liquidity providers come nearest to alignment.

We expect low volatility assets (stable coins) will likely congregate in the lowest fee tier, as the price risk for liquidity providers holding these assets is very low, and those swapping will be motivated to pursue an execution price closest to 1:1 as they can get.

Similarly, we anticipate more exotic assets, or those traded rarely, will naturally gravitate towards a higher fee - as liquidity providers will be motivated to offset the cost risk of holding these assets for the duration of their position.

## Protocol Fees

Both Uniswap v3 and v4 include a protocol fee mechanism that can be activated through UNI governance. This fee structure offers greater flexibility compared to v2, allowing governance to adjust the fraction of swap fees allocated to the protocol. For detailed information about protocol fees, refer to the [v3 whitepaper](https://uniswap.org/whitepaper-v3.pdf) and [v4 whitepaper](https://uniswap.org/whitepaper-v4.pdf).

[^1]: In-range liquidity refers to the liquidity contained in any positions which span both sides of the spot price.
</file>

<file path="docs/concepts/protocol/hooks.md">
---
id: hooks
title: Hooks
sidebar_position: 1
---

## Introduction

Uniswap v4 inherits all of the capital efficiency gains of Uniswap v3 while introducing major architectural improvements.

The key innovations are the Hook System and Singleton Architecture, which together enable unprecedented protocol customization and gas optimization.

## Hooks

Hooks allow developers to customize and extend the behavior of liquidity pools. They are external smart contracts that can be attached to individual pools to intercept and modify the execution flow at specific points during pool-related actions.

The logic is executed before and/or after major operations such as pool creation, liquidity addition and removal, swapping, and donations.

Through these hook functions, developers can build sophisticated features like custom AMMs with different pricing curves, yield farming protocols, advanced trading features including limit orders, dynamic fee strategies, and custom oracle implementations. Each pool can have one hook (though a hook can serve multiple pools), hooks are optional and specified during pool creation, and developers can implement any combination of hook functions based on their needs.

## Singleton Architecture

The hook system in v4 is built on top of a revolutionary architectural change known as the singleton design. Unlike previous versions where each pool was a separate smart contract, v4 manages all pools through a single contract called the [PoolManager](/contracts/v4/concepts/PoolManager). This architectural innovation brings several key improvements:

- **Efficient Pool Creation**: Pools are created as state updates rather than contract deployments, significantly reducing gas costs
- **Gas Optimization**: Multi-hop swaps and complex operations are streamlined through a single contract
- **Flash Accounting**: Token balances are tracked internally and settled at the end of transactions, minimizing transfers
- **Native ETH Support**: Direct ETH trading without the need to wrap to WETH, improving user experience

These core features are just the beginning of what's possible with Uniswap v4.

To explore all features including flash accounting, native ETH support, dynamic fees, and custom accounting, check out the [v4 whitepaper](https://uniswap.org/whitepaper-v4.pdf).

For technical implementations and detailed guides, visit the [v4 technical documentation](/contracts/v4/overview).
</file>

<file path="docs/concepts/protocol/integration-issues.md">
---
id: integration-issues
title: Token Integration Issues
sidebar_position: 7
---

Fee-on-transfer and rebasing tokens will not function correctly on v3.

## Fee-on-transfer Tokens

Fee-on-transfer tokens will not function with our router contracts. As a workaround, the token creators may create a token wrapper or a customized router. We will not be making a router that supports fee-on-transfer tokens in the future.

## Rebasing Tokens

Rebasing tokens will succeed in pool creation and swapping, but liquidity providers will bear the loss of a negative rebase when their position becomes active, with no way to recover the loss.
</file>

<file path="docs/concepts/protocol/oracle.md">
---
id: oracle
title: Oracle
sidebar_position: 4
---

:::note
Uniswap v4 does not include built-in oracle functionality. If you're unfamiliar with oracles, check out the Ethereum Foundation's [oracle overview](https://ethereum.org/en/developers/docs/oracles/).
:::

All Uniswap v3 pools can serve as oracles, offering access to historical price and liquidity data. This capability unlocks a wide range of on-chain use cases.

Historical data is stored as an array of observations. At first, each pool tracks only a single observation, overwriting it as blocks elapse. This limits how far into the past users may access data. However, any party willing to pay the transaction fees may [increase the number of tracked observations](../../contracts/v3/reference/core/UniswapV3Pool#increaseobservationcardinalitynext) (up to a maximum of `65535`), expanding the period of data availability to ~9 days or more.

Storing price and liquidity history directly in the pool contract substantially reduces the potential for logical errors on the part of the calling contract, and reduces integration costs by eliminating the need to store historical values. Additionally, the v3 oracle's considerable maximum length makes oracle price manipulation significantly more difficult, as the calling contract may cheaply construct a time-weighted average over any arbitrary range inside of (or fully encompassing) the length of the oracle array.

## Observations

`Observation`s take the following form:

```solidity
struct Observation {
    // the block timestamp of the observation
    uint32 blockTimestamp;
    // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized
    int56 tickCumulative;
    // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized
    uint160 secondsPerLiquidityCumulativeX128;
    // whether or not the observation is initialized
    bool initialized;
}
```

`Observation`s may be retrieved via the [`observations`](../../contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolState#observations) method on v3 pools. However, this is _not_ the recommended way to consume oracle data. Instead, prefer [`observe`](../../contracts/v3/reference/core/UniswapV3Pool#observe):

```solidity
function observe(uint32[] calldata secondsAgos)
    external
    view
    returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
```

Each time `observe` is called, the caller must specify an array containing any number of seconds ago, denoting the times to return observations from. Note that each of the given times must be more recent (or as old as) the oldest stored observation. Note: if the times don't correspond exactly to a block in which an observation was written, a counterfactual observation will be constructed, removing the need for the caller to interpolate manually. This is one of the primary reasons to use `observe` over `observations`.

Note that because the oracle is only updated at most once every block, calling `observe` with a `secondsAgo` value of `0` will return the most recently written observation, which can only be as recent as the beginning of the current block (or older).

## Tick Accumulator

The tick accumulator stores the cumulative sum of the active tick at the time of the observation. The tick accumulator value increases monotonically and grows by the value of the current tick - per second.

To derive the arithmetic mean tick over an interval, the caller needs to retrieve two observations, one after the other, take the delta of the two values, and divide by the time elapsed between them. Calculating a TWAP from the tick accumulator is also covered in the [**whitepaper**](https://uniswap.org/whitepaper-v3.pdf). Note that using an arithmetic mean tick to derive a price corresponds to a _geometric_ mean price.

See [OracleLibrary](https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol) for an example of how to use the tick accumulator.

## Liquidity Accumulator

The liquidity accumulator stores the value of seconds / in-range liquidity at the time of the observation. The liquidity accumulator value increases monotonically and grows by the value of seconds / in-range liquidity - per second.

To derive the harmonic mean liquidity over an interval, the caller needs to retrieve two observations, one after the other, take the delta of the two values, then divide the time elapsed by this value. Calculating TWAL is addressed in finer detail in the [**whitepaper**](https://uniswap.org/whitepaper-v3.pdf).

:::note
The in-range liquidity accumulator should be used with care. Because the current tick and the current in-range liquidity can be entirely uncorrelated, there are scenarios in which taking the arithmetic mean tick and the harmonic mean liquidity over the same interval in a pool can inaccurately characterize this pool relative to another. For example, if the current tick on pool A is 0 for 5 seconds, and 100 for 5 seconds, the tick accumulator will be 50. If over this same interval, the in-range liquidity was 5000 and 50, the harmonic mean liquidity will be ~99. Compare this to pool B (composed of the same assets) where the tick was 50 and the in-range liquidity was ~99 for 10 seconds. The accumulator values will be identical, but the underlying behavior is of course quite different.
:::

## Deriving Price From A Tick

> When we use "active tick" or otherwise to refer to the current tick of a pool, we mean the lower tick boundary that is closest to the current price.

When a pool is created, each token is assigned to either `token0` or `token1` based on the contract address of the tokens in the pair. Whether or not a token is `token0` or `token1` is meaningless; it is only used to maintain a fixed assignment for the purpose of relative valuation and general logic in the pool contract.

Deriving an asset price from the current tick is achievable due to the fixed expression across the pool contract of token0 in terms of token1.

---

An example of finding the price of WETH in a WETH / USDC pool, where WETH is `token0` and USDC is `token1`:

You have an oracle reading that shows a return of `tickCumulative` as [`70_000`, `1_070_000`], with an elapsed time between the observations of 10 seconds.

We can derive the average tick over this interval by taking the difference in accumulator values (`1_070_000` - `70_000` = `1_000_000`), and dividing by the time elapsed (`1_000_000` / `10` = `100_000`).

With a tick reading of `100_000`, we can find the value of `token1` (USDC) in terms of `token0` (WETH) by using the current tick as `i` in the formula `p(i) = 1.0001**i` (see 6.1 in the [whitepaper](https://uniswap.org/whitepaper-v3.pdf)).

`1.0001**100_000 ≅ 22015.5` USDC / WETH

---

Ticks are signed integers and can be expressed as a negative number, so for any circumstances where `token0` is of a lower value than `token1`, a negative tick value will be returned by `tickCumulative` and a relative value of `< 0` will be returned by a calculation of `token0` in terms of `token1`.

## Oracles Integrations on Layer 2 Rollups

### Arbitrum One

On Arbitrum One, multiple transactions can be part of a block, and [multiple blocks](https://arbiscan.io/blocks) are usually created per second (up to a maximum of 4 blocks per second). Their `block.timestamp` reflect the time at which the block was produced based on the sequencer's clock (see [Arbitrum's sequencer documentation](https://docs.arbitrum.io/sequencer) to learn more about its trust assumptions), so observations have enough granularity to make the oracle more difficult to manipulate. Thus, Uniswap pools on Arbitrum One are suitable for providing oracle prices. For more information on how block numbers and time work on Arbitrum One, please see the [Arbitrum documentation portal](https://docs.arbitrum.io/time).
</file>

<file path="docs/concepts/protocol/range-orders.md">
---
id: range-orders
title: Range Orders
sidebar_position: 5
---

:::note
Range orders have the same implementation in both Uniswap v3 and v4, offering consistent functionality across both versions.
:::

Customizable liquidity positions, along with single-sided asset provisioning, allow for a new style of swapping with automated market makers: the range order.

In typical order book markets, anyone can easily set a limit order: to buy or sell an asset at a specific predetermined price, allowing the order to be filled at an indeterminate time in the future.

With Uniswap v3, one can approximate a limit order by providing a single asset as liquidity within a specific range. Like traditional limit orders, range orders may be set with the expectation they will execute at some point in the future, with the target asset available for withdrawal after the spot price has crossed the full range of the order.

Unlike some markets where limit orders may incur fees, the range order maker generates fees while the order is filled. This is due to the range order technically being a form of liquidity provisioning rather than a typical swap.

## Possibilities of Range orders

The nature of AMM design makes some styles of limit orders possible, while others cannot be replicated. The following are four examples of range orders and their traditional counterparts; the first two are possible, the second two are not.

> One important distinction: range orders, unlike traditional limit orders, will be **unfilled** if the spot price crosses the given range and then reverses to recross in the opposite direction before the target asset is withdrawn. While you will be earning LP fees during this time, if the goal is to exit fully in the desired destination asset, you will need to keep an eye on the order and either manually remove your liquidity when the order has been filled or use a third party position manager service to withdraw on your behalf.

### Take-Profit Orders

> The current price of a DAI / ETH pool is 1,500 DAI / ETH. You would like to sell your ETH for DAI when the price of ETH reaches 1,600 DAI / ETH. This is possible, as the price space above the spot price is denominated in the higher valued asset, ETH. You can provide ETH at a price of 1,600 DAI / ETH and have the order filled when the spot price crosses your position.

<img src={require('./images/RangeOrder1.png').default} alt="RangeOrder1" width="45%" height="45%" />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<img src={require('./images/RangeOrder2.png').default} alt="RangeOrder1" width="45%" height="45%" />

---

### Buy Limit Orders

> The Current price of a DAI / ETH pool is 1,500 DAI / ETH. You expect that ETH will rebound after it drops to 1,000 at the next market downturn, so you would like to place a range order swapping DAI to ETH at the price of 1,000 DAI / ETH. This is possible, as the price space below the spot price is denominated in the lower-priced asset, DAI. You can provide DAI at the price of 1,000 DAI / ETH, which will be swapped for ETH when the spot price of ETH drops past 1,000 DAI / ETH.

As the above examples show, in Uniswap v3, the two paired assets in a given pool are separated above and below the spot price, with the higher price asset available above the spot price and the lower-priced asset below.

The following examples show limit order styles that are unable to be replicated due to the separation of assets in price space.

---

### Buy Stop Orders

> The current price of a DAI / ETH pool is 1,500 DAI / ETH. You expect the price of ETH to rocket up to 3,000 once it hits 2,000 DAI/ ETH, So you would like to place a range order from DAI to ETH at a price of 2,000 DAI/ETH. This is not possible as the price space above 1,500 DAI / ETH is denominated in ETH - and thus, you cannot provide the DAI necessary at your desired price to be swapped into ETH.

---

### Stop-Loss Orders

> The current price of a DAI / ETH pool is 1,500 DAI / ETH. You expect once the price of ETH drops to below 1,000, it will tank to 200. So you would like to place a range order from ETH to DAI at a price of 1,000. This is not possible as the price space below the spot price is denominated in DAI, and so you cannot allocate the ETH necessary at 1,000 to be swapped into DAI.

---

## Fees

The fees due to your liquidity position will be denominated in both tokens of the given pair. In any of the above examples, after swapping ETH for DAI, or DAI for ETH, a small amount of both ETH and DAI will be due to your account as liquidity provisioning rewards.

Approaches to concentration when setting range orders are up to the user. Selecting a wider range may generate more fees if there is price churn within your range, at the cost of increasing the risk of having your order unfilled if the spot price reverses before completing your full range.
</file>

<file path="docs/concepts/protocol/swaps.md">
---
id: swaps
title: Swaps
sidebar_position: 2
---

## Introduction

Swaps are the most common way of interacting with the Uniswap protocol. For end-users, swapping is straightforward: a user selects an ERC-20 token that they own and a token they would like to trade it for. Executing a swap sells the currently owned tokens for the proportional[^1] amount of the tokens desired, minus the swap fee, which is awarded to liquidity providers[^2]. Swapping with the Uniswap protocol is a permissionless process.

> note: Using web interfaces (websites) to swap via the Uniswap protocol can introduce additional permission structures, and may result in different execution behavior compared to using the Uniswap protocol directly. To learn more about the differences between the protocol and a web interface, see What is Uniswap.

Swaps using the Uniswap protocol are different from traditional order book trades in that they are not executed against discrete orders on a first-in-first-out basis — rather, swaps execute against a passive pool of liquidity, with liquidity providers earning fees proportional to their capital committed

## Price Impact

In a traditional order-book market, a sizeable market-buy order may deplete the available liquidity of a prior limit-sell and continue to execute against a subsequent limit-sell order at a higher price. The result is the final execution price of the order is somewhere in between the two limit-sell prices against which the order was filled.

Price impact affects the execution price of a swap similarly but is a result of a different dynamic. When using an automated market maker, the relative value of one asset in terms of the other continuously shifts during the execution of a swap, leaving the final execution price somewhere between where the relative price started - and ended.

This dynamic affects every swap using the Uniswap protocol, as it is an inextricable part of AMM design.

As the amount of liquidity available at different price points can vary, the price impact for a given swap size will change relative to the amount of liquidity available at any given point in price space. The greater the liquidity available at a given price, the lower the price impact for a given swap size. The lesser the liquidity available, the higher the price impact.

Approximate[^3] price impact is anticipated in real-time via the Uniswap interface, and warnings appear if unusually high price impact will occur during a swap. Anyone executing a swap will have the ability to assess the circumstances of price impact when needed.

## Slippage

The other relevant detail to consider when approaching swaps with the Uniswap protocol is slippage. Slippage is the term we use to describe alterations to a given price that could occur while a submitted transaction is pending.

When transactions are submitted to Ethereum, their order of execution is established by the amount of "gas" offered as a fee for executing each transaction. The higher the fee offered, the faster the transaction is executed. The transactions with a lower gas fee will remain pending for an indeterminate amount of time. During this time, the price environment in which the transaction will eventually be executed will change, as other swaps will be taking place.

Slippage tolerances establish a margin of change acceptable to the user beyond price impact. As long as the execution price is within the slippage range, e.g., 1%, the transaction will be executed. If the execution price ends up outside of the accepted slippage range, the transaction will fail, and the swap will not occur.

A comparable situation in a traditional market would be a market-buy order executed after a delay. One can know the expected price of a market-buy order when submitted, but much can change in the time between submission and execution.

## Safety Checks

Price impact and slippage can both change while a transaction is pending, which is why we have built numerous safety checks into the Uniswap protocol to protect end-users from drastic changes in the execution environment of their swap. Some of the most commonly encountered safety checks:

- **Expired** : A transaction error that occurs if a swap is pending longer than a predetermined deadline. The deadline is a point in time after which the swap will be canceled to protect against unusually long pending periods and the changes in price that typically accompany the passage of time.

- **INSUFFICIENT_OUTPUT_AMOUNT** : When a user submits a swap, the Uniswap interface will send an estimate of how much of the purchased token the user should expect to receive. If the anticipated output amount of a swap does not match the estimate within a certain margin of error (the slippage tolerance), the swap will be canceled. This attempts to protect the user from any drastic and unfavorable price changes while their transaction is pending.

[^1]: Proportional in this instance takes into account many factors, including the relative price of one token in terms of the other, slippage, price impact, and other factors related to the open and adversarial nature of Ethereum.
[^2]: For information about liquidity provision, see the liquidity user guide
[^3]: The Uniswap interface informs the user about the circumstances of their swap, but it is not guaranteed.
</file>

<file path="docs/concepts/glossary.md">
---
id: glossary
title: Glossary
sidebar_position: 6
---

## Automated Market Maker

An automated market maker is a smart contract on Ethereum that holds liquidity reserves. Users can trade against these reserves at prices determined by a fixed formula. Anyone may contribute liquidity to these smart contracts, earning pro-rata trading fees in return.

## Asset

While a digital asset can take many forms, the Uniswap Protocol supports ERC-20 token pairs, and represents a position in the form of an NFT (ERC-721).

## Concentrated Liquidity

Liquidity that is allocated within a determined price range.

## Constant Product Formula

The automated market making algorithm used by Uniswap. In v1 and v2, this was x\*y=k.

## Core

Smart contracts that are considered foundational, and are essential for Uniswap to exist. Upgrading to a new version of core would require deploying an entirely new set of smart contracts on Ethereum and would be considered a new version of the Uniswap Protocol.

## ERC20

ERC20 tokens are fungible tokens on Ethereum. Uniswap supports all standard ERC20 implementations.

## Factory

A smart contract that deploys a unique smart contract for any ERC20/ERC20 trading pair.

## Flash Swap

A trade that uses the tokens purchased before paying for them.

## Invariant

The “k” value in the constant product formula X\*Y=K

## Liquidity Provider / "LP"

A liquidity provider is someone who deposits ERC20 tokens into a given liquidity pool. Liquidity providers take on price risk and are compensated with trading fees.

## Liquidity

Digital assets that are stored in a Uniswap pool contract, and are able to be traded against by traders.

## Mid Price

The price between the available buy and sell prices. In Uniswap v1 and v2, this is the ratio of the two ERC20 token reserves. In V3, this is the ratio of the two ERC20 token reserves available within the current active tick.

## Observation

An instance of historical price and liquidity data of a given pair.

## Pair

A smart contract deployed from a Uniswap v1 or v2 factory contract that enables trading between two ERC20 tokens. Pair contracts are now called Pools in v3.

## Periphery

External smart contracts that are useful, but not required for Uniswap to exist. New periphery contracts can always be deployed without migrating liquidity.

## Pool

A contract deployed by the V3 factory that pairs two ERC-20 assets. Different pools may have different fees despite containing the same token pair. Pools were previously called Pairs before the introduction of multiple fee options.

## Position

An instance of liquidity defined by upper and lower tick. And the amount of liquidity contained therein.

## Price Impact

The difference between the mid-price and the execution price **caused by your trade size relative to the pool’s liquidity**. This is an expected result of the constant product formula in AMMs.

## Protocol Fees

Fees that are rewarded to the protocol itself, rather than to liquidity providers.

## Range

Any interval between two ticks of any distance.

## Range Order

An approximation of a limit order, in which a single asset is provided as liquidity across a specified range, and is continuously swapped to the destination address as the spot price crosses the range.

## Reserves

The liquidity available within a pair. This was more commonly referenced before concentrated liquidity was introduced.

## Slippage

The total difference between the expected price at the time of submitting a transaction and the actual execution price, which may include price impact and other market movements that occur before the transaction is mined.

## Spot Price

The current price of a token relative to another within a given pair.

## Swap Fees

The fees collected upon swapping which are rewarded to liquidity providers.

## Tick Interval

The price space between two nearest ticks.

## Tick

The boundaries between discrete areas in price space.
</file>

<file path="docs/concepts/research.md">
---
id: research
title: Research
sidebar_position: 4
---

The [Uniswap Foundation](https://www.uniswapfoundation.org/) supports the protocol's growth and decentralization through strategic research initiatives, empowering our community with grants and resources to conduct groundbreaking research and develop practical implementations that advance the frontier DeFi. Featured research from our community:

## Layer 2 be or Layer not 2 be: Scaling on Uniswap v3

Authors: Austin Adams

> This research paper analyzes how cheaper and faster blockchain networks impact Uniswap v3's performance compared to Ethereum mainnet, revealing that reduced transaction costs lead to better gas-adjusted execution and more efficient capital deployment by liquidity providers. Faster block times and lower costs enable increased arbitrage activity, resulting in higher fee returns for liquidity providers, though there's evidence that 2-second block times may not be optimal compared to a first-come-first-served model. Evidence suggests that many current AMM limitations stem from blockchain constraints rather than protocol design, and these issues can be significantly improved through faster, cheaper transactions.

- [Layer 2 be or Layer not 2 be: Scaling on Uniswap v3 [Mar 2024]](https://arxiv.org/abs/2403.09494)

## Who Wins Ethereum Block Building Auctions and Why?

Authors: Burak Öz, Danning Sui, Thomas Thiery, Florian Matthes

> The MEV-Boost block auction contributes approximately 90% of all Ethereum blocks. Between October 2023 and March 2024, only three builders produced 80% of them, highlighting the concentration of power within the block builder market. To foster competition and preserve Ethereum's decentralized ethos and censorship-resistance properties, understanding the dominant players' competitive edges is essential. This identifies features that play a significant role in builders' ability to win blocks and earn profits by conducting a comprehensive empirical analysis of MEV-Boost auctions over a six-month period. 

- [Who Wins Ethereum Block Building Auctions and Why? [Jul 2024]](https://arxiv.org/abs/2407.13931)

## MEV Capture and Decentralization in Execution Tickets

Authors: Jonah Burian, Davide Crapis, Fahad Saleh

> Provides an economic model of Execution Tickets and uses it to study the ability of the Ethereum protocol to capture MEV from block construction, demonstrating that Execution Tickets extract all MEV when all buyers are homogeneous, risk neutral and face no capital costs. We also show that MEV capture decreases with risk aversion and capital costs. Moreover, when buyers are heterogeneous, MEV capture can be especially low and a single dominant buyer can extract much of the MEV. This adverse effect can be partially mitigated by the presence of a Proposer Builder Separation (PBS) mechanism, which gives ET buyers access to a market of specialized builders, but in practice centralization vectors still persist. With PBS, ETs are concentrated among those with the highest ex-ante MEV extraction ability and lowest cost of capital. We show how it is possible that large investors that are not builders but have substantial advantage in capital cost can come to dominate the ET market.

- [MEV Capture and Decentralization in Execution Tickets [Aug 2024]](https://arxiv.org/abs/2408.11255)

## What Drives Liquidity on Decentralized Exchanges? Evidence from the Uniswap Protocol

Authors: Alex Evans

> Geometric mean market makers (G3Ms), such as Uniswap and Balancer, comprise a popular class of automated market makers (AMMs) defined by the following rule: the reserves of the AMM before and after each trade must have the same (weighted) geometric mean. This paper extends several results known for constant-weight G3Ms to the general case of G3Ms with time-varying and potentially stochastic weights. These results include the returns and no-arbitrage prices of liquidity pool (LP) shares that investors receive for supplying liquidity to G3Ms. Using these expressions, we show how to create G3Ms whose LP shares replicate the payoffs of financial derivatives. The resulting hedges are model-independent and exact for derivative contracts whose payoff functions satisfy an elasticity constraint. These strategies allow LP shares to replicate various trading strategies and financial contracts, including standard options. G3Ms are thus shown to be capable of recreating a variety of active trading strategies through passive positions in LP shares.

- [What Drives Liquidity on Decentralized Exchanges? Evidence from the Uniswap Protocol [Oct 2024]](https://arxiv.org/abs/2410.19107)

## The Evolution of Decentralized Exchange: Risks, Benefits, and Oversight

Authors: Campbell R. Harvey, Joel Hasbrouck, Fahad Saleh

> A decentralized exchange or DEX is an application deployed on a blockchain that allows investors to exchange digital assets at pricing terms determined by a preset exchange rate formula. This technology has several unique features, including accessibility to all investors, transparency of pricing, and simultaneity of execution and settlement. Notably, trading via a DEX is feasible for any asset tokenized on a blockchain. In turn, given that assets such as stocks and bonds could be tokenized easily, it is particularly important to understand the risks posed by DEXs. This paper examines both the benefits and risks to investors from DEXs, explores the role of private and public liquidity pools and analyzes possible regulatory approaches.

- [The Evolution of Decentralized Exchange: Risks, Benefits, and Oversight [Oct 2024]](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4861942)


## Research Initiatives: Get Involved

- [TLDR (The Latest in DeFi Research):](https://www.thelatestindefi.org/) empowers engineers, academics, and students through research fellowships with grants and expert mentorship, culminating in an annual conference to showcase groundbreaking work.

- [CBER CtCe (Crafting the Cryptoeconomy):](https://x.com/UniswapFND/status/1859719158763749514) developed to generate and promote practical yet rigorous research in cryptoeconomics by connecting researchers, economists and practitioners through workshops, grants and conferences. 

- [DEX Analytics Portal:](https://dexanalytics.org/) accurate, verified, and ergonomic DEX and Uniswap datasets to save researchers time.


<!-- 

The automated market maker is a new concept, and as such, new research comes out frequently. We've selected some of the most thoughtful here.

# Uniswap's Financial Alchemy

Authors: Dave White, Martin Tassy, Charlie Noyes, and Dan Robinson

> An automated market maker is a type of decentralized exchange that lets customers trade between on-chain assets like USDC and ETH. Uniswap is the most popular AMM on Ethereum. Like most AMMs, Uniswap facilitates trading between a particular pair of assets by holding reserves of both assets. It sets the trading price between them based on the size of its reserves in such a way that prices will stay in line with the broader market. Anybody who would like to can join the “pool” for a particular pair and become a liquidity provider, or LP, so-called because they provide liquid assets for others to trade against. LPs contribute assets to both reserves simultaneously, taking on some of the risk of trading in exchange for a share of the returns.

- [Uniswap's Financial Alchemy](https://www.paradigm.xyz/2020/12/uniswaps-alchemy) 

# An analysis of Uniswap markets

Authors: Guillermo Angeris, Hsien-Tang Kao, Rei Chiang, Charlie Noyes, Tarun Chitra

> Uniswap---and other constant product markets---appear to work well in practice despite their simplicity. In this paper, we give a simple formal analysis of constant product markets and their generalizations, showing that, under some common conditions, these markets must closely track the reference market price. We also show that Uniswap satisfies many other desirable properties and numerically demonstrate, via a large-scale agent-based simulation, that Uniswap is stable under a wide range of market conditions.

- [An analysis of Uniswap markets](https://arxiv.org/abs/1911.03380)

# Improved Price Oracles: Constant Function Market Makers

Authors: Guillermo Angeris, Tarun Chitra

> Automated market makers, first popularized by Hanson's logarithmic market scoring rule (or LMSR) for prediction markets, have become important building blocks, called 'primitives,' for decentralized finance. A particularly useful primitive is the ability to measure the price of an asset, a problem often known as the pricing oracle problem. In this paper, we focus on the analysis of a very large class of automated market makers, called constant function market makers (or CFMMs) which includes existing popular market makers such as Uniswap, Balancer, and Curve, whose yearly transaction volume totals to billions of dollars. We give sufficient conditions such that, under fairly general assumptions, agents who interact with these constant function market makers are incentivized to correctly report the price of an asset and that they can do so in a computationally efficient way. We also derive several other useful properties that were previously not known. These include lower bounds on the total value of assets held by CFMMs and lower bounds guaranteeing that no agent can, by any set of trades, drain the reserves of assets held by a given CFMM.

- [Improved Price Oracles: Constant Function Market Makers](https://arxiv.org/abs/2003.10001)

# Pintail research

Published [medium](https://medium.com/@pintail) articles by Pintail.

- [Understanding Uniswap Returns](https://medium.com/@pintail/understanding-uniswap-returns-cc593f3499ef)
- [Uniswap: A Good Deal for Liquidity Providers?](https://medium.com/@pintail/uniswap-a-good-deal-for-liquidity-providers-104c0b6816f2)

# Liquidity Provider Returns in Geometric Mean Markets

Authors: Alex Evans

> Geometric mean market makers (G3Ms), such as Uniswap and Balancer, comprise a popular class of automated market makers (AMMs) defined by the following rule: the reserves of the AMM before and after each trade must have the same (weighted) geometric mean. This paper extends several results known for constant-weight G3Ms to the general case of G3Ms with time-varying and potentially stochastic weights. These results include the returns and no-arbitrage prices of liquidity pool (LP) shares that investors receive for supplying liquidity to G3Ms. Using these expressions, we show how to create G3Ms whose LP shares replicate the payoffs of financial derivatives. The resulting hedges are model-independent and exact for derivative contracts whose payoff functions satisfy an elasticity constraint. These strategies allow LP shares to replicate various trading strategies and financial contracts, including standard options. G3Ms are thus shown to be capable of recreating a variety of active trading strategies through passive positions in LP shares.

- [Liquidity Provider Returns in Geometric Mean Markets](https://arxiv.org/abs/2006.08806)

# The Replicating Portfolio of a Constant Product Market

Authors: Joseph Clark

> We derive the replicating portfolio of a constant product market. This is structurally short volatility (selling options) which explains why positive transaction costs are needed to induce liquidity providers to participate. Where futures and options markets do not exist, this payoff can be used to create them.

- [https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3550601](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3550601)

-->
</file>

<file path="docs/concepts/resources.md">
---
id: resources
title: Resources
sidebar_position: 5
---

This page will be periodically updated with helpful resources for calculations and software design as they are made available.

- [**Uniswap v2 Visualization**](https://www.desmos.com/calculator/j8eppi5vvu)
- [**Uniswap v3 Visualization**](https://www.desmos.com/calculator/q2kxfue441)
- [**Uniswap v3 (Multiple Positions) Visualization**](https://www.desmos.com/calculator/oduetjzfp4)
- [**v2 / v3 Calculations**](https://docs.google.com/spreadsheets/d/1VH-lbF9RDUpVozGeA3BtWwypjW66MjcD1DnOYzcHmzk/edit#gid=0)
</file>

<file path="docs/concepts/uniswap-protocol.md">
---
id: uniswap-protocol
title: The Uniswap Protocol
sidebar_position: 2
---


## Introduction

The Uniswap protocol is a peer-to-peer[^1] system designed for exchanging cryptocurrencies [(ERC-20 Tokens)](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/) on the [Ethereum](https://ethereum.org/) blockchain. The protocol is implemented as a set of persistent, non-upgradable smart contracts; designed to prioritize censorship resistance, security, self-custody, and to function without any trusted intermediaries who may selectively restrict access.

There are currently four versions of the Uniswap protocol. [v1](/contracts/v1/overview) and [v2](/contracts/v2/overview) are open source and licensed under GPL. [v3](/contracts/v3/overview) introduced concentrated liquidity and is open source with slight modifications, which are viewable [here](https://github.com/Uniswap/uniswap-v3-core/blob/main/LICENSE). [v4](/contracts/v4/overview) introduces the singleton pool architecture and hooks system, enabling unprecedented protocol customization, and uses a dual license structure viewable [here](https://github.com/Uniswap/v4-core/tree/main/licenses). Each version of Uniswap, once deployed, will function in perpetuity, with 100% uptime, provided the continued existence of the Ethereum blockchain.

## How does the Uniswap protocol compare to a typical market?

To understand how the Uniswap protocol differs from a traditional exchange, it is helpful to first look at two subjects: how the Automated Market Maker design deviates from traditional central limit order book-based exchanges, and how permissionless systems depart from conventional permissioned systems.

### Order Book VS AMM

Most publicly accessible markets use a central limit [order book](https://www.investopedia.com/terms/o/order-book.asp) style of exchange, where buyers and sellers create orders organized by price level that are progressively filled as demand shifts. Anyone who has traded stocks through brokerage firms will be familiar with an order book system.

The Uniswap protocol takes a different approach, using an Automated Market Maker (AMM), sometimes referred to as a Constant Function Market Maker, in place of an order book. Through its evolution, the protocol has enhanced this model: [v3](/contracts/v3/overview) introduced concentrated liquidity for capital efficiency, and [v4](/contracts/v4/overview)'s singleton pool architecture and hooks system enable unprecedented customization of pool behavior while maintaining the core AMM principles.

At a very high level, an AMM replaces the buy and sell orders in an order book market with a liquidity pool of two assets, both valued relative to each other. As one asset is traded for the other, the relative prices of the two assets shift, and a new market rate for both is determined. In this dynamic, a buyer or seller trades directly with the pool, rather than with specific orders left by other parties. The advantages and disadvantages of Automated Market Makers versus their traditional order book counterparts are under active research by a growing number of parties. We have collected some notable examples on our [research page](./research.md).

### Permissionless Systems

The second departure from traditional markets is the permissionless and immutable design of the Uniswap protocol. These design decisions were inspired by Ethereum's core tenets, and our commitment to the ideals of permissionless access and immutability as indispensable components of a future in which anyone in the world can access financial services without fear of discrimination or counter-party risk.

Permissionless design means that the protocol's services are entirely open for public use, with no ability to selectively restrict who can or cannot use them. Anyone can swap, provide liquidity, or create new markets at will. This is a departure from traditional financial services, which typically restrict access based on geography, wealth status, and age.

The protocol is also immutable, in other words not upgradeable. No party is able to pause the contracts, reverse trade execution, or otherwise change the behavior of the protocol in any way. It is worth noting that Uniswap Governance has the right (but no obligation) to divert a percentage of swap fees on any pool to a specified address. However, this capability is known to all participants in advance, and to prevent abuse, the percentage is constrained between 10% and 25%.

## Where can I find more information

For research into the economics of AMMs, game theory, or optimization research, check out our [research](./research.md) page.

For features implemented in v3 that expand and refine the AMM design, see the [v3 Concepts](./protocol/concentrated-liquidity.md) page.

For the latest innovations in v4, including singleton pools and hooks, see the [v4 Concepts](./protocol/hooks.md) page.

[^1]: Ethereum protocols are sometimes referred to as peer-to-contract systems as well. These are similar to a peer-to-peer systems, but with immutable, persistent programs known as smart contracts taking the place of a peer.
</file>

<file path="docs/concepts/what-is-uniswap.md">
---
id: overview
title: Uniswap Overview
sidebar_position: 1
pagination_next: concepts/uniswap-protocol
---

## Protocol, Interface, Labs

To begin, we should make clear the distinctions between the different areas of "Uniswap", some of which may confuse new users.

- **[Uniswap Labs](https://x.com/Uniswap)**: The company which developed the Uniswap protocol, along with the web interface.
- **[Uniswap Foundation](https://www.uniswapfoundation.org/)**: A non-profit organization that supports the development of the Uniswap protocol and its DeFi ecosystem.
- **[Uniswap Protocol](https://github.com/Uniswap/contracts)**: A suite of persistent, non-upgradable smart contracts that together create an automated market maker, a protocol that facilitates peer-to-peer market making and swapping of ERC-20 tokens on the Ethereum blockchain.
- **[Uniswap Interface](https://app.uniswap.org/)**: A web interface that allows for easy interaction with the Uniswap protocol. The interface is only one of many ways one may interact with the Uniswap protocol.
- **[Uniswap Governance](https://gov.uniswap.org/)**: A governance system for governing the Uniswap Protocol, enabled by the UNI token.
</file>

<file path="docs/contracts/liquidity-launchpad/_category_.json">
{
  "label": "Liquidity Launchpad",
  "position": 7,
  "collapsed": true
}
</file>

<file path="docs/contracts/liquidity-launchpad/01-introduction.md">
---
id: Overview
title: Overview
sidebar_position: 1
---

# Introduction & Overview

## What is the Uniswap Liquidity Launchpad?

The Uniswap Liquidity Launchpad is a comprehensive framework for bootstrapping initial liquidity for Uniswap V4 pools through fair, transparent price discovery (see <a href='/whitepaper_cca.pdf' target='_blank' rel='noopener noreferrer'>whitepaper</a>). It combines three critical functions into a single, composable system:

1. **Price Discovery** - Run fair auctions using a novel Continuous Clearing Auction (CCA) mechanism to establish market price
2. **Liquidity Bootstrapping** - Automatically seed Uniswap V4 pools with auction proceeds at the discovered price
3. **Token Creation** (Optional) - Deploy new ERC-20 tokens with rich metadata and optional cross-chain capabilities

Unlike traditional approaches that rely on centralized market makers or expose participants to timing games and manipulation, the Uniswap Liquidity Launchpad provides a decentralized, mechanism-design-driven approach for establishing deep, sustainable liquidity from day one.


### Key Benefits

- **Fair Price Discovery** - Continuous clearing auctions eliminate timing games and establish credible market prices
- **Immediate Deep Liquidity** - Seamless transition from price discovery to active Uniswap V4 trading with substantial initial depth
- **Permissionless** - Anyone can bootstrap liquidity or participate in price discovery without gatekeepers
- **Transparent** - All parameters set upfront; real-time visibility into price discovery progress
- **Composable** - Modular architecture supports multiple auction formats and distribution strategies
- **Gas Efficient** - Optimized implementations using Permit2, multicall, and efficient data structures

## Core Components

The Uniswap Liquidity Launchpad framework is built on three coordinated components that work together to bootstrap liquidity:

1. **[Liquidity Launcher →](https://github.com/Uniswap/liquidity-launcher)** Central orchestration contract that coordinates distribution and liquidity deployment
2. **[Token Factory →](https://github.com/Uniswap/uerc20-factory)** (Optional) Creates new ERC-20 tokens with metadata, or integrates existing tokens
3. **Liquidity Strategies** - Modular contracts for different price discovery and liquidity mechanisms (prebuilt [LBP Strategy](https://github.com/Uniswap/liquidity-launcher) or [custom strategies](quickstarts/building.md))

Each component is designed to be composable and extensible, allowing you to customize your liquidity bootstrapping while maintaining security and fairness guarantees.

## High-Level Architecture

![Token Launcher Architecture](./images/TokenLauncherOverview.png)

### Typical Liquidity Bootstrapping Flow

The liquidity bootstrapping process follows a straightforward sequence from price discovery to active trading:

1. **Prepare Token** (Optional)

   Launch a new token using `LiquidityLauncher.createToken()` via the factory, which deploys a UERC20 or UERC20Superchain token and mints the initial supply to the launcher. Alternatively, use an existing token and approve the launcher to distribute it.

2. **Configure Liquidity Bootstrap**

   Set up your bootstrapping parameters:
   - **Auction parameters**: Supply release schedule, price floor, duration & timing, and graduation threshold
   - **Pool parameters**: Token split (max 50% to auction), fee tier & tick spacing, migration delay, and optional hooks

3. **Start Price Discovery**

   Call `LiquidityLauncher.distributeToken()` to allocate tokens to the LBP Strategy. This deploys a CCA auction with the allocated tokens, and price discovery begins as participants submit bids.

4. **Fair Price Discovery**

   As bids arrive, the auction continuously clears orders with automatic bid spreading, ensuring a uniform clearing price and real-time transparency for all participants. This establishes the fair market price for the token.

5. **Auction Completion**

   When the auction ends, the system checks if the graduation threshold was met. If graduated, the process proceeds to liquidity migration. If not, all bidders receive refunds.

6. **Liquidity Deployment**

   After the migration block delay, anyone can trigger `migrate()` to:
   - Initialize the Uniswap V4 pool at the discovered price
   - Deploy full-range liquidity using auction proceeds + reserve tokens
   - Deploy a one-sided position (if remaining tokens exist)
   - Mint the LP NFT to the position recipient

7. **Active Liquid Market**

   The pool is now live on Uniswap V4 with deep initial liquidity, making the token immediately tradable across the entire ecosystem with sustainable market depth.


## Next Steps

- Learn about the [Continous Clearing Auction](./05-auction-mechanism.md) mechanism
- Read the <a href='/whitepaper_cca.pdf' target='_blank' rel='noopener noreferrer'>whitepaper</a> to learn more about the mechanism
- Dive into the repos below to see the code and start building

## Smart Contracts

| Contract | Description | Source | Mainnet Address | Unichain |
|----------|-------------|--------|-----------------|----------|
| **LiquidityLauncher** | Central orchestration contract | [liquidity-launcher](https://github.com/Uniswap/liquidity-launcher) | [0x00000008412db3394C91A5CbD01635c6d140637C](https://etherscan.io/address/0x00000008412db3394C91A5CbD01635c6d140637C) | Coming soon |
| **UERC20Factory** | Standard ERC-20 token factory | [uerc20-factory](https://github.com/Uniswap/uerc20-factory) | [0x0cde87c11b959e5eb0924c1abf5250ee3f9bd1b5](https://etherscan.io/address/0x0cde87c11b959e5eb0924c1abf5250ee3f9bd1b5) | Coming soon |
| **LBPStrategyBasicFactory** | LBP strategy factory | [liquidity-launcher](https://github.com/Uniswap/liquidity-launcher) | [0x00000010F37b6524617b17e66796058412bbC487](https://etherscan.io/address/0x00000010F37b6524617b17e66796058412bbC487) | Coming soon |
| **ContinuousClearingAuction** | Continuous clearing auction factory | [continuous-clearing-auction](https://github.com/Uniswap/continuous-clearing-auction) |[0x0000ccaDF55C911a2FbC0BB9d2942Aa77c6FAa1D](https://etherscan.io/address/0x0000ccaDF55C911a2FbC0BB9d2942Aa77c6FAa1D) | Coming soon |
| **Permit2** | Token approval manager | [Uniswap](https://github.com/Uniswap/permit2) | [0x000000000022D473030F116dDEE9F6B43aC78BA3](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) | [0x000000000022D473030F116dDEE9F6B43aC78BA3](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |
</file>

<file path="docs/contracts/liquidity-launchpad/05-auction-mechanism.md">
---
id: CCA
title: Continuous Clearing Auction
sidebar_position: 2
---

# Continuous Clearing Auction (CCA)

**Repository:** [github.com/Uniswap/continuous-clearing-auction](https://github.com/Uniswap/continuous-clearing-auction)

The Continuous Clearing Auction (CCA) is a novel auction mechanism that generalizes the uniform-price auction into continuous time. It provides fair price discovery for bootstrapping initial liquidity while eliminating timing games and encouraging early participation (see [whitepaper](/whitepaper_cca.pdf)).

## Overview

Bootstrapping initial liquidity for new tokens is challenging. Traditional approaches suffer from various weaknesses:
- **Fixed-price sales** lead to mispricing and priority races, creating thin or unstable liquidity
- **Dutch auctions** create timing games and favor professionals over genuine participants
- **One-shot auctions** enable demand reduction and last-minute sniping
- **Bonding curves** are path-dependent and vulnerable to manipulation
- **Centralized market makers** require trust and extract significant value

CCA addresses these issues through a unique approach: **automatic bid spreading over time** combined with **continuous price discovery**.

### Key Innovation: Bid Spreading

Every bid submitted to a CCA is automatically divided across all remaining auction intervals according to the token release schedule. This means:

- No participant can concentrate demand at a single moment
- Timing of bid submission matters less than valuation
- Early bidders naturally gain more exposure to lower prices
- Sniping and last-minute gaming become ineffective

### How It Works

The CCA process for liquidity bootstrapping follows these steps:

1. **Configure Liquidity Bootstrap**

   The project team sets up the price discovery parameters:
   - Supply release schedule Q(t) defining how tokens are released over time
   - Price floor to protect against selling below minimum valuation
   - Duration specified by start and end blocks
   - Graduation threshold that must be met for successful liquidity deployment

2. **Price Discovery Through Bidding**

   Participants establish market price by:
   - Specifying the maximum price they're willing to pay
   - Committing a fixed amount of currency to spend (exact-in bids)
   - Their bid automatically spreads over all remaining auction intervals according to the release schedule

3. **Continuous Price Clearing**

   As the auction progresses:
   - Each block with new bids creates a checkpoint
   - The clearing price is calculated from aggregate demand versus available supply
   - The price can only increase or stay the same (never decrease)
   - All participants active in that interval pay the same uniform clearing price

4. **Auction Completion & Price Established**

   When price discovery concludes:
   - The system checks if the graduation threshold was met
   - If graduated: the final clearing price becomes the pool initialization price
   - If not graduated: all bidders receive full refunds and no pool is created

5. **Liquidity Deployment**

   After the auction succeeds:
   - Bidders exit to calculate their final fills and claim tokens
   - The raised currency + remaining tokens are deployed as liquidity in a Uniswap V4 pool
   - The pool initializes at the discovered clearing price
   - Deep, sustainable liquidity is established from day one

### Auction Configuration

The auction and its supply curve are configured through the AuctionFactory which deploys individual Auction contracts with configurable parameters.

```solidity
interface IAuctionFactory {
    function initializeDistribution(
        address token,
        uint256 amount,
        bytes calldata configData
    ) external returns (address);
}

/// @notice Parameters for the auction
/// @dev token and totalSupply are passed as constructor arguments
struct AuctionParameters {
    address currency; // token to raise funds in. Use address(0) for ETH
    address tokensRecipient; // address to receive leftover tokens
    address fundsRecipient; // address to receive all raised funds
    uint64 startBlock; // Block which the first step starts
    uint64 endBlock; // When the auction finishes
    uint64 claimBlock; // Block when the auction can claimed
    uint256 tickSpacing; // Fixed granularity for prices
    address validationHook; // Optional hook called before a bid
    uint256 floorPrice; // Starting floor price for the auction
    uint128 requiredCurrencyRaised; // Amount of currency required to be raised for the auction to graduate
    bytes auctionStepsData; // Packed bytes describing token issuance schedule
}

constructor(
    address _token,
    uint128 _totalSupply,
    AuctionParameters memory _parameters
) {}
```

The factory decodes `configData` into `AuctionParameters` and deploys the Auction contract via CREATE2.

## Warnings

It is imperative that bidders and users of the Auction carefully validate the parameters of the auction before participating. An auction can be configured to have an excessively high floor price which would result in a loss of funds.

Auction launchers should be aware of the following limitations regarding total supply and maximum bid prices:

- The maximum total supply that can be sold in the auction is 1e30 wei of `token`. For a token with 18 decimals, this is 1 trillion tokens.
- The auction also ensures that the total currency raised does not exceed the maximum allowable liquidity for a Uniswap v4 liquidity position. The lowest bound for this is 2^107 wei (given the smallest possible tick spacing of 1).

Given a total supply of:

- 1 trillion 18 decimal tokens (1e30), the maximum bid price is 2^110. The max ratio of currency to token is 2^(110-96) = 2^14 = 16384.
- 1 billion 6 decimal tokens (1e15), the maximum bid price is 2^160. The max ratio of currency to token is 2^(160-96) = 2^64 = 18446744073709551616.

We strongly recommend that the `currency` is chosen to be more valuable than `token`, and that the total supply is not excessively large.

## Types

### Q96 Fixed-Point Math

The auction uses Q96 fixed-point arithmetic for price and demand representation:

```solidity
library FixedPoint96 {
    uint8 internal constant RESOLUTION = 96;
    uint256 internal constant Q96 = 0x1000000000000000000000000; // 2^96
}
```

- **Price**: Stored as as a Q96 fixed point number to allow for fractional prices
- **Demand**: Currency amounts are scaled by Q96 to prevent significant precision loss in calculations

#### MPS terms (Milli-Basis Points)

**MPS = 1e7** (10 million), each representing one thousandth of a basis point:

```solidity
library ConstantsLib {
    uint24 public constant MPS = 1e7; // 10,000,000
}
```

#### ValueX7

A custom uint256 type that represents values which have either been implicitly or explicitly multiplied by 1e7 (ConstantsLib.MPS). These values will be suffixed in the code with `_X7` for clarity.

```solidity
/// @notice A ValueX7 is a uint256 value that has been multiplied by MPS
/// @dev X7 values are used for supply values to avoid intermediate division by MPS
type ValueX7 is uint256;
```

### Auction steps (supply issuance schedule)

The auction steps define the supply issuance schedule. The auction steps are packed into a bytes array and passed to the constructor along with the other parameters. Each step is a packed `uint64` with the first 24 bits being the per-block issuance rate in MPS (milli-bips), and the last 40 bits being the number of blocks to sell over.

```solidity
/// AuctionStepLib.sol

function parse(bytes8 data) internal pure returns (uint24 mps, uint40 blockDelta) {
    mps = uint24(bytes3(data));
    blockDelta = uint40(uint64(data));
}
```

For example, to sell 1 basis point of supply per block for 100 blocks, then 2 basis points for the next 100 blocks, the packed `uint64` would be:

```solidity
uint24 mps = 1000; // 1000 mps = 1 basis point
uint40 blockDelta = 100; // 100 blocks
bytes8 packed1 = uint64(mps) | (uint64(blockDelta) << 24);

mps = 2000; // 2000 mps = 2 basis points
blockDelta = 100; // 100 blocks
bytes8 packed2 = uint64(mps) | (uint64(blockDelta) << 24);

bytes packed = abi.encodePacked(packed1, packed2);
```

The data is deployed to an external SSTORE2 contract for cheaper reads over the lifetime of the auction.

### Validation Hooks

Optional validation hooks allow custom logic to be executed before bids are accepted, enabling features like allowlists, rate limiting, or complex validation rules.

```solidity
interface IValidationHook {
    function validate(
        uint256 maxPrice,
        uint128 amount,
        address owner,
        address sender,
        bytes calldata hookData
    ) external;
}
```

Any validation hook set in the auction parameters is called during `_submitBid()`. It MUST revert to prevent a bit from being submitted in the auction.

## Contract Entrypoints

### submitBid()

Users can submit bids specifying the currency amount they want to spend. The bid id is returned to the user and can be used to claim tokens or exit the bid. The `prevTickPrice` parameter is used to determine the location of the tick to insert the bid into. The hint must be the price of the tick immediately preceding it in the linked list of prices.

- For convenience, if the `prevTickPrice` is not provided, the contract will iterate through every tick starting from the floor price until it reaches the correct position.
- This will be gas intensive and should not be used unless the caller is sure that `maxPrice` is already initialized, as it will not perform the search.

A bid's `maxPrice` is the maximum price the bidder is willing to pay.
The `amount` is the amount of currency the user is bidding, and `owner` is the address of the user who will receive any purchased tokens or refunded currency.

The Auction enforces the following rules on bid prices:

- Bids must be strictly above the current clearing price
- The maximum bid price must be below the computed MAX_BID_PRICE based on the total supply of the auction.

```solidity
interface IContinuousClearingAuction {
    function submitBid(
        uint256 maxPrice,
        uint128 amount,
        address owner,
        uint256 prevTickPrice,
        bytes calldata hookData
    ) external payable returns (uint256 bidId);

    /// @notice Optional function if the maxPrice is already initialized or if the caller doesn't care about gas efficiency.
    function submitBid(
        uint256 maxPrice,
        uint128 amount,
        address owner,
        bytes calldata hookData
    ) external payable returns (uint256 bidId);
}

event BidSubmitted(uint256 indexed id, address indexed owner, uint256 price, uint256 amount);
event TickInitialized(uint256 price);
```

### checkpoint()

The auction is checkpointed once every block with a new bid. The checkpoint is a snapshot of the auction state up to (NOT including) that block. Checkpoints ultimately determine the token allocations for each bid.

```solidity
interface IContinuousClearingAuction {
    function checkpoint() external returns (Checkpoint memory _checkpoint);
}

event CheckpointUpdated(uint256 indexed blockNumber, uint256 clearingPrice, uint24 cumulativeMps);
```

### exitBid()

Users can use `exitBid` to exit their bid after the auction has ended, or to receive a refund of their currency if the auction has not graduated. This function requires that the bid has a max price above the final clearing price of the auction. This means that the bid was never outbid or partially filled.

```solidity
interface IContinuousClearingAuction {
    /// @notice Exit a bid where max price is above final clearing price
    function exitBid(uint256 bidId) external;
}

event BidExited(uint256 indexed bidId, address indexed owner, uint256 tokensFilled, uint256 currencyRefunded);
```

### exitPartiallyFilledBid()

Exiting partially filled bids is more complex than fully filled ones. The `exitPartiallyFilledBid` function requires the user to provide two checkpoint hints (`lastFullyFilledCheckpointBlock`, `outbidBlock`). These are used to determine the checkpoints immediately before and after the period of time in which the bid was partially filled (auction.clearingPrice == bid.maxPrice).

- `lastFullyFilledCheckpointBlock`: Last checkpoint where clearing price is strictly < bid.maxPrice
- `outbidBlock`: First checkpoint where clearing price is strictly > bid.maxPrice, or 0 if the final clearing price is equal to the bid's max price at the end of the auction, since it was never outbid.

Checkpoints also store a cumulative value (`currencyRaisedAtClearingPriceQ96_X7`) which tracks the amount of currency raised from bids at the clearing price. This is reset every time the clearing price changes, but this is used to determine the user's pro-rata share of the tokens sold at the clearing price.

### Decision tree for determining when to use `exitBid` vs `exitPartiallyFilledBid`:

![Exit Bid Diagram](./images/exitBidDiagram.png)

## View functions / getters

### isGraduated()

Auctions are graduated if the currency raised meets or exceeds the required threshold set by the auction launcher on deployment.

A core invariant of the auction is that no bids can be exited before the auction has graduated.

```solidity
interface IContinuousClearingAuction {
    /// @notice Whether the auction has graduated (currency raised >= required)
    function isGraduated() external view returns (bool);
}
```

### sweepCurrency() and sweepUnsoldTokens()

After an auction ends, raised currency and unsold tokens can be withdrawn to the designated recipients in the auction deployment parameters.

```solidity
interface IContinuousClearingAuction {
    /// @notice Withdraw all raised currency (only for graduated auctions)
    function sweepCurrency() external;

    /// @notice Withdraw any unsold tokens
    function sweepUnsoldTokens() external;
}

event CurrencySwept(address indexed fundsRecipient, uint256 currencyAmount);
event TokensSwept(address indexed tokensRecipient, uint256 tokensAmount);
```

Note:

- `sweepCurrency()` is only callable by anyone after the auction ends, and only for graduated auctions
- `sweepUnsoldTokens()` is callable by anyone after the auction ends and will sweep different amounts depending on graduation.
- For graduated auctions: sweeps all tokens that were not sold per the supply issuance schedule
- For non-graduated auctions: sweeps total supply of tokens

### Warning

Do NOT send more tokens than intended in `totalSupply` to the auction. They will not be recoverable.

### claimTokens()

Users can claim purchased tokens after the auction's claim block. The bid must be exited before claiming tokens, and the auction must have graduated.

```solidity
interface IContinuousClearingAuction {
    function claimTokens(uint256 bidId) external;
}

event TokensClaimed(uint256 indexed bidId, address indexed owner, uint256 tokensFilled);
```

Anyone can call this function for any valid bid id.

## Deployment Addresses

### ContinuousClearingAuctionFactory

| Network | Address | Commit Hash | Version |
|---------|---------|------------|---------|
| Mainnet | 0x0000ccaDF55C911a2FbC0BB9d2942Aa77c6FAa1D | 154fd189022858707837112943c09346869c964f | v1.0.0-candidate |
| Sepolia | 0x0000ccaDF55C911a2FbC0BB9d2942Aa77c6FAa1D | 154fd189022858707837112943c09346869c964f | v1.0.0-candidate |
</file>

<file path="docs/contracts/permit2/reference/_category_.json">
{
  "label": "Technical Reference",
  "position": 2,
  "collapsed": false
}
</file>

<file path="docs/contracts/permit2/reference/allowance-transfer.md">
---
id: allowance-transfer
title: AllowanceTransfer
sidebar_position: 2
---

> [**Source Code**](https://github.com/Uniswap/permit2/blob/main/src/AllowanceTransfer.sol)

## Overview

The main entry points on this contract are:

- `approve`
    - Use approve when you do not want to set token permissions through signature validation.
- `permit`
    - Use permit when you do want to set token permissions through signature validation.
- `transferFrom`
    - Use transferFrom when you want to transfer a token and have the necessary permissions to do so.

## Functions

### `approve`

**Function Signature**

```solidity
function approve(address token, address spender, uint160 amount, uint48 expiration) external
```

**Parameters**

- token - the token address to approve
- spender - the spender address to approve
- amount - the approved amount of the token, `type(uint160).max` is treated as an unlimited allowance
- expiration - the timestamp at which the approval is no longer valid, passing in `0` will expire the permissions at `block.timestamp`

### Single `permit`

**Function Signature**

```solidity
function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;
```

**Parameters**

- owner - the address of the token’s owner
- permitSingle - constructed with the following:

```solidity
struct PermitSingle {
        // the permit data for a single token allowance
        PermitDetails details;
        // address permissioned on the allowed tokens
        address spender;
        // deadline on the permit signature
        uint256 sigDeadline;
    }

struct PermitDetails {
        // ERC20 token address
        address token;
        // the maximum amount allowed to spend
        uint160 amount;
        // timestamp at which a spender's token allowances become invalid
        uint48 expiration;
        // an incrementing value indexed per owner,token,and spender for each signature
        uint48 nonce;
    }
```

- signature - the signature over the permit data. Supports EOA signatures, compact signatures defined by [EIP-2098](https://eips.ethereum.org/EIPS/eip-2098), and contract signatures defined by [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271)

### Batched `permit`

**Function Signature**

```solidity
function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;
```

**Parameters**

- owner - the address of the token’s owner
- permitBatch - constructed with the following:

```solidity
struct PermitBatch {
        // the permit data for multiple token allowances
        PermitDetails[] details;
        // address permissioned on the allowed tokens
        address spender;
        // deadline on the permit signature
        uint256 sigDeadline;
    }
struct PermitDetails {
        // ERC20 token address
        address token;
        // the maximum amount allowed to spend
        uint160 amount;
        // timestamp at which a spender's token allowances become invalid
        uint48 expiration;
        // an incrementing value indexed per owner,token,and spender for each signature
        uint48 nonce;
    }
```

- signature - the signature over the permit data. Supports EOA signatures, compact signatures defined by [EIP-2098](https://eips.ethereum.org/EIPS/eip-2098), and contract signatures defined by [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271)

### Single `transferFrom`

**Function Signature**

```solidity
function transferFrom(address from, address to, uint160 amount, address token) external;
```

**Parameters**

- from - the address to transfer the token from
- to -  the address of the recipient
- amount - the amount of the token to transfer, the maximum amount is `type(uint160).max`
- token - the address of the token to be transferred

### Batched `transferFrom`

**Function Signature**

```solidity
function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;
```

**Parameters**

- transferDetails - constructed with the following

```solidity
struct AllowanceTransferDetails {
        // the owner of the token
        address from;
        // the recipient of the token
        address to;
        // the amount of the token
        uint160 amount;
        // the token to be transferred
        address token;
    }
```

## Nonce Schema

The nonces used to protect against replay attacks of signatures are similar to standard incrementing nonces. However, we pack nonces with an allowed amount, and an allowed duration. This means that nonces are incremented *per owner*, *per token*, and *per spender.* Which further implies that you could sign two different permits at the same time with the same nonces and they *won’t* cancel each other out so long as the token or spender differ.

The mapping nonces are packed in is defined as follows:

```solidity
mapping(address => mapping(address => mapping(address => PackedAllowance))) public allowance;
```

and indexed as follows:

```solidity
PackedAllowance allowanceInformation = allowance[ownerAddress][tokenAddress][spenderAddress];
uint48 nonce = allowanceInformation.nonce;
```

## Security Considerations

Similar to the security considerations outlined in SignatureTransfer, integrating contracts need to perform valid safety checks on the caller and pass in correct addresses for the `from` argument in any transfer calls.

All amounts on the `AllowanceTransfer` contract are of type `uint160` so make sure integrating contracts safely downcast if they have to. See how Permit2Lib downcasts safely.
</file>

<file path="docs/contracts/permit2/reference/signature-transfer.md">
---
id: signature-transfer
title: SignatureTransfer
sidebar_position: 1
---

> [**Source Code**](https://github.com/Uniswap/permit2/blob/main/src/SignatureTransfer.sol)

## Overview

The main entry points on this contract are:

- `permitTransferFrom`
    - Use permitTransferFrom when you want to transfer a token from an owner through signature validation.
- `permitWitnessTransferFrom`
    - Use permitWitnessTransferFrom when you want to transfer a token from an owner through signature validation, but you would also like to validate other data. Any other data you wish to be validated can be passed through with the `witness` param.

Each of these functions is overloaded with a batched version that allows users to transfer multiple tokens with 1 transaction.

## Functions

### Single `permitTransferFrom`

Use the `permitTransferFrom` to transfer just one token.

**Function signature**

```solidity
function permitTransferFrom(
        PermitTransferFrom memory permit,
        SignatureTransferDetails calldata transferDetails,
        address owner,
        bytes calldata signature
    ) external
```

**Parameters**

- permit - Construct `PermitTransferFrom` struct with the following:

```solidity
struct PermitTransferFrom {
        TokenPermissions permitted;
        // a unique value for every token owner's signature to prevent signature replays
        uint256 nonce;
        // deadline on the permit signature
        uint256 deadline;
    }

struct TokenPermissions {
        // ERC20 token address
        address token;
        // the maximum amount that can be spent
        uint256 amount;
    }
```

- transferDetails - information about recipient and amount

```solidity
struct SignatureTransferDetails {
        // recipient address
        address to;
        // spender requested amount
        uint256 requestedAmount;
    }
```

- owner - the signer of the permit message and owner of the tokens
- signature - the signature over the permit data. Supports EOA signatures, compact signatures defined by [EIP-2098](https://eips.ethereum.org/EIPS/eip-2098), and contract signatures defined by [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271)

### Batched `permitTransferFrom`

Use `permitTransferFrom` with the batched parameters when you want to transfer multiple tokens from an owner.

**Function Signature**

```solidity
function permitTransferFrom(
        PermitBatchTransferFrom memory permit,
        SignatureTransferDetails[] calldata transferDetails,
        address owner,
        bytes calldata signature
    ) external
```

**Parameters**

- permit - Construct `PermitBatchTransferFrom` with the following:

```solidity
struct PermitBatchTransferFrom {
        // the tokens and corresponding amounts permitted for a transfer
        TokenPermissions[] permitted;
        // a unique value for every token owner's signature to prevent signature replays
        uint256 nonce;
        // deadline on the permit signature
        uint256 deadline;
    }

struct TokenPermissions {
        // ERC20 token address
        address token;
        // the maximum amount that can be spent
        uint256 amount;
    }
```

- transferDetails - parameterized by the spender with information about the token transfer.
    - The length of the `SignatureTransferDetails` array must equal the length of the `TokenPermissions` array passed in with `PermitBatchTransferFrom` struct. The token to be transferred specified in the `TokenPermissions` array should match the index of the `SignatureTransferDetails` array.
    - Note that if a spender is permitted to a token but does not need to transfer that token, they can specify that the `requestedAmount` is 0 so that the transfer is skipped.
- owner - the signer of the permit message and owner of the tokens

```solidity
struct SignatureTransferDetails {
        // recipient address
        address to;
        // spender requested amount
        uint256 requestedAmount;
    }
```

- signature - the signature over the permit data. Supports EOA signatures, compact signatures defined by [EIP-2098](https://eips.ethereum.org/EIPS/eip-2098), and contract signatures defined by [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271)

### Single `permitWitnessTransferFrom`

**Function Signature**

```solidity
function permitWitnessTransferFrom(
        PermitTransferFrom memory permit,
        SignatureTransferDetails calldata transferDetails,
        address owner,
        bytes32 witness,
        string calldata witnessTypeString,
        bytes calldata signature
    ) external
```

**Parameters**

- permit - constructed with the same type as defined above in the single permitTransferFrom case
- transferDetails constructed with same type as defined above in the single permitTransferFrom case
- owner - the signer of the permit message and owner of the tokens
- witness - arbitrary data passed through that was signed by the user. Is used to reconstruct the signature. Pass through this data if you want the permit signature recovery also to validate other data.
- witnessTypeString - a string that defines the typed data that the witness was hashed from. It must also include the `TokenPermissions` struct and comply with [EIP-712](https://eips.ethereum.org/EIPS/eip-712) struct ordering. See an example below.
- signature - the signature over the permit data. Supports EOA signatures, compact signatures defined by [EIP-2098](https://eips.ethereum.org/EIPS/eip-2098), and contract signatures defined by [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271)

### Batch `permitWitnessTransferFrom`

**Function Signature**

```solidity
function permitWitnessTransferFrom(
        PermitBatchTransferFrom memory permit,
        SignatureTransferDetails[] calldata transferDetails,
        address owner,
        bytes32 witness,
        string calldata witnessTypeString,
        bytes calldata signature
    ) external
```

**Parameters**

- permit - constructed with the same type in the batched case of `permitTransferFrom`
- transferDetails - constructed with the same type in the batched case of `permitTransferFrom`
- owner - the signer of the permit message and owner of the tokens
- witness - arbitrary data passed through that was signed by the user. Is used to reconstruct the signature. Pass through this data if you want the permit signature recovery to also validate other data.
- witnessTypeString - a string that defines the typed data that the witness was hashed from. It must also include the `TokenPermissions` struct and comply with [EIP-712](https://eips.ethereum.org/EIPS/eip-712) struct ordering. See an example below.
- signature - the signature over the permit data. Supports EOA signatures, compact signatures defined by [EIP-2098](https://eips.ethereum.org/EIPS/eip-2098), and contract signatures defined by [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271)

**Example `permitWitnessTransferFrom` parameters**

If an integrating contract would also like the signer to verify information about a trade, an integrating contract may ask the signer to also sign an `ExampleTrade` object that we define below:

```solidity
struct ExampleTrade {
	address exampleTokenAddress;
	uint256 exampleMinimumAmountOut;
}
```

Following EIP-712, the typehash for the data would be defined by:

```solidity
bytes32 _EXAMPLE_TRADE_TYPEHASH = keccak256('ExampleTrade(address exampleTokenAddress,uint256 exampleMinimumAmountOut)');
```

The `witness` that should be passed along with the permit message should be:

```solidity
 bytes32 witness = keccak256(
            abi.encode(_EXAMPLE_TRADE_TYPEHASH, exampleTrade.exampleTokenAddress, exampleTrade.exampleMinimumAmountOut));
```

And the `witnessTypeString` to be passed in should be:

```solidity
string constant witnessTypeString = "ExampleTrade witness)ExampleTrade(address exampleTokenAddress,uint256 exampleMinimumAmountOut)TokenPermissions(address token,uint256 amount)"
```

It’s important to note that when hashing multiple typed structs, the ordering of the structs in the type string matters. Referencing EIP-721:

> If the struct type references other struct types (and these in turn reference even more struct types), then the set of referenced struct types is collected, sorted by name and appended to the encoding. An example encoding is `Transaction(Person from,Person to,Asset tx)Asset(address token,uint256 amount)Person(address wallet,string name)`
> 

## Nonce Schema

Instead of using incrementing nonces, we introduce non-monotonic, or unordered nonces with a `nonceBitmap`. 

The `nonceBitmap` maps an owner's address to a uint248 value, which we will call `wordPos` which is the index of the desired bitmap. There are 2<sup>248</sup> possible indices thus 2<sup>248</sup> possible bitmaps where each bitmap holds 256 bits. A bit must be flipped on to prevent replays of users’ signatures. Bits that are dirtied may not be used again.

```solidity
// nonceBitmap[ownerAddress][wordPosition] retrieves a uint256 bitmap
mapping(address => mapping(uint248 => uint256)) public nonceBitmap;
```

Users will sign a `uint256 nonce` value where the first 248 bits correspond to the word position of the bitmap to dirty and the last 8 bits correspond to the actual bit position being flipped on.

```solidity
uint248 wordPos = uint248(nonce >> 8);
uint8 bitPos = uint8(nonce);
```

```solidity
uint256 bitmap = nonceBitmap[ownerAddress][wordPos] ^ (1 << bitPos)
```

## Security Considerations

An integrating contract must check that tokens are released by a triggering call from the signer, or that the signer meant for their signature to be released by someone else.

<aside>
💡 Consider this scenario:

A signer called Bob signs a permit to transfer 100 USDC with a router contract as the permissioned spender. The router contract never checks who the caller is but spends any permit messages on the Permit2 contract. An attacker Eve can steal Bob’s signature, pass it through to the router with herself as the recipient, and transfer Bob’s tokens to herself.

</aside>

Universal Router protects against this by checking that the `msg.sender` from inside the routing contract is the supposed spender by passing `msg.sender` in as the `owner`  param in any permit calls and by passing in `msg.sender` as the `from` param in any transfer calls.
</file>

<file path="docs/contracts/permit2/_category_.json">
{
  "label": "Permit2",
  "position": 6,
  "collapsed": true
}
</file>

<file path="docs/contracts/permit2/overview.md">
---
id: overview
title: Overview
sidebar_position: 1
---

[`Permit2`](https://github.com/Uniswap/permit2) is a unification of 2 contracts, [`SignatureTransfer`](./reference/signature-transfer.md) and [`AllowanceTransfer`](./reference/allowance-transfer.md). The `SignatureTransfer` contract handles all signature-based transfers, meaning that an allowance on the token is bypassed and permissions to the spender only last for the duration of the transaction that the one-time signature is spent. The `AllowanceTransfer` contract handles setting allowances on tokens, giving permissions to spenders on a specified amount for a specified duration of time. Any transfers that then happen through the `AllowanceTransfer` contract will only succeed if the proper permissions have been set.

## Resources

A great [explanation](https://github.com/dragonfly-xyz/useful-solidity-patterns/tree/main/patterns/permit2) of the Permit2 contract and example usage.

## Approving Permit2

Before integrating contracts can request users’ tokens through Permit2, users must approve the Permit2 contract through the specific token contract by calling something like:

```solidity
USDC.approve(permit2Address, totalAmount);
```

To get the maximal benefits from Permit2, users should do a max approval on the contract where: 
```solidity
totalAmount = type(uint256).max;
```
</file>

<file path="docs/contracts/protocol-fee/guides/_category_.json">
{
  "label": "Guides",
  "position": 8,
  "collapsed": true
}
</file>

<file path="docs/contracts/protocol-fee/guides/best-practices.mdx">
# Best Practices

Below, please find a list of best practices when interacting with the Uniswap Protocol Fee system.

## Calldata Nonce

Recall [`Firepit.release()`](../technical-reference/IReleaser#release) requires a `_nonce` parameter that matches the contract storage [`Firepit.nonce()`](../technical-reference/INonce#nonce).

The nonce mechanism prevents front-running attacks, where a successful front-run would cause the victim
to burn a substantial amount of UNI in exchange for little to no assets. The nonce mechanism ensures sequencing, so **if two competing transactions
use the same nonce, only one will succeed**

:::danger
Integrating *contracts* should **NEVER** read the `nonce` at the time of the transaction

```solidity
contract Vulnerable {
    IFirepit public firepit;

    function vulnerable(Currency[] memory assets) external {
        // ❌ THIS IS VULNERABLE TO FRONT RUNNING ❌ //
        uint256 nonce = firepit.nonce();
        firepit.release(nonce, assets, address(this));
    }
}
```
:::

:::tip
```solidity
contract SafeRelease {
    IFirepit public firepit;

    // ✅ THIS IS SAFE FROM FRONT RUNNING ✅ //
    function safeRelease(uint256 _nonce, Currency[] memory assets) external {
        firepit.release(_nonce, assets, address(this));
    }
}
```
In the safe pattern, the caller is responsible for reading the `Firepit.nonce()` offchain, assocating it with releasable assets, and passing it as a **calldata** parameter
:::

## Collect Uniswap v3 Fees

For further reading, please see [Read Asset Balance](./read-asset-balance)

In the Uniswap Protocol Fee system, Uniswap v3 fees *must be collected* to the `AssetSink` before they are eligible for release.

:::tip
We recommend that integrators check and collect Uniswap v3 fees before calling `Firepit.release()`, to ensure the maximum assets are released.

Collection is available via
[IV3FeeController.collect()](../technical-reference/IV3FeeController#collect)

```solidity
IV3FeeController v3FeeController;

function collectAndRelease(
    IV3FeeController.CollectParams memory collectParams,
    uint256 _nonce,
    Currency[] memory assets,
    address recipient
) external {
    v3FeeController.collect(collectParams);
    firepit.release(_nonce, assets, recipient);
}
```
:::

## UNI Approvals

The Uniswap Protocol Fee system allows for an *updatable* [`Firepit.threshold()`](../technical-reference/IResourceManager#threshold)

While the system does not intend to maliciously front-run `.release()` calls, max-approving UNI allowances may lead to an unexpectedly higher burn of UNI.
The risk only appears if and only if the `thresholdSetter` increases the `threshold` amount while there is a pending `.release()` call.

Integrators can avoid this risk by:

* only holding an amount of UNI they are willing to burn
* approving only the amount of UNI they intend to burn
* perform balance checks before and after calling `.release()`, comparing the burned amount against a calldata value

## Payable Contracts

Because the Uniswap Protocol Fee system can release native tokens (Ether), recipients of the tokens should be `payable`

## Pricing Uniswap v2 ERC-20 Tokens

For further reading, please see [Read Asset Balance](./read-asset-balance#uniswap-v2-pool-protocol-fees)

Uniswap v2 Protocol Fees are automatically pushed to the `AssetSink` contract, but are represented as ERC-20 LP tokens. These ERC-20 LP tokens represent a combination of `token0` and `token1`

To compute the underlying amount of `token0` and `token1` represented by the LP tokens, integrators can use the following formula:

```solidity
IUniswapV2Pair pair;

function getUnderlyingAmounts(uint256 lpTokens) external view returns (uint256 amount0, uint256 amount1) {
    uint256 totalSupply = pair.totalSupply();
    uint256 poolBalance0 = IERC20(pair.token0()).balanceOf(address(pair));
    uint256 poolBalance1 = IERC20(pair.token1()).balanceOf(address(pair));

    amount0 = (lpTokens * poolBalance0) / totalSupply;
    amount1 = (lpTokens * poolBalance1) / totalSupply;
}
```

:::note
Integrators should perform additional validation, i.e. pool price and slippage checks as to not
misrepresent the LP token's underlying token amounts
:::
</file>

<file path="docs/contracts/protocol-fee/guides/getting-started.mdx">
---
title: Get Started
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Get Started

In the current version of the Uniswap Protocol Fee system, searchers can *permissionlessly* capture value from the system
by receiving assets valued greater than the UNI tokens provided to the system.

The simplest way to interact with the system is calling [`Firepit.release()`](../technical-reference/IReleaser#release) from a wallet

:::note
It is possible to interact with the `Firepit` contract via a custom smart contract to enable:
* slippage / balance checks
* Uniswap v3 Fee [collection](./best-practices.mdx#collect-uniswap-v3-fees)
* Uniswap v2 LP Token [redemptions](./read-asset-balance.mdx#uniswap-v2-pool-protocol-fees)
* UNI token flash loans
:::

## Acquire a sufficient amount of UNI
The `Firepit` contract requires integrators to hold a minimum amount of UNI to call `release()`.
Participants can view the `threshold` by calling [`Firepit.threshold()`](../technical-reference/IResourceManager#threshold)

<Tabs>
<TabItem value="solidity" label="solidity">
```solidity
uint256 threshold = IFirepit(address(0x0000..TBD)).threshold();
```
</TabItem>
<TabItem value="bash" label="cast">
```bash
cast call 0x0000..TBD "threshold()(uint256)" --rpc-url <RPC_URL>
```
</TabItem>
</Tabs>

## Approve the Firepit to spend UNI
Because the `Firepit` contract transfers UNI to `address(0xdead)`, integrating addresses **must first approve** the contract to spend their UNI

:::warning
Integrators should assess the risks of max approving the `Firepit` contract
:::

<Tabs>
<TabItem value="solidity" label="solidity">
```solidity
IERC20(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984).approve(
    0x0000..TBD,
    type(uint256).max
);
```
</TabItem>
<TabItem value="bash" label="cast">
```bash
cast send 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984 \
    "approve(address,uint256)(bool)" \
    --rpc-url <RPC_URL> \
    0x0000..TBD \
    115792089237316195423570985008687907853269984665640564039457584007913129639935
```
</TabItem>
</Tabs>

## Read the Nonce

The `Firepit` contract uses a `nonce` as a safety mechanism to avoid malicious front-running. The value is provided to `release(...)` must be equal
to the value in contract storage

<Tabs>
<TabItem value="solidity" label="solidity">
```solidity [solidity]
uint256 nonce = IFirepit(address(0x0000..TBD)).nonce();
```
</TabItem>
<TabItem value="bash" label="cast">
```bash
cast call 0x0000..TBD "nonce()(uint256)" --rpc-url <RPC_URL>
```
</TabItem>
</Tabs>

## Call `Firepit.release()`

Once the value of the assets exceeds the value of the UNI tokens, integrators should call [`Firepit.release()`](../technical-reference/IReleaser#release)

<Tabs>
<TabItem value="solidity" label="solidity">
```solidity
uint256 _nonce = IFirepit(address(0x0000..TBD)).nonce();

Currency[] memory _assets = new Currency[](3);
_assets[0] = Currency.wrap(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)); // USDC
_assets[1] = Currency.wrap(address(0xdAC17F958D2ee523a2206206994597C13D831ec7)); // USDT
_assets[2] = Currency.wrap(address(0x0000000000000000000000000000000000000000)); // ETH

IFirepit(address(0x0000..TBD)).release(_nonce, _assets, 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045);
```
</TabItem>

<TabItem value="bash" label="cast">
```bash
cast send 0x0000..TBD "release(uint256,address[],address)" --rpc-url <RPC_URL> \
    <CURRENT_NONCE> <ASSET_ADDRESSES> <RECEIVER_ADDRESS>

# example: release USDC, USDT, and ETH to vitalik.eth
cast send 0x0000..TBD "release(uint256,address[],address)" --rpc-url <RPC_URL> \
    0 \
    0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,0xdAC17F958D2ee523a2206206994597C13D831ec7,0x0000000000000000000000000000000000000000 \
    0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
```
</TabItem>
</Tabs>
</file>

<file path="docs/contracts/protocol-fee/guides/read-asset-balance.mdx">
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Reading Asset Balance

As noted in [Best Practices](./best-practices), the `AssetSink's` available asset balance is observed in three places:

* the contract address of the `AssetSink` itself
* the `UniswapV3Pool` contract addresses
* the `UniswapV2Pair` liquidity tokens

For example, the *releasable* USDC balance is `USDC.balanceOf(address(assetSink)) + sum of UniswapV3Pool.protocolFees() + sum of UniswapV2Pair.burn()` for each USDC-paired pool

---

## Uniswap v3 Pool Protocol Fees

Reading available Uniswap v3 Pool protocol fees requires calling `.protocolFees()` on each `UniswapV3Pool` contract

```solidity
import {IERC20} from "forge-std/interfaces/IERC20.sol";
import {IUniswapV3Pool} from "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3Pool.sol";
import {IAssetSink} from "@uniswap/phoenix-fees/src/interfaces/IAssetSink.sol";

contract Example {
    IAssetSink assetSink = IAssetSink(0x0);

    function releaseableBalance(address token, address[] calldata pools)
        external
        view
        returns (uint256)
    {
        return IERC20(token).balanceOf(address(assetSink)) // [!code hl]
            + _getV3ProtocolFeesUnclaimed(token, pools); // [!code hl]
    }

    function _getV3ProtocolFeesUnclaimed(address token, address[] calldata pools)
        internal
        view
        returns (uint256 feesUnclaimed)
    {
        uint128 token0Unclaimed;
        uint128 token1Unclaimed;
        for (uint256 i; i < pools.length; i++) {
            (token0Unclaimed, token1Unclaimed) = IUniswapV3Pool(pools[i]).protocolFees(); // [!code hl]
            
            // determine if the requested `token` parameter is `pool.token0()` or `pool.token1()`
            feesUnclaimed += pool.token0() == token
                ? token0Unclaimed
                : pool.token1() == token
                ? token1Unclaimed
                : 0;
        }
    }
}
```
:::note
Uniswap v3 does not support native Ether tokens. Protocol fees in ETH are accrued as [Wrapped Ether (WETH)](https://etherscan.io/token/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2).
:::

Because unclaimed tokens are stored in Uniswap v3 Pool contracts, integrators should use offchain indexing to track 
which pools contain the asset of interest. For example, USDC protocol fees are accrued in many different pools:

* USDC / TOKENA 0.05% Fee
* USDC / TOKENA 0.30% Fee
* USDC / TOKENB 0.30% Fee
* USDC / TOKENC 0.30% Fee
* and so on...

To track which pools contain the asset of interest, we recommend to index the `PoolCreated` 
[event emitted](https://github.com/Uniswap/v3-core/blob/main/contracts/UniswapV3Factory.sol#L50) by the `UniswapV3Factory` contract

## Uniswap v2 Pool Protocol Fees

Uniswap v2 protocol fees are automatically "pushed" to the `AssetSink` so no additional calls are required to make the assets releasable.
However, Uniswap v2 protocol fees are accrued in the form of liquidity tokens (LP tokens) which are redeemable for underlying assets. Ownership of the LP
token represents the proportional share of the pool's assets.

<Tabs>
<TabItem value="math" label="Math">
```
(LP Token Balance / LP Token Total Supply) * Pool Reserves
```
</TabItem>
<TabItem value="solidity" label="Solidity">
```solidity
IERC20 lpToken;

uint256 amount0 = (lpToken.balanceOf(address(assetSink)) * IERC20(lpToken.token0()).balanceOf(address(lpToken))) / lpToken.totalSupply();
uint256 amount1 = (lpToken.balanceOf(address(assetSink)) * IERC20(lpToken.token1()).balanceOf(address(lpToken))) / lpToken.totalSupply();
```
</TabItem>
</Tabs>

:::note
To access the underlying assets, integrators should call [IUniswapV2Pair.burn()](https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L134)

```solidity
(uint256 amount0, uint256 amount1) = IUniswapV2Pair(pool).burn(recipient);
```
:::
</file>

<file path="docs/contracts/protocol-fee/technical-reference/_category_.json">
{
  "label": "Technical Reference",
  "position": 9,
  "collapsed": true
}
</file>

<file path="docs/contracts/protocol-fee/technical-reference/ArrayLib.md">
# ArrayLib
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/libraries/ArrayLib.sol)


## Functions
### includes


```solidity
function includes(uint24[] storage array, uint24 value) internal view returns (bool);
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/Deployer.md">
# Deployer
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/Deployer.sol)


## State Variables
### TOKEN_JAR

```solidity
ITokenJar public immutable TOKEN_JAR
```


### RELEASER

```solidity
IReleaser public immutable RELEASER
```


### FEE_ADAPTER

```solidity
IV3FeeAdapter public immutable FEE_ADAPTER
```


### UNI_MINTER

```solidity
IUNIMinter public immutable UNI_MINTER
```


### RESOURCE

```solidity
address public constant RESOURCE = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984
```


### THRESHOLD

```solidity
uint256 public constant THRESHOLD = 69_420
```


### V3_FACTORY

```solidity
IUniswapV3Factory public constant V3_FACTORY =
  IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984)
```


### SALT_TOKEN_JAR

```solidity
bytes32 constant SALT_TOKEN_JAR = 0
```


### SALT_RELEASER

```solidity
bytes32 constant SALT_RELEASER = 0
```


### SALT_FEE_ADAPTER

```solidity
bytes32 constant SALT_FEE_ADAPTER = 0
```


## Functions
### constructor

1. Deploy the TokenJar
3. Set the releaser on the token jar.
4. Update the owner on the token jar.
RELEASER:
2. Deploy the Releaser.
5. Update the thresholdSetter on the releaser to the owner.
6. Update the owner on the releaser.
FEE_ADAPTER:
7. Deploy the FeeAdapter.
8. Update the feeSetter to the owner.
9. Store fee tiers.
10. Update the owner on the fee adapter.
UNIMinter
11. Deploy the UNIMinter
- To enable the UNIMinter, the owner must call `setMinter` on the UNI contract


```solidity
constructor() ;
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/ExchangeReleaser.md">
# ExchangeReleaser
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/releasers/ExchangeReleaser.sol)

**Inherits:**
[IReleaser](/home/toda/dev/phoenix-fees/forge-docs/src/src/interfaces/IReleaser.sol/interface.IReleaser.md), [ResourceManager](/home/toda/dev/phoenix-fees/forge-docs/src/src/base/ResourceManager.sol/abstract.ResourceManager.md), [Nonce](/home/toda/dev/phoenix-fees/forge-docs/src/src/base/Nonce.sol/abstract.Nonce.md)

A contract that releases assets from an TokenJar in exchange for transferring a
threshold
amount of a resource token

Inherits from ResourceManager for resource transferring functionality and Nonce for replay
protection

**Note:**
security-contact: security@uniswap.org


## State Variables
### TOKEN_JAR

```solidity
ITokenJar public immutable TOKEN_JAR
```


## Functions
### constructor

Creates a new ExchangeReleaser instance


```solidity
constructor(address _resource, uint256 _threshold, address _tokenJar, address _recipient)
  ResourceManager(_resource, _threshold, msg.sender, _recipient);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`_resource`|`address`|The address of the resource token that must be transferred|
|`_threshold`|`uint256`||
|`_tokenJar`|`address`|The address of the TokenJar contract holding the assets|
|`_recipient`|`address`|The address that will receive the resource tokens|


### release

Releases assets to a specified recipient if the resource threshold is met


```solidity
function release(uint256 _nonce, Currency[] calldata assets, address recipient) external virtual;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`_nonce`|`uint256`|The nonce for the release, must equal to the contract nonce otherwise revert|
|`assets`|`Currency[]`|The list of assets (addresses) to release, which may have length limits Native tokens (Ether) are represented as the zero address|
|`recipient`|`address`|The address to receive the released assets, paid out by Token Jar|


### _release

Internal function to handle the nonce check, transfer the RESOURCE, and call the
release of assets on the TokenJar.


```solidity
function _release(uint256 _nonce, Currency[] calldata assets, address recipient)
  internal
  handleNonce(_nonce);
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/Firepit.md">
# Firepit
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/releasers/Firepit.sol)

**Inherits:**
[ExchangeReleaser](/home/toda/dev/phoenix-fees/forge-docs/src/src/releasers/ExchangeReleaser.sol/abstract.ExchangeReleaser.md)

An ExchangeReleaser with recipient set to the burn address address(0xdead) and a limit
on the number of currencies that can be released at any time.

**Note:**
security-contact: security@uniswap.org


## State Variables
### MAX_RELEASE_LENGTH
Maximum number of different assets that can be released in a single call


```solidity
uint256 public constant MAX_RELEASE_LENGTH = 20
```


## Functions
### constructor


```solidity
constructor(address _resource, uint256 _threshold, address _tokenJar)
  ExchangeReleaser(_resource, _threshold, _tokenJar, address(0xdead));
```

### release

Releases assets to a specified recipient if the resource threshold is met


```solidity
function release(uint256 _nonce, Currency[] calldata assets, address recipient)
  external
  override;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`_nonce`|`uint256`|The nonce for the release, must equal to the contract nonce otherwise revert|
|`assets`|`Currency[]`|The list of assets (addresses) to release, which may have length limits Native tokens (Ether) are represented as the zero address|
|`recipient`|`address`|The address to receive the released assets, paid out by Token Jar|


## Errors
### TooManyAssets
Thrown when attempting to release too many assets at once


```solidity
error TooManyAssets();
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/FirepitDestination.md">
# FirepitDestination
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/crosschain/FirepitDestination.sol)

**Inherits:**
[Nonce](/home/toda/dev/phoenix-fees/forge-docs/src/src/base/Nonce.sol/abstract.Nonce.md), Owned

a contract for receiving crosschain messages. Validates messages and releases assets
from the TokenJar


## State Variables
### allowableSource
the source contract that is allowed to originate messages to this contract i.e.
FirepitSource

updatable by owner


```solidity
address public allowableSource
```


### allowableCallers
the local contract(s) that are allowed to call this contract, i.e. Message Relayers

updatable by owner


```solidity
mapping(address callers => bool allowed) public allowableCallers
```


### TOKEN_JAR

```solidity
TokenJar public immutable TOKEN_JAR
```


### MINIMUM_RELEASE_GAS

```solidity
uint256 public constant MINIMUM_RELEASE_GAS = 100_000
```


## Functions
### constructor


```solidity
constructor(address _owner, address _tokenJar) Owned(_owner);
```

### onlyAllowed


```solidity
modifier onlyAllowed() ;
```

### claimTo

Calls Token Jar to release assets to a destination

only callable by the messenger via the authorized L1 source contract


```solidity
function claimTo(uint256 _nonce, Currency[] calldata assets, address claimer)
  external
  onlyAllowed
  handleNonce(_nonce);
```

### setAllowableCallers


```solidity
function setAllowableCallers(address callers, bool isAllowed) external onlyOwner;
```

### setAllowableSource


```solidity
function setAllowableSource(address source) external onlyOwner;
```

## Events
### FailedRelease

```solidity
event FailedRelease(uint256 indexed _nonce, address indexed _claimer);
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/FirepitSource.md">
# FirepitSource
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/crosschain/FirepitSource.sol)

**Inherits:**
[ResourceManager](/home/toda/dev/phoenix-fees/forge-docs/src/src/base/ResourceManager.sol/abstract.ResourceManager.md), [Nonce](/home/toda/dev/phoenix-fees/forge-docs/src/src/base/Nonce.sol/abstract.Nonce.md)


## State Variables
### DEFAULT_BRIDGE_ID

```solidity
uint256 public constant DEFAULT_BRIDGE_ID = 0
```


## Functions
### constructor

TODO: Move threshold to constructor. It should not default to 0.


```solidity
constructor(address _owner, address _resource)
  ResourceManager(_resource, 69_420, _owner, address(0xdead));
```

### _sendReleaseMessage


```solidity
function _sendReleaseMessage(
  uint256 bridgeId,
  uint256 destinationNonce,
  Currency[] calldata assets,
  address claimer,
  bytes memory addtlData
) internal virtual;
```

### release

Torches the RESOURCE by sending it to the burn address and sends a cross-domain
message to release the assets


```solidity
function release(uint256 _nonce, Currency[] calldata assets, address claimer, uint32 l2GasLimit)
  external
  handleNonce(_nonce);
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/IFirepitDestination.md">
# IFirepitDestination
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/interfaces/IFirepitDestination.sol)


## Functions
### claimTo


```solidity
function claimTo(uint256 _nonce, Currency[] calldata assets, address claimer) external;
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/IL1CrossDomainMessenger.md">
# IL1CrossDomainMessenger
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/interfaces/IL1CrossDomainMessenger.sol)


## Functions
### sendMessage


```solidity
function sendMessage(address _target, bytes calldata _message, uint32 _minGasLimit) external;
```

### xDomainMessageSender


```solidity
function xDomainMessageSender() external view returns (address);
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/INonce.md">
# INonce
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/interfaces/base/INonce.sol)


## Functions
### nonce


```solidity
function nonce() external view returns (uint256);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint256`|The contract's nonce|


## Errors
### InvalidNonce
Thrown when a user-provided nonce is not equal to the contract's nonce


```solidity
error InvalidNonce();
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/IOwned.md">
# IOwned
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/interfaces/base/IOwned.sol)

Interface for Solmate's Owned.sol contract


## Functions
### owner


```solidity
function owner() external view returns (address);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`address`|owner of the contract|


### transferOwnership

Transfers ownership of the contract to a new address


```solidity
function transferOwnership(address newOwner) external;
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/IReleaser.md">
# IReleaser
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/interfaces/IReleaser.sol)

**Inherits:**
[IResourceManager](/home/toda/dev/phoenix-fees/forge-docs/src/src/interfaces/base/IResourceManager.sol/interface.IResourceManager.md), [INonce](/home/toda/dev/phoenix-fees/forge-docs/src/src/interfaces/base/INonce.sol/interface.INonce.md)


## Functions
### TOKEN_JAR


```solidity
function TOKEN_JAR() external view returns (ITokenJar);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`ITokenJar`|Address of the Token Jar contract that will release the assets|


### release

Releases assets to a specified recipient if the resource threshold is met


```solidity
function release(uint256 _nonce, Currency[] calldata assets, address recipient) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`_nonce`|`uint256`|The nonce for the release, must equal to the contract nonce otherwise revert|
|`assets`|`Currency[]`|The list of assets (addresses) to release, which may have length limits Native tokens (Ether) are represented as the zero address|
|`recipient`|`address`|The address to receive the released assets, paid out by Token Jar|
</file>

<file path="docs/contracts/protocol-fee/technical-reference/IResourceManager.md">
# IResourceManager
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/interfaces/base/IResourceManager.sol)

The interface for managing the resource token and its threshold value


## Functions
### RESOURCE

The resource token required by parent IReleaser


```solidity
function RESOURCE() external view returns (ERC20);
```

### RESOURCE_RECIPIENT

The recipient of the `RESOURCE` tokens


```solidity
function RESOURCE_RECIPIENT() external view returns (address);
```

### threshold

The minimum threshold of `RESOURCE` tokens required to perform a release


```solidity
function threshold() external view returns (uint256);
```

### thresholdSetter

The address authorized to set the `threshold` value


```solidity
function thresholdSetter() external view returns (address);
```

### setThresholdSetter

Set the address authorized to set the `threshold` value

only callable by `owner`


```solidity
function setThresholdSetter(address newThresholdSetter) external;
```

### setThreshold

Set the minimum threshold of `RESOURCE` tokens required to perform a release

only callable by `thresholdSetter`
the `thresholdSetter` should take explicit care when updating the threshold
* lowering the threshold may create instantaneous value leakage
* front-running a release with an increased threshold may cause economic loss
to the releaser/searcher


```solidity
function setThreshold(uint256 newThreshold) external;
```

## Errors
### Unauthorized
Thrown when an unauthorized address attempts to call a restricted function


```solidity
error Unauthorized();
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/ITokenJar.md">
# ITokenJar
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/interfaces/ITokenJar.sol)

The interface for releasing assets from the contract


## Functions
### releaser

The releaser has exclusive access to the `release()` function


```solidity
function releaser() external view returns (address);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`address`|Address of the current IReleaser|


### setReleaser

Set the address of the IReleaser contract

only callabe by `owner`


```solidity
function setReleaser(address _releaser) external;
```

### release

Release assets to a specified recipient

only callable by `releaser`


```solidity
function release(Currency[] calldata assets, address recipient) external;
```

## Errors
### Unauthorized
Thrown when an unauthorized address attempts to call a restricted function


```solidity
error Unauthorized();
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/IUniswapV3FactoryOwnerActions.md">
# IUniswapV3FactoryOwnerActions
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/interfaces/IUniswapV3FactoryOwnerActions.sol)

The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the
protocol fees

Stripped down and renamed from:
https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/interfaces/IUniswapV3Factory.sol


## Functions
### owner

Returns the current owner of the factory

Can be changed by the current owner via setOwner


```solidity
function owner() external view returns (address);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`address`|The address of the factory owner|


### setOwner

Updates the owner of the factory

Must be called by the current owner


```solidity
function setOwner(address _owner) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`_owner`|`address`|The new owner of the factory|


### enableFeeAmount

Enables a fee amount with the given tickSpacing

Fee amounts may never be removed once enabled


```solidity
function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`fee`|`uint24`|The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)|
|`tickSpacing`|`int24`|The spacing between ticks to be enforced for all pools created with the given fee amount|


### feeAmountTickSpacing

Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled

A fee amount can never be removed, so this value should be hard coded or cached in the
calling context


```solidity
function feeAmountTickSpacing(uint24 fee) external view returns (int24);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`fee`|`uint24`|The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`int24`|The tick spacing|
</file>

<file path="docs/contracts/protocol-fee/technical-reference/IUniswapV3PoolOwnerActions.md">
# IUniswapV3PoolOwnerActions
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/interfaces/IUniswapV3PoolOwnerActions.sol)

Contains pool methods that may only be called by the factory owner

Vendored from
https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol


## Functions
### setFeeProtocol

Set the denominator of the protocol's % share of the fees


```solidity
function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`feeProtocol0`|`uint8`|new protocol fee for token0 of the pool|
|`feeProtocol1`|`uint8`|new protocol fee for token1 of the pool|


### collectProtocol

Collect the protocol fee accrued to the pool


```solidity
function collectProtocol(address recipient, uint128 amount0Requested, uint128 amount1Requested)
  external
  returns (uint128 amount0, uint128 amount1);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`recipient`|`address`|The address to which collected protocol fees should be sent|
|`amount0Requested`|`uint128`|The maximum amount of token0 to send, can be 0 to collect fees in only token1|
|`amount1Requested`|`uint128`|The maximum amount of token1 to send, can be 0 to collect fees in only token0|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amount0`|`uint128`|The protocol fee collected in token0|
|`amount1`|`uint128`|The protocol fee collected in token1|
</file>

<file path="docs/contracts/protocol-fee/technical-reference/IV3FeeAdapter.md">
# IV3FeeAdapter
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/interfaces/IV3FeeAdapter.sol)


## Functions
### TOKEN_JAR


```solidity
function TOKEN_JAR() external view returns (address);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`address`|The address where collected fees are sent.|


### FACTORY


```solidity
function FACTORY() external view returns (IUniswapV3Factory);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`IUniswapV3Factory`|The Uniswap V3 Factory contract.|


### merkleRoot


```solidity
function merkleRoot() external view returns (bytes32);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes32`|The current merkle root used to designate which pools have a fee enabled|


### feeSetter


```solidity
function feeSetter() external view returns (address);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`address`|The authorized address to set fees-by-fee-tier AND the merkle root|


### feeTiers


```solidity
function feeTiers(uint256 i) external view returns (uint24);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint24`|The fee tiers enabled on the factory|


### storeFeeTier

Stores a fee tier.

Must be a fee tier that exists on the Uniswap V3 Factory.


```solidity
function storeFeeTier(uint24 feeTier) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`feeTier`|`uint24`|The fee tier to store.|


### defaultFees

Returns the default fee value for a given fee tier.


```solidity
function defaultFees(uint24 feeTier) external view returns (uint8 defaultFeeValue);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`feeTier`|`uint24`|The fee tier to query.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`defaultFeeValue`|`uint8`|The default fee value expressed as the denominator on the inclusive interval [4, 10]. The fee value is packed (token1Fee \<\< 4 \| token0Fee)|


### enableFeeAmount

Enables a new fee tier on the Uniswap V3 Factory.

Only callable by `owner`. Also updates the `feeTiers` array.


```solidity
function enableFeeAmount(uint24 newFeeTier, int24 tickSpacing) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`newFeeTier`|`uint24`|The fee tier to enable.|
|`tickSpacing`|`int24`|The corresponding tick spacing for the new fee tier.|


### setFactoryOwner

Sets the owner of the Uniswap V3 Factory.

Only callable by `owner`


```solidity
function setFactoryOwner(address newOwner) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`newOwner`|`address`|The new owner of the Uniswap V3 Factory.|


### collect

Collects protocol fees from the specified pools to the designated `TOKEN_JAR`


```solidity
function collect(CollectParams[] calldata collectParams)
  external
  returns (Collected[] memory amountsCollected);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`collectParams`|`CollectParams[]`|Array of collection parameters for each pool.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amountsCollected`|`Collected[]`|Array of collected amounts for each pool.|


### setMerkleRoot

Sets the merkle root used for designating which pools have the fee enabled.

Only callable by `feeSetter`


```solidity
function setMerkleRoot(bytes32 _merkleRoot) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`_merkleRoot`|`bytes32`|The new merkle root to set.|


### setDefaultFeeByFeeTier

Sets the default fee value for a specific fee tier.


```solidity
function setDefaultFeeByFeeTier(uint24 feeTier, uint8 defaultFeeValue) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`feeTier`|`uint24`|The fee tier, expressed in pips, to set the default fee for.|
|`defaultFeeValue`|`uint8`|The default fee value to set, expressed as the denominator on the inclusive interval [4, 10]. The fee value is packed (token1Fee \<\< 4 \| token0Fee)|


### triggerFeeUpdate

Triggers a fee update for a single pool with merkle proof verification.


```solidity
function triggerFeeUpdate(address pool, bytes32[] calldata merkleProof) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`pool`|`address`|The pool address to update the fee for.|
|`merkleProof`|`bytes32[]`|The merkle proof corresponding to the set merkle root.|


### triggerFeeUpdate

Triggers a fee update for one pair of tokens with merkle proof verification. There may
be multiple pools initialized from the given pair.

Assumes that token0 < token1.


```solidity
function triggerFeeUpdate(address token0, address token1, bytes32[] calldata proof) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`token0`|`address`|The first token of the pair.|
|`token1`|`address`|The second token of the pair.|
|`proof`|`bytes32[]`|The merkle proof corresponding to the set merkle root.|


### batchTriggerFeeUpdate

Triggers fee updates for multiple pairs of tokens with batch merkle proof
verification.

Assumes that token0 < token1 in the token pair.


```solidity
function batchTriggerFeeUpdate(
  Pair[] calldata pairs,
  bytes32[] calldata proof,
  bool[] calldata proofFlags
) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`pairs`|`Pair[]`|The pair of two tokens. There may be multiple pools initialized from the same pair.|
|`proof`|`bytes32[]`|The merkle proof corresponding to the set merkle root.|
|`proofFlags`|`bool[]`|The flags for the merkle proof verification.|


### setFeeSetter

Sets a new fee setter address.


```solidity
function setFeeSetter(address newFeeSetter) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`newFeeSetter`|`address`|The new address authorized to set fees and merkle roots.|


## Errors
### InvalidProof
Thrown when the merkle proof is invalid.


```solidity
error InvalidProof();
```

### InvalidFeeTier
Thrown when trying to set a default fee for a non-enabled fee tier.


```solidity
error InvalidFeeTier();
```

### Unauthorized
Thrown when an unauthorized address attempts to call a restricted function


```solidity
error Unauthorized();
```

### TierAlreadyStored
Thrown when trying to store a fee tier that is already stored.


```solidity
error TierAlreadyStored();
```

## Structs
### CollectParams
The input parameters for the collection.


```solidity
struct CollectParams {
  /// @param pool The pool to collect fees from.
  address pool;
  /// @param amount0Requested The amount of token0 to collect. If this is higher than the total
  /// collectable amount, it will collect all but 1 wei of the total token0 allotment.
  uint128 amount0Requested;
  /// @param amount1Requested The amount of token1 to collect. If this is higher than the total
  /// collectable amount, it will collect all but 1 wei of the total token1 allotment.
  uint128 amount1Requested;
}
```

### Collected
The returned amounts of token0 and token1 that are collected.


```solidity
struct Collected {
  /// @param amount0Collected The amount of token0 that is collected.
  uint128 amount0Collected;
  /// @param amount1Collected The amount of token1 that is collected.
  uint128 amount1Collected;
}
```

### Pair
The pair of tokens to trigger fees for. Each node in the merkle tree is the sorted
pair. If one pair in the merkle tree is (USDC, USDT), all pools consisting of those tokens
will be allowed to have a fee enabled.


```solidity
struct Pair {
  /// @param token0 The first token of the pair.
  address token0;
  /// @param token1 The second token of the pair.
  address token1;
}
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/Nonce.md">
# Nonce
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/base/Nonce.sol)

**Inherits:**
[INonce](/home/toda/dev/phoenix-fees/forge-docs/src/src/interfaces/base/INonce.sol/interface.INonce.md)


## State Variables
### nonce

```solidity
uint256 public nonce
```


## Functions
### handleNonce


```solidity
modifier handleNonce(uint256 _nonce) ;
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/OPStackFirepitSource.md">
# OPStackFirepitSource
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/crosschain/OPStackFirepitSource.sol)

**Inherits:**
[FirepitSource](/home/toda/dev/phoenix-fees/forge-docs/src/src/crosschain/FirepitSource.sol/abstract.FirepitSource.md)


## State Variables
### MESSENGER

```solidity
IL1CrossDomainMessenger public immutable MESSENGER
```


### L2_TARGET

```solidity
address public immutable L2_TARGET
```


## Functions
### constructor


```solidity
constructor(address _resource, address _messenger, address _l2Target)
  FirepitSource(msg.sender, _resource);
```

### _sendReleaseMessage


```solidity
function _sendReleaseMessage(
  uint256, // bridgeId
  uint256 destinationNonce,
  Currency[] calldata assets,
  address claimer,
  bytes memory addtlData
) internal override;
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/ResourceManager.md">
# ResourceManager
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/base/ResourceManager.sol)

**Inherits:**
[IResourceManager](/home/toda/dev/phoenix-fees/forge-docs/src/src/interfaces/base/IResourceManager.sol/interface.IResourceManager.md), Owned

A contract that holds immutable state for the resource token and the resource recipient
address. It also maintains logic for managing the threshold of the resource token.


## State Variables
### threshold
The minimum threshold of `RESOURCE` tokens required to perform a release


```solidity
uint256 public threshold
```


### thresholdSetter
The address authorized to set the `threshold` value


```solidity
address public thresholdSetter
```


### RESOURCE
The resource token required by parent IReleaser


```solidity
ERC20 public immutable RESOURCE
```


### RESOURCE_RECIPIENT
The recipient of the `RESOURCE` tokens


```solidity
address public immutable RESOURCE_RECIPIENT
```


## Functions
### onlyThresholdSetter

Ensures only the threshold setter can call the setThreshold function


```solidity
modifier onlyThresholdSetter() ;
```

### constructor

At construction the thresholdSetter defaults to 0 and its on the owner to set.


```solidity
constructor(address _resource, uint256 _threshold, address _owner, address _recipient)
  Owned(_owner);
```

### setThresholdSetter

Set the address authorized to set the `threshold` value

only callable by `owner`


```solidity
function setThresholdSetter(address _thresholdSetter) external onlyOwner;
```

### setThreshold

Set the minimum threshold of `RESOURCE` tokens required to perform a release

only callable by `thresholdSetter`
the `thresholdSetter` should take explicit care when updating the threshold
* lowering the threshold may create instantaneous value leakage
* front-running a release with an increased threshold may cause economic loss
to the releaser/searcher


```solidity
function setThreshold(uint256 _threshold) external onlyThresholdSetter;
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/TokenJar.md">
# TokenJar
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/TokenJar.sol)

**Inherits:**
Owned, [ITokenJar](/home/toda/dev/phoenix-fees/forge-docs/src/src/interfaces/ITokenJar.sol/interface.ITokenJar.md)

A singular destination for protocol fees

Fees accumulate passively in this contract from external sources.
Stored fees can be released by an authorized releaser contract.

**Note:**
security-contact: security@uniswap.org


## State Variables
### releaser
The releaser has exclusive access to the `release()` function


```solidity
address public releaser
```


## Functions
### onlyReleaser

Ensures only the releaser can call the release function


```solidity
modifier onlyReleaser() ;
```

### constructor

creates an token jar where the deployer is the initial owner
during deployment, the deployer SHOULD set the releaser address and
transfer ownership


```solidity
constructor() Owned(msg.sender);
```

### release

Release assets to a specified recipient

only callable by `releaser`


```solidity
function release(Currency[] calldata assets, address recipient) external onlyReleaser;
```

### setReleaser

Set the address of the IReleaser contract

only callabe by `owner`


```solidity
function setReleaser(address _releaser) external onlyOwner;
```

### receive


```solidity
receive() external payable;
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/UnauthorizedCall.md">
# UnauthorizedCall
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/crosschain/FirepitDestination.sol)


```solidity
error UnauthorizedCall();
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/V3FeeAdapter.md">
# V3FeeAdapter
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/feeAdapters/V3FeeAdapter.sol)

**Inherits:**
[IV3FeeAdapter](/home/toda/dev/phoenix-fees/forge-docs/src/src/interfaces/IV3FeeAdapter.sol/interface.IV3FeeAdapter.md), Owned

A contract that allows the setting and collecting of protocol fees per pool, and adding
new fee tiers to the Uniswap V3 Factory.

This contract is ownable. The owner can set the merkle root for proving protocol fee
amounts per pool, set new fee tiers on Uniswap V3, and change the owner of this contract.
Note that this contract will be the set owner on the Uniswap V3 Factory.

**Note:**
security-contact: security@uniswap.org


## State Variables
### FACTORY

```solidity
IUniswapV3Factory public immutable FACTORY
```


### TOKEN_JAR

```solidity
address public immutable TOKEN_JAR
```


### merkleRoot

```solidity
bytes32 public merkleRoot
```


### feeSetter

```solidity
address public feeSetter
```


### defaultFees
Returns the default fee value for a given fee tier.


```solidity
mapping(uint24 feeTier => uint8 defaultFeeValue) public defaultFees
```


### feeTiers
Returns four enabled fee tiers: 100, 500, 3000, 10000. May return more if more are
enabled.


```solidity
uint24[] public feeTiers
```


## Functions
### onlyFeeSetter

Ensures only the fee setter can call the setMerkleRoot and setDefaultFeeByFeeTier
functions


```solidity
modifier onlyFeeSetter() ;
```

### constructor

At construction, the fee setter defaults to 0 and its on the owner to set.


```solidity
constructor(address _factory, address _tokenJar) Owned(msg.sender);
```

### storeFeeTier

Stores a fee tier.

Must be a fee tier that exists on the Uniswap V3 Factory.


```solidity
function storeFeeTier(uint24 feeTier) public;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`feeTier`|`uint24`|The fee tier to store.|


### enableFeeAmount

Enables a new fee tier on the Uniswap V3 Factory.

Only callable by `owner`. Also updates the `feeTiers` array.


```solidity
function enableFeeAmount(uint24 fee, int24 tickSpacing) external onlyOwner;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`fee`|`uint24`||
|`tickSpacing`|`int24`|The corresponding tick spacing for the new fee tier.|


### setFactoryOwner


```solidity
function setFactoryOwner(address newOwner) external onlyOwner;
```

### collect

Collects protocol fees from the specified pools to the designated `TOKEN_JAR`


```solidity
function collect(CollectParams[] calldata collectParams)
  external
  returns (Collected[] memory amountsCollected);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`collectParams`|`CollectParams[]`|Array of collection parameters for each pool.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amountsCollected`|`Collected[]`|Array of collected amounts for each pool.|


### setMerkleRoot

Sets the merkle root used for designating which pools have the fee enabled.

Only callable by `feeSetter`


```solidity
function setMerkleRoot(bytes32 _merkleRoot) external onlyFeeSetter;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`_merkleRoot`|`bytes32`|The new merkle root to set.|


### setDefaultFeeByFeeTier

Sets the default fee value for a specific fee tier.


```solidity
function setDefaultFeeByFeeTier(uint24 feeTier, uint8 defaultFeeValue) external onlyFeeSetter;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`feeTier`|`uint24`|The fee tier, expressed in pips, to set the default fee for.|
|`defaultFeeValue`|`uint8`|The default fee value to set, expressed as the denominator on the inclusive interval [4, 10]. The fee value is packed (token1Fee \<\< 4 \| token0Fee)|


### setFeeSetter

Sets a new fee setter address.


```solidity
function setFeeSetter(address newFeeSetter) external onlyOwner;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`newFeeSetter`|`address`|The new address authorized to set fees and merkle roots.|


### triggerFeeUpdate

Triggers a fee update for a single pool with merkle proof verification.


```solidity
function triggerFeeUpdate(address pool, bytes32[] calldata proof) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`pool`|`address`|The pool address to update the fee for.|
|`proof`|`bytes32[]`||


### triggerFeeUpdate

Triggers a fee update for a single pool with merkle proof verification.


```solidity
function triggerFeeUpdate(address token0, address token1, bytes32[] calldata proof) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`token0`|`address`||
|`token1`|`address`||
|`proof`|`bytes32[]`||


### batchTriggerFeeUpdate

Triggers fee updates for multiple pairs of tokens with batch merkle proof
verification.

Assumes that token0 < token1 in the token pair.


```solidity
function batchTriggerFeeUpdate(
  Pair[] calldata pairs,
  bytes32[] calldata proof,
  bool[] calldata proofFlags
) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`pairs`|`Pair[]`|The pair of two tokens. There may be multiple pools initialized from the same pair.|
|`proof`|`bytes32[]`|The merkle proof corresponding to the set merkle root.|
|`proofFlags`|`bool[]`|The flags for the merkle proof verification.|


### _setProtocolFeesForPair


```solidity
function _setProtocolFeesForPair(address token0, address token1) internal;
```

### _setProtocolFee


```solidity
function _setProtocolFee(address pool, uint24 feeTier) internal;
```

### _doubleHash


```solidity
function _doubleHash(address token0, address token1) internal pure returns (bytes32 poolHash);
```

### _feeTierExists


```solidity
function _feeTierExists(uint24 feeTier) internal view returns (bool);
```
</file>

<file path="docs/contracts/protocol-fee/technical-reference/V4FeeAdapter.md">
# V4FeeAdapter
[Git Source](https://github.com/Uniswap/phoenix-fees/blob/f7ccbcc4f1be2c8485a362f78f4f1ea34145b2b0/src/feeAdapters/V4FeeAdapter.sol)

**Inherits:**
Owned

Triggers the collection of protocol fees to a predefined token jar.


## State Variables
### POOL_MANAGER

```solidity
IPoolManager public immutable POOL_MANAGER
```


### tokenJar

```solidity
address public tokenJar
```


### merkleRoot

```solidity
bytes32 public merkleRoot
```


## Functions
### constructor


```solidity
constructor(address _poolManager, address _tokenJar, address _owner) Owned(_owner);
```

### collect

Collects the protocol fees for the given currencies to the token jar.


```solidity
function collect(
  Currency[] calldata currency,
  uint256[] calldata amountRequested,
  uint256[] calldata amountExpected
) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency`|`Currency[]`|The currencies to collect fees for.|
|`amountRequested`|`uint256[]`|The amount of each currency to request.|
|`amountExpected`|`uint256[]`|The amount of each currency that is expected to be collected.|


### setMerkleRoot

Sets the merkle root for the fee adapter.

only callable by owner


```solidity
function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`_merkleRoot`|`bytes32`|The merkle root to set.|


### triggerFeeUpdate

Triggers the fee update for the given pool key.


```solidity
function triggerFeeUpdate(
  PoolKey calldata _poolKey,
  uint24 newProtocolFee,
  bytes32[] calldata proof
) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`_poolKey`|`PoolKey`|The pool key to update the fee for.|
|`newProtocolFee`|`uint24`|The new protocol fee to set.|
|`proof`|`bytes32[]`|The merkle proof corresponding to the set merkle root. Merkle root is generated from leaves of keccak256(abi.encode(poolKey, protocolFee)).|


## Errors
### AmountCollectedTooLow
Thrown when the amount collected is less than the amount expected.


```solidity
error AmountCollectedTooLow(uint256 amountCollected, uint256 amountExpected);
```

### InvalidProof
Thrown when the merkle proof is invalid.


```solidity
error InvalidProof();
```
</file>

<file path="docs/contracts/protocol-fee/_category_.json">
{
  "label": "Protocol Fee",
  "position": 2.1,
  "collapsed": true
}
</file>

<file path="docs/contracts/protocol-fee/deployments.mdx">
---
title: Deployments
sidebar_position: 1.1
---

# Deployment Addresses

## Ethereum Mainnet

| Contract        | Address                                                                                                               |
|-----------------|-----------------------------------------------------------------------------------------------------------------------|
| AssetSink       | 0xPLACEHOLDER_TBD                                                                                                     |
| Firepit         | 0xPLACEHOLDER_TBD                                                                                                     |
| V3FeeController | 0xPLACEHOLDER_TBD                                                                                                     |
| UNI             | [0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984](https://etherscan.io/address/0x1f9840a85d5af5bf1d1762f925bdaddc4201f984) |

### Deployment Process

To enable fees for v2 and v3 on *mainnet*, the [Deployer](/technical-reference/Deployer) handles the entire set up in one transaction. Subsequent transactions
will be required to set the initial fee values.

The `Deployer` contract performs the following steps, in its constructor:

1. Deploys the `AssetSink` contract
2. Deploys the `Firepit` contract, with the initial UNI-threshold requirement as a parameter
3. Set the `Firepit` as the releaser on the `AssetSink`
4. Transfers ownership of the `AssetSink` to the [Uniswap Governance Timelock’s address](https://etherscan.io/address/0x1a9c8182c09f50c8318d769245bea52c32be35bc)
5. Sets the [Uniswap Governance Timelock’s address](https://etherscan.io/address/0x1a9c8182c09f50c8318d769245bea52c32be35bc) as the initial `thresholdSetter`,
giving the Governance Timelock the ability to update the UNI-threshold requirement
6. Transfers ownership of the `Firepit` to the [Uniswap Governance Timelock’s address](https://etherscan.io/address/0x1a9c8182c09f50c8318d769245bea52c32be35bc).
Uniswap Governance can appoint a different `thresholdSetter` at a later time.
7. Deploys the `V3FeeController` contract, with the `AssetSink` as the destination for collected fees
8. Sets the [Uniswap Governance Timelock’s address](https://etherscan.io/address/0x1a9c8182c09f50c8318d769245bea52c32be35bc) as the initial `feeSetter`, giving the Governance Timelock
the ability to set fee values at a later date
9. Transfers ownership of the `V3FeeController` to the [Uniswap Governance Timelock’s address](https://etherscan.io/address/0x1a9c8182c09f50c8318d769245bea52c32be35bc),
giving the Governance Timelock the ability to appoint a different `feeSetter` at a later time

Enabling fee values themselves will require a Uniswap Governance vote, which will involve:
  - calling [`setFeeTo`](https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Factory.sol#L40) on the mainnet [UniswapV2Factory](https://etherscan.io/address/0x5c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f) and passing the `AssetSink` address as the parameter
  - calling [`setMerkleRoot`](https://github.com/Uniswap/protocol-fees/blob/6f39580d36a75a1ed1f34daf7d3262ced4b9df3f/src/feeControllers/V3FeeController.sol#L93C12-L93C25) on the V3FeeController contract and passing a properly constructed Merkle root as a parameter
</file>

<file path="docs/contracts/protocol-fee/fee-setting-rational.mdx">
---
title: Fee Configuration
sidebar_position: 3
---
# **Protocol Fee Configuration**

For v2, fees are hardcoded and can only be enabled or disabled across all pools at once. For v3, we propose turning on protocol fees first for token pairs where the Uniswap Protocol currently accounts for over 90% of total DEX volume.

A full list of v3 pools included in the initial rollout is available [here](https://github.com/Uniswap/protocol-fees/blob/main/merkle-generator/data/merkle-tree.json).

| Version | Fee Tier | LP Fee | Protocol Fee |
| ----- | ----- | ----- | ----- |
| v2 | All pools | 0.25% | 0.05% |
| v3 | 0.01% | 0.0075% | 0.0025% |
| v3 | 0.05% | 0.0375% | 0.0125% |
| v3 | 0.30% | 0.25% | 0.05% |
| v3 | 1.00% | 0.8334% | 0.1666% |
</file>

<file path="docs/contracts/protocol-fee/overview.mdx">
---
title: Overview
sidebar_position: 1
---

# Uniswap Protocol Fees

Fees from protocol versions (v2, v3, v4, UniswapX, Unichain) flow into a single onchain collector on each network. From there, specialized contracts handle how those assets are released or transformed (for example, burning UNI).

## Flow of Assets

1. **Fee Sources**  
Each protocol component that generates fees (v2, v3, v4, UniswapX, Unichain, and others) routes those fees through an associated Fee Adapter contract. Adapters define how and when fees are collected and send them to the TokenJar on the same chain.

2. **TokenJar**  
   Each chain has one immutable contract called the **TokenJar**. All fee sources send tokens here. It’s the unified collection point for raw tokens.

3. **Releasers**  
   Releasers define how tokens in the TokenJar are accessed. The simplest version burns UNI in exchange for the collected tokens. Other Releasers could handle cross-chain conversions or alternative value flows.

4. **Governance Control**  
   Governance can update which Releaser a Sink uses or adjust configuration on Fee Controllers, but the core contracts themselves are immutable.

## Components

### TokenJar

Immutable contract that receives all tokens from fee sources on a given chain. Only the active Releaser can withdraw from it.  

See [TokenJar](technical-reference/AssetSink.md) for more.

### Fee Adapters

Adapters that connect specific protocol versions or products to the TokenJar. They define how and when fees are collected.  

See [Fee Adapters](technical-reference/V3FeeController.md).

### Releasers

Contracts that convert collected fees into protocol value according to defined logic.  
Examples include the Firepit Releaser, which burns UNI in return for assets.  

See [Releasers](technical-reference/IReleaser.md).

## Real-World Example

- Assume 100 UNI is the `threshold` amount for the Firepit Releaser.
- When the top *N* assets in the *TokenJar* are worth slightly more than 100 UNI, **anyone** is incentivized to use the `Firepit.release()` contract to:
    1. Burn 100 UNI
    2. Withdraw the top *N* assets, *valued* at slightly more than 100 UNI
</file>

<file path="docs/contracts/smart-wallet/advanced-usage/_category_.json">
{
    "label": "Advanced Usage",
    "position": 4,
    "collapsed": true
  }
</file>

<file path="docs/contracts/smart-wallet/advanced-usage/01-alternative-signer.md">
---
id: alternative-signers
title: Alternative Signers
sidebar_position: 1
---

Calibur allows for a user to add any number of signers to their account. Known as `keys`, the following types are supported: `Secp256k1`, `Secp256r1 (P256)`, and `WebAuthn P256`.

This is an **advanced** feature. Please be aware of the following:

- By default, added keys do not expire and have no hooks.
- A malicious key could steal all of your ETH and tokens

Registering external signers on your account changes the security model. Proceed with caution!
</file>

<file path="docs/contracts/smart-wallet/advanced-usage/02-hooks.md">
---
id: hooks
title: Hooks
sidebar_position: 2
---

Hooks are powerful add-ons to keys which can perform arbitrary validation on signatures, and/or actions during execution time.

There are two subtypes of hooks: `ValidationHook` and `ExecutionHook`. A hook can implement either, or both interfaces.

Validation hooks have three call sites:

- `afterVerifySignature`
- `afterIsValidSignature`
- `afterValidateUserOp`

Execution hooks have two call sites:

- `beforeExecute`
- `afterExecute`

Hooks must revert to indicate that the given action should revert.

Example functionality which can be implemented in hooks includes:

- Spending limits
- Restricting keys from calling certain contracts and methods
- Turning a key into a multisig, effectively requiring additional signatures for verification
- Automated actions pre/post swaps

There are a few example hooks referenced in the repo. Be aware that these example hooks are not production code and may contain bugs. We do not recommend you to deploy these hooks or use them as reference implementations for productionized code. They are proof of concepts.
</file>

<file path="docs/contracts/smart-wallet/advanced-usage/03-erc-7739.md">
---
id: erc-7739
title: ERC-7739
sidebar_position: 3
---

ERC-7739 is a standard which defines a defensive rehashing model for external signers on smart contract accounts. This does not apply to signatures from the root EOA (the one delegated to the implementation), but is enforced for all alternative keys which have been added to an account.

The ERC is still in draft [here](https://eips.ethereum.org/EIPS/eip-7739), and has example implementations in [Solady](https://github.com/Vectorized/solady/blob/main/src/accounts/ERC1271.sol) and [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-community-contracts/blob/master/contracts/utils/cryptography/signers/ERC7739.sol). We are looking forward to its finalization and welcome any comments / feedback from the community.

Viem has a client-side implementation [here](https://viem.sh/experimental/erc7739/signTypedData)
</file>

<file path="docs/contracts/smart-wallet/advanced-usage/04-erc-7914.md">
---
id: erc-7914
title: ERC-7914
sidebar_position: 4
---

ERC-7914 is a standard which adds native Ether “transfer from” functionality to smart contract wallets. It allows for our Smart Wallet to approve other accounts and contracts to spend ETH, which is not possible today with Externally Owned Accounts (EOAs). 

We are contributors to the [ERC](https://github.com/ethereum/ERCs/blob/8380220418521ff1995445cff5ca1d0e496a3d2d/ERCS/erc-7914.md) and welcome any feedback from the community on the spec or our implementation.

Calibur’s reference implementation is [here](https://github.com/Uniswap/calibur/blob/main/src/ERC7914.sol).
</file>

<file path="docs/contracts/smart-wallet/concepts/_category_.json">
{
    "label": "Concepts",
    "position": 3,
    "collapsed": true
  }
</file>

<file path="docs/contracts/smart-wallet/concepts/01-delegation.md">
---
id: delegation
title: Delegation
sidebar_position: 1
---

This contract is meant to be used with [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702): Set Code for EOAs. After the Ethereum Pectra fork, Externally Owned Accounts (EOAs) can now internalize code at a remotely deployed smart contract address. This process is called **delegation.** 

For simplicity, we will refer to these EOAs as *users* and these remote smart contracts as *implementations.* The term *Smart Wallet* will refer to the Uniswap smart wallet product.

Users can only be delegated to one contract at a time but can have other delegations on different chains.

After a user is delegated, they can execute transactions using the logic defined in the contract implementation, enabling advanced features like transaction batching, gas-less transactions, and custom permission controls - all while keeping their original address and on-chain history.
</file>

<file path="docs/contracts/smart-wallet/concepts/02-batched-transactions.md">
---
id: batched-transactions
title: Batched Transactions
sidebar_position: 2
---

Batched transactions are transactions which include one or more actions. For example, approving an ERC20 token and a swap using that token. Our smart wallet natively supports batched transactions, saving users gas and clicks.

Our smart wallet supports simple batched calls as well as [ERC-7821](https://eips.ethereum.org/EIPS/eip-7821): **Minimal Batch Executor Interface**, a standard which increases interoperability between dapps and contract implementations.
</file>

<file path="docs/contracts/smart-wallet/concepts/03-gas-transactions.md">
---
id: gas-abstraction
title: Gas Abstraction
sidebar_position: 3
---

Gas abstraction allows users to transact without needing to have a balance of ETH to pay for gas fees. Instead, a third party called a [bundler](https://www.alchemy.com/overviews/what-is-a-bundler) can cover or manage those fees on their behalf.

Our smart wallet implements [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337): **Account Abstraction Using Alt Mempool**, a widely adopted standard within the industry.

By default, EntryPoint v0.8 (0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108) is enabled on the account. This can be disabled or changed by the root signer - please exercise caution as this can lead to a loss of funds. 

You can view details about the deployment of the EntryPoint contract [here](https://github.com/eth-infinitism/account-abstraction/releases). It is considered a public good deployed by the community.
</file>

<file path="docs/contracts/smart-wallet/_category_.json">
{
  "label": "Smart Wallet",
  "position": 3,
  "collapsed": true
}
</file>

<file path="docs/contracts/smart-wallet/01-overview.md">
---
id: overview
title: Overview
sidebar_position: 1
---

Uniswap smart wallet features are powered by the Calibur contract which is meant to be used alongside [EIP-7702.](https://eips.ethereum.org/EIPS/eip-7702)

Calibur is a singular contract which has been deployed to the same address across all supported networks. For more details, see the [Deployments](./02-deployments.md) page below. It is non upgradeable and has no owner.

Curious about the name? 

> Introducing Calibur, a derivation of *Excalibur* and a nod to the mythical sword's reputation as a symbol of rightful authority and exceptional power.
>
</file>

<file path="docs/contracts/smart-wallet/02-deployments.md">
---
id: deployments
title: Deployments
sidebar_position: 2
---



## Deployment Addresses

| Network | Address | Commit Hash | Version |
|---------|---------|------------|---------|
| Mainnet | 0x000000009B1D0aF20D8C6d0A44e162d11F9b8f00 | 35d80918e120d177a49d3d90bcd4dd011caedd32 | v1.0.0 |
| Unichain | 0x000000009B1D0aF20D8C6d0A44e162d11F9b8f00 | 35d80918e120d177a49d3d90bcd4dd011caedd32 | v1.0.0 |
| Base | 0x000000009B1D0aF20D8C6d0A44e162d11F9b8f00 | 35d80918e120d177a49d3d90bcd4dd011caedd32 | v1.0.0 |
| Optimism | 0x000000009B1D0aF20D8C6d0A44e162d11F9b8f00 | 35d80918e120d177a49d3d90bcd4dd011caedd32 | v1.0.0 |
| BNB | 0x000000009B1D0aF20D8C6d0A44e162d11F9b8f00 | 35d80918e120d177a49d3d90bcd4dd011caedd32 | v1.0.0 |
| Unichain Sepolia | 0x000000009B1D0aF20D8C6d0A44e162d11F9b8f00 | 35d80918e120d177a49d3d90bcd4dd011caedd32 | v1.0.0 |
| Sepolia | 0x000000009B1D0aF20D8C6d0A44e162d11F9b8f00 | 35d80918e120d177a49d3d90bcd4dd011caedd32 | v1.0.0 |

### Github Repository

https://github.com/Uniswap/calibur

### Audits

https://github.com/Uniswap/calibur/tree/main/audits
</file>

<file path="docs/contracts/smart-wallet/03-technical-reference.md">
---
id: technical-reference
title: Technical Reference
sidebar_position: 5
---

For more details, see the [technical reference](https://github.com/Uniswap/calibur/tree/main/docs).

### Important Integration Callouts

The Calibur contracts are open sourced and MIT licensed. While anyone is free to build off of them, it is extremely important that integrators protect against certain known integration pitfalls.

- By default, registered keys do not expire and they do not have any hooks attached to them. While they are not admin keys and thus cannot self-call (callback into the Calibur contract), they can still spend any token and ETH balances.
- An admin key added to the account can add other keys with any expiration or admin status
- It is possible to pass along hookData to hooks for extra verification. This data is arbitrary and hook developers MUST verify its uniqueness and integrity.
- The contract does not enforce that the User Verification flag is set in Webauthn signatures
- Signatures from the private key of the EOA are always valid on the Calibur contracts. Those from alternative signers can be invalidated if desired by calling `updateSalt`, which will update the account’s EIP712 domain separator.
- It is completely valid to not execute the ERC7739 rehash code path on a signature originating from the root EOA. This is because this contract makes an assumption that IF the root key is registered on another wallet, that wallet is responsible for rehashing.
- Undelegating and redelegating may leave your account exposed to dirtied storage. Proceed with caution when redelegating to another contract.

For a comprehensive list of best practices, reference the documentation in the Github repository, past audit reports, and inline comments in the contract code.
</file>

<file path="docs/contracts/the-compact/reference/_category_.json">
{
  "label": "Technical Reference",
  "position": 2,
  "collapsed": false
}
</file>

<file path="docs/contracts/the-compact/reference/allocators.md">
---
id: allocators
title: Allocators
sidebar_position: 4
---

Allocators are crucial infrastructure components in The Compact protocol that ensure resource lock integrity and prevent double-spending.

## Role and Responsibilities

Each resource lock is mediated by an allocator with four primary responsibilities:

1. **Preventing Double-Spending**: Ensuring sponsors don't commit the same tokens to multiple compacts or transfer away committed funds
2. **Validating Transfers**: Attesting to standard ERC6909 transfers of resource lock tokens
3. **Authorizing Claims**: Validating claims against resource locks
4. **Nonce Management**: Ensuring nonces are not reused for claims

## Registration

Allocators must be registered with The Compact before they can be assigned to locks.

### Registration Requirements

Anyone can register an allocator if one of three conditions is met:
- The caller is the allocator address being registered
- The allocator address contains code
- A proof is supplied representing valid create2 deployment parameters

### Registration Function

```solidity
function __registerAllocator(
    address allocator,
    bytes calldata proof
) external returns (uint96 allocatorId)
```

### Create2 Proof Format

When registering an allocator that doesn't yet exist but will be deployed via create2, provide an 85-byte proof:
```
0xff ++ factory ++ salt ++ initcode hash
```

This allows pre-registration of deterministic addresses.

## IAllocator Interface

All allocators must implement the `IAllocator` interface:

### attest Function

Called on standard ERC6909 transfers to validate them:

```solidity
function attest(
    address operator,
    address from,
    address to,
    uint256 id,
    uint256 amount
) external returns (bytes4)
```

**Requirements**:
- Must verify the transfer is safe
- Must return `IAllocator.attest.selector` on success

### authorizeClaim Function

Called by The Compact during claim processing for on-chain authorization:

```solidity
function authorizeClaim(
    bytes32 claimHash,
    address arbiter,
    address sponsor,
    uint256 nonce,
    uint256 expires,
    uint256[2][] calldata idsAndAmounts,
    bytes calldata allocatorData
) external returns (bytes4)
```

**Parameters**:
- `claimHash`: The hash of the claim being processed
- `arbiter`: The arbiter processing the claim
- `sponsor`: The sponsor of the compact
- `nonce`: The nonce for replay protection
- `expires`: Expiration timestamp
- `idsAndAmounts`: Array of [id, amount] pairs
- `allocatorData`: Custom data (e.g., signatures)

**Requirements**:
- Must return `IAllocator.authorizeClaim.selector` on success

### isClaimAuthorized Function

Off-chain view function to check if a claim would be authorized:

```solidity
function isClaimAuthorized(
    bytes32 claimHash,
    address arbiter,
    address sponsor,
    uint256 nonce,
    uint256 expires,
    uint256[2][] calldata idsAndAmounts,
    bytes calldata allocatorData
) external view returns (bool)
```

Should perform the same authorization checks as `authorizeClaim` but as a view function.

## Allocator Data

The `allocatorData` parameter allows allocators to implement custom authorization logic:

- Can contain signatures from off-chain systems
- May include merkle proofs or other authorization evidence
- The format is entirely defined by each allocator implementation

## Nonce Management

Allocators can directly consume nonces to invalidate compacts:

```solidity
function consume(uint256 nonce) external
```

This emits a `NonceConsumedDirectly` event and prevents any compact using that nonce from being claimed.

Check if a nonce has been consumed:
```solidity
function hasConsumedAllocatorNonce(
    address allocator,
    uint256 nonce
) external view returns (bool)
```

## Implementation Patterns

### On-chain Allocators

Purely on-chain allocators can:
- Track balances in contract storage
- Implement authorization logic directly
- Use on-chain randomness or oracles

### Hybrid Allocators

Combine on-chain and off-chain components:
- Off-chain tracking and signature generation
- On-chain signature verification
- Balance attestation via `allocatorData`

### Sample Implementations

Two basic sample implementations are available:

- **[Smallocator](https://github.com/uniswap/smallocator)**: A minimal implementation
- **[Autocator](https://github.com/uniswap/autocator)**: An automated allocator

## Trust Assumptions

### For Sponsors
- Allocators won't unduly censor valid requests against fully funded locks
- Sponsors can initiate forced withdrawals if allocators become unresponsive

### For Claimants
- Allocators are sound and won't allow resource locks to become underfunded
- Allocators will properly track and enforce balance constraints

## Forced Withdrawal Mechanism

To protect sponsors from unresponsive or malicious allocators, The Compact implements a forced withdrawal mechanism that allows sponsors to bypass allocator authorization after a waiting period.

### How It Works

1. **Initiation**: A sponsor calls `enableForcedWithdrawal(uint256 id)` to signal their intent to withdraw without allocator approval.
2. **Timelock Period**: The protocol enforces a waiting period equal to the resource lock's `resetPeriod`.
3. **Execution**: After the timelock expires, the sponsor can call `forcedWithdrawal(uint256 id, address recipient, uint256 amount)` to withdraw the underlying tokens.

A sponsor can call `disableForcedWithdrawal(uint256 id)` at any time before execution to cancel the process. Once their withdrawal status has been set as enabled, that state will persist until it is explicitly disabled; should they wish to utilize the underlying resource lock again, the withdrawal status will first need to be disabled.

### Functions

```solidity
// Enable forced withdrawal for a resource lock
function enableForcedWithdrawal(uint256 id) external

// Disable a pending forced withdrawal
function disableForcedWithdrawal(uint256 id) external

// Execute forced withdrawal after timelock expires
function forcedWithdrawal(
    uint256 id,
    address recipient,
    uint256 amount
) external
```

### Security Considerations

- The timelock period provides adequate notice to all parties about the withdrawal intent
- This prevents sudden balance changes that could lead to equivocation
- The reset period is chosen by the sponsor when creating the resource lock
- Shorter reset periods provide faster exit but may offer less security to claimants

### Checking Withdrawal Status

```solidity
function getForcedWithdrawalStatus(
    address account,
    uint256 id
) external view returns (ForcedWithdrawalStatus status, uint256 withdrawableAt)
```

Status can be:
- `Disabled`: No forced withdrawal is pending
- `Pending`: Withdrawal initiated but timelock not expired
- `Enabled`: Timelock expired and withdrawal can be executed


## Events

```solidity
event AllocatorRegistered(
    uint96 allocatorId,
    address allocator
)

event NonceConsumedDirectly(
    address indexed allocator,
    uint256 nonce
)
```

## Error Handling

Common allocator-related errors:
- `InvalidAllocation(address allocator)`: Invalid allocator used
- `InvalidBatchAllocation()`: Batch allocation is invalid
- `InvalidRegistrationProof(address allocator)`: Registration proof is invalid
- `InconsistentAllocators()`: Allocators are inconsistent across batch operations
- `InvalidNonce(address account, uint256 nonce)`: Nonce is invalid or already consumed
</file>

<file path="docs/contracts/the-compact/reference/arbiters.md">
---
id: arbiters
title: Arbiters
sidebar_position: 5
---

Arbiters are entities responsible for verifying and submitting claims against resource locks in The Compact protocol. When a sponsor creates a compact, they assign an arbiter per chain. That arbiter is the sole account that can trigger a claim against the compact on the respective chain and determines which accounts receive the locked balances and in what amounts.

## Role and Responsibilities

Arbiters serve as intermediaries between sponsors and claimants with these key responsibilities:

1. **Claim Verification**: Validate that claim conditions are met before submission
2. **Claim Submission**: Submit claims to The Compact on behalf of claimants
3. **Recipient Allocation**: Determine which accounts receive funds and their amounts
4. **Witness Data Validation**: Verify any witness data included in compacts
5. **Cross-chain Coordination**: For multichain compacts, coordinate claims across different chains

## Arbiter Selection

Arbiters are specified per compact or per element (in multichain compacts):

### Single and Batch Compacts
```solidity
struct Compact {
    address arbiter;    // The designated arbiter for this compact
    address sponsor;
    uint256 nonce;
    uint256 expires;
    // ...
}
```

### Multichain Compacts
```solidity
struct Element {
    address arbiter;    // Can be different per chain
    uint256 chainId;
    Lock[] commitments;
    Mandate mandate;    // Required for multichain
}
```

## Specifying Claimants

When submitting a claim, arbiters specify claimants through a `Component` struct that encodes both the recipient and the destination format:

```solidity
struct Component {
    uint256 claimant;  // Encodes both lockTag and recipient address
    uint256 amount;    // The amount of tokens to claim
}
```

### Claimant Encoding

The `claimant` field packs two pieces of information:
- **Upper 96 bits**: `bytes12 lockTag` (destination format)
- **Lower 160 bits**: `address recipient` (who receives the tokens)

### Destination Options

Based on the `lockTag` in the claimant field, arbiters can direct claimed resources to three different destinations:

#### 1. Direct Transfer (Keep as ERC6909)
When the `lockTag` matches the original resource lock's tag, the ERC6909 tokens are transferred directly to the recipient. This maintains the same lock properties (allocator, reset period, scope).

#### 2. Convert to New Resource Lock
When the `lockTag` is non-zero but different from the original, the tokens are converted to a new resource lock with different properties. This allows changing allocators, reset periods, or scopes while keeping funds locked.

#### 3. Withdraw to Underlying Token
When the `lockTag` is `bytes12(0)`, the ERC6909 tokens are burned and the underlying tokens (native or ERC20) are withdrawn to the recipient. This fully exits The Compact system.

:::important
To prevent griefing attacks (e.g., via malicious receive hooks or intentionally underpaying gas), The Compact implements a withdrawal fallback mechanism:  

1. The protocol first attempts withdrawals with half the available gas
2. If this fails (and sufficient gas remains above a benchmarked stipend), it falls back to a direct ERC6909 transfer to the recipient
<br/>
This mechanism ensures that claims cannot be maliciously blocked through receive hook manipulation, while still preserving the intended withdrawal functionality under normal conditions.
<br/>
The required gas stipends for this fallback are determined through benchmarking, which measures:

- Cold account access costs
- Typical ERC20 transfer gas requirements
- Native token transfer gas requirements

The benchmark can be re-run at any time through a call to `__benchmark`.
:::

### Example
```solidity
// Example: Arbiter specifying three different destinations
Component[] memory claimants = new Component[](3);

// Direct transfer - keep same lock properties
claimants[0] = Component({
    claimant: uint256(uint160(alice)) | (uint256(originalLockTag) << 160),
    amount: 100e18
});

// Convert to new lock with different allocator
claimants[1] = Component({
    claimant: uint256(uint160(bob)) | (uint256(newLockTag) << 160),
    amount: 50e18
});

// Withdraw to underlying token
claimants[2] = Component({
    claimant: uint256(uint160(charlie)), // lockTag is 0
    amount: 25e18
});
```

## Submitting Claims

Arbiters submit claims using one of six available claim functions based on:
- **Single vs Batch**: Whether claiming against one or multiple resource locks on a chain
- **Single-chain vs Multichain**: Whether the compact spans one or multiple chains
- **Notarized vs Exogenous** (multichain only): Whether claiming on the primary signed chain or other chains

### Single-Chain Claims

#### claim (Compact)
For single resource lock on a single chain:
```solidity
function claim(Claim calldata claimPayload) external returns (bytes32 claimHash)
```

#### batchClaim (BatchCompact)
For multiple resource locks on a single chain:
```solidity
function batchClaim(BatchClaim calldata claimPayload) external returns (bytes32 claimHash)
```

### Multichain Claims

#### multichainClaim (MultichainCompact - Notarized)
For single resource lock on the notarized chain (domain matches signature):
```solidity
function multichainClaim(
    MultichainClaim calldata claimPayload
) external returns (bytes32 claimHash)
```

#### exogenousClaim (MultichainCompact - Exogenous)
For single resource lock on exogenous chains (not the notarized chain):
```solidity
function exogenousClaim(
    ExogenousMultichainClaim calldata claimPayload
) external returns (bytes32 claimHash)
```

#### batchMultichainClaim (BatchMultichainClaim - Notarized)
For multiple resource locks on the notarized chain:
```solidity
function batchMultichainClaim(
    BatchMultichainClaim calldata claimPayload
) external returns (bytes32 claimHash)
```

#### exogenousBatchClaim (BatchMultichainClaim - Exogenous)
For multiple resource locks on exogenous chains:
```solidity
function exogenousBatchClaim(
    ExogenousBatchMultichainClaim calldata claimPayload
) external returns (bytes32 claimHash)
```

## Trust Model

### For Sponsors
- Sponsors trust arbiters to:
  - Only submit valid claims that meet agreed-upon conditions
  - Not collude with claimants to drain resource locks prematurely
  - Properly verify witness data before claim submission

### For Claimants
- Claimants trust arbiters to:
  - Submit claims promptly when conditions are met
  - Not censor valid claims
  - Distribute claimed resources according to compact terms

## Arbiter Authorization

When an arbiter submits a claim, The Compact verifies authorization in this order:

1. **Arbiter is Caller**: The `msg.sender` must match the arbiter specified in the compact
2. **Claim Validity**: The claim must be valid (not expired, correct nonce, etc.)
3. **Sponsor Signature**: The sponsor's signature must authorize the compact (unless registered)
4. **Allocator Authorization**: The allocator must approve the claim

## Best Practices

### For Arbiter Selection
- Choose arbiters with proven track records
- Consider using decentralized arbiter networks for reduced trust requirements
- Implement arbiter reputation systems for accountability

### For Arbiter Implementation
- Validate all claim parameters before submission
- Implement robust witness data verification
- Maintain audit logs of all claim submissions
- Use secure key management for arbiter accounts

## Common Patterns

### Automated Arbiters
Smart contracts can act as arbiters to provide trustless claim verification:
- Oracle-based arbiters that verify external conditions
- Time-locked arbiters for scheduled releases
- Multi-signature arbiters requiring multiple approvals

### Arbiter Networks
Multiple arbiters can be coordinated through:
- Consensus mechanisms for claim approval
- Reputation-based selection systems
- Stake-based security models

## Error Handling

Common arbiter-related errors:
- `InvalidArbiter()`: The caller is not the designated arbiter
- `ClaimExpired()`: The claim has passed its expiration time
- `InvalidClaimSignature()`: The sponsor's signature is invalid
- `UnauthorizedClaim()`: The arbiter is not authorized for this claim

## Events

Key events related to arbiter actions:
```solidity
event Claim(
    address indexed sponsor,
    address indexed allocator,
    address indexed arbiter,
    bytes32 claimHash,
    uint256 nonce
)
```

## Security Considerations

### Arbiter Compromise
- If an arbiter's key is compromised, they could submit unauthorized claims
- Sponsors should monitor for suspicious claim activity
- Consider using time delays or multi-signature requirements for high-value compacts

### Arbiter Censorship
- Arbiters could refuse to submit valid claims
- Sponsors can mitigate by:
  - Using multiple arbiters
  - Implementing arbiter replacement mechanisms
  - Setting appropriate expiration times

### Front-running Protection
- Arbiters should use private mempools or commit-reveal schemes when appropriate
- Consider using flashbot bundles for sensitive claims
</file>

<file path="docs/contracts/the-compact/reference/compacts-eip712.md">
---
id: compacts-eip712
title: Compacts & EIP-712
sidebar_position: 2
---

A **compact** is an agreement created by a sponsor that allows their locked resources to be claimed under specified conditions. The Compact protocol uses EIP-712 typed structured data for creating and verifying signatures for these agreements.

## Compact Types

### 1. Single Compact
For single resource lock operations on a single chain.

```solidity
struct Compact {
    address arbiter;    // The account tasked with verifying and submitting the claim
    address sponsor;    // The account to source the tokens from
    uint256 nonce;      // A parameter to enforce replay protection, scoped to allocator
    uint256 expires;    // The time at which the claim expires
    bytes12 lockTag;    // A tag representing the allocator, reset period, and scope
    address token;      // The locked token, or address(0) for native tokens
    uint256 amount;     // The amount of ERC6909 tokens to commit from the lock
    // (Optional) Witness data may follow:
    // Mandate mandate;
}
```

### 2. Batch Compact
For allocating multiple resource locks on a single chain.

```solidity
struct BatchCompact {
    address arbiter;            // The account tasked with verifying and submitting the claim
    address sponsor;            // The account to source the tokens from
    uint256 nonce;              // A parameter to enforce replay protection, scoped to allocator
    uint256 expires;            // The time at which the claim expires
    Lock[] commitments;         // The committed locks with lock tags, tokens, & amounts
    // (Optional) Witness data may follow:
    // Mandate mandate;
}

struct Lock {
    bytes12 lockTag;    // A tag representing the allocator, reset period, and scope
    address token;      // The locked token, or address(0) for native tokens
    uint256 amount;     // The maximum committed amount of tokens
}
```

### 3. Multichain Compact
For allocating one or more resource locks across multiple chains.

```solidity
struct MultichainCompact {
    address sponsor;     // The account to source the tokens from
    uint256 nonce;       // A parameter to enforce replay protection, scoped to allocator
    uint256 expires;     // The time at which the claim expires
    Element[] elements;  // Arbiter, chainId, commitments, and mandate for each chain
}

struct Element {
    address arbiter;            // The account tasked with verifying and submitting the claim
    uint256 chainId;            // The chainId where the tokens are located
    Lock[] commitments;         // The committed locks with lock tags, tokens, & amounts
    // Witness data MUST follow (mandatory for multichain compacts):
    Mandate mandate;
}
```

## Witness Structure

The witness mechanism (`Mandate` struct) allows extending compacts with additional data for specifying conditions or parameters for a claim.

### Format
The witness is always a `Mandate` struct appended to the compact:

```solidity
Compact(..., Mandate mandate)Mandate(uint256 myArg, bytes32 otherArg)
```

### Witness Typestring
The `witnessTypestring` provided during a claim should be the arguments *inside* the `Mandate` struct (e.g., `uint256 myArg,bytes32 otherArg`), followed by any nested structs.

### Nested Structs
EIP-712 requires nested structs to be ordered alphanumerically after the top-level struct in the typestring. Prefix nested structs with "Mandate" (e.g., `MandateCondition`) to ensure correct ordering.

Example witness typestring:
```
MandateCondition condition,uint256 arg)MandateCondition(bool flag,uint256 val
```

> ⚠️ **Important**: Do not include the closing parenthesis in your witness typestring. It will be added by the protocol during dynamic typestring construction.

## Permit2 Integration

The Compact supports integration with Permit2 for gasless deposits:

### CompactDeposit
For basic Permit2 deposits:
```solidity
CompactDeposit(bytes12 lockTag,address recipient)
```

### Activation
Combines deposits with single compact registration:
```solidity
Activation(address activator,uint256 id,Compact compact)Compact(...)Mandate(...)
```

### BatchActivation
Combines deposits with batch compact registration:
```solidity
BatchActivation(address activator,uint256[] ids,Compact compact)Compact(...)Mandate(...)
```

## CompactCategory Enum

Used to distinguish between different types of compacts when using Permit2 integration:

```solidity
enum CompactCategory {
    Compact,        // 0
    BatchCompact,   // 1
    MultichainCompact // 2
}
```

## Registration

As an alternative to signing EIP-712 payloads, compacts can be registered directly on The Compact contract:

### Register Functions
```solidity
// Register a single compact
function register(bytes32 claimHash, bytes32 typehash) external;

// Register multiple compacts
function registerMultiple(bytes32[] calldata claimHashes, bytes32[] calldata typehashes) external;

// Register on behalf of sponsor
function registerFor(
    address sponsor,
    bytes32 claimHash,
    bytes32 typehash,
    bytes memory sponsorSignature
) external;
```

### Registration Event

When a compact is registered, the following event is emitted:

```solidity
event CompactRegistered(
    address indexed sponsor,
    bytes32 claimHash,
    bytes32 typehash
);
```

This event is emitted when a compact is registered via `register`, `registerMultiple`, or any of the combined deposit-and-register functions.

### Check Registration Status
```solidity
function isRegistered(
    address sponsor,
    bytes32 claimHash,
    bytes32 typehash
) external view returns (bool);
```

## Signature Verification

When a claim is submitted for a non-registered compact, The Compact verifies the sponsor's authorization in the following order:

1. **Caller is Sponsor**: If `msg.sender == sponsor`, authorization is granted
2. **ECDSA Signature**: Attempt standard ECDSA signature verification
3. **EIP-1271 `isValidSignature`**: If ECDSA fails, call `isValidSignature` on the sponsor's address
4. **Emissary `verifyClaim`**: If EIP-1271 fails, call the emissary's `verifyClaim` function
</file>

<file path="docs/contracts/the-compact/reference/core-interfaces.md">
---
id: core-interfaces
title: Core Interfaces
sidebar_position: 3
---

The Compact protocol is composed of several key interfaces that define its functionality.

## ITheCompact

The core interface for The Compact protocol, providing functions for deposits, transfers, registration, and management.

### Deposit Functions

#### Basic Deposits
```solidity
// Deposit native tokens
function depositNative(
    bytes12 lockTag,
    address recipient
) external payable returns (uint256 id);

// Deposit ERC20 tokens
function depositERC20(
    address token,
    bytes12 lockTag,
    uint256 amount,
    address recipient
) external returns (uint256 id);

// Batch deposits (native + ERC20)
function batchDeposit(
    uint256[2][] calldata idsAndAmounts,
    address recipient
) external payable returns (bool);
```

#### Permit2 Deposits
```solidity
// Single deposit via Permit2
function depositERC20ViaPermit2(
    ISignatureTransfer.PermitTransferFrom calldata permit,
    address depositor,
    bytes12 lockTag,
    address recipient,
    bytes calldata signature
) external returns (uint256 id);

// Batch deposit via Permit2
function batchDepositViaPermit2(
    address depositor,
    ISignatureTransfer.TokenPermissions[] calldata permitted,
    DepositDetails calldata details,
    address recipient,
    bytes calldata signature
) external payable returns (uint256[] memory ids);
```

#### Deposit + Register Combinations
```solidity
// Native deposit and register
function depositNativeAndRegister(
    bytes12 lockTag,
    bytes32 claimHash,
    bytes32 typehash
) external payable returns (uint256 id);

// Native deposit and register for another
function depositNativeAndRegisterFor(
    address recipient,
    bytes12 lockTag,
    address arbiter,
    uint256 nonce,
    uint256 expires,
    bytes32 typehash,
    bytes32 witness
) external payable returns (uint256 id, bytes32 claimHash);

// ERC20 deposit and register
function depositERC20AndRegister(
    address token,
    bytes12 lockTag,
    uint256 amount,
    bytes32 claimHash,
    bytes32 typehash
) external returns (uint256 id);

// ERC20 deposit and register for another
function depositERC20AndRegisterFor(
    address recipient,
    address token,
    bytes12 lockTag,
    uint256 amount,
    address arbiter,
    uint256 nonce,
    uint256 expires,
    bytes32 typehash,
    bytes32 witness
) external returns (uint256 id, bytes32 claimHash, uint256 registeredAmount);

// Batch deposit and register multiple
function batchDepositAndRegisterMultiple(
    uint256[2][] calldata idsAndAmounts,
    bytes32[2][] calldata claimHashesAndTypehashes
) external payable returns (bool);

// Batch deposit and register for another
function batchDepositAndRegisterFor(
    address recipient,
    uint256[2][] calldata idsAndAmounts,
    address arbiter,
    uint256 nonce,
    uint256 expires,
    bytes32 typehash,
    bytes32 witness
) external payable returns (bytes32 claimHash, uint256[] memory registeredAmounts);

// Deposit via Permit2 and register
function depositERC20AndRegisterViaPermit2(
    ISignatureTransfer.PermitTransferFrom calldata permit,
    address depositor,
    bytes12 lockTag,
    bytes32 claimHash,
    CompactCategory compactCategory,
    string calldata witness,
    bytes calldata signature
) external returns (uint256 id);

// Batch deposit via Permit2 and register
function batchDepositAndRegisterViaPermit2(
    address depositor,
    ISignatureTransfer.TokenPermissions[] calldata permitted,
    DepositDetails calldata details,
    bytes32 claimHash,
    CompactCategory compactCategory,
    string calldata witness,
    bytes calldata signature
) external payable returns (uint256[] memory ids);
```

### Allocated Transfers

```solidity
// Transfer single ID to multiple recipients with allocator approval
function allocatedTransfer(
    AllocatedTransfer calldata transfer
) external returns (bool);

// Transfer multiple IDs
function allocatedBatchTransfer(
    AllocatedBatchTransfer calldata transfer
) external returns (bool);
```

### Registration Functions

```solidity
// Register single compact
function register(
    bytes32 claimHash,
    bytes32 typehash
) external returns (bool);

// Register multiple compacts
function registerMultiple(
    bytes32[2][] calldata claimHashesAndTypehashes
) external returns (bool);

// Register compact on behalf of sponsor
function registerFor(
    bytes32 typehash,
    address arbiter,
    address sponsor,
    uint256 nonce,
    uint256 expires,
    bytes12 lockTag,
    address token,
    uint256 amount,
    bytes32 witness,
    bytes calldata sponsorSignature
) external returns (bytes32 claimHash);

// Register batch compact on behalf of sponsor
function registerBatchFor(
    bytes32 typehash,
    address arbiter,
    address sponsor,
    uint256 nonce,
    uint256 expires,
    bytes32 idsAndAmountsHash,
    bytes32 witness,
    bytes calldata sponsorSignature
) external returns (bytes32 claimHash);

// Register multichain compact on behalf of sponsor
function registerMultichainFor(
    bytes32 typehash,
    address sponsor,
    uint256 nonce,
    uint256 expires,
    bytes32 elementsHash,
    uint256 notarizedChainId,
    bytes calldata sponsorSignature
) external returns (bytes32 claimHash);
```

### Forced Withdrawals

```solidity
// Enable forced withdrawal
function enableForcedWithdrawal(
    uint256 id
) external returns (uint256 withdrawableAt);

// Disable forced withdrawal
function disableForcedWithdrawal(
    uint256 id
) external returns (bool);

// Execute forced withdrawal
function forcedWithdrawal(
    uint256 id,
    address recipient,
    uint256 amount
) external returns (bool);
```

### Management Functions

```solidity
// Emissary management
function assignEmissary(
    bytes12 lockTag,
    address emissary
) external returns (bool);

function scheduleEmissaryAssignment(
    bytes12 lockTag
) external returns (uint256 emissaryAssignmentAvailableAt);

// Allocator management
function __registerAllocator(
    address allocator,
    bytes calldata proof
) external returns (uint96 allocatorId);

// Consume nonces (for allocators)
function consume(
    uint256[] calldata nonces
) external returns (bool);

// Benchmark withdrawal costs
function __benchmark(bytes32 salt) external payable;
```

### View Functions

```solidity
function getLockDetails(uint256 id) external view returns (
    address token,
    address allocator,
    ResetPeriod resetPeriod,
    Scope scope,
    bytes12 lockTag
);

function isRegistered(
    address sponsor,
    bytes32 claimHash,
    bytes32 typehash
) external view returns (bool isActive);

function getForcedWithdrawalStatus(
    address account,
    uint256 id
) external view returns (
    ForcedWithdrawalStatus status,
    uint256 forcedWithdrawalAvailableAt
);

function getEmissaryStatus(
    address sponsor,
    bytes12 lockTag
) external view returns (
    EmissaryStatus status,
    uint256 emissaryAssignmentAvailableAt,
    address currentEmissary
);

function hasConsumedAllocatorNonce(
    uint256 nonce,
    address allocator
) external view returns (bool consumed);

function getRequiredWithdrawalFallbackStipends() external view returns (
    uint256 nativeTokenStipend,
    uint256 erc20TokenStipend
);

function DOMAIN_SEPARATOR() external view returns (bytes32);

function name() external pure returns (string memory);
```

## ITheCompactClaims

The claims interface provides endpoints for arbiters to settle compacts.

### Single Chain Claims

```solidity
// Standard single-chain, single-ID claim
function claim(Claim calldata claimPayload) external returns (bytes32 claimHash);

// Multiple IDs on a single chain
function batchClaim(BatchClaim calldata claimPayload) external returns (bytes32 claimHash);
```

### Multichain Claims

```solidity
// For the notarized chain of a multichain compact
function multichainClaim(
    MultichainClaim calldata claimPayload
) external returns (bytes32 claimHash);

// For an exogenous chain of a multichain compact
function exogenousClaim(
    ExogenousMultichainClaim calldata claimPayload
) external returns (bytes32 claimHash);

// Batch versions for multiple resource locks
function batchMultichainClaim(
    BatchMultichainClaim calldata claimPayload
) external returns (bytes32 claimHash);

function exogenousBatchClaim(
    ExogenousBatchMultichainClaim calldata claimPayload
) external returns (bytes32 claimHash);
```

### Claim Struct

```solidity
struct Claim {
    bytes allocatorData;
    bytes sponsorSignature;
    address sponsor;
    uint256 nonce;
    uint256 expires;
    bytes32 witness;
    string witnessTypestring;
    uint256 id;
    uint256 allocatedAmount;
    Component[] claimants;
}
```

### Component Struct

```solidity
struct Component {
    uint256 claimant; // The lockTag + recipient
    uint256 amount;   // The amount of tokens
}
```

The `claimant` field encodes both:
- **recipient** address (lower 160 bits)
- **bytes12 lockTag** (upper 96 bits)

This encoding determines processing:
1. **Direct Transfer**: If `lockTag` matches the claimed lock's tag
2. **Convert Lock**: If `lockTag` is non-zero but different
3. **Withdraw**: If `lockTag` is `bytes12(0)`

## IAllocator

Interface that allocators must implement.

```solidity
interface IAllocator {
    // Called on standard ERC6909 transfers
    function attest(
        address operator,
        address from,
        address to,
        uint256 id,
        uint256 amount
    ) external returns (bytes4);
    
    // Called during claim processing for on-chain authorization
    function authorizeClaim(
        bytes32 claimHash,
        address arbiter,
        address sponsor,
        uint256 nonce,
        uint256 expires,
        uint256[2][] calldata idsAndAmounts,
        bytes calldata allocatorData
    ) external returns (bytes4);
    
    // Off-chain view function
    function isClaimAuthorized(
        bytes32 claimHash,
        address arbiter,
        address sponsor,
        uint256 nonce,
        uint256 expires,
        uint256[2][] calldata idsAndAmounts,
        bytes calldata allocatorData
    ) external view returns (bool);
}
```

Return values:
- `attest` must return `IAllocator.attest.selector`
- `authorizeClaim` must return `IAllocator.authorizeClaim.selector`

## IEmissary

Interface for emissaries providing fallback claim verification.

```solidity
interface IEmissary {
    // Called only if all other sponsor verification methods fail
    function verifyClaim(
        address sponsor,
        bytes32 digest,
        bytes32 claimHash,
        bytes calldata signature,
        bytes12 lockTag
    ) external view returns (bytes4);
}
```

Must return `IEmissary.verifyClaim.selector` on successful verification.

## Key Events

```solidity
event Claim(
    address indexed sponsor,
    address indexed allocator,
    address indexed arbiter,
    bytes32 claimHash,
    uint256 nonce
);

event NonceConsumedDirectly(
    address indexed allocator,
    uint256 nonce
);

event ForcedWithdrawalStatusUpdated(
    address indexed account,
    uint256 indexed id,
    bool activating,
    uint256 withdrawableAt
);

event CompactRegistered(
    address indexed sponsor,
    bytes32 claimHash,
    bytes32 typehash
);

event AllocatorRegistered(
    uint96 allocatorId,
    address allocator
);

event EmissaryAssigned(
    address indexed sponsor,
    bytes12 indexed lockTag,
    address indexed emissary
);

event EmissaryAssignmentScheduled(
    address indexed sponsor,
    bytes12 indexed lockTag,
    uint256 assignableAt
);
```

## Key Errors

```solidity
error InvalidToken(address token);
error Expired(uint256 expiration);
error InvalidSignature();
error PrematureWithdrawal(uint256 id);
error ForcedWithdrawalFailed();
error ForcedWithdrawalAlreadyDisabled(address account, uint256 id);
error UnallocatedTransfer(address operator, address from, address to, uint256 id, uint256 amount);
error InvalidBatchAllocation();
error InvalidRegistrationProof(address allocator);
error InvalidBatchDepositStructure();
error AllocatedAmountExceeded(uint256 allocatedAmount, uint256 providedAmount);
error InvalidScope(uint256 id);
error InvalidDepositTokenOrdering();
error InvalidDepositBalanceChange();
error Permit2CallFailed();
error ReentrantCall(address existingCaller);
error InconsistentAllocators();
error InvalidAllocation(address allocator);
error ChainIndexOutOfRange();
error InvalidEmissaryAssignment();
error EmissaryAssignmentUnavailable(uint256 assignableAt);
error InvalidLockTag();
```

## ERC6909 Metadata

The Compact implements standard ERC6909 metadata functions:

```solidity
function name(uint256 id) external view returns (string memory);
function symbol(uint256 id) external view returns (string memory);
function decimals(uint256 id) external view returns (uint8);
function tokenURI(uint256 id) external view returns (string memory);
</file>

<file path="docs/contracts/the-compact/reference/periphery-contracts.md">
---
id: Periphery Contracts
title: Periphery Contracts
sidebar_position: 6
---

## Emissaries
Emissaries provide a fallback verification mechanism for sponsors when authorizing claims. This is particularly useful for:
1.  Smart contract accounts that might update their EIP-1271 signature verification logic.
2.  Accounts using EIP-7702 delegation that leverages EIP-1271.
3.  Situations where the sponsor wants to delegate claim verification to a trusted third party.

A sponsor assigns an emissary for a specific `lockTag` using [`assignEmissary`](./src/interfaces/ITheCompact.sol#L556). The emissary must implement the [`IEmissary`](./src/interfaces/IEmissary.sol) interface, specifically the `verifyClaim` function.

To change an emissary after one has been assigned, the sponsor must first call [`scheduleEmissaryAssignment`](./src/interfaces/ITheCompact.sol#L566), wait for the `resetPeriod` associated with the `lockTag` to elapse, and then call `assignEmissary` again with the new emissary's address (or `address(0)` to remove).

### IEmissary Interface

Emissaries must implement the `IEmissary` interface to integrate with The Compact:
```solidity
interface IEmissary {
    function verifyClaim(
        address sponsor,
        bytes32 digest,
        bytes32 claimHash,
        bytes calldata signature,
        bytes12 lockTag
    ) external view returns (bytes4)
}
```

**Requirements**:
- Must return `IEmissary.verifyClaim.selector` on successful verification

### Assignment and Management

#### Assigning an Emissary

Sponsors assign emissaries for specific lock tags:

```solidity
function assignEmissary(
    bytes12 lockTag,
    address emissary
) external
```

**Parameters**:
- `lockTag`: The specific resource lock tag this emissary will be authorized for
- `emissary`: The address of the emissary contract (or `address(0)` to remove)

The emissary assignment is scoped to a specific `lockTag`, meaning sponsors can have different emissaries for different resource locks.

#### Changing an Emissary

The emissary mechanism includes security timelocks to prevent sudden authorization changes:

1. **Schedule the Change**: Call `scheduleEmissaryAssignment` with the new emissary address
2. **Wait Period**: Wait for the `resetPeriod` associated with the `lockTag` to elapse
3. **Execute Assignment**: Call `assignEmissary` again with the new address

```solidity
function scheduleEmissaryAssignment(
    bytes12 lockTag,
    address newEmissary
) external
```

#### Removing an Emissary

To remove an emissary, assign `address(0)`:

```solidity
assignEmissary(lockTag, address(0))
```

#### Security Rationale

This timelock mechanism ensures that emissary changes cannot suddenly alter the authorization logic for outstanding compacts without providing adequate notice. This protects claimants who may have already begun fulfilling compact conditions based on the existing emissary.

### Role in Claim Verification

When a claim is submitted for a non-registered compact, The Compact verifies the sponsor's authorization in the following order:

1. **Caller is Sponsor**: If `msg.sender == sponsor`, authorization is granted
2. **ECDSA Signature**: Attempt standard ECDSA signature verification
3. **EIP-1271 `isValidSignature`**: If ECDSA fails, call `isValidSignature` on the sponsor's address (if it's a contract) with half the remaining gas
4. **Emissary `verifyClaim`**: If EIP-1271 fails or isn't applicable, and an emissary is assigned for the sponsor and `lockTag`, call the emissary's `verifyClaim` function

### Events

```solidity
event EmissaryAssigned(
    address indexed sponsor,
    bytes12 indexed lockTag,
    address emissary
)
```

Emitted when a sponsor assigns or changes an emissary via `assignEmissary`.

### Trust Assumptions

**Sponsors** must trust that emissaries will not authorize claims maliciously, as emissaries effectively have the same authorization power as the sponsor for claim verification.

**Claimants** must trust that emissaries (if assigned) will faithfully authorize valid claims. For EIP-7702 sponsors and smart contracts with upgradeable EIP-1271 logic, claimants should require the use of known, canonical emissaries that enforce delays before allowing key rotation.


## Tribunal 

Tribunal is a framework for processing cross-chain swap settlements against PGA (priority gas auction) blockchains. It ensures that tokens are transferred according to the mandate specified by the originating sponsor and enforces that a single party is able to perform the settlement in the event of a dispute.

:::note About Tribunal
Tribunal is a reference implementation, not part of The Compact core protocol. The Compact itself is an unopinionated primitive that doesn't depend on or have awareness of any specific settlement engine. Tribunal is included in this documentation as an example that demonstrates how developers can build cross-chain settlement systems on top of The Compact.
<br/>
Other teams can (and should) build their own settlement engines with different trust assumptions, auction mechanisms, or cross-chain messaging approaches. Tribunal simply shows one proven pattern for orchestrating cross-chain fills and settlements using The Compact's resource locks.
<br/>
**Status**: Tribunal is actively under development. For the latest updates and implementation details, see the [Tribunal repository](https://github.com/Uniswap/Tribunal).
:::

### How Tribunal Works

Fillers call `fill` and provide any native value necessary to pay for cross-chain messaging. Tribunal verifies expiry, chain IDs, validity conditions, computes hashes and amounts, and then executes the settlement:

* **Transfers the filled tokens to the intended recipient**
* **For same-chain fills**: Claims tokens via The Compact and calls back into the arbiter or recipient
* **For cross-chain fills**: Emits or processes directives that instruct remote arbiters to pull the claim

By enforcing a single settlement path, Tribunal eliminates disputes and ensures fairness even in the presence of multiple fillers. 

### Extending Tribunal

External bridge protocols can extend Tribunal by overriding internal functions to implement the relevant directive processing logic for passing a message to the arbiter on the claim chain (or ensure that the necessary state is updated to allow for the arbiter to "pull" the message themselves).
</file>

<file path="docs/contracts/the-compact/reference/resource-locks.md">
---
id: resource-locks
title: Resource Locks
sidebar_position: 1
---

Resource locks are the fundamental building blocks of The Compact protocol. They are created when a depositor places tokens (either native tokens or ERC20 tokens) into The Compact.

## Structure

Each resource lock has four key properties:

1. **Underlying Token**: The token held in the resource lock
2. **Allocator**: Tasked with cosigning on claims against the resource locks
3. **Scope**: Either spendable on any chain or limited to a single chain
4. **Reset Period**: For forcibly exiting the lock and for emissary reassignment timelocks

Each unique combination of these four properties is represented by a fungible ERC6909 tokenID. The owner of these ERC6909 tokens can act as a sponsor and create compacts.

## Lock Tag

Each resource lock is uniquely identified by a combination of:

1. **Underlying Token**: The address of the ERC20 token or native token held in the lock
2. **Allocator ID**: The ID of the entity responsible for authorizing uses of the lock, which consists of the 4-bit compact flag (shifted left by 88 bits) with the lowest 88 bits of the allocator address, resulting in a 92-bit value
3. **Scope**: Whether the lock can be spent on any chain (Multichain) or only on the same chain where the deposit occurred (Chain-specific)
4. **Reset Period**: The time that must elapse before a forced withdrawal can be completed. The reset period is one of eight predefined values, detailed in the section below.

The allocator ID, scope and reset period are encoded into a bytes12 lockTag, and the resource lock's unique ID (the ERC6909 tokenId) is derived by combining this lockTag with the underlying token address.

```solidity
lockTag = scope << 255 | resetPeriod << 252 | allocatorId << 160
lockId  = lockTag | tokenAddress
```

### Allocator ID Details

The compact flag is a 4-bit value (0-15) that represents how "compact" an allocator address is, based on the number of leading zero nibbles:
- If address has 0-3 leading zero nibbles: flag = 0
- If address has 4-17 leading zero nibbles: flag = (number of leading zeros - 3)
- If address has 18+ leading zero nibbles: flag = 15

Mathematically, the allocator ID can be represented as:

```solidity
compactFlag = min(max(0, leadingZeroNibbles - 3), 15)
id = (compactFlag << 88) | (allocator & 0x00000000000000000000FFFFFFFFFFFFFFFFFFFF)
```

### Reset Period Details

 The reset period is one of eight predefined values:

| Index | Reset Period Value        | Index | Reset Period Value        |
|-------|---------------------------|-------|---------------------------|
| 0     | `OneSecond`              | 4     | `OneHourAndFiveMinutes`  |
| 1     | `FifteenSeconds`         | 5     | `OneDay`                 |
| 2     | `OneMinute`              | 6     | `SevenDaysAndOneHour`    |
| 3     | `TenMinutes`             | 7     | `ThirtyDays`             |

## Creating Resource Locks

Resource locks are created by depositing tokens into The Compact. Multiple deposit methods are available:

### Native Token Deposits
```solidity
function depositNative(
    address recipient,
    bytes12 lockTag
) external payable returns (uint256 id)
```

### ERC20 Token Deposits
```solidity
function depositERC20(
    address token,
    address recipient,
    uint256 amount,
    bytes12 lockTag
) external returns (uint256 id)
```

### Batch Deposits
```solidity
function batchDeposit(
    DepositDetails[] calldata depositDetails
) external payable returns (uint256[] memory ids)
```

### Permit2 Integration
```solidity
function depositERC20ViaPermit2(
    ISignatureTransfer.PermitBatchTransferFrom memory permit,
    bytes memory signature
) external returns (uint256 id)
```

## Token Handling

### Native Tokens
For native tokens, The Compact mints an amount of ERC6909 tokens equal to the msg.value. For example, a native deposit with a value of 1e18 wei would result in exactly 1e18 ERC6909 tokens being minted to the caller (or specified recipient). A withdrawal of native underlying tokens from a resource lock causes a native value equal to the number of burned ERC6909 tokens to be transferred out of the contract.

### ERC20 Tokens
For ERC20 tokens, The Compact mints an amount of ERC6909 tokens equal to the actual balance change observed by the protocol as a result of an ERC20 deposit, accounting for the token's precision. In most cases, this is equal to the `amount` parameter passed to the token's `transfer`/`transferFrom` function, which is analogous to `msg.value`. One notable exception is fee-on-transfer tokens, where the actual and intended balance changes differ.

Deposits and withdrawals against an ERC20 resource lock are handled by:

- Checking the contract's balance before and after the token transfer
- Minting (or burning) an amount of ERC6909 tokens exactly equal to the observed balance change

### Fee-on-Transfer Tokens
The Compact correctly handles fee-on-transfer tokens for both deposits and withdrawals. The amount of ERC6909 tokens minted or burned is based on the *actual balance change* in The Compact contract, not just the specified amount.

:::warning Important Integration Notice

In order to support fee-on-transfer tokens, The Compact does not fully adhere to the Checks-Effects-Interactions (CEI) paradigm as part of deposits and withdrawals.
<br/>
If you are integrating with The Compact, particularly as an allocator, and are reading ERC6909 token balances, be aware that those balances may subsequently increase or decrease as part of the same transaction if the call executes a deposit, withdrawal, or claim against The Compact that in turn triggers a nested call to the integrator in question.
<br/>
To ensure that all balances are fully "settled," integrators should first ensure that the reentrancy guard on The Compact is not set via:

```solidity
require(
    TheCompact.exttload(0x0000000000000000000000000000000000000000000000929eee149b4bd21268) < 2,
    "Balance state may not be final on The Compact"
)
```

*Note: Use `extsload` instead of `exttload` on chains without `tstore` support.*

:::

### Rebasing Tokens
**Rebasing tokens (e.g., stETH) are NOT supported in The Compact V1.** Any yield or other balance changes occurring after deposit will not accrue to the depositor's ERC6909 tokens. For such assets, use their wrapped, non-rebasing counterparts (e.g., wstETH).

## Forced Withdrawals

Resource lock owners can initiate forced withdrawals if an allocator becomes unresponsive:

1. **Enable**: Call `enableForcedWithdrawal(uint256 id)`
2. **Wait**: The `resetPeriod` must elapse
3. **Withdraw**: Call `forcedWithdrawal(uint256 id, address recipient, uint256 amount)`

The forced withdrawal state can be reversed with `disableForcedWithdrawal(uint256 id)`.

## View Functions

Query resource lock details:
```solidity
function getLockDetails(uint256 id) external view returns (
    address token,
    address allocator,
    uint48 resetPeriod,
    Scope scope,
    bytes12 lockTag
)
```

Check forced withdrawal status:
```solidity
function getForcedWithdrawalStatus(
    address account,
    uint256 id
) external view returns (ForcedWithdrawalStatus status)
```

## Error Handling

Common errors when working with resource locks:
- `InvalidToken(address token)`: Invalid token address provided
- `InvalidLockTag()`: Invalid lock tag provided
- `InvalidDepositBalanceChange()`: Actual balance change doesn't match expectations
- `PrematureWithdrawal(uint256 id)`: Attempting withdrawal before reset period
- `ForcedWithdrawalFailed()`: Forced withdrawal operation failed
</file>

<file path="docs/contracts/the-compact/_category_.json">
{
  "label": "The Compact",
  "position": 7,
  "collapsed": true
}
</file>

<file path="docs/contracts/the-compact/overview.md">
---
id: overview
title: Overview
sidebar_position: 1
---

[The Compact 🤝](https://github.com/Uniswap/the-compact) is an ownerless ERC6909 contract that facilitates the voluntary formation and mediation of reusable **resource locks**. It enables tokens to be credibly committed to be spent in exchange for performing actions across arbitrary, asynchronous environments, and claimed once the specified conditions have been met.

## Key Components

### Resource Locks
Resource locks are created when depositors place tokens (ERC20 or native) into The Compact. Each lock is represented by an ERC6909 token with four key properties:
- The underlying token
- The allocator (prevents double-spending)
- The scope (single-chain or multichain)
- The reset period (for forced withdrawals)

### Compacts
A compact is a commitment created by a resource lock owner (sponsor) that allows tokens to be claimed under specified conditions. Compacts use EIP-712 typed structured data for signatures and can be:
- **Single**: One resource lock on one chain
- **Batch**: Multiple resource locks on one chain
- **Multichain**: Resource locks across multiple chains

### Key Actors

- **Sponsors**: Deposit tokens and create compacts
- **Allocators**: Prevent double-spending and validate transfers
- **Arbiters**: Verify conditions and process claims
- **Claimants**: Fulfill conditions and receive tokens
- **Emissaries**: Provide fallback signature verification

## How It Works

1. **Deposit**: Sponsors deposit tokens to create resource locks (ERC6909 tokens)
2. **Create Compact**: Sponsors sign or register compacts specifying conditions
3. **Fulfill**: Claimants meet the specified conditions
4. **Claim**: Arbiters verify and process claims to transfer tokens

## Trust Model

The Compact operates on a trust-minimized model where:
- Sponsors trust allocators won't censor valid requests (but can force withdraw if needed).
- Sponsors trust arbiters will only process valid claims.
- Claimants trust allocators will maintain lock integrity.
- Claimants trust arbiters will process valid claims.

The Compact V1 has undergone two independent security reviews by [OpenZeppelin](https://openzeppelin.com) and [Spearbit Cantina](https://cantina.xyz).

## Deployments

The Compact is deployed at the same address across multiple chains:

| Network | Address |
|---------|---------|
| Ethereum Mainnet | `0x00000000000000171ede64904551eeDF3C6C9788` |
| Base | `0x00000000000000171ede64904551eeDF3C6C9788` |
| Unichain | `0x00000000000000171ede64904551eeDF3C6C9788` |

> The Compact uses a deterministic deployment address, ensuring the same address across all supported networks.

The Compact uses a permissionless deployment process. Anyone can deploy the protocol to a new EVM chain by submitting a transaction with the same `to` and `data` arguments. This ensures the same deterministic address across all chains and enables the creation of compacts that commit resource locks across multiple chains.
</file>

<file path="docs/contracts/the-compact/resources.md">
---
id: resources
title: Resources
sidebar_position: 3
---

## Core Contracts

The foundation of The Compact protocol - an ERC6909-based system for reusable resource locks.

- **[TheCompact](https://github.com/Uniswap/the-compact)** - Main protocol implementation
- **[ITheCompact Interface](https://github.com/Uniswap/the-compact/blob/main/src/interfaces/ITheCompact.sol)** - Core interface definition
- **[ITheCompactClaims Interface](https://github.com/Uniswap/the-compact/blob/main/src/interfaces/ITheCompactClaims.sol)** - Claims interface
- **[License](https://github.com/Uniswap/the-compact/blob/main/LICENSE.md)** - MIT

## Peripheral Contracts

:::warning DEVELOPER WARNING
 These repositories are under development and are intended to serve as reference implementations for understanding peripheral contract functionality within The Compact. These are for testing/reference purposes only - do not use these contracts in production environments.
:::
### Reference Allocators

#### Smart Contract Allocators
**[Repository](https://github.com/Uniswap/sc-allocators)**

Various example allocator implementations for use with The Compact. Allocators co-sign or authorize claims against sponsors' locked balances, prevent under-allocation, and in the case of the HybridERC7683 implementation, broadcast cross-chain orders using ERC-7683. Some allocators also rely on Uniswap Tribunal. The provided examples include both fully on-chain and hybrid (on-chain + off-chain) allocators.

#### Smallocator (Off-chain)
**[Repository](https://github.com/uniswap/smallocator)**

A minimalistic server-based allocator for The Compact. Smallocator provides an API for sponsors to request resource lock allocations across multiple blockchains, with support for EIP-4361 session authentication and signing EIP-712 Compact messages. It also includes a frontend application for interacting directly with the server that also facilitates making deposits into resource locks it oversees.

#### Autocator (Off-chain)
**[Repository](https://github.com/uniswap/autocator)**

A server-based allocator for The Compact that leverages protocol signatures and transactions for authentication. Autocator provides an API for requesting resource lock allocations across multiple blockchains by providing the details of associated compacts with accompanying sponsor signatures or onchain registrations. It also includes a frontend application for interacting directly with the server that also facilitates making deposits into resource locks it oversees.

### Supporting Infrastructure

#### Emissary
**[Repository](https://github.com/Uniswap/emissary)**

An on-chain signature authority delegation registry with support for secp256k1 and P256 keys (both HSM and WebAuthn formats). Designed for use as a fallback signature validation mechanism.

#### Tribunal
**[Repository](https://github.com/Uniswap/Tribunal)**

Tribunal is an illustration for how processing cross-chain swap settlements against PGA (priority gas auction) blockchains. It ensures that tokens are transferred according to the mandate specified by the originating sponsor and enforces that a single party is able to perform the settlement in the event of a dispute.

#### Arbiters
**[Repository](http://github.com/Uniswap/arbiters)**

A repository for developing arbiter implementations that leverage The Compact for performing cross-chain swaps.
</file>

<file path="docs/contracts/uniswapx/fillers/arbitrum/_category_.json">
{
    "label": "Arbitrum",
    "position": 3,
    "collapsed": true
  }
</file>

<file path="docs/contracts/uniswapx/fillers/arbitrum/arbitrumfiller.md">
---
id: arbitrumfiller
title: Filling on Arbitrum
sidebar_position: 4
---

Unlike UniswapX on Mainnet, orders on Arbitrum have **no RFQ portion and thus no exclusivity**. Filling on Arbitrum, however, follows the same two steps as filling on Mainnet: 
1. Retrieving signed orders  
2. Filling orders

## Retrieving Signed Orders
All signed Dutch Orders on Arbitrum, created through the Uniswap UI will be available via the UniswapX Orders Endpoint. We have [swagger documentation](https://api.uniswap.org/v2/uniswapx/docs) but see below for a quick example curl.

```
GET https://api.uniswap.org/v2/orders?orderStatus=open&chainId=42161&limit=1000
```

Use the [UniswapX SDK](https://github.com/Uniswap/sdks/tree/main/sdks/uniswapx-sdk) to parse the `encodedOrder` field returned from endpoint. Each one of these `Orders` represents a fillable user trader. 

As a lower latency alternative to polling the API, fillers can also apply to register a webhook and receive a feed of all open orders. See details for registering [here](../webhooks)

## Filling Orders
To execute a discovered order, a filler needs to call the [execute](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/BaseReactor.sol#L31) method of the Reactor specified in the retrieved `encodedOrder` body. The Reactor used by the Uniswap interface is located at:  

[0xB274d5F4b833b61B340b654d600A864fB604a87c](https://arbiscan.io/address/0xb274d5f4b833b61b340b654d600a864fb604a87c)

Always confirm the address from the retrieved order before submitting. 

The simplest fill strategy is called `Direct Filler`, where the trade is executed directly against tokens held in the fillers address. To use this strategy, a filler can simply approve the order's output tokens to the reactor and call `execute` or `executeBatch` from their address. (see [source](https://github.com/Uniswap/UniswapX/blob/v2.0.0-deploy/src/reactors/BaseReactor.sol)):

```solidity
// Execute direct filler order
outputToken.approve(reactor, type(uint256).max);
reactor.execute(order);
```

More sophisticated fillers can implement arbitrarily complex strategies by deploying their own Executor contracts. This contract should implement the [IReactorCallback](https://github.com/Uniswap/UniswapX/blob/v2.0.0-deploy/src/interfaces/IReactorCallback.sol) interface, which takes in an order with input tokens and acquires the allotted number of output tokens for the caller. It must approve the output tokens to the reactor, which then transfers them to the order output recipients to settle the order. Executor contracts must call `reactor.executeWithCallback` or `reactor.executeBatchWithCallback`. They can also specify arbitrary callback data that will be passed into the `reactorCallback` call.

```solidity
contract Executor {
  function execute(Order calldata order, bytes calldata callbackData) {
    reactor.executeWithCallback(order, callbackData)
  }

  function reactorCallback(ResolvedOrder[] calldata orders, bytes calldata callbackData) {
    // implement strategy here
  }
}

// Execute custom fill strategy
address executor = /* Address of deployed executor contract */ ;
bytes fillData = /* Call data to be sent to your executor contract */;
executor.execute(order, fillData);
```

For convenience, we’ve provided an [example Executor Contract](https://github.com/Uniswap/UniswapX/blob/v2.0.0-deploy/src/sample-executors/SwapRouter02Executor.sol) which demonstrates how a filler could implement a strategy that executes a UniswapX order against a Uniswap V3 pool. These contracts should be deployed to each chain that the filler would like to support.

## Order Types
On Arbitrum, DutchV3 order types are supported. You may query for a specific type by specifying the `orderType` query string parameter:

```
GET https://api.uniswap.org/v2/orders?orderStatus=open&chainId=42161&limit=1000&orderType={Dutch_V2 | Dutch_V3}
```

DutchV3 orders use a block-based decay mechanism. This design takes advantage of Arbitrum's 250 ms block frequency, allowing for more granular price updates compared to time-based decay systems that are limited by the `block.timestamp`'s second-level granularity in the EVM. 

### Order Type References
| OrderType | Contract Address | Reactor Specification | Example Filler Implementation |
|-----------|------------------|----------------------|------------------------------|
| DutchV3 | `0xB274d5F4b833b61B340b654d600A864fB604a87c` | [V3DutchOrderReactor.sol](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/V3DutchOrderReactor.sol) | [dutchv3_strategy.rs](https://github.com/Uniswap/uniswapx-artemis/blob/main/src/strategies/dutchv3_strategy.rs) |
| DutchV2 (deprecated April 15, 2025) | `0x1bd1aAdc9E230626C44a139d7E70d842749351eb` | [V2DutchOrderReactor.sol](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/V2DutchOrderReactor.sol) | [uniswapx_strategy.rs](https://github.com/Uniswap/uniswapx-artemis/blob/main/src/strategies/uniswapx_strategy.rs) |


# Get in touch
- To keep up to date, join our [Announcements Channel](https://t.me/uniswapx_fillers)
- To ask questions and discuss, join our [Fillers Group](https://t.me/UniswapXdiscussion)
</file>

<file path="docs/contracts/uniswapx/fillers/mainnet/_category_.json">
{
    "label": "Mainnet",
    "position": 2,
    "collapsed": true
  }
</file>

<file path="docs/contracts/uniswapx/fillers/mainnet/becomeQuoter.md">
---
id: becomequoter
title: Become a Quoter
sidebar_position: 2
---

This guide provides step-by-step instructions for integrating as a Quoter on UniswapX. It is intended for experienced defi teams that have experience running similar systems on other protocols.

To ensure a smooth swapping experience for traders, the set of Quoters is vetted by Uniswap Labs. There are plans to make the quoting system fully permissionless in the future.

Once you've been approved to be a quoter by the Uniswap Labs team, follow the instructions below to complete your integration. If you have not been approved, please join the waitlist by filling out our [intake form](https://uniswap.typeform.com/to/UiPDKgY6).

## Getting Started as a Quoter
To participate as a quoter, you must host a service that adheres to the UniswapX RFQ API schema and responds to requests with quotes. The RFQ participant who submits the best quote for a given order will receive exclusive rights to fill it using their Executor during the _Exclusivity Period_ of the auction.

## Performance Expectations
To ensure a smooth experience for swappers and a fair auction process for quoters, we will hold participants to the following performance standards:

- ***500ms Response Time:*** Your server must respond to a request for a quote within **500ms**. If you cannot provide a quote, respond with a 204 status code.

Consistent failure to meet this standard may result in suspension from the system.

## Handling Fades & the Circuit Breaker
Quoters are expected to honor and execute the quotes they submit. If a quoter submits a winning quote but fails to fill the subsequent order, the "circuit breaker" will be triggered, temporarily disabling the quoter from receiving new requests.

- ***Cooldown Time:*** The cooldown period starts at 15 minutes for the first fade and increases exponentially for consecutive fades. More details on the cooldown calculation can be found in the [source code](https://github.com/Uniswap/uniswapx-parameterization-api/blob/bf87dcc0066fa21b72255f7155f5fbd04a518594/lib/cron/fade-rate-v2.ts#L215). 

## RFQ API Integration Details
To successfully receive and respond to UniswapX RFQ Quotes, you must have a publicly accessible endpoint that handles incoming quote requests according to the following schema:

### Request Schema:
```jsx
method: POST
content-type: application/json
data: {
    requestId: "string uuid - a unique identifier for swapper's request",
    tokenInChainId: "number - the `tokenIn` chainId",
    tokenOutChainId: "number - the `tokenOut` chainId",
    swapper: "string address - The swapper’s EOA address that will sign the order",
    tokenIn: "string address - The ERC20 token that the swapper will provide",
    tokenOut: "string address - The ERC20 token that the swapper will receive",
    amount: "string number - If the trade type is exact input then this is amount of `tokenIn` the user wants to swap otherwise this is amount of tokenOut the user wants to receive",
    type: "number - This is either `EXACT_INPUT` or `EXACT_OUTPUT`",
    quoteId: "string uuid - a unique identifier for the quote an integrator is sending back"
}
```

### Response Schema:
If you can fulfill the quote request, your server should respond with (status 200 - OK) and the following data:
```jsx
{
    chainId: "number - the chainId for the quoted token",
    amountIn: "string number - If the request type is exact input then this field is `amount` from the quote request, otherwise this is the provided quote",
    amountOut: "string number - If the request type is exact output then this field is `amount` from the quote request, otherwise this is the provided quote",
    filler: "string address - The executor address that you would like to have last-look exclusivity for this order"

    { ...The following fields should be echoed from the quote request...},
    requestId: "string uuid - a unique identifier for this quote request",
    swapper: "string address - The swapper’s EOA address that will sign the order",
    tokenIn: "string address - The ERC20 token that the swapper will provide",
    tokenOut: "string address - The ERC20 token that the swapper will receive",
    quoteId: "string uuid - a unique identifier for the quote an integrator is sending back"
}
```

If you do not wish to respond to a quote request, you must return an empty response with status code `204`.

### Schema When Disabled Due to Circuit Breaker
If you are an onboarded quoter who is currently disabled by the circuit breaker, your server will receive the following message on the same quote endpoint:

```jsx
method: POST
content-type: application/json
data: {
    blockUntilTimestamp: "timestamp - the timestamp that this quoter is disabled until"
}
```

## Moving to Production
All new quoter instances will start by being onboarded to our [Beta environment](https://beta.api.uniswap.org/v2/uniswapx/docs). Here, they will need to demonstrate at least **5 valid Exclusive RFQ fills** to be moved to production. The Beta environment serves valid mainnet orders that should be filled against production contracts but does not receive traffic from production interfaces.

### Steps to Move to Production

1. **Provide their quote server URL** to your Uniswap Labs contact along with the contract address you’re using to fill. We recommend that this be the same quoting infrastructure that you plan to run in production. 
2. **(Optional) Provide notification webhook URL** to you Uniswap Labs contact. We’ll set up notifications of won orders to be served there. Alternatively, you can poll the [Beta /orders Endpoint](https://beta.api.uniswap.org/v2/uniswapx/docs) for won orders. 
3. **Begin sending quotes and orders to beta** via the [UniswapX CLI](https://github.com/Uniswap/uniswapx-tool?tab=readme-ov-file#simple-order-creation). Reach out to the Uniswap team to be added to the private github.
4. **Send hashes of 5 filled transactions** that demonstrate that the integration was able to fill during the exclusive period; specifically before [decayStartTime](https://github.com/Uniswap/UniswapX/blob/abd7a0b080148fc42ef7c86536d14de714eec4c7/src/lib/ExclusiveDutchOrderLib.sol#L12)

The Uniswap Labs team will review the 5 transactions to confirm they were successful exclusive fills. Once they are confirmed, the quoters setup will be promoted to production and will start receiving traffic.
</file>

<file path="docs/contracts/uniswapx/fillers/mainnet/createFiller.md">
---
id: createfiller
title: Filling on Mainnet
sidebar_position: 1
---

There are two components to integrating as a filler: defining a filler execution strategy and retrieving & executing discovered orders.

## 1. Defining a Filler Execution Strategy

To execute a discovered order, a filler needs to call one of the `execute` methods ([source](https://github.com/Uniswap/UniswapX/blob/v1.1.0/src/reactors/BaseReactor.sol#L31)) of an Order Reactor, providing it with the orders to execute.

The simplest fill strategy is called `Direct Filler`, where the trade is executed directly against tokens held in the fillers address. To use this strategy, a filler can simply approve the order's output tokens to the reactor and call `execute` or `executeBatch` from their address. (see [source](https://github.com/Uniswap/UniswapX/blob/v1.1.0/src/reactors/BaseReactor.sol#L35)):

```solidity
// Execute direct filler order
outputToken.approve(reactor, type(uint256).max);
reactor.execute(order);
```

More sophisticated fillers can implement arbitrarily complex strategies by deploying their own Executor contracts. This contract should implement the [IReactorCallback](https://github.com/Uniswap/UniswapX/blob/v1.1.0/src/interfaces/IReactorCallback.sol) interface, which takes in an order with input tokens and acquires the allotted number of output tokens for the caller. It must approve the output tokens to the reactor, which then transfers them to the order output recipients to settle the order. Executor contracts must call `reactor.executeWithCallback` or `reactor.executeBatchWithCallback`. They can also specify arbitrary callback data that will be passed into the `reactorCallback` call.

```solidity
contract Executor {
  function execute(Order calldata order, bytes calldata callbackData) {
    reactor.executeWithCallback(order, callbackData)
  }

  function reactorCallback(ResolvedOrder[] calldata orders, bytes calldata callbackData) {
    // implement strategy here
  }
}

// Execute custom fill strategy
address executor = /* Address of deployed executor contract */ ;
bytes fillData = /* Call data to be sent to your executor contract */;
executor.execute(order, fillData);
```

For convenience, we’ve provided an [example Executor Contract](https://github.com/Uniswap/UniswapX/tree/v1.1.0/src/sample-executors) which demonstrates how a filler could implement a strategy that executes a UniswapX order against a Uniswap V3 pool. These contracts should be deployed to each chain that the filler would like to support.

## 2A. Retrieve & Execute Signed Dutch Orders

All signed Dutch Orders created through the Uniswap UI will be available via the UniswapX Orders Endpoint. We have [swagger documentation](https://api.uniswap.org/v2/uniswapx/docs) but see below for a quick example curl.

```
GET https://api.uniswap.org/v2/orders?orderStatus=open&chainId=1&limit=1
```

As a lower latency alternative to polling the API, fillers can also apply to register a webhook and receive a feed of all open orders. See details for registering [here](../webhooks). 

It’s up to the individual filler to architect their own systems for finding and executing profitable orders, but the basic flow is as follows:

1. Call `GET` on the `/orders` of the UniswapX Orders Endpoint as written above, to retrieve open signed orders. Dutch Orders are available on Mainnet (`chainId=1`) and Arbitrum (`chainId=42161`).
2. Decode returned orders using the [UniswapX SDK](https://github.com/Uniswap/UniswapX-sdk/#parsing-orders).
3. Determine which orders you would like to execute.
4. Send a new transaction to the [execute](https://github.com/Uniswap/UniswapX/blob/a2025e3306312fc284a29daebdcabb88b50037c2/src/reactors/BaseReactor.sol#L29) or [executeBatch](https://github.com/Uniswap/UniswapX/blob/a2025e3306312fc284a29daebdcabb88b50037c2/src/reactors/BaseReactor.sol#L37) methods of the [Dutch Order Reactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/DutchOrderReactor.sol) specifying the signed orders you’d like to fill and the address of your executor contract.

## 2B. Retrieve & Execute Signed Limit Orders
The process for retrieving and executing limit orders is the same as Dutch Orders above except that Limit Orders will be retrieved from the [Limit Orders Endpoint](https://api.uniswap.org/v2/limit-orders) (full API docs [here](https://api.uniswap.org/v2/uniswapx/docs)) and executed against the [Exclusive Dutch Order Reactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/ExclusiveDutchOrderReactor.sol). The process is: 

1. Call `GET` on the `/limit-orders` of the UniswapX Limit Orders Endpoint as written above, to retrieve open signed orders
2. Decode returned orders using the [UniswapX SDK](https://github.com/Uniswap/UniswapX-sdk/#parsing-orders)
3. Send a new transaction to the [execute](https://github.com/Uniswap/UniswapX/blob/a2025e3306312fc284a29daebdcabb88b50037c2/src/reactors/BaseReactor.sol#L29) or [executeBatch](https://github.com/Uniswap/UniswapX/blob/a2025e3306312fc284a29daebdcabb88b50037c2/src/reactors/BaseReactor.sol#L37) methods of the [Exclusive Dutch Order Reactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/ExclusiveDutchOrderReactor.sol) specifying the signed orders you’d like to fill and the address of your executor contract 

For Dutch and Limit Orders, if the order is valid it will be competing against other fillers attempts to execute it in a gas auction. For this reason, we recommend submitting these transactions through a service like [Flashbots Protect](https://docs.flashbots.net/flashbots-protect/overview).

## Helpful Links

- [UniswapX Fillers - Announcements channel](https://t.me/uniswapx_fillers)
- [UniswapX Fillers - Discussion](https://t.me/UniswapXdiscussion)
</file>

<file path="docs/contracts/uniswapx/fillers/mainnet/uniswapXrfq.md">
---
id: uniswapXrfq
title: UniswapX RFQ
sidebar_position: 3
---

UniswapX RFQ V2 is designed to improve price execution and minimize quoter gaming by redesigning the flow of order quote information. The primary goal is to make trading on Mainnet Ethereum more efficient and more reliable.

## **RFQ Overview**

UniswapX RFQ is architected such that the time between a quoter submitting their quote and being required to fill the order is minimized. This enforces a near 100% fill rate and causes most orders to fill almost instantly.

To achieve this, the quoting flow is divided into two phases:

1. **Indicative Quotes**: Provided pre-signature when the swapper is exploring quotes but has not committed to trading. Quoters can participate here without being held fully accountable.  
2. **Hard Quotes**: Provided post-signature when the swapper has committed to trading. Quoters are held fully accountable for these quotes.

Since hard quotes are provided post-signature, they are instantly executable by fillers removing the risk of market movements causing the order to fail.

To prevent gaming, quoters cannot distinguish between indicative and hard quotes. As a result, they must always assume all quotes are hard and provide competitive prices.

## V2 Flow
<p align="center">
  <img width="599" alt="image" src={require('../../images/v2-flow.png').default} />
</p>

1. The user requests a quote from the interface.  
2. The Uniswap Backend (URA) runs an indicative RFQ auction, soliciting quotes for the best price. (**Note:** Quoters do not know whether the RFQ is indicative or hard, forcing them to always provide competitive prices.)
3. The quotes from the RFQ process parameterize an [initial quote](https://github.com/Uniswap/UniswapX/blob/33fa564cfaa6d58f6e3fcf7e7988cb5fc1c61de7/src/lib/V2DutchOrderLib.sol#L31) order shown to the user.  
4. The user signs the order and submits it for execution.  
6. The Uniswap Backend (GPA) runs a second “hard” RFQ process, soliciting new quotes.  
6. Quoters return their best prices again.  
   * If the price is within or improves on the user’s signed parameters, it is finalized and added to the order’s [CosignerData](https://github.com/Uniswap/UniswapX/blob/33fa564cfaa6d58f6e3fcf7e7988cb5fc1c61de7/src/lib/V2DutchOrderLib.sol#L20).  
   * If the price moves outside the signed parameters, the order fails, and the user must try again.  
7. The finalized order containing CosignerData is posted to the filler network for execution.  
8. The winning filler executes the order.

## Why is a cosigner needed? 

In UniswapX RFQ, users commit to a range of prices when signing their order. Without safeguards, a malicious auctioneer could provide users the worst price within their range.
<p align="center">
  <img width="599" alt="image" src={require('../../images/cosigner.png').default} />
</p>

The cosigner field allows users to designate an auctioneer they trust to run the auction fairly, ensuring the best executable price within the signed parameters. Currently, the trading API sets the cosigner to Uniswap Labs, though this could be updated in the future.

## Current Status
UniswapX RFQ V2 is currently the default version of the protocol running on Mainnet across Uniswap's interfaces.


<details>
  <summary>How did previous versions of UniswapX RFQ work?</summary>

    In V1, the RFQ flow operated entirely pre-signature. Users requested a swap quote, which was parameterized using an RFQ quote. If they accepted the quote, they signed the order. This approach was straightforward but caused quoters in the network to be uncertain about when a quote request would convert into a signed order. This uncertainty led to occasional unfilled orders and degraded performance.
    <br/>
    <img width="599" alt="image" src={require('../../images/v1-flow.png').default} />
    

</details>


## Smart Contracts

* [V2DutchOrderReactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/V2DutchOrderReactor.sol)
</file>

<file path="docs/contracts/uniswapx/fillers/priority/_category_.json">
{
    "label": "Unichain, Base",
    "position": 4,
    "collapsed": true
  }
</file>

<file path="docs/contracts/uniswapx/fillers/priority/priorityorderreactor.md">
---
id: priorityorderreactor
title: Filling on Priority Chains
sidebar_position: 6
---

The [Priority Order Reactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/PriorityOrderReactor.sol) is a UniswapX reactor built specifically for chains that utilize Priority Gas Auctions (PGA) for ordering transactions. This reactor type, which is based on research presented in [Priority is All you Need](https://www.paradigm.xyz/2024/06/priority-is-all-you-need), allows fillers to bid on orders during fulfillment through setting custom priority fees. 

## Example Implementation
Alice submits a PriorityOrder offering 1 ETH in exchange for a minimum of 1000 USDC. The fair market rate for the order is 1100 USDC, resulting in around 100 USDC in potential profit. 

If we assume a filler has a desired margin of 10% of the total profit, the best price is 1090 USDC. This would be 900 bps of improvement. This filler would convert bps to mps (see below for details) to get 900 * 1000 = 900,000 mps of improvement. Thus they would set priorityFee of 900,000 wei on their fill transaction. Keep in mind that this is additional to the base fee.

## Important considerations
- The PriorityOrderReactor is only meant to be used on chains which order transactions by priority fee. 
- We do not plan to run any preliminary auctions for the start price of these orders, rather we set a minimum price that each order must be executed at.
- Each order is only executable after a certain block specified by the user. This block will be a few blocks in the future from when the order is made available through the UniswapX orders endpoint. To ensure the best UX for our users, Uniswap Labs has the ability to make the start block earlier by cosigning the order.
- Only the fill transaction with the highest priority fee will win the order, all other transactions will revert on chain.
- To minimize the gas used on reverting transactions, we revert early if the order is already filled or is not fillable yet.
- For every wei of priority fee above a certain threshold (an optional value specified in the order), the user is owed 1 milli-bps more of their output token (or less of their input token). 
- Milli-bps (or MPS) are one-thousandth of a basis point.
- Unichain supports specifying a target block and has revert protection. For more information, please see the [Unichain Docs](https://docs.unichain.org/docs/technical-information/advanced-txn).

## Retrieving and Executing Signed Orders
All signed Priority Orders created through the Uniswap UI will be available via the UniswapX Orders Endpoint. We have [swagger documentation](https://api.uniswap.org/v2/uniswapx/docs) but see below for a quick example curl.

```
GET https://api.uniswap.org/v2/orders?orderStatus=open&orderType=Priority
```

As a lower latency alternative to polling the API, fillers can also apply to register a webhook and receive a feed of all open orders. See details for registering [here](../webhooks). 

After fetching orders, use the latest version of the [UniswapX SDK](https://github.com/Uniswap/sdks/tree/main/sdks/uniswapx-sdk#parsing-orders). Requires [2.1.0-beta.13](https://www.npmjs.com/package/@uniswap/uniswapx-sdk/v/2.1.0-beta.13) or later.

### Parsing an order
```typescript
import { CosignedPriorityOrder, Order } from '@uniswap/uniswapx-sdk';

const serializedOrder = '0x1111222233334444555500000000234300234...';
const chainId = 130; 

const order: Order = CosignedPriorityOrder.parse(serializedOrder, chainId);

const orderData = order.info;
const orderHash = order.hash();
```

The existing `UniswapXOrderQuoter` can also be used to quote priority orders, however, you must use an JsonRpcProvider which supports block overrides. Without block overrides, the SDK quoter cannot validate the entire order as the block number is checked first in the contract.

## Executing an order
The [PriorityOrderReactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/PriorityOrderReactor.sol) shares the same interface as all other existing UniswapX reactors. Orders are executed against the `execute` and `executeBatch` functions, and optionally a callback is available via `executeWithCallback` and `executeBatchWithCallback`.

## Deployment addresses
The PriorityOrderReactor is deployed on the following chains:

| Chain | Source                                                                                                        | Address                                                                                                               |
| ----- | ------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------|
| Unichain | [PriorityOrderReactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/PriorityOrderReactor.sol) | [0x00000006021a6Bce796be7ba509BBBA71e956e37](https://uniscan.xyz/address/0x00000006021a6Bce796be7ba509BBBA71e956e37) |
| Base  | [PriorityOrderReactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/PriorityOrderReactor.sol)   | [0x000000001Ec5656dcdB24D90DFa42742738De729](https://basescan.org/address/0x000000001Ec5656dcdB24D90DFa42742738De729) |


## Timeline
The Priority Order Reactor is live on Unichain and Base. Join the [UniswapX Fillers Channel](https://t.me/UniswapXdiscussion) for more details.
</file>

<file path="docs/contracts/uniswapx/fillers/_category_.json">
{
  "label": "Fillers",
  "position": 5,
  "collapsed": false
}
</file>

<file path="docs/contracts/uniswapx/fillers/filleroverview.md">
---
id: filleroverview
title: Filler Overview
sidebar_position: 1
---

UniswapX is a permissionless auction-based protocol where fillers compete to execute user swaps at the best prices. Anyone can participate as a filler by winning these auctions.

This overview covers:
- The difference between quoters (Ethereum) and fillers (all chains)
- How to get started quoting or filling orders
- Common questions and troubleshooting

**Getting Started:**
- Join our [Announcements Channel](https://t.me/uniswapx_fillers) on Telegram for updates
- Join our [Fillers Group](https://t.me/UniswapXdiscussion) on Telegram for discussion
- To quote on Ethereum, join the [waitlist](https://uniswap.typeform.com/to/UiPDKgY6) or [email](mailto:quoters@uniswap.org)

## Quoters vs. Fillers

Ethereum Mainnet uses a two-role system (Quoters + Fillers) due to its 12-second blocks and high gas costs, while L2 chains use only Fillers thanks to their fast block times.

- On Ethereum Mainnet
    - **Quoters** (Permissioned): Provide off-chain quotes through RFQ and compete for exclusive fill rights
    - **Fillers** (Permissionless): Execute orders during Dutch auction if quoters fade or decline
- On L2 Chains  
    - **Fillers only** (Permissionless): All participants compete directly onchain without RFQ

This design ensures optimal price discovery: Ethereum needs off-chain quoting to avoid slow auctions, while L2s can efficiently discover prices onchain.

## Become a Quoter or Filler

### Become a Quoter
In the current Uniswap Labs interface implementation of UniswapX, some fillers may choose to help parameterize orders on Ethereum by participating as quoters. These fillers can *only* win a quote if they guarantee improved swap execution over Uniswap v2, v3 or v4 liquidity pools. Fillers who win a quote will receive execution priority for a limited period to fill orders for which they submitted winning quotes.

To ensure a smooth swapping experience for traders, the set of quoters are vetted by Uniswap Labs. To read about expectations for quoters, please see [Become a Quoter](docs/contracts/uniswapx/fillers/mainnet/becomeQuoter.md). If you are interested in participating as a quoter, please reach out [here](mailto:quoters@uniswap.org) or join the [waitlist](https://uniswap.typeform.com/to/UiPDKgY6).

### Become a Filler 
This documentation contains specific integration guides for each chain. Choose your chain to see specific integration details:

- [Ethereum](/contracts/uniswapx/fillers/mainnet/createFiller.md) - RFQ system with exclusive fill periods 
- [Arbitrum](/contracts/uniswapx/fillers/arbitrum/arbitrumfiller.md) - Direct Dutch auction with 0.25s blocks  
- [Unichain, Base](/contracts/uniswapx/fillers/priority/priorityorderreactor.md) - Priority gas auctions

:::note Auction Types
To learn about the different auction mechanics, please see the [Auction Types Overview](../03-auction-types.md) page. 
:::

Fillers should start with polling for orders and rate limit at 6rps. If after polling, a filler's performance is degraded due to the polling rate limit, please see the [Webhook Support](contracts/uniswapx/fillers/webhooks.md) documentation to learn about registering webhooks for orders.

## Filler FAQ

### Getting Started
<details>
  <summary>Which IPs do I need to whitelist?</summary>

    IPs to whitelist:
    <br/>
    **Beta Test Environment**
    - Quote requests: `3.135.148.114`
    - Order notification webhooks: `3.129.136.245`
    <br/>
    **Production Environment**
    - Quote requests: `3.138.88.28`
    - Order notification webhooks: `3.14.56.90`

</details>

<details>
  <summary>Why don’t I get quote requests for Unichain/Base/Arbitrum?</summary>

    On Ethereum, we use RFQ to accurately parameterize the order which often results in exclusive orders. On L2s, we don’t use RFQ and instead parameterize the auction solely based on the AMM price. As a result, we will only notify fillers of orders that are ready to be executed via the orders API or your registered webhook endpoint. Fill out this [onboarding form](https://forms.gle/FtqVhSinod9fZDNH8) if you would like your endpoint to be notified via webhook, but it is recommended that fillers try polling first and only pursue a webhook as needed. 
    <br/>
    For more information, please see our [Webhook Support Page](./webhooks.md).

</details>

<details>
  <summary>What's the expected RPS for quoting on Ethereum?</summary>

    1 RPS. 

</details>

<details>
  <summary>Which tokens are supported in RFQ?</summary>

    All tokens are supported, except those on the [unsupported token list](https://unsupportedtokens.uniswap.org/). 

</details>

### Technical Issues
<details>
  <summary>I’m getting 404, no quotes available?</summary>

  There are several reasons why you might receive this error:
  
  - **Price Impact**: UniswapX has filters that route trades to the AMM when direct AMM execution would be superior. If the price impact is too high or the benefit of routing through UniswapX isn't significant enough, no quote will be returned for this pair.
  
  - **Order Size**: Very small orders may not be economical to fill through UniswapX due to gas costs. Similarly, extremely large orders might exceed available liquidity from quoters.
  
  - **Response Latency**: If your filler responds but takes longer than 500ms, your quote will be rejected. Ensure your infrastructure can consistently respond within this latency requirement. The quote server is located in AWS `US-EAST-2` if you wish to co-locate to reduce latency.

</details>

<details>
  <summary>The transaction is reverting for a certain reason (e.g. `InvalidOrderFields`). What does this mean?</summary>

    Check the [KNOWN_ERRORS](https://github.com/Uniswap/sdks/blob/a7fb8d7b8eecdc8a29d386420339da86b0361a77/sdks/uniswapx-sdk/src/utils/OrderQuoter.ts#L70) in the SDK to see what the likely causes are.

</details>

<details>
  <summary>Why did my server stop receiving quote requests?</summary>

    Your server may be temporarily blocked due to our fade-rate monitor. If you win an RFQ but don't fill the order, this counts as a "fade." After too many fades, we temporarily stop sending you RFQs. 
    <br/>
    You'll know you're blocked when quote requests include a `blockUntilTimestamp` field indicating when you'll start receiving requests again.

</details>

<details>
  <summary>Why does my fill transaction fail the permit2 nonce check?</summary>

    A permit2 nonce check failure typically means:
    <br/>
    - The order has already been filled by another filler
    - The user cancelled the order
    - The signature has expired
    <br/>
    Before attempting to fill, verify the order is still valid. See: "How do I know if an order is still fillable?"

</details>

### Order Mechanics

<details>
  <summary>How do I know if an order is still fillable?</summary>

    The simulation using the [UniswapXOrderQuoter](https://github.com/Uniswap/sdks/blob/416793e034dd065fe3310f7c26b75c7255f610bb/sdks/uniswapx-sdk/src/utils/OrderQuoter.ts#L175) will tell you whether the order is still fillable.

</details>

<details>
  <summary>How is the OrderHash generated? Is it guaranteed to be unique?</summary>
    
    OrderHashes are generated from the hash of the witness information from the order, and are thus guarenteed to be cryptographically unique. 

</details>

<details>
  <summary>Why do I receive inverse requests for every quote (e.g. USDC\<\>ETH and ETH\<\>USDC)?</summary>

    We perform two quote requests per actual quote to obfuscate the swappers actual request to reduce the chances of front-running.

</details>
</file>

<file path="docs/contracts/uniswapx/fillers/webhooks.md">
---
id: webhooks
title: Webhook Support
sidebar_position: 5
---

Signed open orders can always be fetched via the UniswapX API, but to provide improved latency there is the option to register for webhook notifications. Fillers can register an endpoint and receive notifications for every newly posted order that matches their desired filter. It is recommended that fillers try polling first and only pursue a webhook if they feel their performance is degraded by the rate limit.

## Notifications

Order notifications will be sent to the registered endpoint as http requests from the ip `3.14.56.90`. The structure of the requests is as follows:

```jsx
method: POST
content-type: application/json
data: {
    orderHash: "the hash identifier for the order", 
    createdAt: "timestamp at which the order was posted",
    signature: "the swapper signature to include with order execution",
    orderStatus: "current order status (always should be `open` upon receiving notification)",
    encodedOrder: "The abi-encoded order to include with order execution. This can be decoded using the Uniswapx-SDK (https://github.com/uniswap/uniswapx-sdk) to verify order fields and signature",
    chainId: "The chain ID that the order originates from and must be settled on",
    filler?: "If this order was quoted by an RFQ participant then this will be their filler address",
    quoteId?: "If this order was quoted by an RFQ participant then this will be the requestId from the quote request",
    offerer?: "The swapper address",
    type?: "The order type (e.g. 'Dutch_V2', 'Limit', etc)"
}
```

## Filtering
Orders can be filtered by various fields. For quoters, the most common use case is to filter to their address so they are notified immediately of won bids. Alternatively the webhook can be configured to send all open orders to your endpoint.


## Request a Webhook
To register your webhook endpoint, please fill out our [onboarding form](https://forms.gle/FtqVhSinod9fZDNH8). Reach out in the [UniswapX Fillers - Discussion](https://t.me/UniswapXdiscussion) Telegram group with any questions.
</file>

<file path="docs/contracts/uniswapx/_category_.json">
{
  "label": "UniswapX",
  "position": 3,
  "collapsed": true
}
</file>

<file path="docs/contracts/uniswapx/01-overview.md">
---
id: overview
title: Overview
sidebar_position: 1
---

UniswapX is a permissionless, open source, auction-based swapping protocol for trading across AMMs and other liquidity sources. It improves swapping in several ways:

- Better prices by aggregating liquidity sources
- Gas-free swapping
- Protection against MEV (Maximal Extractable Value)
- No cost for failed transactions

Swappers generate signed orders which specify the outputs of their swap, and fillers compete to satisfy these orders using their own filling strategies.

## Trading on UniswapX
To trade using UniswapX, swappers create orders that define their auction parameters and price tolerance. Each supported chain uses different auction mechanisms optimized for its specific characteristics.

For example, the graphic below illustrates a Dutch Auction, one type of auction used in UniswapX. In this auction, the order starts at a maximum price and decays down to a minimum price over time. Note that orders technically specify output token amounts, but the documentation will sometimes use 'price' interchangeably for simplicity.

 <img src={require('./images/Uniswapx_graph.png').default} alt="UniswapX" width="100%%" /> 

Instead of submitting these orders directly onchain, swappers sign a message that uses Permit2 to allow the transfer of tokens to complete the trade as long as the number of tokens sent and received matches what is specified in the decay curve. These signed order messages are broadcast publicly and available to be executed by anyone who wants to be a "filler."

Once an order is broadcast, fillers race to submit these orders onchain as soon as it is economically profitable for them to do so. The realized price for an order is based on when the order is filled by the first successful filler within the auction timeline. Some auctions use the block timestamp to determine the price, and some use the block number.

:::info Auction Types
Different chains use different auction mechanisms. See our [Auction Types Overview](/contracts/uniswapx/auctiontypes) for details.
:::

## Fillers on UniswapX
As mentioned above, UniswapX introduces a new participant in the Uniswap ecosystem, the Filler. Fillers are sophisticated entities who perform complex calculations and employ MEV-protected strategies to pick up signed orders and execute them to achieve the most profitable fill. 

:::info Getting Started as a Filler
Anyone can fill orders on UniswapX. Get started by reading our [Filler Integration Overview](/contracts/uniswapx/fillers/filleroverview.md).
:::
</file>

<file path="docs/contracts/uniswapx/02-architecture.md">
---
id: architecture
title: Architecture
sidebar_position: 2
---

<!-- ![Architecture](./assets/uniswapx-architecture.png) -->
<img src={require('./images/UniswapX.png').default} alt="UniswapX" width="100%%" />

## Reactors

Order Reactors _settle_ UniswapX orders. They are responsible for validating orders of a specific type, resolving them into inputs and outputs, executing them against the filler's strategy, and verifying that the order was successfully fulfilled.

Reactors process orders using the following steps:
- Validate the order
- Resolve the order into inputs and outputs
- Pull input tokens from the swapper to the fillContract using permit2 `permitWitnessTransferFrom` with the order as witness
- Call `reactorCallback` on the fillContract
- Verify that the output tokens were received by the output recipients

Reactors implement the [IReactor](https://github.com/Uniswap/UniswapX/blob/main/src/interfaces/IReactor.sol) interface which abstracts the specifics of the order specification. This allows for different reactor implementations with different order formats to be used with the same interface, allowing for shared infrastructure and easy extension by fillers.

Current reactor implementations:
- [PriorityOrderReactor.sol](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/PriorityOrderReactor.sol): A reactor that settles orders via a filler competitions that use priority gas fees
- [V2DutchOrderReactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/V2DutchOrderReactor.sol): A Dutch Order Reactor that settles V2 linear decay Dutch orders. This version uses the block timestamp for auction decay.
- [V3DutchOrderReactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/V3DutchOrderReactor.sol): The latest version of the Dutch Order Reactor, which settles linear decay Dutch orders. Unlike V2 orders, these orders specify auction decay in blocks instead of using the block timestamp. Given that the block timestamp only has 1-second resolution, using the block number in this reactor is advantageous on chains like Arbitrum, which have a block resolution of 250ms.
- [ExclusiveDutchOrderReactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/ExclusiveDutchOrderReactor.sol): A reactor that settles linear-decay dutch orders with a period of exclusivity before decay begins
- [LimitOrderReactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/LimitOrderReactor.sol): A reactor that settles simple static limit orders

## Fill Contracts

Order fillContracts _fill_ UniswapX orders. They specify the filler's strategy for fulfilling orders and are called by the reactor with `reactorCallback`.

Some sample fillContract implementations are provided in this repository:
- [SwapRouter02Executor](https://github.com/Uniswap/UniswapX/blob/main/src/sample-executors/SwapRouter02Executor.sol): A fillContract that uses UniswapV2 and UniswapV3 via the SwapRouter02 router

## Direct Fill

If a filler wants to fill orders using funds on-hand rather than a fillContract, they can do so gas efficiently using the `directFill` macro by specifying `address(1)` as the fillContract. This will pull tokens from the filler using `msg.sender` to satisfy the order outputs.

## Whitepaper
More details on the UniswapX protocol are available in the [UniswapX Whitepaper](https://uniswap.org/whitepaper-uniswapx.pdf) and in the [UniswapX Repo](https://github.com/Uniswap/UniswapX).
</file>

<file path="docs/contracts/uniswapx/03-auction-types.md">
---
id: auctiontypes
title: Auction Types
sidebar_position: 3
---

UniswapX operates different auction mechanisms across supported chains, each optimized for the specific characteristics of that blockchain. Understanding these differences is essential for integrating UniswapX on each chain. 

## Overview

The following is an overview of the different types of auction mechanisms on each chain. Each auction type is explained in detail in this section.


| Chain | Auction Type | Competition Model | Timing Mechanism |
|-------|-------------|------------------|------------------|
| **Ethereum** | Exclusive Dutch Auction | Exclusive via RFQ, then open | Exclusivity period, then time-based decay |
| **Arbitrum** | Dutch Auction | Open competition | Block-based decay |
| **Base, Unichain** | Priority Gas Auction | Priority fee bidding | Target block activation, then priority fee bidding |

Regardless of their differences, all auctions do not require users to pay gas. Gas fees are wrapped into the final price and are paid by the filler, and failed swaps do not incur any fees at all.

## Reference Terminology

- **Request for Quote (RFQ)** — A process of crowdsourcing quotes for price discovery.
- **Fillers** — Parties who execute trades programmatically using sophisticated operations. These participants may also be called market makers, searchers, solvers, or MEV bots.
- **Quoters** — A subset of fillers that provide quotes in the RFQ process.
- **Classic Quote** — The quote from the AMM route.
- **Soft Quote** — An indicative quote used to show users their expected swap result.
- **Hard Quote** — The final quote collected to parameterize the auction before posting onchain.


## Ethereum: RFQ + Exclusive Dutch Auction 

TL;DR — **Two-phase auction system with exclusive filling rights for winning quoters.**

UniswapX on Ethereum uses a sophisticated two-phase auction system that balances execution quality with gas efficiency. Due to Ethereum's higher gas costs and 12-second block time, the system employs a Request for Quote (RFQ) process to ensure competitive pricing before committing users to onchain execution. This approach grants exclusive filling rights to winning quoters during an initial period, then falls back to an open Dutch auction if the exclusive filler cannot execute. The two-phase design minimizes failed transactions while maintaining competitive pricing through both permissioned quoters and permissionless fillers.

<ins>**Quote Discovery (Steps 1-3)**</ins>
1. User goes into the interface and inputs a swap.
2. Uniswap Labs fetches two quotes in parallel:
    - **Classic Quote**: This quote reflects the best price the user can get from classic Uniswap Protocol pools.
    - **UniswapX Quote**: A quote determined via a Request for Quote (RFQ) process with quoters. Because of the nature of the system, this set of market makers is permissioned and known to Labs.
3. Uniswap Labs selects the best quote (soft quote) returned and compares it to the Classic Quote. If the UniswapX quote is better, the user is shown a purple lightning bolt <img src="/img/bolt.svg" alt="Bolt icon" style={{height: "1em", width: "1em", display: "inline", verticalAlign: "middle", margin: "0 0.2em"}} />, indicating that they will be swapping through X.

<ins>**Order Execution (Steps 4-5)**</ins>
4. The UniswapX Quote contains auction parameters, which the user signs to create a gasless off-chain message. This signed message commits to the auction parameters and defines a slippage tolerance, representing the minimum amount the swapper will accept.
5. This gets sent to Uniswap Labs' server, which requests a final "hard quote" from the group of quoters. Whichever quote (hard quote) is highest wins exclusivity and gives the quoter a fixed amount of time to fill the order (sending users their tokens and settling the transaction).
    - If no quoter provides the amount that the swapper had signed for (e.g. prices moved), then the order is sent out without exclusivity, meaning anyone can fill the order.

<ins>**Fallback Mechanisms (Steps 6-7)**</ins>
6. Sometimes the market maker who won the RFQ doesn't want to fill the order anymore (e.g., price moved against them). This is called "fading." The system penalizes quoters who fade too frequently by ignoring their quotes for a period of time.
7. If the exclusive filler fades or there is no exclusive filler, the system proceeds to a Dutch Auction (a descending price auction), where the user's transaction is posted for anyone to permissionlessly fill the order.
    - The auction starts at or slightly below the quote price that the quoter faded.
    - Every block, the price decreases by a small amount.
    - This achieves a great price for users because market makers are incentivized to fill the user's order the moment the price becomes profitable for them. Because they are competing with each other, the best price is achieved, assuming at least two competitive actors.
    - In this system, we call the market makers in step 2 "Quoters" because they respond to our request for a quote. We call the market makers in step 6 "Fillers." The difference is that the set of Quoters is permissioned while the set of Fillers is permissionless.

<p align="center">
  <img src={require('./images/mainnet_flowchart.png').default} alt="UniswapX" width="60%" />
</p>

:::note Cosigners
Cosigners update auction parameters to reflect real-time prices, compensating for the delay between quoting and signing (which can be up to 30 seconds). They set the auction start block and adjust pricing within the user's signed parameters, while never exceeding the user's slippage tolerance. If you'd like to see how the Cosigner works in practice, please see the technical overview of [UniswapX V2 on Mainnet](/contracts/uniswapx/fillers/mainnet/02-v1-vs-v2.md). 
<br/>
Currently, the Uniswap Interface and Trading API sets the cosigner to Uniswap Labs, though this could be updated in the future.
:::

## Arbitrum: Dutch Auction

TL;DR — **Direct Dutch auction without RFQ, leveraging fast block times for onchain price discovery.**

Because Arbitrum's block frequency is much higher than Ethereum's, the Dutch auction can decay through more price points in the same amount of time. For example, exploring 5 price points takes 60 seconds on Ethereum (5 × 12-second blocks) but only 1.25 seconds on Arbitrum (5 × 0.25-second blocks). This speed advantage eliminates the need for an RFQ process since the auction can open directly to all fillers without exclusivity and still deliver excellent price discovery within an acceptable timeframe.


1. Based on the token pair and AMM liquidity, Uniswap Labs determines whether the swap will likely benefit from UniswapX.
2. If not, the user is routed to the AMM.
3. If so, an algorithm (called Unimind) sets the auction start and end prices (auction parameters) based on the historical performance of this pair.
    - Unimind is a gradient descent algorithm developed by Uniswap Labs to optimize both the amount given to the swapper and auction speed.
4. The user signs the auction parameters and sends them to Uniswap Labs.
5. Uniswap Labs updates the auction parameters to set the auction start block and sends the auction to fillers.
6. Fillers compete to fill the auction onchain.

## Base & Unichain: Priority Gas Auctions

TL;DR — **Priority fee bidding system leveraging OP Stack's transaction ordering mechanism.**

OP Stack rollups use Priority Ordering, a method for determining the order of transactions in a block based on the priority gas fees included in each transaction. This contrasts with Arbitrum, which uses first-come-first-serve ordering. Priority Gas Auctions (PGA) are a type of UniswapX auction that take advantage of this priority ordering  mechanism to decide the winner. 

Unlike a Dutch auction that decays over time, Priority Orders function more like a traditional English auction, where the auction starts at the user's max slippage tolerance. At a specified start block, the auction opens and fillers simultaneously submit their bids by including priority fees with their transactions. The highest priority fee wins the right to fill the order, while competing transactions revert.

1. Based on the token pair and AMM liquidity, Uniswap Labs determines whether the swap will likely benefit from UniswapX.
2. If not, the user is routed to the AMM.
3. If so, the auction is created using the classic price and max slippage provided by the user.
4. The user signs the auction parameters and sends them to Uniswap Labs.
5. Uniswap Labs updates the auction parameters to set the auction start block and sends the auction to fillers.
6. Fillers compete to fill the auction onchain by submitting transactions with varying priority fees at the target block.
</file>

<file path="docs/contracts/uniswapx/04-deployments.md">
---
id: deployment
title: Deployments Addresses
sidebar_position: 4
---

## Mainnet

| Contract | Contract Address | Source Code | Example Filler Implementation |
|-----------|------------------|----------------------|------------------------------|
| V2 Dutch Order Reactor | [0x00000011f84b9aa48e5f8aa8b9897600006289be](https://etherscan.io/address/0x00000011f84b9aa48e5f8aa8b9897600006289be) | [V2DutchOrderReactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/V2DutchOrderReactor.sol) | [uniswapx_strategy](https://github.com/Uniswap/uniswapx-artemis/blob/main/src/strategies/uniswapx_strategy.rs)
| V1 Exclusive Dutch Order Reactor | [0x6000da47483062A0D734Ba3dc7576Ce6A0B645C4](https://etherscan.io/address/0x6000da47483062A0D734Ba3dc7576Ce6A0B645C4) | [ExclusiveDutchOrderReactor](https://github.com/Uniswap/UniswapX/blob/v1.0.0/src/reactors/ExclusiveDutchOrderReactor.sol) | N/A |
| OrderQuoter| [0x54539967a06Fc0E3C3ED0ee320Eb67362D13C5fF](https://etherscan.io/address/0x54539967a06Fc0E3C3ED0ee320Eb67362D13C5fF) | [OrderQuoter](https://github.com/Uniswap/UniswapX/blob/v1.0.0/src/OrderQuoter.sol)| N/A |
| Permit2| [0x000000000022D473030F116dDEE9F6B43aC78BA3](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) | [Permit2](https://github.com/Uniswap/permit2)| N/A|

## Arbitrum

| Contract | Contract Address | Source Code | Example Filler Implementation |
|-----------|------------------|----------------------|------------------------------|
| DutchV3OrderReactor | [0xB274d5F4b833b61B340b654d600A864fB604a87c](https://arbiscan.io/address/0xB274d5F4b833b61B340b654d600A864fB604a87c) | [V3DutchOrderReactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/V3DutchOrderReactor.sol) | [dutchv3_strategy](https://github.com/Uniswap/uniswapx-artemis/blob/main/src/strategies/dutchv3_strategy.rs) |
| DutchV2OrderReactor (deprecated April 15, 2025) | [0x1bd1aAdc9E230626C44a139d7E70d842749351eb](https://arbiscan.io/address/0x1bd1aAdc9E230626C44a139d7E70d842749351eb) | [V2DutchOrderReactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/V2DutchOrderReactor.sol) | [uniswapx_strategy](https://github.com/Uniswap/uniswapx-artemis/blob/main/src/strategies/uniswapx_strategy.rs) |
| OrderQuoter| [0x88440407634F89873c5D9439987Ac4BE9725fea8](https://arbiscan.io/address/0x88440407634F89873c5D9439987Ac4BE9725fea8) | [OrderQuoter](https://github.com/Uniswap/UniswapX/blob/v1.0.0/src/OrderQuoter.sol)| N/A |
| Permit2| [0x000000000022D473030F116dDEE9F6B43aC78BA3](https://arbiscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) | [Permit2](https://github.com/Uniswap/permit2)| N/A|

## Unichain

| Contract | Contract Address | Source Code | Example Filler Implementation |
|-----------|------------------|----------------------|------------------------------|
| PriorityOrderReactor | [0x00000006021a6Bce796be7ba509BBBA71e956e37](https://uniscan.xyz/address/0x00000006021a6Bce796be7ba509BBBA71e956e37) | [PriorityOrderReactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/PriorityOrderReactor.sol) |  [priority_strategy](https://github.com/Uniswap/uniswapx-artemis/blob/main/src/strategies/priority_strategy.rs) |
| OrderQuoter| [0x88440407634F89873c5D9439987Ac4BE9725fea8](https://uniscan.xyz/address/0x88440407634F89873c5D9439987Ac4BE9725fea8) | [OrderQuoter](https://github.com/Uniswap/UniswapX/blob/v1.0.0/src/OrderQuoter.sol)| N/A |
| Permit2| [0x000000000022D473030F116dDEE9F6B43aC78BA3](https://uniscan.xyz/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) | [Permit2](https://github.com/Uniswap/permit2)| N/A|

## Base

| Contract | Contract Address | Source Code | Example Filler Implementation |
|-----------|------------------|----------------------|------------------------------|
| PriorityOrderReactor  | [0x000000001Ec5656dcdB24D90DFa42742738De729](https://basescan.org/address/0x000000001Ec5656dcdB24D90DFa42742738De729) | [PriorityOrderReactor](https://github.com/Uniswap/UniswapX/blob/main/src/reactors/PriorityOrderReactor.sol) | [priority_strategy](https://github.com/Uniswap/uniswapx-artemis/blob/main/src/strategies/priority_strategy.rs) |
| OrderQuoter| [0x88440407634f89873c5d9439987ac4be9725fea8](https://basescan.org/address/0x88440407634f89873c5d9439987ac4be9725fea8) | [OrderQuoter](https://github.com/Uniswap/UniswapX/blob/v1.0.0/src/OrderQuoter.sol)| N/A |
| Permit2| [0x000000000022D473030F116dDEE9F6B43aC78BA3](https://basescan.org/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) | [Permit2](https://github.com/Uniswap/permit2)| N/A|
</file>

<file path="docs/contracts/universal-router/_category_.json">
{
  "label": "Universal Router",
  "position": 5,
  "collapsed": true
}
</file>

<file path="docs/contracts/universal-router/01-overview.md">
---
id: overview
title: Overview
sidebar_position: 1
---

The `UniversalRouter` is an ETH and ERC20 swap router, designed to aggregate trades across Uniswap protocols (including v2, v3, and v4) and provide users with highly flexible and composable transactions. The contract is unowned and non-upgradeable.

The flexible command-based architecture enables:

- Splitting and interleaving of Uniswap v2/v3/v4 swaps
- Partial fills of trades
- Wrapping and unwrapping of ETH (via WETH)
- Time-bound, signature-controlled token approvals using [Permit2](../permit2/overview.md)
- v3 and v4 position manager interactions (e.g., permit, liquidity modification, pool initialization)
- Sub-plan execution and balance checks

Transactions are encoded as a sequence of byte-sized commands, each with structured inputs. These commands can be chained within a single transaction to express highly customized workflows, including multi-hop swaps, liquidity migration from v3 to v4, and complex value routing—all without the need for prior token approvals.

> **Note:** The `UniversalRouter` integrates with `Permit2` to eliminate the need for direct token approvals. See the [Permit2 documentation](../permit2/overview.md) for details.

## Resources

- [UniversalRouter GitHub Repository](https://github.com/Uniswap/universal-router)
</file>

<file path="docs/contracts/universal-router/02-technical-reference.md">
---
id: technical-reference
title: Technical Reference
sidebar_position: 1
---

## Functions

Transactions to the `UniversalRouter` all go through the `execute` function:

- `execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)`
- `execute(bytes calldata commands, bytes[] calldata inputs)`

Both functions behave and process the commands exactly the same, the first one with a deadline. The function without the deadline parameter will not revert based on block.timestamp.

The `execute` function behaves like a minimal virtual machine. It interprets a list of 1-byte commands and their corresponding ABI-encoded inputs and executes them sequentially.

## Command Structure

Each command byte uses the following bit structure:

| 0   | 1 2 | 3 4 5 6 7 |
| :-- | :-- | :-------- |
| f   | r   | command   |

### `f`

A single bit flag, that signals whether or not the command should be allowed to revert without the whole transaction failing.

- If `f` is `0` aka `false` and the command reverts, then the entire transaction will revert and none of the commands will be executed.
- If `f` is `1` aka `true` and the command reverts, then the transaction will continue, allowing us to achieve partial fills. If using this flag, be careful to include further commands that will remove any funds that could be left unused in the `UniversalRouter` contract.

### `r`

2 unused bits, reserved for future use. Leaving these 2 bits as `0` will save gas, but any value passed into the contract will be ignored. Later versions of the `UniversalRouter` will likely expand the 5 bits used for `command` to use at least 1 of these bits.

### `command`

A 5 bit unique identifier for the command that should be carried out. The values of these commands can be found within [Commands.sol](https://github.com/Uniswap/universal-router/blob/main/contracts/libraries/Commands.sol), or can be viewed in the table below.

The command types that are not defined do not have an assigned command at this moment in time. Providing one of these identifiers will cause the transaction to revert with `InvalidCommandType`.

## v2 vs v1 Overview

**Note:** For details on the previous version, see [Universal Router (Legacy)](../../universal-router-legacy/overview).

| Feature                   | v1                        | v2                                       |
| ------------------------- | ------------------------- | ---------------------------------------- |
| NFT support               | ✅ Multiple marketplaces  | ❌ Removed                               |
| v4 pool interaction       | ❌ Not supported          | ✅ `V4_SWAP`, `V4_POSITION_MANAGER_CALL` |
| v3/v4 position management | ❌ Not supported          | ✅ `V3_POSITION_MANAGER_*` / `V4_*`      |
| Commands                  | 0x00–0x3f (dense NFT ops) | 0x00–0x21 (compact core logic)           |
| Permit2-based transfers   | ✅                        | ✅ Extended with batch & position flows  |
| Sub-plan execution        | ✅ `EXECUTE_SUB_PLAN`     | ✅ Still supported                       |

## Supported Commands (v2)

| Command | Name                          |
| ------: | ----------------------------- |
|  `0x00` | `V3_SWAP_EXACT_IN`            |
|  `0x01` | `V3_SWAP_EXACT_OUT`           |
|  `0x02` | `PERMIT2_TRANSFER_FROM`       |
|  `0x03` | `PERMIT2_PERMIT_BATCH`        |
|  `0x04` | `SWEEP`                       |
|  `0x05` | `TRANSFER`                    |
|  `0x06` | `PAY_PORTION`                 |
|  `0x08` | `V2_SWAP_EXACT_IN`            |
|  `0x09` | `V2_SWAP_EXACT_OUT`           |
|  `0x0a` | `PERMIT2_PERMIT`              |
|  `0x0b` | `WRAP_ETH`                    |
|  `0x0c` | `UNWRAP_WETH`                 |
|  `0x0d` | `PERMIT2_TRANSFER_FROM_BATCH` |
|  `0x0e` | `BALANCE_CHECK_ERC20`         |
|  `0x10` | `V4_SWAP`                     |
|  `0x11` | `V3_POSITION_MANAGER_PERMIT`  |
|  `0x12` | `V3_POSITION_MANAGER_CALL`    |
|  `0x13` | `V4_INITIALIZE_POOL`          |
|  `0x14` | `V4_POSITION_MANAGER_CALL`    |
|  `0x21` | `EXECUTE_SUB_PLAN`            |

Commands not listed are placeholders and will revert if called.

## Command Inputs

Each command requires its own input structure. Inputs are encoded using `abi.encode(...)` and placed in `inputs[i]` to match `commands[i]`. For example:

---

## Swap Commands

### `0x00` – V3_SWAP_EXACT_IN

**Parameters:**

- `address recipient`
- `uint256 amountIn`
- `uint256 amountOutMin`
- `bytes path`
- `bool payerIsUser`

**Calls:** `v3SwapExactInput(...)` in V3SwapModule  
**Usage:** Ideal for deterministic trades where the input amount is fixed.

---

### `0x01` – V3_SWAP_EXACT_OUT

**Parameters:**

- `address recipient`
- `uint256 amountOut`
- `uint256 amountInMax`
- `bytes path`
- `bool payerIsUser`

**Calls:** `v3SwapExactOutput(...)`  
**Usage:** When the user wants to receive a precise amount of output tokens, regardless of price volatility, within a max budget.

---

### `0x08` – V2_SWAP_EXACT_IN

**Parameters:**

- `address recipient`
- `uint256 amountIn`
- `uint256 amountOutMin`
- `address[] path`
- `bool payerIsUser`

**Calls:** `v2SwapExactInput(...)` in V2SwapModule  
**Usage:** Simple Uniswap v2-style fixed input swap using token pairs.

---

### `0x09` – V2_SWAP_EXACT_OUT

**Parameters:**

- `address recipient`
- `uint256 amountOut`
- `uint256 amountInMax`
- `address[] path`
- `bool payerIsUser`

**Calls:** `v2SwapExactOutput(...)`  
**Usage:** Swaps to get an exact output amount with limited token budget.

---

## Permit2 Commands

### `0x02` – PERMIT2_TRANSFER_FROM

**Parameters:**

- `address token`
- `address recipient`
- `uint160 amount`

**Calls:** `permit2TransferFrom(...)`  
**Usage:** Transfers a single token using Permit2 allowances. Always pulls from `msg.sender`.

---

### `0x03` – PERMIT2_PERMIT_BATCH

**Parameters:**

- `PermitBatch permitBatch`
- `bytes signature`

**Calls:** `PERMIT2.permit(...)`  
**Usage:** Sets approval for multiple tokens in one signature.

---

### `0x0a` – PERMIT2_PERMIT

**Parameters:**

- `PermitSingle permitSingle`
- `bytes signature`

**Calls:** `PERMIT2.permit(...)`  
**Usage:** Sets approval for one token, often before `PERMIT2_TRANSFER_FROM`.

---

### `0x0d` – PERMIT2_TRANSFER_FROM_BATCH

**Parameters:**

- `AllowanceTransferDetails[] batch`

**Calls:** `permit2TransferFrom(...)`  
**Usage:** Transfers many tokens in one call from a user to one or more destinations.

---

## Payment & Balance Commands

### `0x04` – SWEEP

**Parameters:**

- `address token`
- `address recipient`
- `uint256 amountMin`

**Calls:** `Payments.sweep(...)`  
**Usage:** Clears out all router-held ETH or ERC20 tokens to a destination address.

---

### `0x05` – TRANSFER

**Parameters:**

- `address token`
- `address recipient`
- `uint256 amount`

**Calls:** `Payments.pay(...)`  
**Usage:** Transfers a specific amount (not full balance) from the router.

---

### `0x06` – PAY_PORTION

**Parameters:**

- `address token`
- `address recipient`
- `uint256 bips`

**Calls:** `Payments.payPortion(...)`  
**Usage:** Sends a % of the token balance (e.g., 2500 = 25%).

---

### `0x0e` – BALANCE_CHECK_ERC20

**Parameters:**

- `address owner`
- `address token`
- `uint256 minBalance`

**Calls:** view-only `balanceOf(...)`  
**Usage:** Ensures required token balance exists; useful for conditional workflows.

---

## ETH & WETH

### `0x0b` – WRAP_ETH

**Parameters:**

- `address recipient`
- `uint256 amount`

**Calls:** `Payments.wrapETH(...)` → WETH.deposit()  
**Usage:** Converts ETH held by router into WETH and optionally sends it.

---

### `0x0c` – UNWRAP_WETH

**Parameters:**

- `address recipient`
- `uint256 amountMin`

**Calls:** `Payments.unwrapWETH9(...)`  
**Usage:** Converts all router-held WETH into ETH and sends it.

---

## v3 & v4 Advanced

## `0x10` – V4_SWAP

### Parameters:

- **`bytes actions`**  
  Encoded action identifiers specifying the type of swap or payment action.  
  For available action types, see [Uniswap v4 SDK Actions](../../sdk/v4/reference/enumerations/Actions.md).

- **`bytes[] params`**
  ABI-encoded parameters array, corresponding one-to-one with each action provided in `actions`.
  Each action type requires its own parameter structure.

### Calls:

Executes actions via `V4SwapRouter._handleAction(action, params)`:

- Swap-related actions call `_swapExactInput(...)` or `_swapExactOutput(...)`.
- Payment-related actions (`settle`, `take`) call internal balance management methods (`_settle(...)`, `_take(...)`).
- Swap actions ultimately call `_swap(...)`, executing swaps via `PoolManager.swap(...)`.

**Usage:** Executes a swap on Uniswap v4 using the provided parameters.

### Internal Flow:

```markdown
UniversalRouter.execute(...) receives command `0x10`
↓ dispatch (UniversalRouter.sol)
V4SwapRouter.\_handleAction(action, params)
├── SWAP_EXACT_IN → \_swapExactInput(...)
├── SWAP_EXACT_OUT → \_swapExactOutput(...)
├── SETTLE / SETTLE_ALL → \_settle(...)
├── TAKE / TAKE_ALL / TAKE_PORTION → \_take(...)
↓ swap calls route to
\_swap(...) → PoolManager.swap(...)
```

---

### `0x11` – V3_POSITION_MANAGER_PERMIT

**Parameters:**

- `address spender`
- `uint256 tokenId`
- `uint256 deadline`
- `uint8 v, bytes32 r, bytes32 s`

**Calls:** NonfungiblePositionManager.permit(...)  
**Usage:** Grants router permission to operate on a user’s v3 NFT.

---

### `0x12` – V3_POSITION_MANAGER_CALL

**Parameters:**

- `bytes callData`

**Calls:** Arbitrary call to NonfungiblePositionManager  
**Usage:** Executes v3 NFT ops like `burn`, `collect`, `decreaseLiquidity`.

---

### `0x13` – V4_INITIALIZE_POOL

**Parameters:**

- `PoolKey key`
- `uint160 sqrtPriceX96`

**Calls:** `PoolManager.initialize(...)`  
**Usage:** Creates new V4 pool with specified fee, tick spacing, etc.

---

### `0x14` – V4_POSITION_MANAGER_CALL

**Parameters:**

- `bytes callData`

**Calls:** Arbitrary call to v4 PositionManager  
**Usage:** Used for `modifyLiquidity`, `mint`, `settle`, etc. on a pool.

---

## Composability

### `0x21` – EXECUTE_SUB_PLAN

**Parameters:**

- `bytes subCommands`
- `bytes[] subInputs`

**Calls:** `execute(...)` (reentrantly)

**Usage:** Nested command execution for conditional or fallback logic. Used to group steps or allow selective reverts (via `f` flag).

## Reverting Command Example

To allow a command to fail without reverting the entire transaction, set the high bit:

```solidity
command = 0x80 | 0x00; // V3_SWAP_EXACT_IN with ALLOW_REVERT
```

Be sure to follow such commands with cleanup logic (e.g., `SWEEP`) to handle unused ETH or tokens.

## References

- [Uniswap Universal Router GitHub](https://github.com/Uniswap/universal-router)
- [Latest Commands.sol](https://github.com/Uniswap/universal-router/blob/main/contracts/libraries/Commands.sol)

## Legacy Documentation

- [Universal Router (Legacy) Overview](../../universal-router-legacy/overview)
- [Universal Router (Legacy) Technical Reference](../../universal-router-legacy/technical-reference)
</file>

<file path="docs/contracts/v1/guides/_category_.json">
{
  "label": "Guides",
  "position": 2,
  "collapsed": false
}
</file>

<file path="docs/contracts/v1/guides/01-connect-to-uniswap.md">
---
id: connect-to-uniswap
title: Connect to Uniswap
---

The Uniswap smart contracts exist on the Ethereum blockchain. Use [ethers.js](https://github.com/ethers-io/ethers.js/) or [web3.js](https://github.com/ethereum/web3.js) to connect your website to Ethereum. Users will need a web3-enabled browser. On desktop this means using the [MetaMask](https://metamask.io/) extension or something similar. On mobile, web3-compatible browsers include [Trust Wallet](https://trustwallet.com/) and [Coinbase Wallet](https://wallet.coinbase.com/). See [ethereum.org](https://ethereum.org/use/#_3-what-is-a-wallet-and-which-one-should-i-use) to learn more.

## Factory Contract

The Uniswap [factory contract](https://github.com/Uniswap/uniswap-v1/blob/master/contracts/uniswap_factory.vy) can be used to create exchange contracts for any ERC20 token that does not already have one. It also functions as a registry of ERC20 tokens that have been added to the system, and the exchange with which they are associated.

The factory contract can be instantiated using the factory address and ABI:

## [Factory Address](https://etherscan.io/address/0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95)

```javascript
// mainnet
const factory = '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'

// testnets
const ropsten = '0x9c83dCE8CA20E9aAF9D3efc003b2ea62aBC08351'
const rinkeby = '0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36'
const kovan = '0xD3E51Ef092B2845f10401a0159B2B96e8B6c3D30'
const görli = '0x6Ce570d02D73d4c384b46135E87f8C592A8c86dA'
```

### Factory Interface

Creating the factory interface in web3 requires the **factory address** and the **factory ABI**:

```javascript
const factoryABI = [
  {
    name: 'NewExchange',
    inputs: [
      { type: 'address', name: 'token', indexed: true },
      { type: 'address', name: 'exchange', indexed: true },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'initializeFactory',
    outputs: [],
    inputs: [{ type: 'address', name: 'template' }],
    constant: false,
    payable: false,
    type: 'function',
    gas: 35725,
  },
  {
    name: 'createExchange',
    outputs: [{ type: 'address', name: 'out' }],
    inputs: [{ type: 'address', name: 'token' }],
    constant: false,
    payable: false,
    type: 'function',
    gas: 187911,
  },
  {
    name: 'getExchange',
    outputs: [{ type: 'address', name: 'out' }],
    inputs: [{ type: 'address', name: 'token' }],
    constant: true,
    payable: false,
    type: 'function',
    gas: 715,
  },
  {
    name: 'getToken',
    outputs: [{ type: 'address', name: 'out' }],
    inputs: [{ type: 'address', name: 'exchange' }],
    constant: true,
    payable: false,
    type: 'function',
    gas: 745,
  },
  {
    name: 'getTokenWithId',
    outputs: [{ type: 'address', name: 'out' }],
    inputs: [{ type: 'uint256', name: 'token_id' }],
    constant: true,
    payable: false,
    type: 'function',
    gas: 736,
  },
  {
    name: 'exchangeTemplate',
    outputs: [{ type: 'address', name: 'out' }],
    inputs: [],
    constant: true,
    payable: false,
    type: 'function',
    gas: 633,
  },
  {
    name: 'tokenCount',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [],
    constant: true,
    payable: false,
    type: 'function',
    gas: 663,
  },
]
```

```javascript
const factoryContract = new web3.eth.Contract(factoryABI, factoryAddress)
```

## Exchange Contracts

### Get Exchange Address

There is a separate exchange contract for every ERC20 token. The `getExchange` method in the factory contract can be used to find the Ethereum address associated with an ERC20 token address.

```javascript
const exchangeAddress = factoryContract.methods.getExchange(tokenAddress)
```

If the return value is `0x0000000000000000000000000000000000000000` the token does not yet have an exchange.

### Exchange Interface

Creating an exchange interface in web3 requires the **exchange address** and the **exchange ABI**:

```javascript
const exchangeABI = [
  {
    name: 'TokenPurchase',
    inputs: [
      { type: 'address', name: 'buyer', indexed: true },
      { type: 'uint256', name: 'eth_sold', indexed: true },
      { type: 'uint256', name: 'tokens_bought', indexed: true },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'EthPurchase',
    inputs: [
      { type: 'address', name: 'buyer', indexed: true },
      { type: 'uint256', name: 'tokens_sold', indexed: true },
      { type: 'uint256', name: 'eth_bought', indexed: true },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'AddLiquidity',
    inputs: [
      { type: 'address', name: 'provider', indexed: true },
      { type: 'uint256', name: 'eth_amount', indexed: true },
      { type: 'uint256', name: 'token_amount', indexed: true },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'RemoveLiquidity',
    inputs: [
      { type: 'address', name: 'provider', indexed: true },
      { type: 'uint256', name: 'eth_amount', indexed: true },
      { type: 'uint256', name: 'token_amount', indexed: true },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'Transfer',
    inputs: [
      { type: 'address', name: '_from', indexed: true },
      { type: 'address', name: '_to', indexed: true },
      { type: 'uint256', name: '_value', indexed: false },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'Approval',
    inputs: [
      { type: 'address', name: '_owner', indexed: true },
      { type: 'address', name: '_spender', indexed: true },
      { type: 'uint256', name: '_value', indexed: false },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'setup',
    outputs: [],
    inputs: [{ type: 'address', name: 'token_addr' }],
    constant: false,
    payable: false,
    type: 'function',
    gas: 175875,
  },
  {
    name: 'addLiquidity',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'min_liquidity' },
      { type: 'uint256', name: 'max_tokens' },
      { type: 'uint256', name: 'deadline' },
    ],
    constant: false,
    payable: true,
    type: 'function',
    gas: 82605,
  },
  {
    name: 'removeLiquidity',
    outputs: [
      { type: 'uint256', name: 'out' },
      { type: 'uint256', name: 'out' },
    ],
    inputs: [
      { type: 'uint256', name: 'amount' },
      { type: 'uint256', name: 'min_eth' },
      { type: 'uint256', name: 'min_tokens' },
      { type: 'uint256', name: 'deadline' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 116814,
  },
  {
    name: '__default__',
    outputs: [],
    inputs: [],
    constant: false,
    payable: true,
    type: 'function',
  },
  {
    name: 'ethToTokenSwapInput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'min_tokens' },
      { type: 'uint256', name: 'deadline' },
    ],
    constant: false,
    payable: true,
    type: 'function',
    gas: 12757,
  },
  {
    name: 'ethToTokenTransferInput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'min_tokens' },
      { type: 'uint256', name: 'deadline' },
      { type: 'address', name: 'recipient' },
    ],
    constant: false,
    payable: true,
    type: 'function',
    gas: 12965,
  },
  {
    name: 'ethToTokenSwapOutput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'tokens_bought' },
      { type: 'uint256', name: 'deadline' },
    ],
    constant: false,
    payable: true,
    type: 'function',
    gas: 50455,
  },
  {
    name: 'ethToTokenTransferOutput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'tokens_bought' },
      { type: 'uint256', name: 'deadline' },
      { type: 'address', name: 'recipient' },
    ],
    constant: false,
    payable: true,
    type: 'function',
    gas: 50663,
  },
  {
    name: 'tokenToEthSwapInput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'tokens_sold' },
      { type: 'uint256', name: 'min_eth' },
      { type: 'uint256', name: 'deadline' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 47503,
  },
  {
    name: 'tokenToEthTransferInput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'tokens_sold' },
      { type: 'uint256', name: 'min_eth' },
      { type: 'uint256', name: 'deadline' },
      { type: 'address', name: 'recipient' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 47712,
  },
  {
    name: 'tokenToEthSwapOutput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'eth_bought' },
      { type: 'uint256', name: 'max_tokens' },
      { type: 'uint256', name: 'deadline' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 50175,
  },
  {
    name: 'tokenToEthTransferOutput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'eth_bought' },
      { type: 'uint256', name: 'max_tokens' },
      { type: 'uint256', name: 'deadline' },
      { type: 'address', name: 'recipient' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 50384,
  },
  {
    name: 'tokenToTokenSwapInput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'tokens_sold' },
      { type: 'uint256', name: 'min_tokens_bought' },
      { type: 'uint256', name: 'min_eth_bought' },
      { type: 'uint256', name: 'deadline' },
      { type: 'address', name: 'token_addr' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 51007,
  },
  {
    name: 'tokenToTokenTransferInput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'tokens_sold' },
      { type: 'uint256', name: 'min_tokens_bought' },
      { type: 'uint256', name: 'min_eth_bought' },
      { type: 'uint256', name: 'deadline' },
      { type: 'address', name: 'recipient' },
      { type: 'address', name: 'token_addr' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 51098,
  },
  {
    name: 'tokenToTokenSwapOutput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'tokens_bought' },
      { type: 'uint256', name: 'max_tokens_sold' },
      { type: 'uint256', name: 'max_eth_sold' },
      { type: 'uint256', name: 'deadline' },
      { type: 'address', name: 'token_addr' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 54928,
  },
  {
    name: 'tokenToTokenTransferOutput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'tokens_bought' },
      { type: 'uint256', name: 'max_tokens_sold' },
      { type: 'uint256', name: 'max_eth_sold' },
      { type: 'uint256', name: 'deadline' },
      { type: 'address', name: 'recipient' },
      { type: 'address', name: 'token_addr' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 55019,
  },
  {
    name: 'tokenToExchangeSwapInput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'tokens_sold' },
      { type: 'uint256', name: 'min_tokens_bought' },
      { type: 'uint256', name: 'min_eth_bought' },
      { type: 'uint256', name: 'deadline' },
      { type: 'address', name: 'exchange_addr' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 49342,
  },
  {
    name: 'tokenToExchangeTransferInput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'tokens_sold' },
      { type: 'uint256', name: 'min_tokens_bought' },
      { type: 'uint256', name: 'min_eth_bought' },
      { type: 'uint256', name: 'deadline' },
      { type: 'address', name: 'recipient' },
      { type: 'address', name: 'exchange_addr' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 49532,
  },
  {
    name: 'tokenToExchangeSwapOutput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'tokens_bought' },
      { type: 'uint256', name: 'max_tokens_sold' },
      { type: 'uint256', name: 'max_eth_sold' },
      { type: 'uint256', name: 'deadline' },
      { type: 'address', name: 'exchange_addr' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 53233,
  },
  {
    name: 'tokenToExchangeTransferOutput',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'uint256', name: 'tokens_bought' },
      { type: 'uint256', name: 'max_tokens_sold' },
      { type: 'uint256', name: 'max_eth_sold' },
      { type: 'uint256', name: 'deadline' },
      { type: 'address', name: 'recipient' },
      { type: 'address', name: 'exchange_addr' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 53423,
  },
  {
    name: 'getEthToTokenInputPrice',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [{ type: 'uint256', name: 'eth_sold' }],
    constant: true,
    payable: false,
    type: 'function',
    gas: 5542,
  },
  {
    name: 'getEthToTokenOutputPrice',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [{ type: 'uint256', name: 'tokens_bought' }],
    constant: true,
    payable: false,
    type: 'function',
    gas: 6872,
  },
  {
    name: 'getTokenToEthInputPrice',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [{ type: 'uint256', name: 'tokens_sold' }],
    constant: true,
    payable: false,
    type: 'function',
    gas: 5637,
  },
  {
    name: 'getTokenToEthOutputPrice',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [{ type: 'uint256', name: 'eth_bought' }],
    constant: true,
    payable: false,
    type: 'function',
    gas: 6897,
  },
  {
    name: 'tokenAddress',
    outputs: [{ type: 'address', name: 'out' }],
    inputs: [],
    constant: true,
    payable: false,
    type: 'function',
    gas: 1413,
  },
  {
    name: 'factoryAddress',
    outputs: [{ type: 'address', name: 'out' }],
    inputs: [],
    constant: true,
    payable: false,
    type: 'function',
    gas: 1443,
  },
  {
    name: 'balanceOf',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [{ type: 'address', name: '_owner' }],
    constant: true,
    payable: false,
    type: 'function',
    gas: 1645,
  },
  {
    name: 'transfer',
    outputs: [{ type: 'bool', name: 'out' }],
    inputs: [
      { type: 'address', name: '_to' },
      { type: 'uint256', name: '_value' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 75034,
  },
  {
    name: 'transferFrom',
    outputs: [{ type: 'bool', name: 'out' }],
    inputs: [
      { type: 'address', name: '_from' },
      { type: 'address', name: '_to' },
      { type: 'uint256', name: '_value' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 110907,
  },
  {
    name: 'approve',
    outputs: [{ type: 'bool', name: 'out' }],
    inputs: [
      { type: 'address', name: '_spender' },
      { type: 'uint256', name: '_value' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 38769,
  },
  {
    name: 'allowance',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'address', name: '_owner' },
      { type: 'address', name: '_spender' },
    ],
    constant: true,
    payable: false,
    type: 'function',
    gas: 1925,
  },
  {
    name: 'name',
    outputs: [{ type: 'bytes32', name: 'out' }],
    inputs: [],
    constant: true,
    payable: false,
    type: 'function',
    gas: 1623,
  },
  {
    name: 'symbol',
    outputs: [{ type: 'bytes32', name: 'out' }],
    inputs: [],
    constant: true,
    payable: false,
    type: 'function',
    gas: 1653,
  },
  {
    name: 'decimals',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [],
    constant: true,
    payable: false,
    type: 'function',
    gas: 1683,
  },
  {
    name: 'totalSupply',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [],
    constant: true,
    payable: false,
    type: 'function',
    gas: 1713,
  },
]
```

```javascript
const exchangeContract = new web3.eth.Contract(exchangeABI, exchangeAddress)
```

## Token Contracts

Some Uniswap interactions require making calls directly to ERC20 token contracts rather than the exchanges with which they are associated.

### Get Token Address

The `getToken` method in the factory contract can be used to find the ERC20 token address associated with an exchange contract. There is no barrier of entry for adding an ERC20 token to Uniswap or checks on the validity of the token contracts. Frontend interfaces should maintain a list of valid ERC20 tokens that users can safely trade or allow users to paste in arbitrary addresses.

```javascript
const tokenAddress = factoryContract.methods.getToken(exchangeAddress)
```

If the return value is `0x0000000000000000000000000000000000000000` the input address is not a Uniswap exchange.

### Token Interface

Creating a token interface in web3 requires the **token address** and the **token ABI**:

```javascript
const tokenABI = [
  {
    name: 'Transfer',
    inputs: [
      { type: 'address', name: '_from', indexed: true },
      { type: 'address', name: '_to', indexed: true },
      { type: 'uint256', name: '_value', indexed: false },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'Approval',
    inputs: [
      { type: 'address', name: '_owner', indexed: true },
      { type: 'address', name: '_spender', indexed: true },
      { type: 'uint256', name: '_value', indexed: false },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: '__init__',
    outputs: [],
    inputs: [
      { type: 'bytes32', name: '_name' },
      { type: 'bytes32', name: '_symbol' },
      { type: 'uint256', name: '_decimals' },
      { type: 'uint256', name: '_supply' },
    ],
    constant: false,
    payable: false,
    type: 'constructor',
  },
  {
    name: 'deposit',
    outputs: [],
    inputs: [],
    constant: false,
    payable: true,
    type: 'function',
    gas: 74279,
  },
  {
    name: 'withdraw',
    outputs: [{ type: 'bool', name: 'out' }],
    inputs: [{ type: 'uint256', name: '_value' }],
    constant: false,
    payable: false,
    type: 'function',
    gas: 108706,
  },
  {
    name: 'totalSupply',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [],
    constant: true,
    payable: false,
    type: 'function',
    gas: 543,
  },
  {
    name: 'balanceOf',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [{ type: 'address', name: '_owner' }],
    constant: true,
    payable: false,
    type: 'function',
    gas: 745,
  },
  {
    name: 'transfer',
    outputs: [{ type: 'bool', name: 'out' }],
    inputs: [
      { type: 'address', name: '_to' },
      { type: 'uint256', name: '_value' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 74698,
  },
  {
    name: 'transferFrom',
    outputs: [{ type: 'bool', name: 'out' }],
    inputs: [
      { type: 'address', name: '_from' },
      { type: 'address', name: '_to' },
      { type: 'uint256', name: '_value' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 110600,
  },
  {
    name: 'approve',
    outputs: [{ type: 'bool', name: 'out' }],
    inputs: [
      { type: 'address', name: '_spender' },
      { type: 'uint256', name: '_value' },
    ],
    constant: false,
    payable: false,
    type: 'function',
    gas: 37888,
  },
  {
    name: 'allowance',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [
      { type: 'address', name: '_owner' },
      { type: 'address', name: '_spender' },
    ],
    constant: true,
    payable: false,
    type: 'function',
    gas: 1025,
  },
  {
    name: 'name',
    outputs: [{ type: 'bytes32', name: 'out' }],
    inputs: [],
    constant: true,
    payable: false,
    type: 'function',
    gas: 723,
  },
  {
    name: 'symbol',
    outputs: [{ type: 'bytes32', name: 'out' }],
    inputs: [],
    constant: true,
    payable: false,
    type: 'function',
    gas: 753,
  },
  {
    name: 'decimals',
    outputs: [{ type: 'uint256', name: 'out' }],
    inputs: [],
    constant: true,
    payable: false,
    type: 'function',
    gas: 783,
  },
]
```

```javascript
const tokenContract = new web3.eth.Contract(tokenABI, tokenAddress)
```
</file>

<file path="docs/contracts/v1/guides/02-pool-liquidity.md">
---
id: pool-liquidity
title: Pool Liquidity
---

## Formalized Model

Uniswap liquidity pools are autonomous and use the Constant Product Market Maker \(`x * y = k`\). This model was formalized and the smart contract implementation passed a lightweight formal verification.

- [Formalized Specification](https://github.com/runtimeverification/verified-smart-contracts/blob/uniswap/uniswap/x-y-k.pdf)
- [Lightweight Verification](https://github.com/runtimeverification/verified-smart-contracts/tree/uniswap/uniswap/results)

## Create Exchange

The `createExchange` function is used to deploy exchange contracts for ERC20 tokens that do not yet have one.

```javascript
factory.methods.createExchange(tokenAddress).send()
```

Once an exchange is created the address can be retrieved with [`getExchange`](connect-to-uniswap/#get-exchange-address).

## Exchange Reserves

Each exchange contract holds a liquidity reserve of ETH and its associated ERC20 token.

### ETH Reserve

The ETH reserve associated with an ERC20 token exchange is the ETH balance of the exchange smart contract.

```javascript
const ethReserve = web3.eth.getBalance(exchangeAddress)
```

### ERC20 Reserve

The ERC20 reserve associated with an ERC20 token exchange is the ERC20 balance of the exchange smart contract.

```javascript
const tokenReserve = tokenContract.methods.balanceOf(exchangeAddress)
```

## Add Liquidity

Anyone who wants can join a Uniswap liquidity pool by calling the `addLiquidity` function.

```javascript
exchange.methods.addLiquidity(min_liquidity, max_tokens, deadline).send({ value: ethAmount })
```

Adding liquidity requires depositing an equivalent **value** of ETH and ERC20 tokens into the ERC20 token's associated exchange contract.

The first liquidity provider to join a pool sets the initial exchange rate by depositing what they believe to be an equivalent value of ETH and ERC20 tokens. If this ratio is off, arbitrage traders will bring the prices to equilibrium at the expense of the initial liquidity provider.

All future liquidity providers deposit ETH and ERC20's using the exchange rate at the moment of their deposit. If the exchange rate is bad there is a profitable arbitrage opportunity that will correct the price.

### Parameters

The `ethAmount` sent to `addLiquidity` is the exact amount of ETH that will be deposited into the liquidity reserves. It should be 50% of the total value a liquidity provider wishes to deposit into the reserves.

Since liquidity providers must deposit at the current exchange rate, the Uniswap smart contracts use `ethAmount` to determine the amount of ERC20 tokens that must be deposited. This token amount is the remaining 50% of total value a liquidity provider wishes to deposit. Since exchange rate can change between when a transaction is signed and when it is executed on Ethereum, `max_tokens` is used to bound the amount this rate can fluctuate. For the first liquidity provider, `max_tokens` is the exact amount of tokens deposited.

Liquidity tokens are minted to track the relative proportion of total reserves that each liquidity provider has contributed. `min_liquidity` is used in combination with `max_tokens` and `ethAmount` to bound the rate at which liquidity tokens are minted. For the first liquidity provider, `min_liquidity` does not do anything and can be set to 0.

Transaction `deadline` is used to set a time after which a transaction can no longer be executed. This limits the "free option" problem, where Ethereum miners can hold signed transactions and execute them based off market movements.

## Remove Liquidity

Liquidity providers use the `removeLiquidity` function to withdraw their portion of the reserves.

```javascript
exchange.methods.removeLiquidity(amount, min_eth, min_tokens, deadline).send()
```

Liquidity is withdrawn at the same ratio as the reserves at the time of withdrawal. If the exchange rate is bad there is a profitable arbitrage opportunity that will correct the price.

### Parameters

`amount` specifies the number of liquidity tokens that will be burned. Dividing this amount by the total liquidity token supply gives the percentage of both the ETH and ER20 reserves the provider is withdrawing.

Since exchange rate can change between when a transaction is signed and when it is executed on Ethereum, `min_eth` and `min_tokens` are used to bound the amount this rate can fluctuate.

Same as in `addLiquidity`, `deadline` is used to set a time after which a transaction can no longer be executed.
</file>

<file path="docs/contracts/v1/guides/03-trade-tokens.md">
---
id: trade-tokens
title: Trade Tokens
---

In Uniswap, there is a separate exchange contract for each ERC20 token. These exchanges hold reserves of both ETH and their associated ERC20. Instead of waiting to be matched in an order-book, users can make trades against the reserves at any time. Reserves are pooled between a decentralized network of liquidity providers who collect fees on every trade.

Pricing is automatic, based on the `x * y = k` market making formula which automatically adjusts prices based off the relative sizes of the two reserves and the size of the incoming trade. Since all tokens share ETH as a common pair, it is used as an intermediary asset for direct trading between any ERC20 ⇄ ERC20 pair.

## ETH ⇄ ERC20 Calculations

The variables needed to determine price when trading between ETH and ERC20 tokens is:

- ETH reserve size of the ERC20 exchange
- ERC20 reserve size of the ERC20 exchange
- Amount sold \(input\) or amount bought \(output\)

### Amount Bought \(sell order\)

For sell orders \(exact input\), the amount bought \(output\) is calculated:

```javascript
// Sell ETH for ERC20
const inputAmount = userInputEthValue
const inputReserve = web3.eth.getBalance(exchangeAddress)
const outputReserve = tokenContract.methods.balanceOf(exchangeAddress).call()

// Sell ERC20 for ETH
const inputAmount = userInputTokenValue
const inputReserve = tokenContract.methods.balanceOf(exchangeAddress).call()
const outputReserve = web3.eth.getBalance(exchangeAddress)

// Output amount bought
const numerator = inputAmount * outputReserve * 997
const denominator = inputReserve * 1000 + inputAmount * 997
const outputAmount = numerator / denominator
```

### Amount Sold \(buy order\)

For buy orders \(exact output\), the cost \(input\) is calculated:

```javascript
// Buy ERC20 with ETH
const outputAmount = userInputTokenValue
const inputReserve = web3.eth.getBalance(exchangeAddress)
const outputReserve = tokenContract.methods.balanceOf(exchangeAddress).call()

// Buy ETH with ERC20
const outputAmount = userInputEthValue
const inputReserve = tokenContract.methods.balanceOf(exchangeAddress).call()
const outputReserve = web3.eth.getBalance(exchangeAddress)

// Cost
const numerator = outputAmount * inputReserve * 1000
const denominator = (outputReserve - outputAmount) * 997
const inputAmount = numerator / denominator + 1
```

### Liquidity Provider Fee

There is a 0.3% liquidity provider fee built into the price formula. This can be calculated:

```javascript
fee = inputAmount * 0.003
```

### Exchange Rate

The exchange rate is simply the output amount divided by the input amount.

```javascript
const rate = outputAmount / inputAmount
```

## ERC20 ⇄ ERC20 Calculations

The variables needed to determine price when trading between two ERC20 tokens is:

- ETH reserve size of the input ERC20 exchange
- ERC20 reserve size of the input ERC20 exchange
- ETH reserve size of the output ERC20 exchange
- ERC20 reserve size of the output ERC20 exchange
- Amount sold \(input\) or amount bought \(output\)

### Amount Bought \(sell order\)

For sell orders \(exact input\), the amount bought \(output\) is calculated:

```javascript
// TokenA (ERC20) to ETH conversion
const inputAmountA = userInputTokenAValue
const inputReserveA = tokenContractA.methods.balanceOf(exchangeAddressA).call()
const outputReserveA = web3.eth.getBalance(exchangeAddressA)

const numeratorA = inputAmountA * outputReserveA * 997
const denominatorA = inputReserveA * 1000 + inputAmountA * 997
const outputAmountA = numeratorA / denominatorA

// ETH to TokenB conversion
const inputAmountB = outputAmountA
const inputReserveB = web3.eth.getBalance(exchangeAddressB)
const outputReserveB = tokenContract.methods.balanceOf(exchangeAddressB).call()

const numeratorB = inputAmountB * outputReserveB * 997
const denominatorB = inputReserveB * 1000 + inputAmountB * 997
const outputAmountB = numeratorB / denominatorB
```

### Amount Sold \(buy order\)

For buy orders \(exact output\), the cost \(input\) is calculated:

```javascript
// Buy TokenB with ETH
const outputAmountB = userInputTokenBValue
const inputReserveB = web3.eth.getBalance(exchangeAddressB)
const outputReserveB = tokenContractB.methods.balanceOf(exchangeAddressB).call()

// Cost
const numeratorB = outputAmountB * inputReserveB * 1000
const denominatorB = (outputReserveB - outputAmountB) * 997
const inputAmountB = numeratorB / denominatorB + 1

// Buy ETH with TokenA
const outputAmountA = userInputEthValue
const inputReserveA = tokenContractA.methods.balanceOf(exchangeAddressA).call()
const outputReserveA = web3.eth.getBalance(exchangeAddressA)

// Cost
const numeratorA = outputAmountA * inputReserveA * 1000
const denominatorA = (outputReserveA - outputAmountA) * 997
const inputAmountA = numeratorA / denominatorA + 1
```

### Liquidity Provider Fee

There is a 0.30% liquidity provider fee to swap from TokenA to ETH on the input exchange. There is another 0.3% liquidity provider fee to swap the remaining ETH to TokenB.

```javascript
const exchangeAFee = inputAmountA * 0.003
const exchangeBFee = inputAmountB * 0.003
```

Since users only inputs Token A, it can be represented to them as:

```javascript
const combinedFee = inputAmountA * 0.00591
```

### Exchange Rate

The exchange rate is simply the output amount divided by the input amount.

```javascript
const rate = outputAmountB / inputAmountA
```

## Deadlines

Many Uniswap functions include a transaction `deadline` that sets a time after which a transaction can no longer be executed. This limits miners holding signed transactions for extended durations and executing them based off market movements. It also reduces uncertainty around transactions that take a long time to execute due to issues with gas price.

Deadlines are calculated by adding the desired amount of time \(in seconds\) to the latest Ethereum block timestamp.

```javascript
web3.eth.getBlock('latest', (error, block) => {
  deadline = block.timestamp + 300 // transaction expires in 300 seconds (5 minutes)
})
```

## Recipients

Uniswap allows traders to swap tokens and transfer the output to a new `recipient` address. This allows for a type of payment where the payer sends one token and the payee receives another.

## ETH ⇄ ERC20 Trades

Coming soon...

## ERC20 ⇄ ERC20 Trades

Coming soon...

## Custom Pools

Coming soon...
</file>

<file path="docs/contracts/v1/guides/04-custom-linking.md">
---
id: custom-linking
title: Custom Linking
---

## Query Parameters

The Uniswap front-end supports URL query parameters to allow for custom linking to the Uniswap exchange. Users and developers can use these query parameters to link to the Uniswap exchange with custom prefilled settings.

Each Page has specific available URL parameters that can be set. Global parameters can be used on all pages.

A parameter used on an incorrect page will have no effect on exchange settings. Parameters not set with a URL parameter will be set to standard exchange defaults.

## Global

| Parameter | Type     | Description                      |
| :-------- | :------- | :------------------------------- |
| theme     | `String` | Sets them to dark or light mode. |

### Theme Options

Theme can be set as `light` or `dark`.

### Example Usage

`https://app.uniswap.org/#/swap?theme=dark&use=v1`

## Swap Page

| Parameter      | Type             | Description                                                            |
| :------------- | :--------------- | :--------------------------------------------------------------------- |
| inputCurrency  | `address`        | Input currency that will be swapped for output currency.               |
| outputCurrency | `address or ETH` | Output currency that input currency will be swapped for.               |
| slippage       | `number`         | Max slippage to be used during transaction \(in bips\)                 |
| value          | `number`         | The custom token amount to buy or sell.                                |
| field          | `string`         | The field to set custom token amount for. Must be `input` or `output`. |

### Defaults

ETH defaults as the input currency. When a different token is selected for either input or output ETH will default as the opposite selected currency.

### Constraints

Addresses must be valid ERC20 addresses. Slippage and amount values must be valid numbers accepted by the exchange \(or error will prevent from swapping\). Slippage can 0, or within the range 10-&gt;9999 bips \(which converts to 0%, 0.01%-&gt;99%\)

When selecting ETH as the output currency a user must also choose an inputCurrency that is not ETH \(to prevent ETH being populated in both fields\)

### Setting Amounts

Two parameters, field and value can be used to set specific token amounts to be sold or bought. Both fields must be set in the URL or there will be no effect on the settings.

### Example Usage

`https://app.uniswap.org/#/swap?field=input&value=10&inputCurrency=0x0F5D2fB29fb7d3CFeE444a200298f468908cC942?use=v1`

## Send Page

The send page has the same options available as the Swap page, plus one additional parameter, `recipient`.

| Parameter | Type      | Description                                     |
| :-------- | :-------- | :---------------------------------------------- |
| recipient | `address` | Address of the recipient of a send transaction. |

### Example Usage

`https://app.uniswap.org/#/send?recipient=0x74Aa01d162E6dC6A657caC857418C403D48E2D77?use=v1`

## Pool Page

The Pool page is made up of 3 subroutes: `add-liquidity`, `remove-liquidity`, `create-exchange`.

### Add Liquidity

| Parameter   | Type      | Description                                            |
| :---------- | :-------- | :----------------------------------------------------- |
| ethAmount   | `number`  | Amount of ETH to deposit into the pool.                |
| token       | `address` | ERC20 address of the pool to add liquidity to.         |
| tokenAmount | `number`  | Amount of the selected token to deposit into the pool. |

### Example Usage

`https://app.uniswap.org/#/add-liquidity?ethAmount=2.34&token=0x42456D7084eacF4083f1140d3229471bbA2949A8&tokenAmount=300?use=v1`

## Remove Liquidity

| Parameter        | Type      | Description                                                                             |
| :--------------- | :-------- | :-------------------------------------------------------------------------------------- |
| poolTokenAddress | `address` | Pool to withdraw liquidity from. \(Must be an ERC20 address with an existing exchange\) |
| poolTokenAmount  | `number`  | Amount of pool token to be withdrawn from liquidity pool.                               |

### Example Usage

`https://app.uniswap.org/#/remove-liquidity?poolTokenAmount=1.23&use=v1`

## Create Exchange

| Parameter    | Type      | Description                                                                                                |
| :----------- | :-------- | :--------------------------------------------------------------------------------------------------------- |
| tokenAddress | `address` | ERC20 token to create the exchange for. Must be valid ERC20 token for which there is no existing exchange. |

### Example Usage

`https://app.uniswap.org/#/swap?use=v1&create-exchange?tokenAddress=0x0F5D2fB29fb7d3CFeE444a200298f468908cC942`

## Custom Routes

Custom token routes can still be used in combination with URL parameters. URL parameters are higher in the settings hierarchy than custom routes.

An example using custom token route and URL parameters.

`https://app.uniswap.org/#/swap/0x0F5D2fB29fb7d3CFeE444a200298f468908cC942?field=input&value=10&use=v1`
</file>

<file path="docs/contracts/v1/guides/05-iframe-integration.md">
---
id: iframe-integration
title: Iframe Integration
---

Uniswap can be used within other sites as an iframe. An iframe shows an exact version of the app.uniswap.org site and can have custom prefilled settings.

## Why You May Want This

Integrating the Uniswap site directly into your web application can be useful for a variety of reasons.

v1.app.uniswap.org allows users to buy, sell, send, or provide liquidity for ERC20 tokens. An iframe integration may be useful if your application provides services around these ERC20 tokens. \(For example, users can buy DAI through a Uniswap iframe on your site, then allow users to lend that DAI on your site\).

It can also be useful if your application requires users to acquire some token in order to use some service \(For example, allow users to buy "REP" token so they can engage in prediction markets on the Augur Dapp\).

## iframe vs. custom UI

One benefit of an iframe integration is that the your site will automatically keep up with any improvements/additions to the v1.app.uniswap.org site. After the initial integration is setup no further work is needed to pull in updates as the exchange site is updated over time.

## Live Example

An example of an Iframe integration can be found on the FOAM site [https://map.foam.space/](https://map.foam.space/#/at/?lng=-74.0045300&lat=40.6771800&zoom=5.00)

To see the Iframe click the dropdown in the top right and click "get foam".

## Add To Your Site

To include a Uniswap iframe within your site just add an iframe element within your website code and link to the Uniswap exchange.

Linking to a ETH &lt;-&gt; DAI swap page would look something like this. To link to a token of your choice replace the address after "outputCurrency" with the token address of the token you want to link to.

```text
<iframe
  src="https://app.uniswap.org/#/swap?use=v1?outputCurrency=0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359"
  height="660px"
  width="100%"
  style="
    border: 0;
    margin: 0 auto;
    display: block;
    border-radius: 10px;
    max-width: 600px;
    min-width: 300px;
  "
  id="myId"
/>
```

You can customize the selected page, selected custom tokens and more using URL query parameters. See [Custom Linking](custom-linking).
</file>

<file path="docs/contracts/v1/guides/06-token-listing.md">
---
id: token-listing
title: Token Listing
---

It is possible that a token you are interested in is not included in the token dropdown on [https://app.uniswap.org/#/swap?use=v1](https://app.uniswap.org/#/swap?use=v1), however, all tokens that have a deployed uniswap exchange are supported on the front-end.

There are three ways to interact with tokens that are not yet included on the default list.

## 1. Paste the token address into the search box.

If a token is not included in the list, try pasting the token address into the search box. It will populate the dropdown with the token you are looking for.

## 2. Custom Linking

[https://app.uniswap.org/#/swap?use=v1](https://app.uniswap.org/#/swap?use=v1) supports custom linking to all tokens that have a Uniswap exchange. See [Custom Linking](custom-linking) for details on how to link.

For example, to populate the output token field with an unlisted token, we can specify the outputCurrency in the URL and pass in the token's address like this:

`https://app.uniswap.org/#/swap?use=v1?outputCurrency=0xfA3E941D1F6B7b10eD84A0C211bfA8aeE907965e`

## Token Details and Assets

Token information (including decimals, symbol, name, etc.) is pulled from token contracts directly. Logo images are pulled from TrustWallet. If you'd like your token logo updated make a pull request into the TrustWallet assets repo [https://github.com/trustwallet/assets](https://github.com/trustwallet/assets).
</file>

<file path="docs/contracts/v1/reference/_category_.json">
{
  "label": "Technical Reference",
  "position": 3,
  "collapsed": false
}
</file>

<file path="docs/contracts/v1/reference/01-factory.md">
---
id: factory
title: Factory
---

## initializeFactory

| Parameter |                           Description |
| :-------- | ------------------------------------: |
| template  | Ethereum address of exchange template |

### Smart Contract

```python
initializeFactory(template: address)
```

### Web3

```javascript
factoryContract.methods.initializeFactory(template).send()
```

## createExchange

| Parameter | Type    |                        Description |
| :-------- | :------ | ---------------------------------: |
| token     | address | Ethereum address of an ERC20 token |

| Returns |                                        |
| :------ | -------------------------------------: |
| address | Ethereum address of a Uniswap exchange |

### Smart Contract

```python
createExchange(token: address): address
```

### Web3

```javascript
factoryContract.methods.createExchange(token).send()
```

## getExchange

| Parameter | Type    |                        Description |
| :-------- | :------ | ---------------------------------: |
| token     | address | Ethereum address of an ERC20 token |

| Returns |                                        |
| :------ | -------------------------------------: |
| address | Ethereum address of a Uniswap exchange |

### Smart Contract

```python
@constant
getExchange(token: address): address
```

### Web3

```javascript
factoryContract.methods.getExchange(token).call()
```

## getToken

| Parameter | Type    |                            Description |
| :-------- | :------ | -------------------------------------: |
| exchange  | address | Ethereum address of a Uniswap exchange |

| Returns |                                    |
| :------ | ---------------------------------: |
| address | Ethereum address of an ERC20 token |

### Smart Contract

```python
@constant
getToken(exchange: address): address
```

### Web3

```javascript
factoryContract.methods.getToken(exchange).call()
```

## getTokenWithId

| Parameter | Type    |                   Description |
| :-------- | :------ | ----------------------------: |
| token_id  | uint256 | Uniswap ID for an ERC20 token |

| Returns |                                    |
| :------ | ---------------------------------: |
| address | Ethereum address of an ERC20 token |

### Smart Contract

```python
@constant
getTokenWithId(token_id: uint256): address
```

### Web3

```javascript
factoryContract.methods.getTokenWithId(token_id).call()
```
</file>

<file path="docs/contracts/v1/reference/02-exchange.md">
---
id: exchange
title: Exchange
---

## setup

| Parameter  |                        Description |
| :--------- | ---------------------------------: |
| token_addr | Ethereum address of an ERC20 Token |

### Smart Contract

```python
# Can only be called by factory contract during createExchange()
setup(token_addr: address):
```

### Web3

```javascript
// Can only be called by factory contract during createExchange()
exchangeContract.methods.setup((token: String)).send()
```

## addLiquidity

| Parameter     | Type    |                Description |
| :------------ | :------ | -------------------------: |
| msg.value     | uint256 |        Amount of ETH added |
| min_liquidity | uint256 |   Minimum minted liquidity |
| max_tokens    | uint256 | Maximum ERC20 tokens added |
| deadline      | uint256 |       Transaction deadline |

| Returns |                                   |
| :------ | --------------------------------: |
| uint256 | Amount of liquidity tokens minted |

### Smart Contract

```python
@payable
addLiquidity(
    min_liquidity: uint256,
    max_tokens: uint256,
    deadline: uint256
): uint256
```

### Web3

```javascript
exchangeContract.methods.addLiquidity(min_liquidity, max_tokens, deadline).send({ value: ethValue })
```

## removeLiquidity

| Parameter  | Type    |                  Description |
| :--------- | :------ | ---------------------------: |
| amount     | uint256 |   Amount of liquidity burned |
| min_eth    | uint256 |          Minimum ETH removed |
| min_tokens | uint256 | Minimum ERC20 tokens removed |
| deadline   | uint256 |         Transaction deadline |

| Returns |                                 |
| :------ | ------------------------------: |
| uint256 |           Amount of ETH removed |
| uint256 | Amount of ERC20 tokens removed. |

### Smart Contract

```python
removeLiquidity(
    amount: uint256;
    min_eth: uint256,
    min_tokens: uint256,
    deadline: uint256
): (uint256, uint256)
```

### Web3

```javascript
exchangeContract.methods.removeLiquidity(amount, min_eth, min_tokens, deadline).send()
```

## default

| Parameter | Type    |        Description |
| :-------- | :------ | -----------------: |
| msg.value | uint256 | Amount of ETH sold |

### Smart Contract

```python
# Default function in Vyper replaces the "fallback" function in Solidity
@payable
__default__():
```

### Web3

```javascript
web3.eth.sendTransaction({ value: ethAmount })
```

## ethToTokenSwapInput

| Parameter  | Type    |                 Description |
| :--------- | :------ | --------------------------: |
| msg.value  | uint256 |          Amount of ETH sold |
| min_tokens | uint256 | Minimum ERC20 tokens bought |
| deadline   | uint256 |        Transaction deadline |

| Returns |                               |
| :------ | ----------------------------: |
| uint256 | Amount of ERC20 tokens bought |

### Smart Contract

```python
@payable
ethToTokenSwapInput(
    min_tokens: uint256,
    deadline: uint256
): uint256
```

### Web3

```javascript
exchangeContract.methods.ethToTokenSwapInput(min_liquidity, max_tokens, deadline).send({ value: ethValue })
```

## ethToTokenTransferInput

| Parameter  | Type    |                        Description |
| :--------- | :------ | ---------------------------------: |
| msg.value  | uint256 |                 Amount of ETH sold |
| min_tokens | uint256 |        Minimum ERC20 tokens bought |
| deadline   | uint256 |               Transaction deadline |
| recipient  | address | Address that receives ERC20 tokens |

| Returns |                               |
| :------ | ----------------------------: |
| uint256 | Amount of ERC20 tokens bought |

### Smart Contract

```python
@payable
ethToTokenTransferInput(
    min_tokens: uint256,
    deadline: uint256,
    recipient: address
): uint256
```

### Web3

```javascript
exchangeContract.methods
  .ethToTokenTransferInput(min_liquidity, max_tokens, deadline, recipient)
  .send({ value: ethValue })
```

## ethToTokenSwapOutput

| Parameter     | Type    |                   Description |
| :------------ | :------ | ----------------------------: |
| msg.value     | uint256 |              Maximum ETH sold |
| tokens_bought | uint256 | Amount of ERC20 tokens bought |
| deadline      | uint256 |          Transaction deadline |

| Returns |                    |
| :------ | -----------------: |
| uint256 | Amount of ETH sold |

### Smart Contract

```python
@payable
ethToTokenSwapOutput(
    tokens_bought: uint256,
    deadline: uint256
): uint256
```

### Web3

```javascript
exchangeContract.methods.ethToTokenSwapOutput(tokens_bought, deadline).send({ value: ethValue })
```

## ethToTokenTransferOutput

| Parameter     | Type    |                        Description |
| :------------ | :------ | ---------------------------------: |
| msg.value     | uint256 |                   Maximum ETH sold |
| tokens_bought | uint256 |      Amount of ERC20 tokens bought |
| deadline      | uint256 |               Transaction deadline |
| recipient     | address | Address that receives ERC20 tokens |

| Returns |                    |
| :------ | -----------------: |
| uint256 | Amount of ETH sold |

### Smart Contract

```python
@payable
ethToTokenTransferOutput(
    tokens_bought: uint256,
    deadline: uint256,
    recipient: address
): uint256
```

### Web3

```javascript
exchangeContract.methods
  .ethToTokenTransferOutput(tokens_bought, deadline, (recipient: String))
  .send({ value: ethValue })
```

## tokenToEthSwapInput

| Parameter   | Type    |                 Description |
| :---------- | :------ | --------------------------: |
| tokens_sold | uint256 | Amount of ERC20 tokens sold |
| min_eth     | uint256 |          Minimum ETH bought |
| deadline    | uint256 |        Transaction deadline |

| Returns |                      |
| :------ | -------------------: |
| uint256 | Amount of ETH bought |

### Smart Contract

```python
tokenToEthSwapInput(
    tokens_sold: uint256,
    min_eth: uint256,
    deadline: uint256
): uint256
```

### Web3

```javascript
exchangeContract.methods.tokenToEthSwapInput(tokens_sold, min_eth, deadline).send()
```

## tokenToEthTransferInput

| Parameter   | Type    |                 Description |
| :---------- | :------ | --------------------------: |
| tokens_sold | uint256 | Amount of ERC20 tokens sold |
| min_eth     | uint256 |          Minimum ETH bought |
| deadline    | uint256 |        Transaction deadline |
| recipient   | address |   Address that receives ETH |

| Returns |                      |
| :------ | -------------------: |
| uint256 | Amount of ETH bought |

### Smart Contract

```python
tokenToEthTransferInput(
    tokens_sold: uint256,
    min_eth: uint256,
    deadline: uint256,
    recipient: address
): uint256
```

### Web3

```javascript
exchangeContract.methods.tokenToEthTransferInput(tokens_sold, min_eth, deadline, recipient).send()
```

## tokenToEthSwapOutput

| Parameter  | Type    |               Description |
| :--------- | :------ | ------------------------: |
| eth_bought | uint256 |      Amount of ETH bought |
| max_tokens | uint256 | Maximum ERC20 tokens sold |
| deadline   | uint256 |      Transaction deadline |

| Returns |                             |
| :------ | --------------------------: |
| uint256 | Amount of ERC20 tokens sold |

### Smart Contract

```python
tokenToEthSwapOutput(
    eth_bought: uint256,
    max_tokens: uint256,
    deadline: uint256
): uint256
```

### Web3

```javascript
exchangeContract.methods.tokenToEthSwapOutput(eth_bought, max_tokens, (deadline: Integer)).send()
```

## tokenToEthTransferOutput

| Parameter  | Type    |               Description |
| :--------- | :------ | ------------------------: |
| eth_bought | uint256 |      Amount of ETH bought |
| max_tokens | uint256 | Maximum ERC20 tokens sold |
| deadline   | uint256 |      Transaction deadline |
| recipient  | address | Address that receives ETH |

| Returns |                             |
| :------ | --------------------------: |
| uint256 | Amount of ERC20 tokens sold |

### Smart Contract

```python
tokenToEthTransferOutput(
    eth_bought: uint256,
    max_tokens: uint256,
    deadline: uint256,
    recipient: address
): uint256
```

### Web3

```javascript
exchangeContract.methods
  .tokenToEthTransferOutput(eth_bought, max_tokens, (deadline: Integer), (recipient: String))
  .send()
```

## tokenToTokenSwapInput

| Parameter         | Type    |                        Description |
| :---------------- | :------ | ---------------------------------: |
| tokens_sold       | uint256 |  Amount of input ERC20 tokens sold |
| min_tokens_bought | uint256 | Minimum output ERC20 tokens bought |
| min_eth_bought    | uint256 | Minimum ETH bought as intermediary |
| deadline          | uint256 |               Transaction deadline |
| token_addr        | address |      Address of output ERC20 token |

| Returns |                                      |
| :------ | -----------------------------------: |
| uint256 | Amount of output ERC20 tokens bought |

### Smart Contract

```python
tokenToTokenSwapInput(
    tokens_sold: uint256,
    min_tokens_bought: uint256,
    min_eth_bought: uint256,
    deadline: uint256,
    token_addr: address
): uint256
```

### Web3

```javascript
exchangeContract.methods
  .tokenToTokenSwapInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, token_addr)
  .send()
```

## tokenToTokenTransferInput

| Parameter         | Type    |                               Description |
| :---------------- | :------ | ----------------------------------------: |
| tokens_sold       | uint256 |         Amount of input ERC20 tokens sold |
| min_tokens_bought | uint256 |        Minimum output ERC20 tokens bought |
| min_eth_bought    | uint256 |        Minimum ETH bought as intermediary |
| deadline          | uint256 |                      Transaction deadline |
| recipient         | address | Address that receives output ERC20 tokens |
| token_addr        | address |             Address of output ERC20 token |

| Returns |                                      |
| :------ | -----------------------------------: |
| uint256 | Amount of output ERC20 tokens bought |

### Smart Contract

```python
tokenToTokenTransferInput(
    tokens_sold: uint256,
    min_tokens_bought: uint256,
    min_eth_bought: uint256,
    deadline: uint256,
    recipient: address
    token_addr: address
): uint256
```

### Web3

```javascript
exchangeContract.methods
  .tokenToTokenTransferInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, recipient, token_addr)
  .send()
```

## tokenToTokenSwapOutput

| Parameter       | Type    |                          Description |
| :-------------- | :------ | -----------------------------------: |
| tokens_bought   | uint256 | Amount of output ERC20 tokens bought |
| max_tokens_sold | uint256 |    Maximum input ERC20 tokens bought |
| max_eth_sold    | uint256 |   Maximum ETH bought as intermediary |
| deadline        | uint256 |                 Transaction deadline |
| token_addr      | address |        Address of output ERC20 token |

| Returns |                                   |
| :------ | --------------------------------: |
| uint256 | Amount of input ERC20 tokens sold |

### Smart Contract

```python
tokenToTokenSwapOutput(
    tokens_bought: uint256,
    max_tokens_sold: uint256,
    max_eth_sold: uint256,
    deadline: uint256,
    token_addr: address
): uint256
```

### Web3

```javascript
exchangeContract.methods
  .tokenToTokenSwapOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, token_addr)
  .send()
```

## tokenToTokenTransferOutput

| Parameter       | Type    |                               Description |
| :-------------- | :------ | ----------------------------------------: |
| tokens_bought   | uint256 |      Amount of output ERC20 tokens bought |
| max_tokens_sold | uint256 |         Maximum input ERC20 tokens bought |
| max_eth_sold    | uint256 |        Maximum ETH bought as intermediary |
| deadline        | uint256 |                      Transaction deadline |
| recipient       | address | Address that receives output ERC20 tokens |
| token_addr      | address |             Address of output ERC20 token |

| Returns |                                   |
| :------ | --------------------------------: |
| uint256 | Amount of input ERC20 tokens sold |

### Smart Contract

```python
tokenToTokenTransferOutput(
    tokens_bought: uint256,
    max_tokens_sold: uint256,
    max_eth_sold: uint256,
    deadline: uint256,
    recipient: address,
    token_addr: address
): uint256
```

### Web3

```javascript
exchangeContract.methods
  .tokenToTokenTransferOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, recipient, token_addr)
  .send()
```

## tokenToExchangeSwapInput

| Parameter         | Type    |                            Description |
| :---------------- | :------ | -------------------------------------: |
| tokens_sold       | uint256 |      Amount of input ERC20 tokens sold |
| min_tokens_bought | uint256 |     Minimum output ERC20 tokens bought |
| min_eth_bought    | uint256 |     Minimum ETH bought as intermediary |
| deadline          | uint256 |                   Transaction deadline |
| exchange_addr     | address | Address of output ERC20 token exchange |

| Returns |                                      |
| :------ | -----------------------------------: |
| uint256 | Amount of output ERC20 tokens bought |

### Smart Contract

```python
tokenToTokenSwapInput(
    tokens_sold: uint256,
    min_tokens_bought: uint256,
    min_eth_bought: uint256,
    deadline: uint256,
    exchange_addr: address
): uint256
```

### Web3

```javascript
exchangeContract.methods
  .tokenToTokenSwapInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, exchange_addr)
  .send()
```

## tokenToExchangeTransferInput

| Parameter         | Type    |                               Description |
| :---------------- | :------ | ----------------------------------------: |
| tokens_sold       | uint256 |         Amount of input ERC20 tokens sold |
| min_tokens_bought | uint256 |        Minimum output ERC20 tokens bought |
| min_eth_bought    | uint256 |        Minimum ETH bought as intermediary |
| deadline          | uint256 |                      Transaction deadline |
| recipient         | address | Address that receives output ERC20 tokens |
| exchange_addr     | address |    Address of output ERC20 token exchange |

| Returns |                                      |
| :------ | -----------------------------------: |
| uint256 | Amount of output ERC20 tokens bought |

### Smart Contract

```python
tokenToExchangeTransferInput(
    tokens_sold: uint256,
    min_tokens_bought: uint256,
    min_eth_bought: uint256,
    deadline: uint256,
    recipient: address
    exchange_addr: address
): uint256
```

### Web3

```javascript
exchangeContract.methods
  .tokenToExchangeTransferInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, recipient, exchange_addr)
  .send()
```

## tokenToExchangeSwapOutput

| Parameter       | Type    |                            Description |
| :-------------- | :------ | -------------------------------------: |
| tokens_bought   | uint256 |   Amount of output ERC20 tokens bought |
| max_tokens_sold | uint256 |      Maximum input ERC20 tokens bought |
| max_eth_sold    | uint256 |     Maximum ETH bought as intermediary |
| deadline        | uint256 |                   Transaction deadline |
| exchange_addr   | address | Address of output ERC20 token exchange |

| Returns |                                   |
| :------ | --------------------------------: |
| uint256 | Amount of input ERC20 tokens sold |

### Smart Contract

```python
tokenToExchangeSwapOutput(
    tokens_bought: uint256,
    max_tokens_sold: uint256,
    max_eth_sold: uint256,
    deadline: uint256,
    exchange_addr: address
): uint256
```

### Web3

```javascript
exchangeContract.methods
  .tokenToExchangeSwapOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, exchange_addr)
  .send()
```

## tokenToExchangeTransferOutput

| Parameter       | Type    |                               Description |
| :-------------- | :------ | ----------------------------------------: |
| tokens_bought   | uint256 |      Amount of output ERC20 tokens bought |
| max_tokens_sold | uint256 |         Maximum input ERC20 tokens bought |
| max_eth_sold    | uint256 |        Maximum ETH bought as intermediary |
| deadline        | uint256 |                      Transaction deadline |
| recipient       | address | Address that receives output ERC20 tokens |
| exchange_addr   | address |    Address of output ERC20 token exchange |

| Returns |                                   |
| :------ | --------------------------------: |
| uint256 | Amount of input ERC20 tokens sold |

### Smart Contract

```python
tokenToExchangeTransferOutput(
    tokens_bought: uint256,
    max_tokens_sold: uint256,
    max_eth_sold: uint256,
    deadline: uint256,
    recipient: address,
    exchange_addr: address
): uint256
```

### Web3

```javascript
exchangeContract.methods
  .tokenToExchangeTransferOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, recipient, exchange_addr)
  .send()
```

## getEthToTokenInputPrice

| Parameter | Type    |        Description |
| :-------- | :------ | -----------------: |
| eth_sold  | uint256 | Amount of ETH sold |

| Returns |                                           |
| :------ | ----------------------------------------: |
| uint256 | Amount of ERC20 tokens that can be bought |

### Smart Contract

```python
@constant
getEthToTokenInputPrice(eth_sold: uint256): uint256
```

### Web3

```javascript
exchangeContract.methods.getEthToTokenInputPrice(eth_sold).call()
```

## getEthToTokenOutputPrice

| Parameter     | Type    |                   Description |
| :------------ | :------ | ----------------------------: |
| tokens_bought | uint256 | Amount of ERC20 tokens bought |

| Returns |                                 |
| :------ | ------------------------------: |
| uint256 | Amount of ETH that must be sold |

### Smart Contract

```python
@constant
getEthToTokenOutputPrice(tokens_bought: uint256): uint256
```

### Web3

```javascript
exchangeContract.methods.getEthToTokenOutputPrice(tokens_bought).call()
```

## getTokenToEthInputPrice

| Parameter   | Type    |                 Description |
| :---------- | :------ | --------------------------: |
| tokens_sold | uint256 | Amount of ERC20 tokens sold |

| Returns |                                  |
| :------ | -------------------------------: |
| uint256 | Amount of ETH that can be bought |

### Smart Contract

```python
@constant
getTokenToEthInputPrice(tokens_sold: uint256): uint256
```

### Web3

```javascript
exchangeContract.methods.getTokenToEthInputPrice(tokens_sold).call()
```

## getTokenToEthOutputPrice

| Parameter  | Type    |          Description |
| :--------- | :------ | -------------------: |
| eth_bought | uint256 | Amount of ETH bought |

| Returns |                                          |
| :------ | ---------------------------------------: |
| uint256 | Amount of ERC20 tokens that must be sold |

### Smart Contract

```python
@constant
getTokenToEthOutputPrice(eth_bought: uint256): uint256
```

### Web3

```javascript
exchangeContract.methods.getTokenToEthOutputPrice(eth_bought).call()
```

## tokenAddress

| Returns |                                         |
| :------ | --------------------------------------: |
| address | Address of ERC20 token sold on exchange |

### Smart Contract

```python
@constant
tokenAddress(): address
```

### Web3

```javascript
exchangeContract.methods.tokenAddress().call()
```

## factoryAddress

| Returns |                                          |
| :------ | ---------------------------------------: |
| address | Address of factory that created exchange |

### Smart Contract

```python
@constant
factoryAddress(): address
```

### Web3

```javascript
exchangeContract.methods.factoryAddress().call()
```

## name

| Returns |                         |
| :------ | ----------------------: |
| bytes32 | Name of liquidity token |

### Smart Contract

```python
# all exchange contracts have the same name
@constant
name(): bytes32 // Uniswap V1
```

### Web3

```javascript
exchangeContract.methods.tokenAddress().call()
```

## symbol

| Returns |                           |
| :------ | ------------------------: |
| bytes32 | Symbol of liquidity token |

### Smart Contract

```python
# all exchange contracts have the same symbol
@constant
symbol(): bytes32 // UNI-V1
```

### Web3

```javascript
exchangeContract.methods.tokenAddress().call()
```

## decimals

| Returns |                             |
| :------ | --------------------------: |
| uint256 | Decimals of liquidity token |

### Smart Contract

```python
# all exchange contracts have the same decimals
@constant
decimals(): uint256 // 18
```

### Web3

```javascript
exchangeContract.methods.decimals().call()
```

## balanceOf

| Parameter | Type    |      Description |
| :-------- | :------ | ---------------: |
| \_owner   | address | Ethereum address |

| Returns |                                    |
| :------ | ---------------------------------: |
| uint256 | Liquidity token balance of address |

### Smart Contract

```python
@constant
balanceOf(_owner: address): uint256
```

### Web3

```javascript
exchangeContract.methods.balanceOf(_owner).call()
```

## transfer

| Parameter | Type    |        Description |
| :-------- | :------ | -----------------: |
| \_to      | address |  Recipient address |
| \_value   | uint256 | Amount transferred |

| Returns |                                                 |
| :------ | ----------------------------------------------: |
| bool    | True if successful. Reverts or false on failure |

### Smart Contract

```python
transfer(
    _to: address,
    _value : uint256
): bool
```

### Web3

```javascript
exchangeContract.methods.transfer(_to, _value).send()
```

## transferFrom

| Parameter | Type    |        Description |
| :-------- | :------ | -----------------: |
| \_from    | address |     Sender address |
| \_to      | address |  Recipient address |
| \_value   | uint256 | Amount transferred |

| Returns |                                                 |
| :------ | ----------------------------------------------: |
| bool    | True if successful. Reverts or false on failure |

### Smart Contract

```python
transferFrom(
    _from: address,
    _to: address,
    _value : uint256
): bool
```

### Web3

```javascript
exchangeContract.methods.transferFrom(_from, _to, _value).send()
```

## approve

| Parameter | Type    |                 Description |
| :-------- | :------ | --------------------------: |
| \_spender | address | Address of approved spender |
| \_value   | uint256 |           Spender allowance |

| Returns |                                                 |
| :------ | ----------------------------------------------: |
| bool    | True if successful. Reverts or false on failure |

### Smart Contract

```python
approve(
    _spender: address,
    _value: uint256
): bool
```

### Web3

```javascript
exchangeContract.methods.approve(_spender, _value).send()
```

## allowance

| Parameter | Type    |                      Description |
| :-------- | :------ | -------------------------------: |
| \_owner   | address | Address of liquidity token owner |
| \_spender | uint256 |      Address of approved spender |

| Returns |                   |
| :------ | ----------------: |
| uint256 | Spender allowance |

### Smart Contract

```python
allowance(
    _owner: address,
    _spender: address
): uint256
```

### Web3

```javascript
exchangeContract.methods.allowance(_owner, _spender).call()
```
</file>

<file path="docs/contracts/v1/reference/03-interfaces.md">
---
id: interfaces
title: Interfaces
---

## Factory

### Solidity

```solidity
interface UniswapFactoryInterface {
    // Public Variables
    address public exchangeTemplate;
    uint256 public tokenCount;
    // Create Exchange
    function createExchange(address token) external returns (address exchange);
    // Get Exchange and Token Info
    function getExchange(address token) external view returns (address exchange);
    function getToken(address exchange) external view returns (address token);
    function getTokenWithId(uint256 tokenId) external view returns (address token);
    // Never use
    function initializeFactory(address template) external;
}
```

### Vyper

```python
contract UniswapFactoryInterface():
    # Create Exchange
    def createExchange(token: address) -> address: modifying
    # Public Variables
    def exchangeTemplate() -> address: constant
    def tokenCount() -> uint256: constant
    # Get Exchange and Token Info
    def getExchange(token_addr: address) -> address: constant
    def getToken(exchange: address) -> address: constant
    def getTokenWithId(token_id: uint256) -> address: constant
    # Initialize Factory
    def initializeFactory(template: address): modifying
```

## Exchange

### Solidity

```solidity
interface UniswapExchangeInterface {
    // Address of ERC20 token sold on this exchange
    function tokenAddress() external view returns (address token);
    // Address of Uniswap Factory
    function factoryAddress() external view returns (address factory);
    // Provide Liquidity
    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);
    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);
    // Get Prices
    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);
    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);
    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);
    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);
    // Trade ETH to ERC20
    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);
    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);
    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);
    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);
    // Trade ERC20 to ETH
    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);
    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);
    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);
    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);
    // Trade ERC20 to ERC20
    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);
    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);
    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);
    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);
    // Trade ERC20 to Custom Pool
    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);
    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);
    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);
    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);
    // ERC20 compatibility for liquidity tokens
    bytes32 public name;
    bytes32 public symbol;
    uint256 public decimals;
    function transfer(address _to, uint256 _value) external returns (bool);
    function transferFrom(address _from, address _to, uint256 value) external returns (bool);
    function approve(address _spender, uint256 _value) external returns (bool);
    function allowance(address _owner, address _spender) external view returns (uint256);
    function balanceOf(address _owner) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    // Never use
    function setup(address token_addr) external;
}
```

### Vyper

```python
contract UniswapExchangeInterface():
    # Public Variables
    def tokenAddress() -> address: constant
    def factoryAddress() -> address: constant
    # Providing Liquidity
    def addLiquidity(min_liquidity: uint256, max_tokens: uint256, deadline: timestamp) -> uint256: modifying
    def removeLiquidity(amount: uint256, min_eth: uint256(wei), min_tokens: uint256, deadline: timestamp) -> (uint256(wei), uint256): modifying
    # Trading
    def ethToTokenSwapInput(min_tokens: uint256, deadline: timestamp) -> uint256: modifying
    def ethToTokenTransferInput(min_tokens: uint256, deadline: timestamp, recipient: address) -> uint256: modifying
    def ethToTokenSwapOutput(tokens_bought: uint256, deadline: timestamp) -> uint256(wei): modifying
    def ethToTokenTransferOutput(tokens_bought: uint256, deadline: timestamp, recipient: address) -> uint256(wei): modifying
    def tokenToEthSwapInput(tokens_sold: uint256, min_eth: uint256(wei), deadline: timestamp) -> uint256(wei): modifying
    def tokenToEthTransferInput(tokens_sold: uint256, min_eth: uint256(wei), deadline: timestamp, recipient: address) -> uint256(wei): modifying
    def tokenToEthSwapOutput(eth_bought: uint256(wei), max_tokens: uint256, deadline: timestamp) -> uint256: modifying
    def tokenToEthTransferOutput(eth_bought: uint256(wei), max_tokens: uint256, deadline: timestamp, recipient: address) -> uint256: modifying
    def tokenToTokenSwapInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, token_addr: address) -> uint256: modifying
    def tokenToTokenTransferInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, recipient: address, token_addr: address) -> uint256: modifying
    def tokenToTokenSwapOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, token_addr: address) -> uint256: modifying
    def tokenToTokenTransferOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, recipient: address, token_addr: address) -> uint256: modifying
    def tokenToExchangeSwapInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, exchange_addr: address) -> uint256: modifying
    def tokenToExchangeTransferInput(tokens_sold: uint256, min_tokens_bought: uint256, min_eth_bought: uint256(wei), deadline: timestamp, recipient: address, exchange_addr: address) -> uint256: modifying
    def tokenToExchangeSwapOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, exchange_addr: address) -> uint256: modifying
    def tokenToExchangeTransferOutput(tokens_bought: uint256, max_tokens_sold: uint256, max_eth_sold: uint256(wei), deadline: timestamp, recipient: address, exchange_addr: address) -> uint256: modifying
    # Get Price
    def getEthToTokenInputPrice(eth_sold: uint256(wei)) -> uint256: constant
    def getEthToTokenOutputPrice(tokens_bought: uint256) -> uint256(wei): constant
    def getTokenToEthInputPrice(tokens_sold: uint256) -> uint256(wei): constant
    def getTokenToEthOutputPrice(eth_bought: uint256(wei)) -> uint256: constant
    # Pool Token ERC20 Compatibility
    def balanceOf() -> address: constant
    def allowance(_owner : address, _spender : address) -> uint256: constant
    def transfer(_to : address, _value : uint256) -> bool: modifying
    def transferFrom(_from : address, _to : address, _value : uint256) -> bool: modifying
    def approve(_spender : address, _value : uint256) -> bool: modifying
    # Setup
    def setup(token_addr: address): modifying
```

## ERC20 Token

### Solidity

```solidity
interface ERC20Interface {
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    // optional
    function name() external view returns (string);
    function symbol() external view returns (string);
    function decimals() external view returns (string);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}
```

### Vyper

```python
contract ERC20Interface():
    def totalSupply() -> uint256: constant
    def balanceOf(_owner: address) -> uint256: constant
    def allowance(_owner : address, _spender : address) -> uint256: constant
    def transfer(_to : address, _value : uint256) -> bool: modifying
    def approve(_spender : address, _value : uint256) -> bool: modifying
    def transferFrom(_from : address, _to : address, _value : uint256) -> bool: modifying
    # optional
    def name() -> bytes32: constant
    def symbol() -> bytes32: constant
    def decimals() -> uint256: constant
```
</file>

<file path="docs/contracts/v1/_category_.json">
{
  "label": "v1 Protocol",
  "position": 8,
  "collapsed": true
}
</file>

<file path="docs/contracts/v1/overview.md">
---
id: overview
title: Overview
sidebar_position: 1
---

## The Uniswap V1 Smart Contracts

Uniswap V1 is the first version of the protocol, [launched in November 2018](https://twitter.com/haydenzadams/status/1058376395108376577) at Devcon 4. Because of its permissionless nature, it will exist for as long as Ethereum does.

Designed with simplicity in mind, the Uniswap protocol provides an interface for seamless exchange of ERC20 tokens on Ethereum. By eliminating unnecessary forms of rent extraction and middlemen it allows faster, more efficient exchange. Where it makes tradeoffs, decentralization, censorship resistance, and security are prioritized.

Uniswap is open source and functions as a public good. There is no central token or platform fee. No special treatment is given to early investors, adopters, or developers. Token listing is open and free. All smart contract functions are public and all upgrades are opt-in.

This site will serve as a project overview for Uniswap - explaining how it works, how to use it, and how to build on top of it. These docs are actively being worked on and more information will be added on an ongoing basis.

## V1 Features

- Add support for any ERC20 token using the Uniswap [factory](https://github.com/Uniswap/uniswap-v1/blob/master/contracts/uniswap_factory.vy)
- Join liquidity pools to collect fees on ETH-ERC20 pairs
- Liquidity-sensitive automated pricing using [constant product formula](https://github.com/runtimeverification/verified-smart-contracts/blob/uniswap/uniswap/x-y-k.pdf)
- Trade ETH for any ERC20 without wrapping
- Trade any ERC20 for any ERC20 in a single transaction
- Trade and transfer to a different address in a single transaction
- Lowest gas cost of any decentralized exchange
- Support for private and custom uniswap exchanges
- Buy ERC20 tokens from any wallet using ENS
- [Partially verified](https://github.com/runtimeverification/verified-smart-contracts/tree/uniswap/uniswap) smart contracts written in Vyper
- Mobile-optimized open source [frontend implementation](https://github.com/Uniswap/uniswap-interface)
- Funded through an [Ethereum Foundation grant](https://blog.ethereum.org/2018/08/17/ethereum-foundation-grants-update-wave-3/)

## Resources

- [Website](https://uniswap.org)
- [GitHub](https://github.com/Uniswap)
- [Twitter](https://twitter.com/Uniswap)
- [Reddit](https://www.reddit.com/r/Uniswap)
- [Email](mailto:contact@uniswap.org)
- [Whitepaper](https://hackmd.io/s/HJ9jLsfTz)

## How it works

Uniswap is made up of a series of ETH-ERC20 exchange contracts. There is exactly one exchange contract per ERC20 token. If a token does not yet have an exchange it can be created by anyone using the Uniswap factory contract. The factory serves as a public registry and is used to look up all token and exchange addresses added to the system.

Each exchange holds reserves of both ETH and its associated ERC20 token. Anyone can become a liquidity provider on an exchange and contribute to its reserves. This is different than buying or selling; it requires depositing an equivalent value of both ETH and the relevant ERC20 token. Liquidity is pooled across all providers and an internal "pool token" (ERC20) is used to track each providers relative contribution. Pool tokens are minted when liquidity is deposited into the system and can be burned at any time to withdraw a proportional share of the reserves.

Exchange contracts are automated market makers between an ETH-ERC20 pair. Traders can swap between the two in either direction by adding to the liquidity reserve of one and withdrawing from the reserve of the other. Since ETH is a common pair for all ERC20 exchanges, it can be used as an intermediary allowing direct ERC20-ERC20 trades in a single transaction. Users can specify a recipient address if they want to receive purchased tokens at a different address from the one used to make a transaction.

Uniswap uses a "constant product" market making formula which sets the exchange rate based off of the relative size of the ETH and ERC20 reserves, and the amount with which an incoming trade shifts this ratio. Selling ETH for ERC20 tokens increases the size of the ETH reserve and decreases the size of the ERC20 reserve. This shifts the reserve ratio, increasing the ERC20 token's price relative to ETH for subsequent transactions. The larger a trade relative to the total size of the reserves, the more price slippage will occur. Essentially, exchange contracts use the open financial market to decide on the relative value of a pair and uses that as a market making strategy.

A small liquidity provider fee \(0.30%\) is taken out of each trade and added to the reserves. While the ETH-ERC20 reserve ratio is constantly shifting, fees makes sure that the total combined reserve size increases with every trade. This functions as a payout to liquidity providers that is collected when they burn their pool tokens to withdraw their portion of total reserves. Guaranteed arbitrage opportunities from price fluctuations should push a steady flow of transactions through the system and increase the amount of fee revenue generated.

Since Uniswap is entirely on-chain, prices can change between when a transaction is signed and when it is included in a block. Traders can bound price fluctuations by specifying the minimum amount bought on sell orders, or the maximum amount sold on buy orders. This acts as a limit order that will automatically cancel if it is not filled. It is also possible to set transaction deadlines which will cancel orders if they are not executed fast enough.

The reason only one exchange per token can be registered to the factory is to encourage providers to pool their liquidity into a single reserve. However, Uniswap has built in support for ERC20-to-ERC20 trades using the public pools from the factory on one side of the transaction and custom, user-specified pool on the other. Custom pools could have fund managers, use alternate pricing mechanisms, remove liquidity provider fees, integrate complex three dimensional fomo-based ponzi-schemes and more. They just need to implement the Uniswap interface and accept ETH as an intermediary asset. Custom pools do not have the same safety properties as the public ones. It is recommended users only interact with audited, open-source smart contracts.

Upgrading censorship resistant, decentralized smart contracts is difficult. If significant improvements are made to the system a new version will be released. Liquidity providers can choose between moving to the new system or staying in the old one. If possible, new versions will be backwards compatible and able to trade ERC20-to-ERC20 with the old versions similar to a custom pool.

## How to use it

[uniswap.org](https://uniswap.org) is the landing page for the Uniswap protocol. It describes the project and directs users where they need to go.

The Uniswap smart contracts live on Ethereum. Anyone can interact with them directly.

The Uniswap frontend is an open source interface designed to improve user experience when interacting with the smart contracts. Anyone can use the source code to host an interface, or build their own. Hosted interfaces are independent of Uniswap, and should comply with their jurisdictional laws and regulations.
</file>

<file path="docs/contracts/v2/concepts/01-protocol-overview/_category_.json">
{
  "label": "Protocol Overview",
  "position": 1
}
</file>

<file path="docs/contracts/v2/concepts/01-protocol-overview/01-how-uniswap-works.md">
---
id: how-uniswap-works
title: How Uniswap works
---

![](./images/anatomy.jpg)

Uniswap is an _automated liquidity protocol_ powered by a [constant product formula](../protocol-overview/glossary#constant-product-formula)
and implemented in a system of non-upgradeable smart contracts on the [Ethereum](https://ethereum.org/) blockchain.
It obviates the need for trusted intermediaries, prioritizing **decentralization**, **censorship resistance**,
and **security**. Uniswap is **open-source software** licensed under the
[GPL](https://en.wikipedia.org/wiki/GNU_General_Public_License).

Each Uniswap smart contract, or pair, manages a liquidity pool made up of reserves of two [ERC-20](https://eips.ethereum.org/EIPS/eip-20) tokens.

Anyone can become a liquidity provider (LP) for a pool by depositing an equivalent value of each underlying token in return for pool tokens. These tokens track pro-rata LP shares of the total reserves, and can be redeemed for the underlying assets at any time.

![](./images/lp.jpg)

Pairs act as automated market makers, standing ready to accept one token for the other as long as the “constant product” formula is preserved. This formula, most simply expressed as `x * y = k`, states that trades must not change the product (`k`) of a pair’s reserve balances (`x` and `y`). Because `k` remains unchanged from the reference frame of a trade, it is often referred to as the invariant. This formula has the desirable property that larger trades (relative to reserves) execute at exponentially worse rates than smaller ones.

In practice, Uniswap applies a 0.30% fee to trades, which is added to reserves. As a result, each trade actually increases `k`. This functions as a payout to LPs, which is realized when they burn their pool tokens to withdraw their portion of total reserves. In the future, this fee may be reduced to 0.25%, with the remaining 0.05% withheld as a protocol-wide charge.

![](./images/trade.jpg)

Because the relative price of the two pair assets can only be changed through trading, divergences between the Uniswap price and external prices create arbitrage opportunities. This mechanism ensures that Uniswap prices always trend toward the market-clearing price.

## Further reading

To see how token swaps work in practice, and to walk through the lifecycle of a swap, check out [Swaps](../core-concepts/swaps). Or, to see how liquidity pools work, see [Pools](../core-concepts/pools).

Ultimately, of course, the Uniswap protocol is just smart contract code running on Ethereum. To understand how they work, head over to [Smart Contracts](../../reference/smart-contracts/factory).
</file>

<file path="docs/contracts/v2/concepts/01-protocol-overview/02-ecosystem-participants.md">
---
id: ecosystem-participants
title: Ecosystem Participants
---

![](./images/participants.jpg)

The Uniswap ecosystem is primarily comprised of three types of users: liquidity providers, traders, and developers. Liquidity providers are incentivized to contribute [ERC-20](https://eips.ethereum.org/EIPS/eip-20) tokens to common liquidity pools. Traders can swap these tokens for one another for a fixed [0.30% fee](../advanced-topics/fees) (which goes to liquidity providers). Developers can integrate directly with Uniswap smart contracts to power new and exciting interactions with tokens, trading interfaces, retail experiences, and more.

In total, interactions between these classes create a positive feedback loop, fueling digital economies by defining a common language through which tokens can be pooled, traded and used.

## Liquidity Providers

Liquidity providers, or LPs, are not a homogeneous group:

- Passive LPs are token holders who wish to passively invest their assets to accumulate trading fees.

- Professional LPs are focused on market making as their primary strategy. They usually develop custom tools and ways of tracking their liquidity positions across different DeFi projects.

- Token projects sometimes choose to become LPs to create a liquid marketplace for their token. This allows tokens to be bought and sold more easily, and unlocks interoperability with other DeFi projects through Uniswap.

- Finally, some DeFi pioneers are exploring complex liquidity provision interactions like incentivized liquidity, liquidity as collateral, and other experimental strategies. Uniswap is the perfect protocol for projects to experiment with these kinds of ideas.

## Traders

There are a several categories of traders in the protocol ecosystem:

- Speculators use a variety of community built tools and products to swap tokens using liquidity pulled from the Uniswap protocol.

- Arbitrage bots seek profits by comparing prices across different platforms to find an edge. (Though it might seem extractive, these bots actually help equalize prices across broader Ethereum markets and keep things fair.)

- DAPP users buy tokens on Uniswap for use in other applications on Ethereum.

- Smart contracts that execute trades on the protocol by implementing swap functionality (from products like DEX aggregators to custom Solidity scripts).

In all cases, trades are subject to the same flat fee for trading on the protocol. Each is important for increasing the accuracy of prices and incentivizing liquidity.

## Developers/Projects

There are far too many ways Uniswap is used in the wider Ethereum ecosystem to count, but some examples include:

- The open-source, accessible nature of Uniswap means there are countless UX experiments and front-ends built to offer access to Uniswap functionality. You can find Uniswap functions in most of the major DeFi dashboard projects. There are also many [Uniswap-specific tools](https://github.com/Uniswap/universe) built by the community.

- Wallets often integrate swapping and liquidity provision functionality as a core offering of their product.

- DEX (decentralized exchange) aggregators pull liquidity from many liquidity protocols to offer traders the best prices by splitting their trades. Uniswap is the biggest single decentralized liquidity source for these projects.

- Smart contract developers use the suite of functions available to invent new DeFi tools and other various experimental ideas. See projects like [Unisocks](https://unisocks.exchange/) or [Zora](https://ourzora.com/), among many, many others.

## Uniswap Team and Community

The Uniswap team along with the broader Uniswap community drives development of the protocol and ecosystem.
</file>

<file path="docs/contracts/v2/concepts/01-protocol-overview/03-smart-contracts.md">
---
id: smart-contracts
title: Smart contracts
---

Uniswap V2 is a binary smart contract system. [Core](#core) contracts provide fundamental safety guarantees for all parties interacting with Uniswap. [Periphery](#periphery) contracts interact with one or more core contracts but are not themselves part of the core.

## Core

[Source code](https://github.com/Uniswap/uniswap-v2-core)

The core consists of a singleton [factory](#factory) and many [pairs](#pairs), which the factory is responsible for creating and indexing. These contracts are quite minimal, even brutalist. The simple rationale for this is that contracts with a smaller surface area are easier to reason about, less bug-prone, and more functionally elegant. Perhaps the biggest upside of this design is that many desired properties of the system can be asserted directly in the code, leaving little room for error. One downside, however, is that core contracts are somewhat user-unfriendly. In fact, interacting directly with these contracts is not recommended for most use cases. Instead, a periphery contract should be used.

### Factory

[Reference documentation](../../reference/smart-contracts/factory)

The factory holds the generic bytecode responsible for powering pairs. Its primary job is to create one and only one smart contract per unique token pair. It also contains logic to turn on the protocol charge.

### Pairs

[Reference documentation](../../reference/smart-contracts/pair)

[Reference documentation (ERC-20)](../../reference/smart-contracts/pair-erc-20)

Pairs have two primary purposes: serving as automated market makers and keeping track of pool token balances. They also expose data which can be used to build decentralized price oracles.

## Periphery

[Source code](https://github.com/Uniswap/uniswap-v2-periphery)

The periphery is a constellation of smart contracts designed to support domain-specific interactions with the core. Because of Uniswap's permissionless nature, the contracts described below have no special privileges, and are in fact only a small subset of the universe of possible periphery-like contracts. However, they are useful examples of how to safely and efficiently interact with Uniswap V2.

### Library

[Reference documentation](../../reference/smart-contracts/library)

The library provides a variety of convenience functions for fetching data and pricing.

### Router

[Reference documentation](../../reference/smart-contracts/router-02)

The router, which uses the library, fully supports all the basic requirements of a front-end offering trading and liquidity management functionality. Notably, it natively supports multi-pair trades (e.g. x to y to z), treats ETH as a first-class citizen, and offers meta-transactions for removing liquidity.

## Design Decisions

The following sections describe some of the notable design decisions made in Uniswap V2. These are safe to skip unless you're interested in gaining a deep technical understanding of how V2 works under the hood, or writing smart contract integrations!

### Sending Tokens

Typically, smart contracts which need tokens to perform some functionality require would-be interactors to first make an approval on the token contract, then call a function that in turn calls transferFrom on the token contract. This is _not_ how V2 pairs accept tokens. Instead, pairs check their token balances at the _end_ of every interaction. Then, at the beginning of the _next_ interaction, current balances are differenced against the stored values to determine the amount of tokens that were sent by the current interactor. See the <a href='/whitepaper.pdf' target='_blank' rel='noopener noreferrer'>whitepaper</a> for a justification of why this is the case, but the takeaway is that **tokens must be transferred to the pair before calling any token-requiring method** (the one exception to this rule is [Flash Swaps](../core-concepts/flash-swaps).

### WETH

Unlike Uniswap V1 pools, V2 pairs do not support ETH directly, so ETH⇄ERC-20 pairs must be emulated with WETH. The motivation behind this choice was to remove ETH-specific code in the core, resulting in a cleaner codebase. End users can be kept fully ignorant of this implementation detail, however, by simply wrapping/unwrapping ETH in the periphery.

The router fully supports interacting with any WETH pair via ETH.

### Minimum Liquidity

To ameliorate rounding errors and increase the theoretical minimum tick size for liquidity provision, pairs burn the first [MINIMUM_LIQUIDITY](../../reference/smart-contracts/pair#minimum_liquidity) pool tokens. For the vast majority of pairs, this will represent a trivial value. The burning happens automatically during the first liquidity provision, after which point the [totalSupply](../../reference/smart-contracts/pair-erc-20#totalsupply) is forevermore bounded.
</file>

<file path="docs/contracts/v2/concepts/01-protocol-overview/04-glossary.md">
---
id: glossary
title: Glossary
---

### Automated market maker

An automated market maker is a smart contract on Ethereum that holds on-chain liquidity reserves. Users can trade against these reserves at prices set by an automated market making formula.

### Constant product formula

The automated market making algorithm used by Uniswap.
See [x\*y=k](#x--y--k).

### ERC20

ERC20 tokens are fungible tokens on Ethereum. Uniswap supports all standard ERC20 implementations.

### Factory

A smart contract that deploys a unique smart contract for any ERC20/ERC20 trading pair.

### Pair

A smart contract deployed from the Uniswap V2 Factory that enables trading between two ERC20 tokens.

### Pool

Liquidity within a pair is pooled across all liquidity providers.

### Liquidity provider / LP

A liquidity provider is someone who deposits an equivalent value of two ERC20 tokens into the liquidity pool within a pair. Liquidity providers take on price risk and are compensated with fees.

### Mid price

The price between what users can buy and sell tokens at a given moment. In Uniswap this is the ratio of the two ERC20 token reserves.

### Price impact

The difference between the mid-price and the execution price of a trade.

### Slippage

The amount the price moves in a trading pair between when a transaction is submitted and when it is executed.

### Core

Smart contracts that are essential for Uniswap to exist. Upgrading to a new version of core would require a liquidity migration.

### Periphery

External smart contracts that are useful, but not required for Uniswap to exist. New periphery contracts can always be deployed without migrating liquidity.

### Flash swap

A trade that uses the tokens being purchased before paying for them.

### `x * y = k`

The constant product formula.

### Invariant

The "k" value in the constant product formula
</file>

<file path="docs/contracts/v2/concepts/02-core-concepts/_category_.json">
{
  "label": "Core Concepts",
  "position": 2
}
</file>

<file path="docs/contracts/v2/concepts/02-core-concepts/01-swaps.md">
---
id: swaps
title: Swaps
subtitle: Learn about the core functionality of the uniswap protocol. Token Swaps.
---

![](./images/trade.jpg)

## Introduction

Token swaps in Uniswap are a simple way to trade one ERC-20 token for another.

For end-users, swapping is intuitive: a user picks an input token and an output token. They specify an input amount, and the protocol calculates how much of the output token they’ll receive. They then execute the swap with one click, receiving the output token in their wallet immediately.

In this guide, we’ll look at what happens during a swap at the protocol level in order to gain a deeper understanding of how Uniswap works.

Swaps in Uniswap are different from trades on traditional platforms. Uniswap does not use an order book to represent liquidity or determine prices. Uniswap uses an automated market maker mechanism to provide instant feedback on rates and slippage.

As we learned in [Protocol Overview](../protocol-overview/how-uniswap-works), each pair on Uniswap is actually underpinned by a liquidity pool. Liquidity pools are smart contracts that hold balances of two unique tokens and enforces rules around depositing and withdrawing them.

This rule is the [constant product formula](../protocol-overview/glossary#constant-product-formula). When either token is withdrawn (purchased), a proportional amount of the other must be deposited (sold), in order to maintain the constant.

## Anatomy of a swap

At the most basic level, all swaps in Uniswap V2 happen within a single function, aptly named `swap`:

```solidity
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data);
```

## Receiving tokens

As is probably clear from the function signature, Uniswap requires `swap` callers to _specify how many output tokens they would like to receive_ via the `amount{0,1}Out` parameters, which correspond to the desired amount of `token{0,1}`.

## Sending Tokens

What’s not as clear is how Uniswap _receives_ tokens as payment for the swap. Typically, smart contracts which need tokens to perform some functionality require callers to first make an approval on the token contract, then call a function that in turn calls transferFrom on the token contract. This is _not_ how V2 pairs accept tokens. Instead, pairs check their token balances at the _end_ of every interaction. Then, at the beginning of the _next_ interaction, current balances are differenced against the stored values to determine the amount of tokens that were sent by the current interactor. See the <a href='/whitepaper.pdf' rel='noopener noreferrer'>whitepaper</a> for a justification of why this is the case.

The takeaway is that **tokens must be transferred to pairs before swap is called** (the one exception to this rule is [Flash Swaps](flash-swaps)). This means that to safely use the `swap` function, it must be called from _another smart contract_. The alternative (transferring tokens to the pair and then calling `swap`) is not safe to do non-atomically because the sent tokens would be vulnerable to arbitrage.

## Developer resources

- To see how to implement token swaps in a smart contract read [Trading from a smart contract](../../guides/smart-contract-integration/trading-from-a-smart-contract).
- To see how to execute a swap from an interface read [Trading (SDK)](../../../../sdk/2.0.0/guides/trading)
</file>

<file path="docs/contracts/v2/concepts/02-core-concepts/02-pools.md">
---
id: pools
title: Pools
---

![](./images/anatomy.jpg)

## Introduction

Each Uniswap liquidity pool is a trading venue for a pair of ERC20 tokens. When a pool contract is created, its balances of each token are 0; in order for the pool to begin facilitating trades, someone must seed it with an initial deposit of each token. This first liquidity provider is the one who sets the initial price of the pool. They are incentivized to deposit an equal _value_ of both tokens into the pool. To see why, consider the case where the first liquidity provider deposits tokens at a ratio different from the current market rate. This immediately creates a profitable arbitrage opportunity, which is likely to be taken by an external party.

When other liquidity providers add to an existing pool, they must deposit pair tokens proportional to the current price. If they don’t, the liquidity they added is at risk of being arbitraged as well. If they believe the current price is not correct, they may arbitrage it to the level they desire, and add liquidity at that price.

## Pool tokens

![](./images/lp.jpg)

Whenever liquidity is deposited into a pool, unique tokens known as _liquidity tokens_ are minted and sent to the provider's address. These tokens represent a given liquidity provider's contribution to a pool. The proportion of the pool's liquidity provided determines the number of liquidity tokens the provider receives. If the provider is minting a new pool, the number of liquidity tokens they will receive will equal sqrt(x \* y), where x and y represent the amount of each token provided.

Whenever a trade occurs, a 0.3% fee is charged to the transaction sender. This fee is distributed _pro-rata_ to all LPs in the pool upon completion of the trade.

To retrieve the underlying liquidity, plus any fees accrued, liquidity providers must "burn" their liquidity tokens, effectively exchanging them for their portion of the liquidity pool, plus the proportional fee allocation.

As liquidity tokens are themselves tradable assets, liquidity providers may sell, transfer, or otherwise use their liquidity tokens in any way they see fit.

> Learn more with advanced topics:

- [Understanding Returns](../../concepts/advanced-topics/understanding-returns)
- [Fees](../../concepts/advanced-topics/fees)

## Why pools?

Uniswap is unique in that it doesn’t use an order book to derive the price of an asset or to match buyers and sellers of tokens. Instead, Uniswap uses what are called Liquidity Pools.

Liquidity is typically represented by discrete orders placed by individuals onto a centrally operated order book. A participant looking to provide liquidity or make markets must actively manage their orders, continuously updating them in response to the activity of others in the marketplace.

While order books are foundational to finance and work great for certain usecases, they suffer from a few important limitations that are especially magnified when applied to a decentralized or blockchain-native setting. Order books require intermediary infrastructure to host the orderbook and match orders. This creates points of control and adds additional layers of complexity. They also require active participation and management from market makers who usually use sophisticated infrastructure and algorithms, limiting participation to advanced traders. Order books were invented in a world with relatively few assets being traded, so it is not surprising they aren't ideal for an ecosystem where anyone can create their own token, and those tokens usually have low liquidity. In sum, with the infrastructural trade-offs presented by a platform like Ethereum, order books are not the native architecture for implementing a liquidity protocol on a blockchain.

Uniswap focuses on the strengths of Ethereum to reimagine token swaps from first principles.

A blockchain-native liquidity protocol should take advantage of the trusted code execution environment, the autonomous and perpetually running virtual machine, and an open, permissionless, and inclusive access model that produces an exponentially growing ecosystem of virtual assets.

It is important to reiterate that a Pool is just a smart contract, operated by users calling functions on it. Swapping tokens is calling `swap` on a Pool contract instance, while providing liquidity is calling `deposit`.

Just how end-users can interact with the Uniswap protocol through the Interface (which in turn interacts with the underlying contracts), developers can interact directly with the smart contracts and integrate Uniswap functionality into their own applications without relying on intermediaries or needing permission.

## Developer resources

- To see how to pool tokens in a smart contract read [Providing Liquidity](../../guides/smart-contract-integration/providing-liquidity).
</file>

<file path="docs/contracts/v2/concepts/02-core-concepts/03-flash-swaps.md">
---
id: flash-swaps
title: Flash Swaps
---

Uniswap flash swaps allow you to withdraw up to the full reserves of any ERC20 token on Uniswap and execute arbitrary logic at no upfront cost, provided that by the end of the transaction you either:

- pay for the withdrawn ERC20 tokens with the corresponding pair tokens
- return the withdrawn ERC20 tokens along with a small fee

Flash swaps are incredibly useful because they obviate upfront capital requirements and unnecessary order-of-operations constraints for multi-step transactions involving Uniswap.

## Examples

### Capital Free Arbitrage

One particularly interesting use case for flash swaps is capital-free arbitrage. It's well-known that an integral part of Uniswap's design is to create incentives for arbitrageurs to trade the Uniswap price to a "fair" market price. While game-theoretically sound, this strategy is accessible only to those with sufficient capital to take advantage of arbitrage opportunities. Flash swaps remove this barrier entirely, effectively democratizing arbitrage.

Imagine a scenario where the cost of buying 1 ETH on Uniswap is 200 DAI (which is calculated by calling `getAmountIn` with 1 ETH specified as an exact output), and on Oasis (or any other trading venue), 1 ETH buys 220 DAI. To anyone with 200 DAI available, this situation represents a risk-free profit of 20 DAI. Unfortunately, you may not have 200 DAI lying around. With flash swaps, however, this risk-free profit is available for anyone to take as long as they're able to pay gas fees.

### Withdrawing ETH from Uniswap

The first step is to _optimistically_ withdraw 1 ETH from Uniswap via a flash swap. This will serve as the capital that we use to execute our arbitrage. Note that in this scenario, we're assuming that:

- 1 ETH is the pre-calculated profit-maximizing trade
- The price has not changed on Uniswap or Oasis since our calculation

It may be the case that we'd like to calculate the profit-maximizing trade on-chain at the moment of execution, which is robust to price movements. This can be somewhat complex, depending on the strategy being executed. However, one common strategy is trading as profitably as possible _against a fixed external price_. (This price may be e.g., the average execution price of one or more orders on Oasis.) If the Uniswap market price is far enough above or below this external price, the following example contains code that calculates the amount to trade over Uniswap for maximum profit: [`ExampleSwapToPrice.sol`](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSwapToPrice.sol).

### Trade at External Venue

Once we've obtained our temporary capital of 1 ETH from Uniswap, we now can trade this for 220 DAI on Oasis. Once we've received the DAI, we need to pay Uniswap back. We've mentioned that the amount required to cover 1 ETH is 200 DAI, calculated via `getAmountIn`. So, after sending 200 of the DAI back to the Uniswap pair, you're left with 20 DAI of profit!

## Instant Leverage

Flash swaps can be used to improve the efficiency of levering up using lending protocols and Uniswap.

Consider Maker in its simplest form: a system which accepts ETH as collateral and allows DAI to be minted against it while ensuring that the value of the ETH never drops below 150% of the value of the DAI.

Say we use this system to deposit a principal amount of 3 ETH, and mint the maximum amount of DAI. At a price of 1 ETH / 200 DAI, we receive 400 DAI. In theory, we could lever this position up by selling the DAI for more ETH, depositing this ETH, minting the maximum amount of DAI (which would be less this time), and repeating until we've reached our desired leverage level.

It's quite simple to use Uniswap as a liquidity source for the DAI-to-ETH component of this process. However, looping through protocols in this way isn't particularly elegant, and can be gas-intensive.

Luckily, flash swaps enable us to withdraw the _full_ ETH amount upfront. If we wanted 2x leverage against our 3 ETH principal, we could simply request 3 ETH in a flash swap and deposit 6 ETH into Maker. This gives us the ability to mint 800 DAI. If we mint as much as we need to cover our flash swap (say 605), the remainder serves as a safety margin against price movements.

## Developer resources

- To see how to integrate a flash swap in your smart contract read [Using Flash Swaps](../../guides/smart-contract-integration/using-flash-swaps).
</file>

<file path="docs/contracts/v2/concepts/02-core-concepts/04-oracles.md">
---
id: oracles
title: Oracles
---

## Introduction

A price oracle is any tool used to view price information about a given asset. When you look at stock prices on your phone, you are using your phone as a price oracle. Similarly, the app on your phone relies on devices to retrieve price information - likely several, which are aggregated and then displayed to you, the end-user. These are price oracles as well.

When building smart contracts that integrate with DeFi protocols, developers will inevitably run into the price oracle problem. What is the best way to retrieve the price of a given asset on-chain?

Many oracle designs on Ethereum have been implemented on an ad-hoc basis, with varying degrees of decentralization and security. Because of this, the ecosystem has witnessed numerous high-profile hacks where the oracle implementation is the primary attack vector.
Some of these vulnerabilities are discussed [here](https://samczsun.com/taking-undercollateralized-loans-for-fun-and-for-profit/).

While there is no one size fits all solution, Uniswap V2 enables developers to build highly decentralized and manipulation-resistant on-chain price oracles, which may solve many of the demands necessary for building robust protocols.

## Uniswap V2 solution

Uniswap V2 includes several improvements for supporting manipulation-resistant public price feeds. First, every pair measures (but does not store) the market price at the beginning of each block, before any trades take place. This price is expensive to manipulate because it is set by the last transaction, whether it is a mint, swap, or burn, in a previous block.

**To set the measured price to one that is out of sync with the global market price, an attacker has to make a bad trade at the end of a previous block** , typically with no guarantee that they will arbitrage it back in the next block. Attackers will lose money to arbitrageurs unless they can “selfishly” mine two blocks in a row. This type of attack presents several challenges and [has not been observed to date](https://arxiv.org/abs/1912.01798).

Unfortunately, this alone is not enough. If significant value settles based on the price resulting from this mechanism, an attack’s profit will likely outweigh the loss.

Instead, Uniswap V2 adds this end-of-block price to a single cumulative-price variable in the core contract weighted by the amount of time this price existed. **This variable represents a sum of the Uniswap price for every second in the entire history of the contract.**

![](./images/v2_onchain_price_data.png)

This variable can be used by external contracts to track accurate time-weighted average prices (TWAPs) across any time interval.

The TWAP is constructed by reading the cumulative price from an ERC20 token pair at the beginning and at the end of the desired interval. The difference in this cumulative price can then be divided by the length of the interval to create a TWAP for that period.

![](./images/v2_twap.png)

TWAPs can be used directly or as the basis for moving averages (EMAs and SMAs) as needed.

A few notes:

- For a 10-minute TWAP, sample once every 10 minutes. For a 1-week TWAP, sample once every week.
- For a simple TWAP, the cost of manipulation increases (approx. linear) with liquidity on Uniswap, as well as (approx. linear) with the length of time over which you average.
- The Cost of an attack is relatively simple to estimate. Moving the price 5% on a 1-hour TWAP is approximately equal to the amount lost to arbitrage and fees for moving the price 5% every block for 1 hour.

There are some nuances that are good to be aware of when using Uniswap V2 as an oracle, especially where manipulation resistance is concerned. The <a href='/whitepaper.pdf' target='_blank' rel='noopener noreferrer'>whitepaper</a> elaborates on some of them. Additional oracle-focused developer guides and documentation will be released soon.

In the meantime, check out our [example implementation](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol) of a 24 hr TWAP Oracle built on Uniswap V2!

### Manipulation resistance

The cost of manipulating the price for a specific time period can be roughly estimated as the amount lost to arbitrage and fees every block for the entire period. For larger liquidity pools and over longer time periods, this attack is impractical, as the cost of manipulation typically exceeds the value at stake.

Other factors, such as network congestion, can reduce the cost of attack. For more information about Uniswap V2 security considerations, see the [Security](../advanced-topics/security) documentation.

## Building an oracle

To learn more about building oracles check out [building an Oracle](../../guides/smart-contract-integration/building-an-oracle) in the developer guides.
</file>

<file path="docs/contracts/v2/concepts/03-advanced-topics/_category_.json">
{
  "label": "Advanced Topics",
  "position": 3
}
</file>

<file path="docs/contracts/v2/concepts/03-advanced-topics/01-fees.md">
---
id: fees
title: Fees
---

## Liquidity provider fees

There is a **0.3%** fee for swapping tokens. **This fee is split by liquidity providers proportional to their contribution to liquidity reserves.**

Swapping fees are immediately deposited into liquidity reserves. This increases the value of liquidity tokens, functioning as a payout to all liquidity providers proportional to their share of the pool. Fees are collected by burning liquidity tokens to remove a proportional share of the underlying reserves.

Since fees are added to liquidity pools, the invariant increases at the end of every trade. Within a single transaction, the invariant represents `token0_pool * token1_pool` at the end of the previous transaction.

There are many community-developed tools to determine returns. You can also read more in the docs about how to think about [LP returns](../advanced-topics/understanding-returns).

## Protocol Fees

At the moment there are no protocol fees. However, it is possible for a 0.05% fee to be turned on in the future.

More information about a potential future protocol fee can be found [here](https://uniswap.org/blog/uniswap-v2/#path-to-sustainability).

## Protocol Charge Calculation

In the future, it is possible that a protocol-wide charge of 0.05% per trade will take effect. This represents ⅙th (16.6̅%) of the 0.30% fee. The fee is in effect if [feeTo](../../reference/smart-contracts/factory/#feeto) is not `address(0)` (`0x0000000000000000000000000000000000000000`), indicating that feeTo is the recipient of the charge.

This amount would not affect the fee paid by traders, but would affect the amount received by liquidity providers.

Rather than calculating this charge on swaps, which would significantly increase gas costs for all users, the charge is instead calculated when liquidity is added or removed. See the <a href='/whitepaper.pdf' target='_blank' rel='noopener noreferrer'>whitepaper</a> for more details.
</file>

<file path="docs/contracts/v2/concepts/03-advanced-topics/02-pricing.md">
---
id: pricing
title: Pricing
---

## How are prices determined?

As we learned in [Protocol Overview](../protocol-overview/how-uniswap-works), each pair on Uniswap is actually underpinned by a liquidity pool. Liquidity pools are smart contracts that hold balances of two unique tokens and enforces rules around depositing and withdrawing them. The primary rule is the [constant product formula](../protocol-overview/glossary#constant-product-formula). When a token is withdrawn (bought), a proportional amount must be deposited (sold) to maintain the constant. The ratio of tokens in the pool, in combination with the constant product formula, ultimately determine the price that a swap executes at.

## How Uniswap handles prices

In Uniswap V1, trades are always executed at the "best possible" price, calculated at execution time. Somewhat confusingly, this calculation is actually accomplished with one of two different formulas, depending on whether the trade specifies an exact _input_ or _output_ amount. Functionally, the difference between these two functions is miniscule, but the very existence of a difference increases conceptual complexity. Initial attempts to support both functions in V2 proved inelegant, and the decision was made to **not provide any pricing functions in the core**. Instead, pairs directly check whether the invariant was satisfied (accounting for fees) after every trade. This means that rather than relying on a pricing function to _also_ enforce the invariant, V2 pairs simply and transparently ensure their own safety, a nice separation of concerns. One downstream benefit is that V2 pairs will more naturally support other flavors of trades which may emerge, (e.g. trading to a specific price at execution time).

At a high level, in Uniswap V2, _trades must be priced in the periphery_. The good news is that the [library](../../reference/smart-contracts/library)
provides a variety of functions designed to make this quite simple, and all swapping functions in the [router](../../reference/smart-contracts/router-02) are designed with this in mind.

### Pricing Trades

When swapping tokens on Uniswap, it's common to want to receive as many output tokens as possible for an _exact input amount_, or to pay as few input tokens as possible for an _exact output amount_. In order to calculate these amounts, a contract must look up the _current reserves_ of a pair, in order to understand what the current price is. However, it is _not safe to perform this lookup and rely on the results without access to an external price_.

Say a smart contract naively wants to send 10 DAI to the DAI/WETH pair and receive as much WETH as it can get, given the current reserve ratio. If, when called, the naive smart contract simply looks up the current price and executes the trade, it is _vulnerable to front-running and will likely suffer an economic loss_. To see why, consider a malicious actor who sees this transaction before it is confirmed. They could execute a swap which dramatically changes the DAI/WETH price immediately before the naive swap goes through, wait for the naive swap to execute at a bad rate, and then swap to change the price back to what it was before the naive swap. This attack is fairly cheap and low-risk, and can typically be performed for a profit.

To prevent these types of attacks, it's vital to submit swaps _that have access to knowledge about the "fair" price their swap should execute at_. In other words, swaps need access to an _oracle_, to be sure that the best execution they can get from Uniswap is close enough to what the oracle considers the "true" price. While this may sound complicated, the oracle can be as simple as an _off-chain observation of the current market price of a pair_. Because of arbitrage, it's typically the case that the ratio of the intra-block reserves of a pair is close to the "true" market price. So, if a user submits a trade with this knowledge in mind, they can ensure that the losses due to front-running are tightly bounded. This is how, for example, the Uniswap frontend ensure trade safety. It calculates the optimal input/output amounts given observed intra-block prices, and uses the router to perform the swap, which guarantees the swap will execute at a rate no less that `x`% worse than the observed intra-block rate, where `x` is a user-specified slippage tolerance (0.5% by default).

There are, of course, other options for oracles, including [native V2 oracles](../core-concepts/oracles).

### Exact Input

If you'd like to send an exact amount of input tokens in exchange for as many output tokens as possible, you'll want to use [getAmountsOut](../../reference/smart-contracts/router-02#getamountout). The equivalent SDK function is [getOutputAmount](../../../../sdk/2.0.0/reference/pair#getoutputamount), or [minimumAmountOut](../../../../sdk/2.0.0/reference/trade#minimumamountout-since-204) for slippage calculations.

### Exact Output

If you'd like to receive an exact amount of output tokens for as few input tokens as possible, you'll want to use [getAmountsIn](../../reference/smart-contracts/router-02#getamountsin). The equivalent SDK function is [getInputAmount](../../../../sdk/2.0.0/reference/pair#getinputamount), or [maximumAmountIn](../../../../sdk/2.0.0/reference/trade#maximumamountin-since-204) for slippage calculations.

### Swap to Price

For this more advanced use case, see [ExampleSwapToPrice.sol](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSwapToPrice.sol).
</file>

<file path="docs/contracts/v2/concepts/03-advanced-topics/03-understanding-returns.md">
---
id: understanding-returns
title: Understanding Returns
---

Uniswap incentivizes users to add liquidity to trading pools by rewarding providers with the fees generated when other users trade with those pools. Market making, in general, is a complex activity. There is a risk of losing money during large and sustained movement in the underlying asset price compared to simply holding an asset.

### Risks

To understand the risks associated with providing liquidity you can read [https://medium.com/@pintail/uniswap-a-good-deal-for-liquidity-providers-104c0b6816f2](https://medium.com/@pintail/uniswap-a-good-deal-for-liquidity-providers-104c0b6816f2) to get an in-depth look at how to conceptualize a liquidity position.

### Example from the article

<blockquote>

Consider the case where a liquidity provider adds 10,000 DAI and 100 WETH to a pool (for a total value of $20,000), the liquidity pool is now 100,000 DAI and 1,000 ETH in total. Because the amount supplied is equal to 10% of the total liquidity, the contract mints and sends the market maker “liquidity tokens” which entitle them to 10% of the liquidity available in the pool. These are not speculative tokens to be traded. They are merely an accounting or bookkeeping tool to keep track of how much the liquidity providers are owed. If others subsequently add/withdraw coins, new liquidity tokens are minted/burned such that everyone’s relative percentage share of the liquidity pool remains the same.

**Now let’s assume the price trades on Coinbase from $100 to $150. The Uniswap contract should reflect this change as well after some arbitrage. Traders will add DAI and remove ETH until the new ratio is now 150:1.**

What happens to the liquidity provider? The contract reflects something closer to 122,400 DAI and 817 ETH (to check these numbers are accurate, 122,400 \* 817 = 100,000,000 (our constant product) and 122,400 / 817 = 150, our new price). Withdrawing the 10% that we are entitled to would now yield 12,240 DAI and 81.7 ETH. The total market value here is $24,500. Roughly $500 worth of profit was missed out on as a result of the market making.

**Obviously no one wants to provide liquidity out of charitable means, and the revenue isn’t dependent on the ability to flip out of good trades (there is no flipping). Instead, 0.3% of all trade volume is distributed proportionally to all liquidity providers. By default, these fees are put back into the liquidity pool, but can be collected any time. It’s difficult to know what the trade-off is between revenues from fees and losses from directional movements without knowing the amount of in-between trades. The more chop and back and forth, the better.**

## Why is my liquidity worth less than I put in?

To understand why the value of a liquidity provider’s stake can go down despite income from fees, we need to look a bit more closely at the formula used by Uniswap to govern trading. The formula really is very simple. If we neglect trading fees, we have the following:

- `eth_liquidity_pool * token_liquidity_pool = constant_product`

In other words, the number of tokens a trader receives for their ETH and vice versa is calculated such that after the trade, the product of the two liquidity pools is the same as it was before the trade. The consequence of this formula is that for trades which are very small in value compared to the size of the liquidity pool we have:

- `eth_price = token_liquidity_pool / eth_liquidity_pool`

Combining these two equations, we can work out the size of each liquidity pool at any given price, assuming constant total liquidity:

- `eth_liquidity_pool = sqrt(constant_product / eth_price)`
- `token_liquidity_pool = sqrt(constant_product * eth_price)`

So let’s look at the impact of a price change on a liquidity provider. To keep things simple, let’s imagine our liquidity provider supplies 1 ETH and 100 DAI to the Uniswap DAI exchange, giving them 1% of a liquidity pool which contains 100 ETH and 10,000 DAI. This implies a price of 1 ETH = 100 DAI. Still neglecting fees, let’s imagine that after some trading, the price has changed; 1 ETH is now worth 120 DAI. What is the new value of the liquidity provider’s stake? Plugging the numbers into the formulae above, we have:

- `eth_liquidity_pool = 91.2871`
- `dai_liquidity_pool = 10954.4511`

"Since our liquidity provider has 1% of the liquidity tokens, this means they can now claim 0.9129 ETH and 109.54 DAI from the liquidity pool. But since DAI is approximately equivalent to USD, we might prefer to convert the entire amount into DAI to understand the overall impact of the price change. At the current price then, our liquidity is worth a total of 219.09 DAI. What if the liquidity provider had just held onto their original 1 ETH and 100 DAI? Well, now we can easily see that, at the new price, the total value would be 220 DAI. So our liquidity provider lost out by 0.91 DAI by providing liquidity to Uniswap instead of just holding onto their initial ETH and DAI."

"Of course, if the price were to return to the same value as when the liquidity provider added their liquidity, this loss would disappear. **For this reason, we can call it an **impermanent loss**.** Using the equations above, we can derive a formula for the size of the impermanent loss in terms of the price ratio between when liquidity was supplied and now. We get the following:"

- "`impermanent_loss = 2 * sqrt(price_ratio) / (1+price_ratio) — 1`"

- "Which we can plot out to get a general sense of the scale of the impermanent loss at different price ratios:"
  ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fdnazarov%2FOscQ_nmzbA.png?alt=media&token=4dff866e-a740-4121-9da4-9c9105baa404)

- "Or to put it another way:"

  - "a 1.25x price change results in a 0.6% loss relative to HODL"
  - "a 1.50x price change results in a 2.0% loss relative to HODL"
  - "a 1.75x price change results in a 3.8% loss relative to HODL"
  - "a 2x price change results in a 5.7% loss relative to HODL"
  - "a 3x price change results in a 13.4% loss relative to HODL"
  - "a 4x price change results in a 20.0% loss relative to HODL"
  - "a 5x price change results in a 25.5% loss relative to HODL"

- "N.B. The loss is the same whichever direction the price change occurs in (i.e. a doubling in price results in the same loss as a halving)." -->

</blockquote>
</file>

<file path="docs/contracts/v2/concepts/03-advanced-topics/04-security.md">
---
id: security
title: Security
---

## Audit & Formal Verification

Between January 8 and April 30, a team of six engineers reviewed and formally verified crucial components of the smart contracts for Uniswap V2.

Their past work includes smart contract development on and formal verification of multi-collateral DAI.

The scope of work includes:

- Formal verification of the core smart contracts
- Code review of core smart contracts
- Numerical error analysis
- Code review of periphery smart contracts (during ongoing development)

The report also has a "Design Comments" section that provided a deep technical understanding of some of the choices made in Uniswap V2.

> Note: The audit report is no longer available at its original URL. The audit was completed by a team of six engineers between January and April 2020.

## Bug Bounty

Uniswap has an open and ongoing bug [bounty program](https://cantina.xyz/bounties/f9df94db-c7b1-434b-bb06-d1360abdd1be) on Cantina.

## Considerations when building on Uniswap

When integrating Uniswap V2 into another on-chain system, particular care must be taken to avoid security vulnerabilities, avenues for manipulations, and the potential loss of funds.

As a preliminary note: smart contract integrations can happen at two levels: directly with [Pair](../../reference/smart-contracts/pair) contracts, or through the [Router](../../reference/smart-contracts/router-02). Direct interactions offer maximal flexibility but require the most work to get right. Mediated interactions offer more limited capabilities but stronger safety guarantees.

There are two primary categories of risk associated with Uniswap V2. The first involves so-called "static" errors. These can include sending too many tokens to a pair during a swap (or requesting too few tokens back) or allowing transactions to linger in the mempool long enough for the sender's expectations about prices to no longer be accurate.

One may address these errors with fairly straightforward logic checks. Executing these logic checks is the primary purpose of routers. Those who interact directly with pairs must perform these checks themselves (with the help of the [Library](../../reference/smart-contracts/library)).

"Dynamic" risk, the second category, involves runtime pricing. Because Ethereum transactions occur in an adversarial environment, naively written smart contracts can, and will, be exploited for profit. For example, suppose a smart contract checks the asset ratio in a Uniswap pool at runtime and trades against it, assuming that the ratio represents the "fair" or "market" price of these assets. In that case, it is highly vulnerable to manipulation. A malicious actor could, e.g., trivially insert transactions before and after the naive transaction (a so-called "sandwich" attack), causing the smart contract to trade at a radically worse price, profit from this at the trader's expense, and then return the contracts to their original state, all at a low cost. (One important caveat is that these types of attacks are mitigated by trading in highly liquid pools, or at low values.)

The best way to protect against these attacks is to introduce a price oracle. An oracle is any device that returns desired information, in this case, a pair's spot price. The best "oracle" is simply a traders' off-chain observation of the prevailing price, which can be passed into the trade as a safety check. This strategy is best suited to retail trading venues where users initiate transactions on their own behalf. However, it is often the case that a trusted price observation is not available (e.g., in multi-step, programmatic interactions involving Uniswap). Without a price oracle, these interactions will be forced to trade at whatever the (potentially manipulated) rate on Uniswap is. For details on the Uniswap V2 approach to oracles, see [Oracles](../core-concepts/oracles).
</file>

<file path="docs/contracts/v2/concepts/03-advanced-topics/05-math.md">
---
id: math
title: Math
---

This section will be expanded in the future. In the mean time, the [Uniswap V2 whitepaper](https://uniswap.org/whitepaper.pdf) has most relevant math for Uniswap V2.
</file>

<file path="docs/contracts/v2/concepts/03-advanced-topics/06-research.md">
---
id: research
title: Research
---

The automated market maker is a new concept, and as such, new research comes out frequently. We've selected some of the most thoughtful here.

## Uniswap's Financial Alchemy

Authors: Dave White, Martin Tassy, Charlie Noyes, and Dan Robinson

> An automated market maker is a type of decentralized exchange that lets customers trade between on-chain assets like USDC and ETH. Uniswap is the most popular AMM on Ethereum. Like most AMMs, Uniswap facilitates trading between a particular pair of assets by holding reserves of both assets. It sets the trading price between them based on the size of its reserves in such a way that prices will stay in line with the broader market. Anybody who would like to can join the “pool” for a particular pair and become a liquidity provider, or LP, so-called because they provide liquid assets for others to trade against. LPs contribute assets to both reserves simultaneously, taking on some of the risk of trading in exchange for a share of the returns.

- [Uniswap's Financial Alchemy](https://research.paradigm.xyz/uniswaps-alchemy)

## An analysis of Uniswap markets

Authors: Guillermo Angeris, Hsien-Tang Kao, Rei Chiang, Charlie Noyes, Tarun Chitra

> Uniswap---and other constant product markets---appear to work well in practice despite their simplicity. In this paper, we give a simple formal analysis of constant product markets and their generalizations, showing that, under some common conditions, these markets must closely track the reference market price. We also show that Uniswap satisfies many other desirable properties and numerically demonstrate, via a large-scale agent-based simulation, that Uniswap is stable under a wide range of market conditions.

- [An analysis of Uniswap markets](https://arxiv.org/abs/1911.03380)

## Improved Price Oracles: Constant Function Market Makers

Authors: Guillermo Angeris, Tarun Chitra

> Automated market makers, first popularized by Hanson's logarithmic market scoring rule (or LMSR) for prediction markets, have become important building blocks, called 'primitives,' for decentralized finance. A particularly useful primitive is the ability to measure the price of an asset, a problem often known as the pricing oracle problem. In this paper, we focus on the analysis of a very large class of automated market makers, called constant function market makers (or CFMMs) which includes existing popular market makers such as Uniswap, Balancer, and Curve, whose yearly transaction volume totals to billions of dollars. We give sufficient conditions such that, under fairly general assumptions, agents who interact with these constant function market makers are incentivized to correctly report the price of an asset and that they can do so in a computationally efficient way. We also derive several other useful properties that were previously not known. These include lower bounds on the total value of assets held by CFMMs and lower bounds guaranteeing that no agent can, by any set of trades, drain the reserves of assets held by a given CFMM.

- [Improved Price Oracles: Constant Function Market Makers](https://arxiv.org/abs/2003.10001)

## Pintail research

Published [medium](https://medium.com/@pintail) articles by Pintail.

- [Understanding Uniswap Returns](https://medium.com/@pintail/understanding-uniswap-returns-cc593f3499ef)
- [Uniswap: A Good Deal for Liquidity Providers?](https://medium.com/@pintail/uniswap-a-good-deal-for-liquidity-providers-104c0b6816f2)

## Liquidity Provider Returns in Geometric Mean Markets

Authors: Alex Evans

> Geometric mean market makers (G3Ms), such as Uniswap and Balancer, comprise a popular class of automated market makers (AMMs) defined by the following rule: the reserves of the AMM before and after each trade must have the same (weighted) geometric mean. This paper extends several results known for constant-weight G3Ms to the general case of G3Ms with time-varying and potentially stochastic weights. These results include the returns and no-arbitrage prices of liquidity pool (LP) shares that investors receive for supplying liquidity to G3Ms. Using these expressions, we show how to create G3Ms whose LP shares replicate the payoffs of financial derivatives. The resulting hedges are model-independent and exact for derivative contracts whose payoff functions satisfy an elasticity constraint. These strategies allow LP shares to replicate various trading strategies and financial contracts, including standard options. G3Ms are thus shown to be capable of recreating a variety of active trading strategies through passive positions in LP shares.

- [Liquidity Provider Returns in Geometric Mean Markets](https://arxiv.org/abs/2006.08806)

## The Replicating Portfolio of a Constant Product Market

Authors: Joseph Clark

> We derive the replicating portfolio of a constant product market. This is structurally short volatility (selling options) which explains why positive transaction costs are needed to induce liquidity providers to participate. Where futures and options markets do not exist, this payoff can be used to create them.

- [https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3550601](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3550601)
</file>

<file path="docs/contracts/v2/concepts/_category_.json">
{
  "label": "Concepts",
  "position": 2,
  "collapsed": false
}
</file>

<file path="docs/contracts/v2/guides/interface-integration/_category_.json">
{
  "label": "Interface Integration",
  "position": 1
}
</file>

<file path="docs/contracts/v2/guides/interface-integration/01-using-the-api.md">
---
id: using-the-api
title: 'Using the API'
---

In this guide we will create a web interface that consumes and displays data from the Uniswap Subgraph. The goal is to provide a quick overview of a setup that you can extend to create your own UIs and analytics around Uniswap data.

Many different libraries can be used to create an interface and a connection to the subgraph graphql endpoint, but in this guide we will use [React](https://reactjs.org/) for the interface, and [Apollo Client](https://www.apollographql.com/docs/react/) for sending queries. We'll also be using yarn for dependency management.

### Setup and Installs

We'll need to create the basic skeleton for the application. We'll use [create-react-app](https://reactjs.org/docs/create-a-new-react-app.html) for this. We'll also add the dependencies we need. Navigate to your root location in your command line and run:

```javascript
yarn create react-app uniswap-demo
cd uniswap-demo
yarn add  apollo-client apollo-cache-inmemory apollo-link-http graphql graphql-tag @apollo/react-hooks
yarn start
```

In your browser you should see the default React app running. In a text editor open `App.js` within `src` and replace the contents with this stripped down boilerplate. We'll add to this as we go.

```javascript
import React from 'react'
import './App.css'

function App() {
  return <div></div>
}

export default App
```

### Graphql Client

We need to set up some middleware in order to make requests to the Uniswap subgraph and receive data. To do this we'll use Apollo and create a graphql client to handle this.

1. Add the imports shown below and instantiate a new client instance. Notice how we use the link to the Uniswap subgraph here.

```javascript
import React from 'react'
import './App.css'
import { ApolloClient } from 'apollo-client'
import { InMemoryCache } from 'apollo-cache-inmemory'
import { HttpLink } from 'apollo-link-http'

export const client = new ApolloClient({
  link: new HttpLink({
    uri: 'https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2',
  }),
  cache: new InMemoryCache(),
})

function App() {
  return <div></div>
}

export default App
```

2. We also need to add a context so that Apollo can handle requests properly. In your `index.js` file import the proper provider and wrap the root in it like this:

```javascript
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'
import registerServiceWorker from './registerServiceWorker'
import './index.css'
import { ApolloProvider } from 'react-apollo'
import { client } from './App'

ReactDOM.render(
  <ApolloProvider client={client}>
    <App />
  </ApolloProvider>,
  document.getElementById('root')
)
registerServiceWorker()
```

### Writing the queries

Next we'll construct our query and fetch data. For this example we will fetch some data about the Dai token on Uniswap V2. We'll get the current price, and total liquidity across all pairs. We'll be using the Dai address as an id in this query. We'll also fetch the USD price of ETH to help create USD conversion for Dai data.

1. First we need to define the query itself. We'll use `gql` to parse a query string into the GraphQL AST standard. Import the `gql` helper into the app and use it to create the query. Add the following to your `App.js` file:

```javascript
import gql from 'graphql-tag'

const DAI_QUERY = gql`
  query tokens($tokenAddress: Bytes!) {
    tokens(where: { id: $tokenAddress }) {
      derivedETH
      totalLiquidity
    }
  }
`

const ETH_PRICE_QUERY = gql`
  query ethPrice {
    bundle(id: "1") {
      ethPrice
    }
  }
`
```

We use an id of `1` for the bundle because there is only one hardcoded bundle in the subgraph.

### Fetch data

Now we're ready to use these queries to fetch data from the Uniswap V2 subgraph. To do this we can use the `useQuery` hook which uses our client instance to fetch data, and gives us live info about the status of the request. To do this add the following to your `App.js` file:

```javascript
import { useQuery } from '@apollo/react-hooks'

const { loading, error, data: ethPriceData } = useQuery(ETH_PRICE_QUERY)
const {
  loading: daiLoading,
  error: daiError,
  data: daiData,
} = useQuery(DAI_QUERY, {
  variables: {
    tokenAddress: '0x6b175474e89094c44da98b954eedeac495271d0f',
  },
})
```

Notice we're using the Dai token address to fetch data about Dai.

### Formatting Response

Now that we have our data we can format it and display it in the UI. First, we parse the return data to get the actual data that we want. Then we'll use it to get the USD price of Dai. Lastly we'll insert this data into the UI itself.

These queries will return a response object for each query. Within each one we're interested in the root field we defined in the query definition. For the `daiData` response we defined this as `tokens`, and for the `ethPriceData` query we defined this as `ethPrice`. Within each one we'll get an array of results. Because we're only querying for single entities we'll reference the `0` index in the data array.

Add the following lines to your `App.js` file to parse the responses:

```javascript
const daiPriceInEth = daiData && daiData.tokens[0].derivedETH
const daiTotalLiquidity = daiData && daiData.tokens[0].totalLiquidity
const ethPriceInUSD = ethPriceData && ethPriceData.bundles[0].ethPrice
```

### Displaying in the UI

Finally we can use our parsed response data to hydrate the UI. We'll do this in two steps.

1. First we'll create loading states. To detect if a query is still pending a response we can reference the loading variables we've already defined. We'll add two loading states, one for the Dai price, and one for the Dai total liquidity. These may flicker fast because the time to query is fast.

2. Populate with loaded data. Once we detect that the queries have finished loading we can populate the UI with the real data.

To do this add the following lines in the return function of your `App.js` file:

```javascript
return (
  <div>
    <div>
      Dai price:{' '}
      {ethLoading || daiLoading
        ? 'Loading token data...'
        : '$' +
          // parse responses as floats and fix to 2 decimals
          (parseFloat(daiPriceInEth) * parseFloat(ethPriceInUSD)).toFixed(2)}
    </div>
    <div>
      Dai total liquidity:{' '}
      {daiLoading
        ? 'Loading token data...'
        : // display the total amount of DAI spread across all pools
          parseFloat(daiTotalLiquidity).toFixed(0)}
    </div>
  </div>
)
```

### Next steps

This should render a very basic page with these two stats about the Dai token within Uniswap. This is a very basic example of what you can do with the Uniswap subgraph and we encourage you to build out more complex and interesting tools!

You can visit our [analytics site](https://uniswap.info/) to see a more advanced analytics page, or visit [the github](https://github.com/Uniswap/uniswap-info) for more detailed examples of using the Uniswap subgraph to create UIs.

### Review

In the end your `App.js` file should look like this:

```javascript
import React, { useEffect } from 'react'
import './App.css'
import { ApolloClient } from 'apollo-client'
import { InMemoryCache } from 'apollo-cache-inmemory'
import { HttpLink } from 'apollo-link-http'
import { useQuery } from '@apollo/react-hooks'
import gql from 'graphql-tag'

export const client = new ApolloClient({
  link: new HttpLink({
    uri: 'https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2',
  }),
  fetchOptions: {
    mode: 'no-cors',
  },
  cache: new InMemoryCache(),
})

const DAI_QUERY = gql`
  query tokens($tokenAddress: Bytes!) {
    tokens(where: { id: $tokenAddress }) {
      derivedETH
      totalLiquidity
    }
  }
`

const ETH_PRICE_QUERY = gql`
  query bundles {
    bundles(where: { id: "1" }) {
      ethPrice
    }
  }
`

function App() {
  const { loading: ethLoading, data: ethPriceData } = useQuery(ETH_PRICE_QUERY)
  const { loading: daiLoading, data: daiData } = useQuery(DAI_QUERY, {
    variables: {
      tokenAddress: '0x6b175474e89094c44da98b954eedeac495271d0f',
    },
  })

  const daiPriceInEth = daiData && daiData.tokens[0].derivedETH
  const daiTotalLiquidity = daiData && daiData.tokens[0].totalLiquidity
  const ethPriceInUSD = ethPriceData && ethPriceData.bundles[0].ethPrice

  return (
    <div>
      <div>
        Dai price:{' '}
        {ethLoading || daiLoading
          ? 'Loading token data...'
          : '$' +
            // parse responses as floats and fix to 2 decimals
            (parseFloat(daiPriceInEth) * parseFloat(ethPriceInUSD)).toFixed(2)}
      </div>
      <div>
        Dai total liquidity:{' '}
        {daiLoading
          ? 'Loading token data...'
          : // display the total amount of DAI spread across all pools
            parseFloat(daiTotalLiquidity).toFixed(0)}
      </div>
    </div>
  )
}

export default App
```
</file>

<file path="docs/contracts/v2/guides/interface-integration/02-custom-interface-linking.md">
---
id: custom-interface-linking
title: Custom Linking
---

## Query Parameters

The Uniswap front-end supports URL query parameters to allow for custom linking to the Uniswap frontend. Users and developers can use these query parameters to link to the Uniswap frontend with custom prefilled settings.

Each Page has specific available URL parameters that can be set. Global parameters can be used on all pages.

A parameter used on an incorrect page will have no effect on frontend settings. Parameters not set with a URL parameter will be set to standard frontend defaults.

## Global

| Parameter | Type     | Description                      |
| :-------- | :------- | :------------------------------- |
| theme     | `String` | Sets them to dark or light mode. |

### Theme Options

Theme can be set as `light` or `dark`.

### Example Usage

`https://app.uniswap.org/#/swap?theme=dark`

## Swap Page

| Parameter      | Type             | Description                                                            |
| :------------- | :--------------- | :--------------------------------------------------------------------- |
| inputCurrency  | `address`        | Input currency that will be swapped for output currency.               |
| outputCurrency | `address or ETH` | Output currency that input currency will be swapped for.               |
| value          | `number`         | The custom token amount to buy or sell.                                |
| field          | `string`         | The field to set custom token amount for. Must be `input` or `output`. |

### Defaults

ETH defaults as the input currency. When a different token is selected for either input or output ETH will default as the opposite selected currency.

### Constraints

Addresses must be valid ERC20 addresses. Slippage and amount values must be valid numbers accepted by the frontend \(or error will prevent from swapping\). Slippage can 0, or within the range 10-&gt;9999 bips \(which converts to 0%, 0.01%-&gt;99%\)

When selecting ETH as the output currency a user must also choose an inputCurrency that is not ETH \(to prevent ETH being populated in both fields\)

### Setting Amounts

Two parameters, field and value can be used to set specific token amounts to be sold or bought. Both fields must be set in the URL or there will be no effect on the settings.

### Example Usage

`https://app.uniswap.org/#/swap?field=input&value=10&inputCurrency=0x0F5D2fB29fb7d3CFeE444a200298f468908cC942`

## Pool Page

The Pool page is made up of 2 subroutes: `add`, `remove`.

### Add Liquidity

| Parameter | Type      | Description                                                                          |
| :-------- | :-------- | :----------------------------------------------------------------------------------- |
| Token0    | `address` | Pool to withdraw liquidity from. \(Must be an ERC20 address with an existing token\) |
| Token1    | `address` | Pool to withdraw liquidity from. \(Must be an ERC20 address with an existing token\) |

### Example Usage

`https://app.uniswap.org/#/add/v2/0x6B175474E89094C44Da98b954EedeAC495271d0F/0xdAC17F958D2ee523a2206206994597C13D831ec7`

## Remove Liquidity

| Parameter | Type      | Description                                                                          |
| :-------- | :-------- | :----------------------------------------------------------------------------------- |
| Token0    | `address` | Pool to withdraw liquidity from. \(Must be an ERC20 address with an existing token\) |
| Token1    | `address` | Pool to withdraw liquidity from. \(Must be an ERC20 address with an existing token\) |

### Example Usage

`https://app.uniswap.org/#/remove/0x6B175474E89094C44Da98b954EedeAC495271d0F-0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2`
</file>

<file path="docs/contracts/v2/guides/interface-integration/03-iframe-integration.mdx">
---
id: iframe-integration
title: Iframe Integration
---

:::note Swap Widget
These docs are deprecated. Please refer to [Swap Widget](../../../swap-widget/guides/getting-started) to embed the Uniswap swap widget as a React component in your website in 2 minutes. 
:::

Uniswap can be used within other sites as an iframe. An iframe shows an exact version of the Uniswap frontend site and can have custom prefilled settings.

## Why You May Want This

Integrating the Uniswap site directly into your web application can be useful for a variety of reasons.

The interface allows users to buy, sell, send, or provide liquidity for ERC20 tokens. An iframe integration may be useful if your application provides services around these ERC20 tokens. \(For example, users can buy DAI through a Uniswap iframe on your site, then allow users to lend that DAI on your site\).

It can also be useful if your application requires users to acquire some token in order to use some service \(For example, allow users to buy "REP" token so they can engage in prediction markets on the Augur Dapp\).

## iframe vs. custom UI

One benefit of an iframe integration is that the your site will automatically keep up with any improvements/additions to the site. After the initial integration is setup no further work is needed to pull in updates as the exchange site is updated over time.

## Example

```text
<iframe
  src="https://app.uniswap.org/#/swap?field=input&value=10&inputCurrency=0x6b175474e89094c44da98b954eedeac495271d0f"
  height="660px"
  width="100%"
  style="
    border: 0;
    margin: 0 auto;
    margin-bottom: .5rem;
    display: block;
    border-radius: 10px;
    max-width: 960px;
    min-width: 300px;
  "
/>
```

An example of an Iframe integration can be found on the FOAM site [https://map.foam.space/](https://map.foam.space/#/at/?lng=-74.0045300&lat=40.6771800&zoom=5.00)

To see the iframe, click the dropdown in the top right and click `Get FOAM`.

## Add To Your Site

To include a Uniswap iframe within your site just add an iframe element within your website code and link to the Uniswap frontend.

Linking to a ETH &lt;-&gt; DAI swap page would look something like this. To link to a token of your choice replace the address after `outputCurrency` with the token address of the token you want to link to.

```text
<iframe
  src="https://app.uniswap.org/#/swap?outputCurrency=0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359"
  height="660px"
  width="100%"
  style="
    border: 0;
    margin: 0 auto;
    display: block;
    border-radius: 10px;
    max-width: 600px;
    min-width: 300px;
  "
/>
```

You can customize the selected page, selected custom tokens and more using URL query parameters. See [Custom Linking](custom-interface-linking).
</file>

<file path="docs/contracts/v2/guides/smart-contract-integration/_category_.json">
{
  "label": "Smart Contract Integration",
  "position": 3
}
</file>

<file path="docs/contracts/v2/guides/smart-contract-integration/01-quick-start.md">
---
id: quick-start
title: Smart Contract Quick start
---

Developing smart contracts for Ethereum involves a variety of off-chain tools used for producing and testing bytecode
that runs on the [Ethereum Virtual Machine (EVM)](<https://eth.wiki/en/concepts/evm/ethereum-virtual-machine-(evm)-awesome-list>).
Some tools also include workflows for deploying this bytecode to the Ethereum network and testnets.
There are many options for these tools. This guide walks you through writing and testing a simple smart contract that
interacts with the Uniswap Protocol using one specific set of tools (`truffle` + `npm` + `mocha`).

## Requirements

To follow this guide, you must have the following installed:

- [nodejs >= v12.x & npm >= 6.x](https://nodejs.org/en/)

## Bootstrapping a project

You can start from scratch, but it's easier to use a tool like `truffle` to bootstrap an empty project.
Create an empty directory and run `npx truffle init` inside that directory to unbox the default
[Truffle box](https://www.trufflesuite.com/boxes).

```shell script
mkdir demo
cd demo
npx truffle init
```

## Setting up npm

In order to reference the Uniswap V2 contracts, you should use the npm artifacts we deploy containing the core and
periphery smart contracts and interfaces. To add npm dependencies, we must first initialize the npm package.
We can run `npm init` in the same directory to create a `package.json` file. You can accept all the defaults and
modify them later.

```shell script
npm init
```

## Adding dependencies

Now that we have an npm package, we can add our dependencies. Let's add both the
[`@uniswap/v2-core`](https://www.npmjs.com/package/@uniswap/v2-core) and
[`@uniswap/v2-periphery`](https://www.npmjs.com/package/@uniswap/v2-periphery) packages.

```shell script
npm i --save @uniswap/v2-core
npm i --save @uniswap/v2-periphery
```

If you check the `node_modules/@uniswap` directory, you can now find the Uniswap V2 contracts.

```shell script
moody@MacBook-Pro ~/I/u/demo> ls node_modules/@uniswap/v2-core/contracts
UniswapV2ERC20.sol    UniswapV2Pair.sol     libraries/
UniswapV2Factory.sol  interfaces/           test/
moody@MacBook-Pro ~/I/u/demo> ls node_modules/@uniswap/v2-periphery/contracts/
UniswapV2Migrator.sol  examples/              test/
UniswapV2Router01.sol  interfaces/
UniswapV2Router02.sol  libraries/
```

These packages include both the smart contract source code and the build artifacts.

## Writing our contract

We can now get started writing our example contract.
For writing Solidity, we recommend IntelliJ or VSCode with a solidity plugin, but you can use any text editor.
Let's write a contract that returns the value of some amount of liquidity shares for a given token pair.
First create a couple of files:

```shell script
mkdir contracts/interfaces
touch contracts/interfaces/ILiquidityValueCalculator.sol
touch contracts/LiquidityValueCalculator.sol
```

This will be the interface of the contract we implement. Put it in `contracts/interfaces/ILiquidityValueCalculator.sol`.

```solidity
pragma solidity ^0.6.6;

interface ILiquidityValueCalculator {
    function computeLiquidityShareValue(uint liquidity, address tokenA, address tokenB) external returns (uint tokenAAmount, uint tokenBAmount);
}
```

Now let's start with the constructor. You need to know where the `UniswapV2Factory` is deployed in order to compute the
address of the pair and look up the total supply of liquidity shares, plus the amounts for the reserves.
We can store this address as a parameter passed to the constructor.

The factory address is constant on mainnet and all testnets, so it may be tempting to make this value a constant in your contract,
but since we need to unit test the contract it should be an argument. You can use solidity immutables to save on gas
when accessing this variable.

```solidity
pragma solidity ^0.6.6;

import './interfaces/ILiquidityValueCalculator.sol';

contract LiquidityValueCalculator is ILiquidityValueCalculator {
    address public factory;
    constructor(address factory_) public {
        factory = factory_;
    }
}
```

Now we need to be able to look up the total supply of liquidity for a pair, and its token balances.
Let's put this in a separate function. To implement it, we must:

1. Look up the pair address
2. Get the reserves of the pair
3. Get the total supply of the pair liquidity
4. Sort the reserves in the order of tokenA, tokenB

The [`UniswapV2Library`](../../reference/smart-contracts/library) has some helpful methods for this.

```solidity
pragma solidity ^0.6.6;

import './interfaces/ILiquidityValueCalculator.sol';
import '@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol';
import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';

contract LiquidityValueCalculator is ILiquidityValueCalculator {
    function pairInfo(address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB, uint totalSupply) {
        IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));
        totalSupply = pair.totalSupply();
        (uint reserves0, uint reserves1,) = pair.getReserves();
        (reserveA, reserveB) = tokenA == pair.token0() ? (reserves0, reserves1) : (reserves1, reserves0);
    }
}
```

Finally, we just need to compute the share value. We will leave that as an exercise to the reader.

```solidity
pragma solidity ^0.6.6;

import './interfaces/ILiquidityValueCalculator.sol';
import '@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol';
import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';

contract LiquidityValueCalculator is ILiquidityValueCalculator {
    address public factory;
    constructor(address factory_) public {
        factory = factory_;
    }

    function pairInfo(address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB, uint totalSupply) {
        IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));
        totalSupply = pair.totalSupply();
        (uint reserves0, uint reserves1,) = pair.getReserves();
        (reserveA, reserveB) = tokenA == pair.token0() ? (reserves0, reserves1) : (reserves1, reserves0);
    }

    function computeLiquidityShareValue(uint liquidity, address tokenA, address tokenB) external override returns (uint tokenAAmount, uint tokenBAmount) {
        revert('TODO');
    }
}
```

## Writing tests

In order to test your contract, you need to:

1. Bring up a testnet
2. Deploy the `UniswapV2Factory`
3. Deploy at least 2 ERC20 tokens for a pair
4. Create a pair for the factory
5. Deploy your `LiquidityValueCalculator` contract
6. Call `LiquidityValueCalculator#computeLiquidityShareValue`
7. Verify the result with an assertion

\#1 is handled for you automatically by the `truffle test` command.

Note that you should only deploy the precompiled Uniswap contracts in the `build` directories for unit tests.
This is because solidity appends a metadata hash to compiled contract artifacts which includes the hash of the contract
source code path, and compilations on other machines will not result in the exact same bytecode.
This is problematic because in Uniswap V2 we use the hash of the bytecode in the v2-periphery
[`UniswapV2Library`](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol#L24),
to compute the pair address.

To get the bytecode for deploying UniswapV2Factory, you can import the file via:

```javascript
const UniswapV2FactoryBytecode = require('@uniswap/v2-core/build/UniswapV2Factory.json').bytecode
```

We recommend using a standard ERC20 from `@openzeppelin/contracts` for deploying an ERC20.

You can read more about deploying contracts and writing tests using Truffle
[here](https://www.trufflesuite.com/docs/truffle/testing/writing-tests-in-javascript).

## Compiling and deploying the contract

Learn more about compiling and deploying contracts using Truffle
[here](https://www.trufflesuite.com/docs/truffle/getting-started/compiling-contracts) and
[here](https://www.trufflesuite.com/docs/truffle/getting-started/running-migrations) respectively.

## WIP

This guide is a WIP. Please contribute to this guide with the edit button below!
</file>

<file path="docs/contracts/v2/guides/smart-contract-integration/02-trading-from-a-smart-contract.md">
---
id: trading-from-a-smart-contract
title: Implement a Swap
---

When trading from a smart contract, the most important thing to keep in mind is that access to an external price source is _required_. Without this, trades can be frontrun for considerable loss.

_Read [safety considerations](#safety-considerations) for more._

## Using the Router

The easiest way to safely swap tokens is to use the [router](../../reference/smart-contracts/router-02), which provides a variety of methods to safely swap to and from different assets. You'll notice that there is a function for each permutation of swapping to/from an exact amount of ETH/tokens.

First you must use an external price source to calculate the safety parameters for the function you'd like to call. This is either a minimum amount received when selling an exact input or the maximum amount you are willing to pay when buying an exact output amount.

It is also important to ensure that your contract controls enough ETH/tokens to make the swap, and has granted approval to the router to withdraw this many tokens.

_Check out the [Pricing](../../concepts/advanced-topics/pricing#pricing-trades) page for a more in depth discussion on getting prices._

## Example

Imagine you want to swap 50 DAI for as much ETH as possible from your smart contract.

### transferFrom

Before swapping, our smart contracts needs to be in control of 50 DAI. The easiest way to accomplish this is by calling `transferFrom` on DAI with the owner set to `msg.sender`:

```solidity
uint amountIn = 50 * 10 ** DAI.decimals();
require(DAI.transferFrom(msg.sender, address(this), amountIn), 'transferFrom failed.');
```

### approve

Now that our contract owns 50 DAI, we need to approve to the [router](../../reference/smart-contracts/router-02) to withdraw this DAI:

```solidity
require(DAI.approve(address(UniswapV2Router02), amountIn), 'approve failed.');
```

### swapExactTokensForETH

Now we're ready to swap:

```solidity
// amountOutMin must be retrieved from an oracle of some kind
address[] memory path = new address[](2);
path[0] = address(DAI);
path[1] = UniswapV2Router02.WETH();
UniswapV2Router02.swapExactTokensForETH(amountIn, amountOutMin, path, msg.sender, block.timestamp);
```

## Safety Considerations

Because Ethereum transactions occur in an adversarial environment, smart contracts that do not perform safety checks _can be exploited for profit_. If a smart contract assumes that the current price on Uniswap is a "fair" price without performing safety checks, _it is vulnerable to manipulation_. A bad actor could e.g. easily insert transactions before and after the swap (a "sandwich" attack) causing the smart contract to trade at a much worse price, profit from this at the trader's expense, and then return the contracts to their original state. (One important caveat is that these types of attacks are mitigated by trading in extremely liquid pools, and/or at low values.)

The best way to protect against these attacks is to use an external price feed or "price oracle". The best "oracle" is simply _traders' off-chain observation of the current price_, which can be passed into the trade as a safety check. This strategy is best for situations _where users initiate trades on their own behalf_.

However, when an off-chain price can't be used, an on-chain oracle should be used instead. Determining the best oracle for a given situation is not a part of this guide, but for more details on the Uniswap V2 approach to oracles, see [Oracles](../../concepts/core-concepts/oracles).
</file>

<file path="docs/contracts/v2/guides/smart-contract-integration/03-providing-liquidity.md">
---
id: providing-liquidity
title: Providing Liquidity
---

When providing liquidity from a smart contract, the most important thing to keep in mind is that tokens deposited into a pool at any rate other than the current reserve ratio _are vulnerable to being arbitraged_. As an example, if the ratio of x:y in a pair is 10:2 (i.e. the price is 5), and someone naively adds liquidity at 5:2 (a price of 2.5), the contract will simply accept all tokens (changing the price to 3.75 and opening up the market to arbitrage), but only issue pool tokens entitling the sender to the amount of assets sent at the proper ratio, in this case 5:1. To avoid donating to arbitrageurs, it is imperative to add liquidity at the current price. Luckily, it's easy to ensure that this condition is met!

## Using the Router

The easiest way to safely add liquidity to a pool is to use the [router](../../reference/smart-contracts/router-02), which provides simple methods to safely add liquidity to a pool. If the liquidity is to be added to an ERC-20/ERC-20 pair, use [addLiquidity](../../reference/smart-contracts/router-02#addliquidity). If WETH is involved, use [addLiquidityETH](../../reference/smart-contracts/router-02#addliquidityeth).

These methods both require the caller to commit to a _belief about the current price_, which is encoded in the `amount*Desired` parameters. Typically, it's fairly safe to assume that the current fair market price is around what the current reserve ratio is for a pair (because of arbitrage). So, if a user wants to add 1 ETH to a pool, and the current DAI/WETH ratio of the pool is 200/1, it's reasonable to calculate that 200 DAI must be sent along with the ETH, which is an implicit commitment to the price of 200 DAI/1 WETH. However, it's important to note that this must be calculated _before the transaction is submitted_. It is _not safe_ to look up the reserve ratio from within a transaction and rely on it as a price belief, as this ratio can be cheaply manipulated to your detriment.

However, it is still possible to submit a transaction which encodes a belief about the price which ends up being wrong because of a larger change in the true market price before the transaction is confirmed. For that reason, it's necessary to pass an additional set of parameters which encode the caller's tolerance to price changes. These `amount*Min` parameters should typically be set to percentages of the calculated desired price. So, at a 1% tolerance level, if our user sends a transaction with 1 ETH and 200 DAI, `amountETHMin` should be set to e.g. .99 ETH, and `amountTokenMin` should be set to 198 DAI. This means that, at worst, liquidity will be added at a rate between 198 DAI/1 ETH and 202.02 DAI/1 ETH (200 DAI/.99 ETH).

Once the price calculations have been made, it's important to ensure that your contract a) controls at least as many tokens/ETH as were passed as `amount*Desired` parameters, and b) has granted approval to the router to withdraw this many tokens.
</file>

<file path="docs/contracts/v2/guides/smart-contract-integration/04-building-an-oracle.md">
---
id: building-an-oracle
title: Building an Oracle
---

To build a price oracle on Uniswap V2, you must first understand the
requirements for your use case. Once you understand the kind of price
average you require, it is a matter of storing the cumulative price
variable from the pair as often as necessary, and computing
the average price using two or more observations of the
cumulative price variables.

## Understanding requirements

To understand your requirements, you should first research the answer to the
following questions:

- Is data freshness important?
  I.e.: must the price average include the current price?
- Are recent prices more important than historical prices?
  I.e.: is the current price given more weight than historical prices?

Note your answers for the following discussion.

## Oracle Strategies

### Fixed windows

In the case where data freshness is not important and recent prices
are weighted equally with historical prices, it is enough to
store the cumulative price once per period (e.g. once per 24 hours.)

Computing the average price over these data points gives you 'fixed windows',
which can be updated after the lapse of each period. We wrote
an example oracle of this kind
[here](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol).

This example does not limit the maximum size of the fixed window, i.e.
it only requires that the window size is greater than 1 period (e.g. 24 hours).

### Moving averages

In the case where data freshness is important, you can use a sliding
window in which the cumulative price variable is measured more often
than once per period.

There are at least
[two kinds of moving averages](https://www.investopedia.com/terms/m/movingaverage.asp#types-of-moving-averages)
that you can compute using the Uniswap cumulative price variable.

[Simple moving averages](https://www.investopedia.com/terms/s/sma.asp)
give equal weight to each price measurement. We have built
an example of a sliding window oracle
[here](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol).

[Exponential moving averages](https://www.investopedia.com/terms/e/ema.asp)
give more weight to the most recent price measurements. We do not yet have an example written for this type of oracle.

You may wish to use exponential moving averages where recent prices
are more important than historical prices, e.g. in case of liquidations. However, note that
putting more weight on recent prices makes the oracle cheaper to manipulate
than weighting all price measurements equally.

### Computing average prices

To compute the average price given two cumulative price observations, take the difference between
the cumulative price at the beginning and end of the period, and
divide by the elapsed time between them in seconds. This will produce a
[fixed point unsigned Q112x112](https://en.wikipedia.org/wiki/Fixed-point_arithmetic#Notation)
number that represents the price of one asset relative to the other. This number is represented as a `uint224` where
the upper 112 bits represent the integer amount, and the lower 112 bits represent the fractional amount.

Pairs contain both `price0CumulativeLast` and `price1CumulativeLast`, which are ratios of reserves
of `token1`/`token0` and `token0`/`token1` respectively. I.e. the price of `token0` is expressed in terms of
`token1`/`token0`, while the price of `token1` is expressed in terms of `token0`/`token1`.

## Getting the latest cumulative price

If you wish to compute the average price between a historical price cumulative observation and the current cumulative
price, you should use the cumulative price values from the current block. If the cumulative price has not been updated
in the current block, e.g. because there has not been any liquidity event (`mint`/`burn`/`swap`) on the pair in the current
block, you can compute the cumulative price counterfactually.

We provide a library for use in oracle contracts that has the method
[`UniswapV2OracleLibrary#currentCumulativePrices`](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol#L16)
for getting the cumulative price as of the current block.
The current cumulative price returned by this method is computed _counterfactually_, meaning it requires no call to
the relative gas-expensive `#sync` method on the pair.
It is correct regardless of whether a swap has already executed in the current block.

## Notes on overflow

The `UniswapV2Pair` cumulative price variables are designed to eventually overflow,
i.e. `price0CumulativeLast` and `price1CumulativeLast` and `blockTimestampLast` will overflow through 0.

This should not pose an issue to your oracle design, as the price average computation is concerned with differences
(i.e. subtraction) between two separate observations of a cumulative price variable.
Subtracting between two cumulative price values will result in a number that fits within the range of `uint256` as long
as the observations are made for periods of max `2^32` seconds, or ~136 years.

`blockTimestampLast` is stored only in a `uint32`. For the same reason as described above, the pair can save a
storage slot, and many SSTORES over the life of the pair, by storing only `block.timestamp % uint32(-1)`.
This is feasible because the pair is only concerned with the time that elapses between each liquidity event when updating
the cumulative prices, which is always expected to be less than `2^32` seconds.

When computing time elapsed within your own oracle, you can simply store the `block.timestamp` of your observations
as `uint256`, and avoid dealing with overflow math for computing the time elapsed between observations. This is how the
[ExampleSlidingWindowOracle](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol)
handles observation timestamps.

## Integrating the oracle

To integrate an oracle into your contracts, you must ensure the oracle's observations of the cumulative price variable
are kept up to date.
As long as your oracle is up to date, you can depend on it to produce average prices.
The process of keeping your oracle up to date is called 'maintenance'.

## Oracle maintenance

In order to measure average prices over a period, the oracle must have a way
of referencing the cumulative price at the start and end of a period.
The recommended way of doing this is by storing these prices in the oracle contract,
and calling the oracle frequently enough to store the latest cumulative price.

Reliable oracle maintenance is a difficult task,
and can become a point of failure in times of congestion.
Instead, consider building this functionality directly into the
critical calls of your own smart contracts, or incentivize oracle
maintenance calls by other parties.

## No-maintenance option

It is possible to avoid regularly storing this cumulative price at the
start of the period by utilizing storage proofs. However, this approach has limitations,
especially in regard to gas cost and maximum length of the time period over which the average price can be measured.
If you wish to try this approach, you can follow
[this repository by Keydonix](https://github.com/Keydonix/uniswap-oracle/).

Keydonix has developed a general purpose price feed oracle built on Uniswap v2 that supports arbitrary time windows (up to 256 blocks) and doesn't require any active maintenance.
</file>

<file path="docs/contracts/v2/guides/smart-contract-integration/05-using-flash-swaps.md">
---
id: using-flash-swaps
title: Flash Swaps
---

Flash swaps are an integral feature of Uniswap V2. In fact, under the hood, all swaps are actually flash swaps! This simply means that pair contracts send output tokens to the recipient _before_ enforcing that enough input tokens have been received. This is slightly atypical, as one might expect a pair to ensure it's received payment before delivery. However, because Ethereum transactions are _atomic_, we can roll back the entire swap if it turns out that the contract hasn't received enough tokens to make itself whole by the end of the transaction.

To see how this all works, let's start by examining the interface of the `swap` function:

```solidity
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data);
```

For the sake of example, let's assume that we're dealing with a DAI/WETH pair, where DAI is `token0` and WETH is `token1`. `amount0Out` and `amount1Out` specify the amount of DAI and WETH that the `msg.sender` wants the pair to send to the `to` address (one of these amounts may be 0). At this point you may be wondering how the contract _receives_ tokens. For a typical (non-flash) swap, it's actually the responsibility of `msg.sender` to ensure that enough WETH or DAI has _already been sent_ to the pair before `swap` is called (in the context of trading, this is all handled neatly by a router contract). But when executing a flash swap, _tokens do not need to be sent to the contract before calling `swap`_. Instead, they must be sent from within a _callback function_ that the pair triggers on the `to` address.

## Triggering a Flash Swap

To differentiate between the "typical" trading case and the flash swap case, pairs use the `data` parameter. Specifically, if `data.length` equals 0, the contract assumes that payment has already been received, and simply transfers the tokens to the `to` address. But, if `data.length` is greater than 0, the contract transfers the tokens and then calls the following function on the `to` address:

```solidity
function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data);
```

The logic behind this identification strategy is simple: the vast majority of valid flash swap use cases involve interactions with external protocols. The best way to pass information dictating how these interactions happen (function arguments, safety parameters, addresses, etc.) is via the `data` parameter. It's expected that `data` will be `abi.decode`d from within `uniswapV2Call`. In the rare case where no data is required, callers should ensure that `data.length` equals 1 (i.e. encode a single junk byte as `bytes`), and then ignore this argument in `uniswapV2Call`.

Pairs call `uniswapV2Call` with the `sender` argument set to the `msg.sender` of the `swap`. `amount0` and `amount1` are simply `amount0Out` and `amount1Out`.

## Using uniswapV2Call

There are several conditions that should be checked in all `uniswapV2Call` functions:

```solidity
function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) {
  address token0 = IUniswapV2Pair(msg.sender).token0(); // fetch the address of token0
  address token1 = IUniswapV2Pair(msg.sender).token1(); // fetch the address of token1
  assert(msg.sender == IUniswapV2Factory(factoryV2).getPair(token0, token1)); // ensure that msg.sender is a V2 pair
  // rest of the function goes here!
}
```

The first 2 lines simply fetch the token addresses from the pair, and the 3rd ensures that the `msg.sender` is an actual Uniswap V2 pair address.

## Repayment

At the end of `uniswapV2Call`, contracts must return enough tokens to the pair to make it whole. Specifically, this means that the product of the pair reserves after the swap, discounting all token amounts sent by 0.3% LP fee, must be greater than before.

## Multi-Token

In the case where the token withdrawn is _not_ the token returned (i.e. DAI was requested in the flash swap, and WETH was returned, or vice versa), the fee simplifies to the simple swap case. This means that the standard `getAmountIn` pricing function should be used to calculate e.g., the amount of WETH that must be returned in exchange for the amount of DAI that was requested out.

This type of fee calculation gives a slight advantage to the caller, as the fee derived from repayment in a corresponding token will always be slightly less than the fee derived from a direct token repayment, as a result of the difference between the amount required to pay back a swap, versus the amount withdrawn and then directly returned. The approximate comparison of fees is ~ 30 bps for a swap fee vs. 30.09 bps for a direct repayment.

## Single-Token

In the case where the token withdrawn is the _same_ as the token returned (i.e. DAI was requested in the flash swap, used, then returned, or vice versa with WETH), the following condition must be satisfied:

`DAIReservePre - DAIWithdrawn + (DAIReturned * .997) >= DAIReservePre`

It may be more intuitive to rewrite this formula in terms of a "fee" levied on the _withdrawn_ amount (despite the fact that Uniswap always levies fees on input amounts, in this case the _returned_ amount, here we can simplify to an effective fee on the _withdrawn_ amount). If we rearrange, the formula looks like:

`(DAIReturned * .997) - DAIWithdrawn >= 0`

`DAIReturned >= DAIWithdrawn / .997`

So, the effective fee on the withdrawn amount is `.003 / .997 ≈ 0.3009027%`.

## Resources

For further exploration of flash swaps, see the <a href='/whitepaper.pdf' target='_blank' rel='noopener noreferrer'>whitepaper</a>.

## Example

A fully functional example of flash swaps is available: [`ExampleFlashSwap.sol`](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleFlashSwap.sol).

## Interface

```solidity
import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol';
```

```solidity
pragma solidity >=0.5.0;

interface IUniswapV2Callee {
  function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;
}
```
</file>

<file path="docs/contracts/v2/guides/smart-contract-integration/06-getting-pair-addresses.md">
---
id: getting-pair-addresses
title: Pair Addresses
---

## getPair

The most obvious way to get the address for a pair is to call [getPair](../../reference/smart-contracts/factory#getpair) on the factory. If the pair exists, this function will return its address, else `address(0)` (`0x0000000000000000000000000000000000000000`).

- The "canonical" way to determine whether or not a pair exists.
- Requires an on-chain lookup.

## CREATE2

Thanks to some [fancy footwork in the factory](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Factory.sol#L32), we can also compute pair addresses _without any on-chain lookups_ because of [CREATE2](https://eips.ethereum.org/EIPS/eip-1014). The following values are required for this technique:

|                        |                                                                        |
| :--------------------- | :--------------------------------------------------------------------- |
| `address`              | The [factory address](../../reference/smart-contracts/factory#address) |
| `salt`                 | `keccak256(abi.encodePacked(token0, token1))`                          |
| `keccak256(init_code)` | `0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f`   |

- `token0` must be strictly less than `token1` by sort order.

* Can be computed offline.
* Requires the ability to perform `keccak256`.

## Examples

### Solidity

```solidity
address factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;
address token0 = 0xCAFE000000000000000000000000000000000000; // change me!
address token1 = 0xF00D000000000000000000000000000000000000; // change me!

address pair = address(uint160(bytes20(keccak256(abi.encodePacked(
  hex'ff',
  factory,
  keccak256(abi.encodePacked(token0, token1)),
  hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'
))));
```
</file>

<file path="docs/contracts/v2/guides/smart-contract-integration/07-supporting-meta-transactions.md">
---
id: supporting-meta-transactions
title: Supporting meta transactions
---

All Uniswap V2 pool tokens support meta-transaction approvals via the [permit](../../reference/smart-contracts/pair-erc-20#permit) function. This obviates the need for a blocking approve transaction before programmatic interactions with pool tokens can occur.

## ERC-712

In vanilla ERC-20 token contracts, owners may only register approvals by directly calling a function which uses `msg.sender` to permission itself. With meta-approvals, ownership and permissioning are derived from a signature passed into the function by the caller (sometimes referred to as the relayer). Because signing data with Ethereum private keys can be a tricky endeavor, Uniswap V2 relies on [ERC-712](https://eips.ethereum.org/EIPS/eip-712), a signature standard with widespread community support, to ensure user safety and wallet compatibility.

## Domain Separator

```solidity
keccak256(
  abi.encode(
    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
    keccak256(bytes(name)),
    keccak256(bytes('1')),
    chainId,
    address(this)
  )
);
```

- `name` is always `Uniswap V2`, see [name](../../reference/smart-contracts/pair-erc-20#name).
- `chainId` is determined from the [ERC-1344](https://ethereum-magicians.org/t/eip-1344-add-chain-id-opcode/1131) `chainid` opcode.
- `address(this)` is the address of the pair, see [Pair Addresses](../../../../sdk/v2/guides/getting-pair-addresses).

## Permit Typehash

```solidity
keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');`
```
</file>

<file path="docs/contracts/v2/guides/_category_.json">
{
  "label": "Guides",
  "position": 3,
  "collapsed": false
}
</file>

<file path="docs/contracts/v2/reference/API/_category_.json">
{
  "label": "API",
  "position": 1
}
</file>

<file path="docs/contracts/v2/reference/API/01-overview.md">
---
id: overview
title: API Overview
---

This section explains the Uniswap Subgraph and how to interact with it. The Uniswap subgraph indexes data from the Uniswap contracts over time. It organizes data about pairs, tokens, Uniswap as a whole, and more. The subgraph updates any time a transaction is made on Uniswap. The subgraph runs on [The Graph](https://thegraph.com/) protocol's hosted service and can be openly queried.

## Resources

[Subgraph Explorer](https://thegraph.com/explorer/subgraph/uniswap/uniswap-v2) - sandbox for querying data and endpoints for developers.

[Uniswap V2 Subgraph](https://github.com/Uniswap/uniswap-v2-subgraph) - source code for deployed subgraph.

## Usage

The subgraph provides a snapshot of the current state of Uniswap and also tracks historical data. It is currently used to power [uniswap.info](https://uniswap.info/). **It is not intended to be used as a data source for structuring transactions (contracts should be referenced directly for the most reliable live data).**

## Making Queries

To learn more about querying a subgraph refer to [The Graph's documentation](https://thegraph.com/docs/about/introduction).

## Versions

The [Uniswap V2 Subgraph](https://thegraph.com/explorer/subgraph/uniswap/uniswap-v2) only tracks data on Uniswap V2. For Uniswap V1 information see the [V1 Subgraph](https://thegraph.com/explorer/subgraph/graphprotocol/uniswap).
</file>

<file path="docs/contracts/v2/reference/API/02-entities.md">
---
id: entities
title: Entities
---

Entities define the schema of the subgraph, and represent the data that can be queried. Within each entity are sets of fields that store useful information related to the entity. Below is a list of the available entities within the Uniswap Subgraph, and descriptions for the available fields.

To see an interactive sandbox of all entities see the [Graph Explorer](https://thegraph.com/explorer/subgraph/uniswap/uniswap-v2).

Each entity is defined with a value type, which will always be a base AssemblyScript type, or a custom type provided by The Graph's custom TypeScript library. For more information on value types see [here](https://thegraph.com/docs/en/developing/assemblyscript-api/#api-reference).

### Uniswap Factory

The Uniswap Factory entity is responsible for storing aggregate information across all Uniswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more. There is only one UniswapFactory entity in the subgraph.

| Field Name        | Value Type | Description                                                     |
| ----------------- | ---------- | --------------------------------------------------------------- |
| id                | ID         | factory address                                                 |
| pairCount         | Int        | amount of pairs created by the Uniswap factory                  |
| totalVolumeUSD    | BigDecimal | all time USD volume across all pairs (USD is derived)           |
| totalVolumeETH    | BigDecimal | all time volume in ETH across all pairs (ETH is derived)        |
| totalLiquidityUSD | BigDecimal | total liquidity across all pairs stored as a derived USD amount |
| totalLiquidityETH | BigDecimal | total liquidity across all pairs stored as a derived ETH amount |
| txCount           | BigInt     | all time amount of transactions across all pairs                |

### Token

Stores aggregated information for a specific token across all pairs that token is included in.

| Field Name         | Value Type | Description                                                                                                  |
| ------------------ | ---------- | ------------------------------------------------------------------------------------------------------------ |
| id                 | ID         | token address                                                                                                |
| symbol             | String     | token symbol                                                                                                 |
| name               | String     | token name                                                                                                   |
| decimals           | BigInt     | token decimals                                                                                               |
| tradeVolume        | BigDecimal | amount of token traded all time across all pairs                                                             |
| tradeVolumeUSD     | BigDecimal | amount of token in USD traded all time across pairs (only for tokens with liquidity above minimum threshold) |
| untrackedVolumeUSD | BigDecimal | amount of token in USD traded all time across pairs (no minimum liquidity threshold)                         |
| txCount            | BigInt     | amount of transactions all time in pairs including token                                                     |
| totalLiquidity     | BigDecimal | total amount of token provided as liquidity across all pairs                                                 |
| derivedETH         | BigDecimal | ETH per token                                                                                                |

### Pair

Information about a pair. Includes references to each token within the pair, volume information, liquidity information, and more. The pair entity mirrors the pair smart contract, and also contains aggregated information about use.

| Field Name           | Value Type          | Description                                                                                                         |
| -------------------- | ------------------- | ------------------------------------------------------------------------------------------------------------------- |
| id                   | ID                  | pair contract address                                                                                               |
| factory              | UniswapFactory      | reference to Uniswap factory entity                                                                                 |
| token0               | Token               | reference to token0 as stored in pair contract                                                                      |
| token1               | Token               | reference to token1 as stored in pair contract                                                                      |
| reserve0             | BigDecimal          | reserve of token0                                                                                                   |
| reserve1             | BigDecimal          | reserve of token1                                                                                                   |
| totalSupply          | BigDecimal          | total supply of liquidity token distributed to LPs                                                                  |
| reserveETH           | BigDecimal          | total liquidity in pair stored as an amount of ETH                                                                  |
| reserveUSD           | BigDecimal          | total liquidity amount in pair stored as an amount of USD                                                           |
| trackedReserveETH    | BigDecimal          | total liquidity with only tracked amount (see tracked amounts)                                                      |
| token0Price          | BigDecimal          | token0 per token1                                                                                                   |
| token1Price          | BigDecimal          | token1 per token0                                                                                                   |
| volumeToken0         | BigDecimal          | amount of token0 swapped on this pair                                                                               |
| volumeToken1         | BigDecimal          | amount of token1 swapped on this pair                                                                               |
| volumeUSD            | BigDecimal          | total amount swapped all time in this pair stored in USD (only tracked if USD liquidity is above minimum threshold) |
| untrackedVolumeUSD   | BigDecimal          | total amount swapped all time in this pair stored in USD, no minimum liquidity threshold                            |
| txCount              | BigInt              | all time amount of transactions on this pair                                                                        |
| createdAtTimestamp   | BigInt              | timestamp contract was created                                                                                      |
| createdAtBlockNumber | BigInt              | Ethereum block contract was created                                                                                 |
| liquidityPositions   | [LiquidityPosition] | array of liquidity providers, used as a reference to LP entities                                                    |

### User

A user entity is created for any address that provides liquidity to a pool on Uniswap. This entity
can be used to track open positions for users. LiquidyPosition entities can be referenced to get
specific data about each position.

| Field Name         | Value Type          | Description                                    |
| ------------------ | ------------------- | ---------------------------------------------- |
| id                 | ID                  | user address                                   |
| liquidityPositions | [LiquidityPosition] | array of all liquidity positions user has open |
| usdSwapped         | BigDecimal          | total USD value swapped                        |

### LiquidityPositiion

This entity is used to store data about a user's liquidity position. This information, along with
information from the pair itself can be used to provide position sizes, token deposits, and more.

| Field Name            | Value Type | Description                                            |
| --------------------- | ---------- | ------------------------------------------------------ |
| id                    | ID         | user address and pair address concatenated with a dash |
| user                  | User       | reference to user                                      |
| pair                  | Pair       | reference to the pair liquidity is being provided on   |
| liquidityTokenBalance | BigDecimal | amount of LP tokens minted for this position           |

### Transaction

Transaction entities are created for each Ethereum transaction that contains an interaction within Uniswap contracts. This subgraph tracks Mint, Burn, and Swap events on the Uniswap core contracts. Each transaction contains 3 arrays, and at least one of these arrays has a length of 1.

| Field Name  | Value Type | Description                                               |
| ----------- | ---------- | --------------------------------------------------------- |
| id          | ID         | Ethereum transaction hash                                 |
| blockNumber | BigInt     | block transaction was mined in                            |
| timestamp   | BigInt     | timestamp for transaction                                 |
| mints       | [Mint]     | array of Mint events within the transaction, 0 or greater |
| burns       | [Burn]     | array of Burn events within transaction, 0 or greater     |
| swaps       | [Swap]     | array of Swap events within transaction, 0 or greater     |

### Mint

Mint entities are created for every emitted Mint event on the Uniswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, who received the liquidity, and more. This entity can be used to track liquidity provisions on pairs.

| Field Name   | Value Type  | Description                                                 |
| ------------ | ----------- | ----------------------------------------------------------- |
| id           | ID          | Transaction hash plus index in the transaction mint array   |
| transaction  | Transaction | reference to the transaction Mint was included in           |
| timestamp    | BigInt      | timestamp of Mint, used to sort recent liquidity provisions |
| pair         | Pair        | reference to pair                                           |
| to           | Bytes       | recipient of liquidity tokens                               |
| liquidity    | BigDecimal  | amount of liquidity tokens minted                           |
| sender       | Bytes       | address that initiated the liquidity provision              |
| amount0      | BigDecimal  | amount of token0 provided                                   |
| amount1      | BigDecimal  | amount of token1 provided                                   |
| logIndex     | BigInt      | index in the transaction event was emitted                  |
| amountUSD    | BigDecimal  | derived USD value of token0 amount plus token1 amount       |
| feeTo        | Bytes       | address of fee recipient (if fee is on)                     |
| feeLiquidity | BigDecimal  | amount of liquidity sent to fee recipient (if fee is on)    |

### Burn

Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned LP tokens, who received tokens, and more. This entity can be used to track liquidity removals on pairs.

| Field Name   | Value Type  | Description                                               |
| ------------ | ----------- | --------------------------------------------------------- |
| id           | ID          | Transaction hash plus index in the transaction burn array |
| transaction  | Transaction | reference to the transaction Burn was included in         |
| timestamp    | BigInt      | timestamp of Burn, used to sort recent liquidity removals |
| pair         | Pair        | reference to pair                                         |
| to           | Bytes       | recipient of tokens                                       |
| liquidity    | BigDecimal  | amount of liquidity tokens burned                         |
| sender       | Bytes       | address that initiated the liquidity removal              |
| amount0      | BigDecimal  | amount of token0 removed                                  |
| amount1      | BigDecimal  | amount of token1 removed                                  |
| logIndex     | BigInt      | index in the transaction event was emitted                |
| amountUSD    | BigDecimal  | derived USD value of token0 amount plus token1 amount     |
| feeTo        | Bytes       | address of fee recipient (if fee is on)                   |
| feeLiquidity | BigDecimal  | amount of tokens sent to fee recipient (if fee is on)     |

### Swap

Swap entities are created for each token swap within a pair. The Swap entity can be used to get things like swap size (in tokens and USD), sender, recipient and more. See the Swap overview page
for more information on amounts.

| Field Name  | Value Type  | Description                                           |
| ----------- | ----------- | ----------------------------------------------------- |
| id          | ID          | transaction hash plus index in Transaction swap array |
| transaction | Transaction | reference to transaction swap was included in         |
| timestamp   | BigInt      | timestamp of swap, used for sorted lookups            |
| pair        | Pair        | reference to pair                                     |
| sender      | Bytes       | address that initiated the swap                       |
| amount0In   | BigDecimal  | amount of token0 sold                                 |
| amount1In   | BigDecimal  | amount of token1 sold                                 |
| amount0Out  | BigDecimal  | amount of token0 received                             |
| amount1Out  | BigDecimal  | amount of token1 received                             |
| to          | Bytes       | recipient of output tokens                            |
| logIndex    | BigInt      | event index within transaction                        |
| amountUSD   | BigDecimal  | derived amount of tokens sold in USD                  |

### Bundle

The Bundle is used as a global store of derived ETH price in USD. Because there is
no guaranteed common base token across pairs, a global reference of USD price is useful
for deriving other USD values. The Bundle entity stores an updated weighted average of ETH\<-\>Stablecoin pair prices. This provides a strong estimate for the USD price of ETH that can
be used in other places in the subgraph.

| Field Name | Value Type | Description                                           |
| ---------- | ---------- | ----------------------------------------------------- |
| id         | ID         | constant 1                                            |
| ethPrice   | BigDecimal | derived price of ETH in USD based on stablecoin pairs |

## Historical Entities

The subgraph tracks aggregated information grouped by days to provide insights to daily activity on Uniswap. While [time travel queries](https://blocklytics.org/blog/ethereum-blocks-subgraph-made-for-time-travel/) can be used for direct comparison against values in the past, it is much more expensive to query grouped data. For this reason the subgraph tracks information grouped in daily buckets, using timestamps provided by contract events. These entities can be used to query things like total volume on a given day, price of a token on a given day, etc.

For each DayData type, a new entity is created each day.

### UniswapDayData

Tracks data across all pairs aggregated into a daily bucket.

| Field Name        | Value Type      | Description                                                                      |
| ----------------- | --------------- | -------------------------------------------------------------------------------- |
| id                | ID              | unix timestamp for start of day / 86400 giving a unique day index                |
| date              | Int             | unix timestamp for start of day                                                  |
| dailyVolumeETH    | BigDecimal      | total volume across all pairs on this day, stored as a derived amount of ETH     |
| dailyVolumeUSD    | BigDecimal      | total volume across all pairs on this day, stored as a derived amount of USD     |
| totalVolumeETH    | BigDecimal      | all time volume across all pairs in ETH up to and including this day             |
| totalLiquidityETH | BigDecimal      | total liquidity across all pairs in ETH up to and including this day             |
| totalVolumeUSD    | BigDecimal      | all time volume across all pairs in USD up to and including this day             |
| totalLiquidityUSD | BigDecimal      | total liquidity across all pairs in USD up to and including this day             |
| maxStored         | Int             | reference used to store most liquid tokens, used for historical liquidity charts |
| mostLiquidTokens  | [TokenDayData!] | tokens with most liquidity in Uniswap                                            |
| txCount           | BigInt          | number of transactions throughout this day                                       |

### Pair Day Data

Tracks pair data across each day.

| Field Name        | Value Type | Description                                                                                     |
| ----------------- | ---------- | ----------------------------------------------------------------------------------------------- |
| id                | ID         | pair contract address and day id (day start timestamp in unix / 86400) concatenated with a dash |
| date              | Int        | unix timestamp for start of day                                                                 |
| pairAddress       | Bytes      | address for pair contract                                                                       |
| token0            | Token      | reference to token0                                                                             |
| token1            | Token      | reference to token1                                                                             |
| reserve0          | BigDecimal | reserve of token0 (updated during each transaction on pair)                                     |
| reserve1          | BigDecimal | reserve of token1 (updated during each transaction on pair)                                     |
| totalSupply       | BigDecimal | total supply of liquidity token distributed to LPs                                              |
| reserveUSD        | BigDecimal | reserve of token0 plus token1 stored as a derived USD amount                                    |
| dailyVolumeToken0 | BigDecimal | total amount of token0 swapped throughout day                                                   |
| dailyVolumeToken1 | BigDecimal | total amount of token1 swapped throughout day                                                   |
| dailyVolumeUSD    | BigDecimal | total volume within pair throughout day                                                         |
| dailyTxns         | BigInt     | amount of transactions on pair throughout day                                                   |

### TokenDayData

Tracks token data aggregated across all pairs that include token.

| Field Name          | Value Type    | Description                                                                                                                            |
| ------------------- | ------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| id                  | ID            | token address and day id (day start timestamp in unix / 86400) concatenated with a dash                                                |
| date                | Int           | unix timestamp for start of day                                                                                                        |
| token               | Token         | reference to token entity                                                                                                              |
| dailyVolumeToken    | BigDecimal    | amount of token swapped across all pairs throughout day                                                                                |
| dailyVolumeETH      | BigDecimal    | amount of token swapped across all pairs throughout day stored as a derived amount of ETH                                              |
| dailyVolumeUSD      | BigDecimal    | amount of token swapped across all pairs throughout day stored as a derived amount of USD                                              |
| dailyTxns           | BigInt        | amount of transactions with this token across all pairs                                                                                |
| totalLiquidityToken | BigDecimal    | token amount of token deposited across all pairs                                                                                       |
| totalLiquidityETH   | BigDecimal    | token amount of token deposited across all pairs stored as amount of ETH                                                               |
| totalLiquidityUSD   | BigDecimal    | token amount of token deposited across all pairs stored as amount of USD                                                               |
| priceUSD            | BigDecimal    | price of token in derived USD                                                                                                          |
| maxStored           | Int           | amount of token deposited in pair with highest token liquidity - used only as a reference for storing most liquid pairs for this token |
| mostLiquidPairs     | [PairDayData] | pairs with most liquidity for this token                                                                                               |
</file>

<file path="docs/contracts/v2/reference/API/03-queries.md">
---
id: queries
title: Queries
---

The subgraph can be queried to retrieve important information about Uniswap, pairs, tokens, transactions, users, and more. This page will provide examples for common queries.

To try these queries and run your own visit the [subgraph sandbox](https://thegraph.com/explorer/subgraph/uniswap/uniswap-v2).

### Global Data

To query global data you can pass in the Uniswap Factory address and select from available fields.

#### Global Stats

All time volume in USD, total liquidity in USD, all time transaction count.

```
{
 uniswapFactory(id: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f"){
   totalVolumeUSD
   totalLiquidityUSD
   txCount
 }
}
```

#### Global Historical lookup

To get a snapshot of past state, use The Graph's block query feature and query at a previous block. See this post to get more information about [fetching block numbers from timestamps](https://blocklytics.org/blog/ethereum-blocks-subgraph-made-for-time-travel/). This can be used to calculate things like 24hr volume.

```
{
 uniswapFactory(id: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", block: {number: 10291203}){
   totalVolumeUSD
   totalLiquidityUSD
   txCount
 }
}
```

### Pair Data

#### Pair Overview

Fetch a snapshot of the current state of the pair with common values. This example fetches the DAI/WETH pair.

```
{
 pair(id: "0xa478c2975ab1ea89e8196811f51a7b7ade33eb11"){
     token0 {
       id
       symbol
       name
       derivedETH
     }
     token1 {
       id
       symbol
       name
       derivedETH
     }
     reserve0
     reserve1
     reserveUSD
     trackedReserveETH
     token0Price
     token1Price
     volumeUSD
     txCount
 }
}
```

#### All pairs in Uniswap

The Graph limits entity return amounts to 1000 per query as of now. To get all pairs on Uniswap use a loop and graphql skip query to fetch multiple chunks of 1000 pairs. The query would look like this (where skip is some incrementing variable passed into your query).

```
{
 query pairs($skip: Int!) {
   pairs(first: 1000, skip: $skip) {
     id
   }
 }
}
```

#### Most liquid pairs

Order by liquidity to get the most liquid pairs in Uniswap.

```
{
 pairs(first: 1000, orderBy: reserveUSD, orderDirection: desc) {
   id
 }
}
```

#### Recent Swaps within a Pair

Get the last 100 swaps on a pair by fetching Swap events and passing in the pair address. You'll often want token information as well.

```
{
swaps(orderBy: timestamp, orderDirection: desc, where:
 { pair: "0xa478c2975ab1ea89e8196811f51a7b7ade33eb11" }
) {
     pair {
       token0 {
         symbol
       }
       token1 {
         symbol
       }
     }
     amount0In
     amount0Out
     amount1In
     amount1Out
     amountUSD
     to
 }
}
```

#### Pair Daily Aggregated

Day data is useful for building charts and historical views around entities. To get stats about a pair in daily buckets query for day entities bounded by timestamps. This query gets the first 100 days after the given unix timestamp on the DAI/WETH pair.

```
{
 pairDayDatas(first: 100, orderBy: date, orderDirection: asc,
   where: {
     pairAddress: "0xa478c2975ab1ea89e8196811f51a7b7ade33eb11",
     date_gt: 1592505859
   }
 ) {
     date
     dailyVolumeToken0
     dailyVolumeToken1
     dailyVolumeUSD
     reserveUSD
 }
}
```

### Token Data

Token data can be fetched using the token contract address as an ID. Token data is aggregated across all pairs the token is included in. Any token that is included in some pair in Uniswap can be queried.

#### Token Overview

Get a snapshot of the current stats on a token in Uniswap. This query fetches current stats on DAI.
The allPairs field gets the first 200 pairs DAI is included in sorted by liquidity in derived USD.

```
{
 token(id: "0x6b175474e89094c44da98b954eedeac495271d0f"){
   name
   symbol
   decimals
   derivedETH
   tradeVolumeUSD
   totalLiquidity
 }
}
```

#### All Tokens in Uniswap

Similar to fetching all pairs (see above), you can query all tokens in Uniswap. Because The Graph service limits return size to 1000 entities use graphql skip query. (Note this query will not work in the graph sandbox and more resembles the structure of a query you'd pass to some graphql middleware like [Apollo](https://www.apollographql.com/)).

```
{
 query tokens($skip: Int!) {
   tokens(first: 1000, skip: $skip) {
     id
     name
     symbol
   }
 }
}
```

#### Token Transactions

To get transactions that include a token you'll need to first fetch an array of pairs that the token is included in (this can be done with the allPairs field on the Token entity.) Once you have an array of pairs the token is included in, filter on that in the transaction lookup.

This query fetches the latest 30 mints, swaps, and burns involving DAI. The allPairs array could look something like this where we include the DAI/WETH pair address and the DAI/USDC pair address.

```
allPairs = [
 "0xa478c2975ab1ea89e8196811f51a7b7ade33eb11",
 "0xae461ca67b15dc8dc81ce7615e0320da1a9ab8d5"
]
```

```
query($allPairs: [String!]) {
 mints(first: 30, where: { pair_in: $allPairs }, orderBy: timestamp, orderDirection: desc) {
   transaction {
     id
     timestamp
   }
   to
   liquidity
   amount0
   amount1
   amountUSD
 }
 burns(first: 30, where: { pair_in: $allPairs }, orderBy: timestamp, orderDirection: desc) {
   transaction {
     id
     timestamp
   }
   to
   liquidity
   amount0
   amount1
   amountUSD
 }
 swaps(first: 30, where: { pair_in: $allPairs }, orderBy: timestamp, orderDirection: desc) {
   transaction {
     id
     timestamp
   }
   amount0In
   amount0Out
   amount1In
   amount1Out
   amountUSD
   to
 }
}
```

#### Token Daily Aggregated

Like pair and global daily lookups, tokens have daily entities that can be queries as well. This query gets daily information for DAI. Note that you may want to sort in ascending order to receive your days from oldest to most recent in the return array.

```
{
 tokenDayDatas(orderBy: date, orderDirection: asc,
  where: {
    token: "0x6b175474e89094c44da98b954eedeac495271d0f"
  }
 ) {
    id
    date
    priceUSD
    totalLiquidityToken
    totalLiquidityUSD
    totalLiquidityETH
    dailyVolumeETH
    dailyVolumeToken
    dailyVolumeUSD
 }
}
```

### ETH Price

You can use the Bundle entity to query current USD price of ETH in Uniswap based on a weighted average of stablecoins.

```
{
 bundle(id: "1" ) {
   ethPrice
 }
}
```
</file>

<file path="docs/contracts/v2/reference/Governance/_category_.json">
{
  "label": "Governance",
  "position": 2
}
</file>

<file path="docs/contracts/v2/reference/Governance/governance-reference.md">
---
id: governance-reference
title: Governance Reference
---

> The updated reference for the newly deployed Governor Bravo is available via [Etherscan](https://etherscan.io/address/0x408ED6354d4973f66138C91495F2f2FCbd8724C3), some of the reference material below may be out of date.

The Uniswap protocol is governed and upgraded by UNI token holders, using three distinct components; the UNI token, governance module, and Timelock. Together, these contracts allow the community to propose, vote, and implement changes to the uniswap protocol.

Any addresses with more than 2.5M UNI delegated to it may propose governance actions, which contain finished, executable code. When a proposal is created, the community can cast their votes during a 3 day voting period. If a majority, and at least 4M votes are cast for the proposal, it is queued in the Timelock, and may be executed in a minimum of 2 days.

### Timelock

The Timelock contract can modify system parameters, logic, and contracts in a 'time-delayed, opt-out' upgrade pattern. Timelock has a hard-coded minimum delay of 2 days, which is the least amount of notice possible for a governance action. Each proposed action will be published at a minimum of 2 days in the future from the time of announcement. Major upgrades, such as changing the risk system, may have up to a 30 day delay. Timelock is controlled by the governance module; pending and completed governance actions can be monitored on the Timelock Dashboard.

![](./images/gov_diagram-1.png)

## Key Events

### DelegateChanged

```solidity
DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate)
```

Emitted when an account changes its delegate.

### DelegateVotesChanged

```solidity
DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance)
```

Emitted when a delegate account's vote balance changes.

### ProposalCreated

```solidity
ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description)
```

Emitted when a new proposal is created.

### VoteCast

```solidity
VoteCast(address voter, uint proposalId, bool support, uint votes)
```

Emitted when a vote has been cast on a proposal.

### ProposalCanceled

```solidity
ProposalCanceled(uint id)
```

Emitted when a proposal has been canceled.

### ProposalQueued

```solidity
ProposalQueued(uint id, uint eta)
```

Emitted when a proposal has been queued in the Timelock.

### ProposalExecuted

```solidity
ProposalExecuted(uint id)
```

Emitted when a proposal has been executed in the Timelock.

## Read-Only Functions: UNI

### Get Current Votes

```solidity
function getCurrentVotes(address account) returns (uint96)
```

Returns the balance of votes for an account as of the current block.

| Name    | Type      |                                                                  |
| :------ | :-------- | :--------------------------------------------------------------- |
| account | `address` | Address of the account of which to retrieve the number of votes. |

### Get Prior Votes

```solidity
function getPriorVotes(address account, uint blockNumber) returns (uint96)
```

Returns the prior number of votes for an account at a specific block number. The block number passed must be a finalized block or the function will revert.

| Name        | Type      |                                                                        |
| :---------- | :-------- | :--------------------------------------------------------------------- |
| account     | `address` | Address of the account of which to retrieve the prior number of votes. |
| blocknumber | `uint`    | The block number at which to retrieve the prior number of votes.       |
|             |           |                                                                        |
| unnamed     | `uint96`  | The number of prior votes                                              |

## State-Changing Functions: UNI

### Delegate

```solidity
function delegate(address delegatee)
```

Delegate votes from the sender to the delegatee. Users can delegate to 1 address at a time, and the number of votes added to the delegatee’s vote count is equivalent to the balance of UNI in the user’s account. Votes are delegated from the current block and onward, until the sender delegates again, or transfers their UNI.

| Name      | Type      |                                                                    |
| :-------- | :-------- | :----------------------------------------------------------------- |
| delegatee | `address` | The address to which msg.sender wishes to delegate their votes to. |

### Delegate By Signature

```solidity
function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s)
```

Delegate votes from the sender to the delegatee. Users can delegate to 1 address at a time, and the number of votes added to the delegatee’s vote count is equivalent to the balance of UNI in the user’s account. Votes are delegated from the current block and onward, until the sender delegates again, or transfers their UNI.

| Name      | Type      |                                                                                                                     |
| :-------- | :-------- | :------------------------------------------------------------------------------------------------------------------ |
| delegatee | `address` | The address to which msg.sender wishes to delegate their vote to                                                    |
| nonce     | `uint`    | The contract state required to match the signature. This can be retrieved from the contract’s public nonces mapping |
| expiry    | `uint`    | The time when the signature expires. A block timestamp in seconds since the unix epoch.                             |
| v         | `uint`    | The recovery byte of the signature.                                                                                 |
| r         | `bytes32` | Half of the ECDSA signature pair.                                                                                   |
| s         | `bytes32` | Half of the ECDSA signature pair.                                                                                   |

## Read-Only Functions: Governor Alpha

### Quorum Votes

```solidity
function quorumVotes() public pure returns (uint)
```

Returns the minimum number of votes required for a proposal to succeed.

### Proposal Threshold

```solidity
function proposalThreshold() returns (uint)
```

Returns the minimum number of votes required for an account to create a proposal.

### Proposal Max Operations

```solidity
function proposalMaxOperations() returns (uint)
```

Returns the maximum number of actions that can be included in a proposal. Actions are functions calls that will be made when a proposal succeeds and executes.

### Voting Delay

```solidity
function votingDelay() returns (uint)
```

Returns the number of blocks to wait before voting on a proposal may begin. This value is added to the current block number when a proposal is created.

### Voting Period

```solidity
function votingPeriod() returns (uint)
```

Returns the duration of voting on a proposal, in blocks.

### Get Actions

```solidity
function getActions(uint proposalId) returns (uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas)
```

Gets the actions of a selected proposal. Pass a proposal ID and get the targets, values, signatures and calldatas of that proposal.

| Name       | Type   |                    |
| :--------- | :----- | :----------------- |
| proposalId | `uint` | ID of the proposal |

Returns:

- Array of addresses of contracts the proposal calls.
- Array of unsigned integers the proposal uses as values.
- Array of strings of the proposal’s signatures.
- Array of calldata bytes of the proposal.

### Get Receipt

```solidity
function getReceipt(uint proposalId, address voter) returns (Receipt memory)
```

Returns a proposal ballot receipt of a given voter.

| Name       | Type      |                                                              |
| :--------- | :-------- | :----------------------------------------------------------- |
| proposalId | `uint`    | ID of the proposal in which to get a voter’s ballot receipt. |
| voter      | `address` | Address of the account of a proposal voter.                  |
|            |           |                                                              |
| Receipt    | `struct`  | A Receipt struct for the ballot of the voter address.        |

### State

```solidity
function state(uint proposalId) returns (ProposalState)
```

Returns enum of type ProposalState, possible types are:
-Pending
-Active
-Canceled
-Defeated
-Succeeded
-Queued
-Expired
-andExecuted

| Name       | Type   |                    |
| :--------- | :----- | :----------------- |
| proposalId | `uint` | ID of the proposal |

## State-Changing Functions: Governor Alpha

### Propose

```solidity
function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) returns (uint)
```

Creates a Proposal to change the protocol.

Proposals will be voted on by delegated voters. If there is sufficient support before the voting period ends, the proposal shall be automatically enacted. Enacted proposals are queued and executed in the Timelock contract.

The sender must hold more UNI than the current proposal threshold (proposalThreshold()) as of the immediately previous block. The proposal can have up to 10 actions (based on proposalMaxOperations()).

The proposer cannot create another proposal if they currently have a pending or active proposal. It is not possible to queue two identical actions in the same block (due to a restriction in the Timelock), therefore actions in a single proposal must be unique, and unique proposals that share an identical action must be queued in different blocks.

| Name        | Type      |                                                                                                                                                                                         |
| :---------- | :-------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| targets     | `address` | The ordered list of target addresses for calls to be made during proposal execution. This array must be the same length as all other array parameters in this function.                 |
| values      | `uint`    | The ordered list of values (i.e. msg.value) to be passed to the calls made during proposal execution. This array must be the same length as all other array parameters in this function |
| signatures  | `string`  | The ordered list of function signatures to be passed during execution. This array must be the same length as all other array parameters in this function.                               |
| calldatas   | `bytes`   | The ordered list of data to be passed to each individual function call during proposal execution. This array must be the same length as all other array parameters in this function.    |
| description | `string`  | A human readable description of the proposal and the changes it will enact.                                                                                                             |
|             |           |                                                                                                                                                                                         |
| Unnamed     | `uint`    | Returns ID of the new proposal                                                                                                                                                          |

### Queue

```solidity
function queue(uint proposalId)
```

After a proposal has succeeded, any address can call the queue method to move the proposal into the Timelock queue. A proposal can only be queued if it has succeeded.

| Name       | Type   |                                   |
| :--------- | :----- | :-------------------------------- |
| proposalId | `uint` | ID of a given successful proposal |

### Execute

```solidity
function execute(uint proposalId) payable
```

After the Timelock delay period, any account may invoke the execute method to apply the changes from the proposal to the target contracts. This will invoke each of the actions described in the proposal.
This function is payable so the Timelock contract can invoke payable functions that were selected in the proposal.

| Name       | Type   |                                   |
| :--------- | :----- | :-------------------------------- |
| proposalId | `uint` | ID of a given successful proposal |

### Cancel

```solidity
function queue(uint proposalId)
```

Cancel a proposal that has not yet been executed. The Guardian is the only one who may execute this unless the proposer does not maintain the delegates required to create a proposal. If the proposer does not have more delegates than the proposal threshold, anyone can cancel the proposal.

| Name       | Type   |                            |
| :--------- | :----- | :------------------------- |
| proposalId | `uint` | ID of a proposal to cancel |

### Cast Vote

```solidity
function castVote(uint proposalId, bool support)
```

Cast a vote on a proposal. The account's voting weight is determined by it's number of delegated votes at the time the proposal becomes active.

| Name       | Type   |                                                                     |
| :--------- | :----- | :------------------------------------------------------------------ |
| proposalId | `uint` | ID of a given successful proposal                                   |
| support    | `bool` | A boolean of true for 'yes' or false for 'no' on the proposal vote. |

### Cast Vote By Signature

```solidity
function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s)
```

Cast a vote on a proposal. The account's voting weight is determined by its number of delegated votes at the time the proposal became active. This method has the same purpose as Cast Vote, but instead enables offline signatures to participate in governance voting. For more details on how to create an offline signature, review EIP-712.

| Name       | Type      |                                                                                         |
| :--------- | :-------- | :-------------------------------------------------------------------------------------- |
| proposalId | `uint`    | ID of a given successful proposal                                                       |
| support    | `bool`    | A boolean of true for 'yes' or false for 'no' on the proposal vote.                     |
| expiry     | `uint`    | The time when the signature expires. A block timestamp in seconds since the unix epoch. |
| v          | `uint`    | The recovery byte of the signature.                                                     |
| r          | `bytes32` | Half of the ECDSA signature pair.                                                       |
| s          | `bytes32` | Half of the ECDSA signature pair.                                                       |
</file>

<file path="docs/contracts/v2/reference/smart-contracts/_category_.json">
{
  "label": "Smart Contracts",
  "position": 4
}
</file>

<file path="docs/contracts/v2/reference/smart-contracts/01-factory.md">
---
id: factory
title: Factory
---

## Code

[`UniswapV2Factory.sol`](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Factory.sol)

## Address

`UniswapV2Factory` is deployed at `0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f` on the Ethereum [mainnet](https://etherscan.io/address/0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f), and the [Ropsten](https://ropsten.etherscan.io/address/0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f), [Rinkeby](https://rinkeby.etherscan.io/address/0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f), [Görli](https://goerli.etherscan.io/address/0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f), and [Kovan](https://kovan.etherscan.io/address/0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f) testnets. It was built from commit [8160750](https://github.com/Uniswap/uniswap-v2-core/tree/816075049f811f1b061bca81d5d040b96f4c07eb).

## Events

### PairCreated

```solidity
event PairCreated(address indexed token0, address indexed token1, address pair, uint);
```

Emitted each time a pair is created via [createPair](#createpair).

- `token0` is guaranteed to be strictly less than `token1` by sort order.
- The final `uint` log value will be `1` for the first pair created, `2` for the second, etc. (see [allPairs](#allpairs)/[getPair](#getpair)).

## Read-Only Functions

### getPair

```solidity
function getPair(address tokenA, address tokenB) external view returns (address pair);
```

Returns the address of the pair for `tokenA` and `tokenB`, if it has been created, else `address(0)` (`0x0000000000000000000000000000000000000000`).

- `tokenA` and `tokenB` are interchangeable.
- Pair addresses can also be calculated deterministically via the SDK.

### allPairs

```solidity
function allPairs(uint) external view returns (address pair);
```

Returns the address of the `n`th pair (`0`-indexed) created through the factory, or `address(0)` (`0x0000000000000000000000000000000000000000`) if not enough pairs have been created yet.

- Pass `0` for the address of the first pair created, `1` for the second, etc.

### allPairsLength

```solidity
function allPairsLength() external view returns (uint);
```

Returns the total number of pairs created through the factory so far.

### feeTo

```solidity
function feeTo() external view returns (address);
```

See [Protocol Charge Calculation](../../concepts/advanced-topics/fees).

### feeToSetter

```solidity
function feeToSetter() external view returns (address);
```

The address allowed to change [feeTo](#feeto).

## State-Changing Functions

### createPair

```solidity
function createPair(address tokenA, address tokenB) external returns (address pair);
```

Creates a pair for `tokenA` and `tokenB` if one doesn't exist already.

- `tokenA` and `tokenB` are interchangeable.
- Emits [PairCreated](#paircreated).

## Interface

```solidity
import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';
```

```solidity
pragma solidity >=0.5.0;

interface IUniswapV2Factory {
  event PairCreated(address indexed token0, address indexed token1, address pair, uint);

  function getPair(address tokenA, address tokenB) external view returns (address pair);
  function allPairs(uint) external view returns (address pair);
  function allPairsLength() external view returns (uint);

  function feeTo() external view returns (address);
  function feeToSetter() external view returns (address);

  function createPair(address tokenA, address tokenB) external returns (address pair);
}
```

## ABI

```typescript
import IUniswapV2Factory from '@uniswap/v2-core/build/IUniswapV2Factory.json'
```

[https://unpkg.com/@uniswap/v2-core@1.0.0/build/IUniswapV2Factory.json](https://unpkg.com/@uniswap/v2-core@1.0.0/build/IUniswapV2Factory.json)
</file>

<file path="docs/contracts/v2/reference/smart-contracts/02-pair.md">
---
id: pair
title: Pair
---

This documentation covers Uniswap-specific functionality. For ERC-20 functionality, see [Pair (ERC-20)](../smart-contracts/pair-erc-20).

## Code

[`UniswapV2Pair.sol`](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Pair.sol)

## Address

See [Pair Addresses](../../guides/smart-contract-integration/getting-pair-addresses).

## Events

### Mint

```solidity
event Mint(address indexed sender, uint amount0, uint amount1);
```

Emitted each time liquidity tokens are created via [mint](#mint-1).

### Burn

```solidity
event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
```

Emitted each time liquidity tokens are destroyed via [burn](#burn-1).

### Swap

```solidity
event Swap(
  address indexed sender,
  uint amount0In,
  uint amount1In,
  uint amount0Out,
  uint amount1Out,
  address indexed to
);
```

Emitted each time a swap occurs via [swap](#swap-1).

### Sync

```solidity
event Sync(uint112 reserve0, uint112 reserve1);
```

Emitted each time reserves are updated via [mint](#mint-1), [burn](#burn-1), [swap](#swap-1), or [sync](#sync-1).

## Read-Only Functions

### MINIMUM_LIQUIDITY

```solidity
function MINIMUM_LIQUIDITY() external pure returns (uint);
```

Returns `1000` for all pairs. See [Minimum Liquidity](../../concepts/protocol-overview/smart-contracts#minimum-liquidity).

### factory

```solidity
function factory() external view returns (address);
```

Returns the [factory address](../smart-contracts/factory#address).

### token0

```solidity
function token0() external view returns (address);
```

Returns the address of the pair token with the lower sort order.

### token1

```solidity
function token1() external view returns (address);
```

Returns the address of the pair token with the higher sort order.

### getReserves

```solidity
function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
```

Returns the reserves of token0 and token1 used to price trades and distribute liquidity. See [Pricing](../../concepts/advanced-topics/pricing). Also returns the `block.timestamp` (mod `2**32`) of the last block during which an interaction occurred for the pair.

### price0CumulativeLast

```solidity
function price0CumulativeLast() external view returns (uint);
```

See [Oracles](../../concepts/core-concepts/oracles).

### price1CumulativeLast

```solidity
function price1CumulativeLast() external view returns (uint);
```

See [Oracles](../../concepts/core-concepts/oracles).

### kLast

```solidity
function kLast() external view returns (uint);
```

Returns the product of the reserves as of the most recent liquidity event. See [Protocol Charge Calculation](../../concepts/advanced-topics/fees#protocol-charge-calculation).

## State-Changing Functions

### mint

```solidity
function mint(address to) external returns (uint liquidity);
```

Creates pool tokens.

- Emits [Mint](#mint), [Sync](#sync), [Transfer](../smart-contracts/pair-erc-20#transfer).

### burn

```solidity
function burn(address to) external returns (uint amount0, uint amount1);
```

Destroys pool tokens.

- Emits [Burn](#burn), [Sync](#sync), [Transfer](../smart-contracts/pair-erc-20#transfer).

### swap

```solidity
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
```

Swaps tokens. For regular swaps, `data.length` must be `0`. Also see [Flash Swaps](../../concepts/core-concepts/flash-swaps).

- Emits [Swap](#swap), [Sync](#sync).

## skim

```solidity
function skim(address to) external;
```

See the <a href='/whitepaper.pdf' target='_blank' rel='noopener noreferrer'>whitepaper</a>.

### sync

```solidity
function sync() external;
```

See the <a href='/whitepaper.pdf' target='_blank' rel='noopener noreferrer'>whitepaper</a>.

- Emits [Sync](#sync).

## Interface

```solidity
import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';
```

```solidity
pragma solidity >=0.5.0;

interface IUniswapV2Pair {
  event Approval(address indexed owner, address indexed spender, uint value);
  event Transfer(address indexed from, address indexed to, uint value);

  function name() external pure returns (string memory);
  function symbol() external pure returns (string memory);
  function decimals() external pure returns (uint8);
  function totalSupply() external view returns (uint);
  function balanceOf(address owner) external view returns (uint);
  function allowance(address owner, address spender) external view returns (uint);

  function approve(address spender, uint value) external returns (bool);
  function transfer(address to, uint value) external returns (bool);
  function transferFrom(address from, address to, uint value) external returns (bool);

  function DOMAIN_SEPARATOR() external view returns (bytes32);
  function PERMIT_TYPEHASH() external pure returns (bytes32);
  function nonces(address owner) external view returns (uint);

  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

  event Mint(address indexed sender, uint amount0, uint amount1);
  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
  event Swap(
      address indexed sender,
      uint amount0In,
      uint amount1In,
      uint amount0Out,
      uint amount1Out,
      address indexed to
  );
  event Sync(uint112 reserve0, uint112 reserve1);

  function MINIMUM_LIQUIDITY() external pure returns (uint);
  function factory() external view returns (address);
  function token0() external view returns (address);
  function token1() external view returns (address);
  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
  function price0CumulativeLast() external view returns (uint);
  function price1CumulativeLast() external view returns (uint);
  function kLast() external view returns (uint);

  function mint(address to) external returns (uint liquidity);
  function burn(address to) external returns (uint amount0, uint amount1);
  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
  function skim(address to) external;
  function sync() external;
}
```

## ABI

```typescript
import IUniswapV2Pair from '@uniswap/v2-core/build/IUniswapV2Pair.json'
```

[https://unpkg.com/@uniswap/v2-core@1.0.0/build/IUniswapV2Pair.json](https://unpkg.com/@uniswap/v2-core@1.0.0/build/IUniswapV2Pair.json)
</file>

<file path="docs/contracts/v2/reference/smart-contracts/03-pair-erc-20.md">
---
id: Pair-ERC-20
title: Pair (ERC-20)
---

This documentation covers ERC-20 functionality for denominating pool tokens. For Uniswap-specific functionality, see [Pair](../smart-contracts/pair).

## Code

[`UniswapV2ERC20.sol`](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)

## Events

### Approval

```solidity
event Approval(address indexed owner, address indexed spender, uint value);
```

Emitted each time an approval occurs via [approve](#approve) or [permit](#permit).

### Transfer

```solidity
event Transfer(address indexed from, address indexed to, uint value);
```

Emitted each time a transfer occurs via [transfer](#transfer-1), [transferFrom](#transferfrom), [mint](../smart-contracts/pair#mint-1), or [burn](../smart-contracts/pair#burn-1).

## Read-Only Functions

### name

```solidity
function name() external pure returns (string memory);
```

Returns `Uniswap V2` for all pairs.

### symbol

```solidity
function symbol() external pure returns (string memory);
```

Returns `UNI-V2` for all pairs.

### decimals

```solidity
function decimals() external pure returns (uint8);
```

Returns `18` for all pairs.

### totalSupply

```solidity
function totalSupply() external view returns (uint);
```

Returns the total amount of pool tokens for a pair.

### balanceOf

```solidity
function balanceOf(address owner) external view returns (uint);
```

Returns the amount of pool tokens owned by an address.

### allowance

```solidity
function allowance(address owner, address spender) external view returns (uint);
```

Returns the amount of liquidity tokens owned by an address that a spender is allowed to transfer via [transferFrom](#transferfrom).

### DOMAIN_SEPARATOR

```solidity
function DOMAIN_SEPARATOR() external view returns (bytes32);
```

Returns a domain separator for use in [permit](#permit).

### PERMIT_TYPEHASH

```solidity
function PERMIT_TYPEHASH() external view returns (bytes32);
```

Returns a typehash for use in [permit](#permit).

### nonces

```solidity
function nonces(address owner) external view returns (uint);
```

Returns the current nonce for an address for use in [permit](#permit).

## State-Changing Functions

### approve

```solidity
function approve(address spender, uint value) external returns (bool);
```

Lets `msg.sender` set their allowance for a spender.

- Emits [Approval](#approval).

### transfer

```solidity
function transfer(address to, uint value) external returns (bool);
```

Lets `msg.sender` send pool tokens to an address.

- Emits [Transfer](#transfer).

### transferFrom

```solidity
function transferFrom(address from, address to, uint value) external returns (bool);
```

Sends pool tokens from one address to another.

- Requires approval.
- Emits [Transfer](#transfer).

### permit

```solidity
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
```

Sets the allowance for a spender where approval is granted via a signature.

- See [Using Permit](../../guides/smart-contract-integration/supporting-meta-transactions).
- Emits [Approval](#approval).

## Interface

```solidity
import '@uniswap/v2-core/contracts/interfaces/IUniswapV2ERC20.sol';
```

```solidity
pragma solidity >=0.5.0;

interface IUniswapV2ERC20 {
  event Approval(address indexed owner, address indexed spender, uint value);
  event Transfer(address indexed from, address indexed to, uint value);

  function name() external pure returns (string memory);
  function symbol() external pure returns (string memory);
  function decimals() external pure returns (uint8);
  function totalSupply() external view returns (uint);
  function balanceOf(address owner) external view returns (uint);
  function allowance(address owner, address spender) external view returns (uint);

  function approve(address spender, uint value) external returns (bool);
  function transfer(address to, uint value) external returns (bool);
  function transferFrom(address from, address to, uint value) external returns (bool);

  function DOMAIN_SEPARATOR() external view returns (bytes32);
  function PERMIT_TYPEHASH() external pure returns (bytes32);
  function nonces(address owner) external view returns (uint);

  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
}
```

## ABI

```typescript
import IUniswapV2ERC20 from '@uniswap/v2-core/build/IUniswapV2ERC20.json'
```

[https://unpkg.com/@uniswap/v2-core@1.0.0/build/IUniswapV2ERC20.json](https://unpkg.com/@uniswap/v2-core@1.0.0/build/IUniswapV2ERC20.json)
</file>

<file path="docs/contracts/v2/reference/smart-contracts/04-library.md">
---
id: library
title: Library
---

## Code

[`UniswapV2Library.sol`](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol)

## Internal Functions

### sortTokens

```solidity
function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1);
```

Sorts token addresses.

### pairFor

```solidity
function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair);
```

Calculates the address for a pair without making any external calls via the v2 SDK.

### getReserves

```solidity
function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB);
```

Calls [getReserves](../smart-contracts/pair#getreserves) on the pair for the passed tokens, and returns the results sorted in the order that the parameters were passed in.

### quote

```solidity
function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB);
```

Given some asset amount and reserves, returns an amount of the other asset representing equivalent value.

- Useful for calculating optimal token amounts before calling [mint](../smart-contracts/pair#mint-1).

### getAmountOut

```solidity
function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut);
```

Given an _input_ asset amount, returns the maximum _output_ amount of the other asset (accounting for fees) given reserves.

- Used in [getAmountsOut](#getamountsout).

### getAmountIn

```solidity
function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn);
```

Returns the minimum _input_ asset amount required to buy the given _output_ asset amount (accounting for fees) given reserves.

- Used in [getAmountsIn](#getamountsin).

### getAmountsOut

```solidity
function getAmountsOut(uint amountIn, address[] memory path) internal view returns (uint[] memory amounts);
```

Given an _input_ asset amount and an array of token addresses, calculates all subsequent maximum _output_ token amounts by calling [getReserves](#getreserves) for each pair of token addresses in the path in turn, and using these to call [getAmountOut](#getamountout).

- Useful for calculating optimal token amounts before calling [swap](../smart-contracts/pair#swap-1).

### getAmountsIn

```solidity
function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts);
```

Given an _output_ asset amount and an array of token addresses, calculates all preceding minimum _input_ token amounts by calling [getReserves](#getreserves) for each pair of token addresses in the path in turn, and using these to call [getAmountIn](#getamountin).

- Useful for calculating optimal token amounts before calling [swap](../smart-contracts/pair#swap-1).
</file>

<file path="docs/contracts/v2/reference/smart-contracts/05-router01.md">
---
id: router-01
title: Router01
---

> UniswapV2Router01 should not be used any longer, because of the discovery of a [low severity bug](../smart-contracts/router-01#getamountin) and the fact that some methods do not work with tokens that take fees on transfer. The current recommendation is to use [UniswapV2Router02](../smart-contracts/router-02).

## Code

[`UniswapV2Router01.sol`](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router01.sol)

## Address

`UniswapV2Router01` is deployed at `0xf164fC0Ec4E93095b804a4795bBe1e041497b92a` on the Ethereum [mainnet](https://etherscan.io/address/0xf164fC0Ec4E93095b804a4795bBe1e041497b92a), and the [Ropsten](https://ropsten.etherscan.io/address/0xf164fC0Ec4E93095b804a4795bBe1e041497b92a), [Rinkeby](https://rinkeby.etherscan.io/address/0xf164fC0Ec4E93095b804a4795bBe1e041497b92a), [Görli](https://goerli.etherscan.io/address/0xf164fC0Ec4E93095b804a4795bBe1e041497b92a), and [Kovan](https://kovan.etherscan.io/address/0xf164fC0Ec4E93095b804a4795bBe1e041497b92a) testnets. It was built from commit [2ad7da2](https://github.com/Uniswap/uniswap-v2-periphery/tree/2ad7da28a6f70ec4299364bc1608af8f30e7646b).

## Read-Only Functions

### factory

```solidity
function factory() external pure returns (address);
```

Returns [factory address](../smart-contracts/factory#address).

### WETH

```solidity
function WETH() external pure returns (address);
```

Returns the [canonical WETH address](https://blog.0xproject.com/canonical-weth-a9aa7d0279dd) on the Ethereum [mainnet](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), or the [Ropsten](https://ropsten.etherscan.io/address/0xc778417e063141139fce010982780140aa0cd5ab), [Rinkeby](https://rinkeby.etherscan.io/address/0xc778417e063141139fce010982780140aa0cd5ab), [Görli](https://goerli.etherscan.io/address/0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6), or [Kovan](https://kovan.etherscan.io/address/0xd0a1e359811322d97991e03f863a0c30c2cf029c) testnets.

## State-Changing Functions

### addLiquidity

```solidity
function addLiquidity(
  address tokenA,
  address tokenB,
  uint amountADesired,
  uint amountBDesired,
  uint amountAMin,
  uint amountBMin,
  address to,
  uint deadline
) external returns (uint amountA, uint amountB, uint liquidity);
```

Adds liquidity to an ERC-20⇄ERC-20 pool.

- To cover all possible scenarios, `msg.sender` should have already given the router an allowance of at least amountADesired/amountBDesired on tokenA/tokenB.
- Always adds assets at the ideal ratio, according to the price when the transaction is executed.
- If a pool for the passed tokens does not exists, one is created automatically, and exactly amountADesired/amountBDesired tokens are added.

| Name           | Type      |                                                                                                                |
| :------------- | :-------- | :------------------------------------------------------------------------------------------------------------- |
| tokenA         | `address` | A pool token.                                                                                                  |
| tokenB         | `address` | A pool token.                                                                                                  |
| amountADesired | `uint`    | The amount of tokenA to add as liquidity if the B/A price is \<= amountBDesired/amountADesired (A depreciates). |
| amountBDesired | `uint`    | The amount of tokenB to add as liquidity if the A/B price is \<= amountADesired/amountBDesired (B depreciates). |
| amountAMin     | `uint`    | Bounds the extent to which the B/A price can go up before the transaction reverts. Must be \<= amountADesired.  |
| amountBMin     | `uint`    | Bounds the extent to which the A/B price can go up before the transaction reverts. Must be \<= amountBDesired.  |
| to             | `address` | Recipient of the liquidity tokens.                                                                             |
| deadline       | `uint`    | Unix timestamp after which the transaction will revert.                                                        |
|                |           |                                                                                                                |
| amountA        | `uint`    | The amount of tokenA sent to the pool.                                                                         |
| amountB        | `uint`    | The amount of tokenB sent to the pool.                                                                         |
| liquidity      | `uint`    | The amount of liquidity tokens minted.                                                                         |

### addLiquidityETH

```solidity
function addLiquidityETH(
  address token,
  uint amountTokenDesired,
  uint amountTokenMin,
  uint amountETHMin,
  address to,
  uint deadline
) external payable returns (uint amountToken, uint amountETH, uint liquidity);
```

Adds liquidity to an ERC-20⇄WETH pool with ETH.

- To cover all possible scenarios, `msg.sender` should have already given the router an allowance of at least amountTokenDesired on token.
- Always adds assets at the ideal ratio, according to the price when the transaction is executed.
- `msg.value` is treated as a amountETHDesired.
- Leftover ETH, if any, is returned to `msg.sender`.
- If a pool for the passed token and WETH does not exists, one is created automatically, and exactly amountTokenDesired/`msg.value` tokens are added.

| Name                           | Type      |                                                                                                                           |
| :----------------------------- | :-------- | :------------------------------------------------------------------------------------------------------------------------ |
| token                          | `address` | A pool token.                                                                                                             |
| amountTokenDesired             | `uint`    | The amount of token to add as liquidity if the WETH/token price is \<= `msg.value`/amountTokenDesired (token depreciates). |
| `msg.value` (amountETHDesired) | `uint`    | The amount of ETH to add as liquidity if the token/WETH price is \<= amountTokenDesired/`msg.value` (WETH depreciates).    |
| amountTokenMin                 | `uint`    | Bounds the extent to which the WETH/token price can go up before the transaction reverts. Must be \<= amountTokenDesired.  |
| amountETHMin                   | `uint`    | Bounds the extent to which the token/WETH price can go up before the transaction reverts. Must be \<= `msg.value`.         |
| to                             | `address` | Recipient of the liquidity tokens.                                                                                        |
| deadline                       | `uint`    | Unix timestamp after which the transaction will revert.                                                                   |
|                                |           |                                                                                                                           |
| amountToken                    | `uint`    | The amount of token sent to the pool.                                                                                     |
| amountETH                      | `uint`    | The amount of ETH converted to WETH and sent to the pool.                                                                 |
| liquidity                      | `uint`    | The amount of liquidity tokens minted.                                                                                    |

### removeLiquidity

```solidity
function removeLiquidity(
  address tokenA,
  address tokenB,
  uint liquidity,
  uint amountAMin,
  uint amountBMin,
  address to,
  uint deadline
) external returns (uint amountA, uint amountB);
```

Removes liquidity from an ERC-20⇄ERC-20 pool.

- `msg.sender` should have already given the router an allowance of at least liquidity on the pool.

| Name       | Type      |                                                                                       |
| :--------- | :-------- | :------------------------------------------------------------------------------------ |
| tokenA     | `address` | A pool token.                                                                         |
| tokenB     | `address` | A pool token.                                                                         |
| liquidity  | `uint`    | The amount of liquidity tokens to remove.                                             |
| amountAMin | `uint`    | The minimum amount of tokenA that must be received for the transaction not to revert. |
| amountBMin | `uint`    | The minimum amount of tokenB that must be received for the transaction not to revert. |
| to         | `address` | Recipient of the underlying assets.                                                   |
| deadline   | `uint`    | Unix timestamp after which the transaction will revert.                               |
|            |           |                                                                                       |
| amountA    | `uint`    | The amount of tokenA received.                                                        |
| amountB    | `uint`    | The amount of tokenB received.                                                        |

### removeLiquidityETH

```solidity
function removeLiquidityETH(
  address token,
  uint liquidity,
  uint amountTokenMin,
  uint amountETHMin,
  address to,
  uint deadline
) external returns (uint amountToken, uint amountETH);
```

Removes liquidity from an ERC-20⇄WETH pool and receive ETH.

- `msg.sender` should have already given the router an allowance of at least liquidity on the pool.

| Name           | Type      |                                                                                      |
| :------------- | :-------- | :----------------------------------------------------------------------------------- |
| token          | `address` | A pool token.                                                                        |
| liquidity      | `uint`    | The amount of liquidity tokens to remove.                                            |
| amountTokenMin | `uint`    | The minimum amount of token that must be received for the transaction not to revert. |
| amountETHMin   | `uint`    | The minimum amount of ETH that must be received for the transaction not to revert.   |
| to             | `address` | Recipient of the underlying assets.                                                  |
| deadline       | `uint`    | Unix timestamp after which the transaction will revert.                              |
|                |           |                                                                                      |
| amountToken    | `uint`    | The amount of token received.                                                        |
| amountETH      | `uint`    | The amount of ETH received.                                                          |

### removeLiquidityWithPermit

```solidity
function removeLiquidityWithPermit(
  address tokenA,
  address tokenB,
  uint liquidity,
  uint amountAMin,
  uint amountBMin,
  address to,
  uint deadline,
  bool approveMax, uint8 v, bytes32 r, bytes32 s
) external returns (uint amountA, uint amountB);
```

Removes liquidity from an ERC-20⇄ERC-20 pool without pre-approval, thanks to [permit](pair-erc-20#permit).

| Name       | Type      |                                                                                       |
| :--------- | :-------- | :------------------------------------------------------------------------------------ |
| tokenA     | `address` | A pool token.                                                                         |
| tokenB     | `address` | A pool token.                                                                         |
| liquidity  | `uint`    | The amount of liquidity tokens to remove.                                             |
| amountAMin | `uint`    | The minimum amount of tokenA that must be received for the transaction not to revert. |
| amountBMin | `uint`    | The minimum amount of tokenB that must be received for the transaction not to revert. |
| to         | `address` | Recipient of the underlying assets.                                                   |
| deadline   | `uint`    | Unix timestamp after which the transaction will revert.                               |
| approveMax | `bool`    | Whether or not the approval amount in the signature is for liquidity or `uint(-1)`.   |
| v          | `uint8`   | The v component of the permit signature.                                              |
| r          | `bytes32` | The r component of the permit signature.                                              |
| s          | `bytes32` | The s component of the permit signature.                                              |
|            |           |                                                                                       |
| amountA    | `uint`    | The amount of tokenA received.                                                        |
| amountB    | `uint`    | The amount of tokenB received.                                                        |

### removeLiquidityETHWithPermit

```solidity
function removeLiquidityETHWithPermit(
  address token,
  uint liquidity,
  uint amountTokenMin,
  uint amountETHMin,
  address to,
  uint deadline,
  bool approveMax, uint8 v, bytes32 r, bytes32 s
) external returns (uint amountToken, uint amountETH);
```

Removes liquidity from an ERC-20⇄WETTH pool and receive ETH without pre-approval, thanks to [permit](pair-erc-20#permit).

| Name           | Type      |                                                                                      |
| :------------- | :-------- | :----------------------------------------------------------------------------------- |
| token          | `address` | A pool token.                                                                        |
| liquidity      | `uint`    | The amount of liquidity tokens to remove.                                            |
| amountTokenMin | `uint`    | The minimum amount of token that must be received for the transaction not to revert. |
| amountETHMin   | `uint`    | The minimum amount of ETH that must be received for the transaction not to revert.   |
| to             | `address` | Recipient of the underlying assets.                                                  |
| deadline       | `uint`    | Unix timestamp after which the transaction will revert.                              |
| approveMax     | `bool`    | Whether or not the approval amount in the signature is for liquidity or `uint(-1)`.  |
| v              | `uint8`   | The v component of the permit signature.                                             |
| r              | `bytes32` | The r component of the permit signature.                                             |
| s              | `bytes32` | The s component of the permit signature.                                             |
|                |           |                                                                                      |
| amountToken    | `uint`    | The amount of token received.                                                        |
| amountETH      | `uint`    | The amount of ETH received.                                                          |

### swapExactTokensForTokens

```solidity
function swapExactTokensForTokens(
  uint amountIn,
  uint amountOutMin,
  address[] calldata path,
  address to,
  uint deadline
) external returns (uint[] memory amounts);
```

Swaps an exact amount of input tokens for as many output tokens as possible, along the route determined by the path. The first element of path is the input token, the last is the output token, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).

- `msg.sender` should have already given the router an allowance of at least amountIn on the input token.

| Name         | Type                 |                                                                                                                                      |
| :----------- | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| amountIn     | `uint`               | The amount of input tokens to send.                                                                                                  |
| amountOutMin | `uint`               | The minimum amount of output tokens that must be received for the transaction not to revert.                                         |
| path         | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to           | `address`            | Recipient of the output tokens.                                                                                                      |
| deadline     | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |
|              |                      |                                                                                                                                      |
| amounts      | `uint[] memory`      | The input token amount and all subsequent output token amounts.                                                                      |

### swapTokensForExactTokens

```solidity
function swapTokensForExactTokens(
  uint amountOut,
  uint amountInMax,
  address[] calldata path,
  address to,
  uint deadline
) external returns (uint[] memory amounts);
```

Receive an exact amount of output tokens for as few input tokens as possible, along the route determined by the path. The first element of path is the input token, the last is the output token, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).

- `msg.sender` should have already given the router an allowance of at least amountInMax on the input token.

| Name        | Type                 |                                                                                                                                      |
| :---------- | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| amountOut   | `uint`               | The amount of output tokens to receive.                                                                                              |
| amountInMax | `uint`               | The maximum amount of input tokens that can be required before the transaction reverts.                                              |
| path        | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to          | `address`            | Recipient of the output tokens.                                                                                                      |
| deadline    | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |
|             |                      |                                                                                                                                      |
| amounts     | `uint[] memory`      | The input token amount and all subsequent output token amounts.                                                                      |

### swapExactETHForTokens

```solidity
function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
  external
  payable
  returns (uint[] memory amounts);
```

Swaps an exact amount of ETH for as many output tokens as possible, along the route determined by the path. The first element of path must be [WETH](#weth), the last is the output token, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).

| Name                   | Type                 |                                                                                                                                      |
| :--------------------- | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| `msg.value` (amountIn) | `uint`               | The amount of ETH to send.                                                                                                           |
| amountOutMin           | `uint`               | The minimum amount of output tokens that must be received for the transaction not to revert.                                         |
| path                   | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to                     | `address`            | Recipient of the output tokens.                                                                                                      |
| deadline               | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |
|                        |                      |                                                                                                                                      |
| amounts                | `uint[] memory`      | The input token amount and all subsequent output token amounts.                                                                      |

### swapTokensForExactETH

```solidity
function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
  external
  returns (uint[] memory amounts);
```

Receive an exact amount of ETH for as few input tokens as possible, along the route determined by the path. The first element of path is the input token, the last must be [WETH](#weth), and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).

- `msg.sender` should have already given the router an allowance of at least amountInMax on the input token.
- If the to address is a smart contract, it must have the ability to receive ETH.

| Name        | Type                 |                                                                                                                                      |
| :---------- | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| amountOut   | `uint`               | The amount of ETH to receive.                                                                                                        |
| amountInMax | `uint`               | The maximum amount of input tokens that can be required before the transaction reverts.                                              |
| path        | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to          | `address`            | Recipient of ETH.                                                                                                                    |
| deadline    | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |
|             |                      |                                                                                                                                      |
| amounts     | `uint[] memory`      | The input token amount and all subsequent output token amounts.                                                                      |

### swapExactTokensForETH

```solidity
function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
  external
  returns (uint[] memory amounts);
```

Swaps an exact amount of tokens for as much ETH as possible, along the route determined by the path. The first element of path is the input token, the last must be [WETH](#weth), and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).

- If the to address is a smart contract, it must have the ability to receive ETH.

| Name         | Type                 |                                                                                                                                      |
| :----------- | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| amountIn     | `uint`               | The amount of input tokens to send.                                                                                                  |
| amountOutMin | `uint`               | The minimum amount of output tokens that must be received for the transaction not to revert.                                         |
| path         | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to           | `address`            | Recipient of the ETH.                                                                                                                |
| deadline     | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |
|              |                      |                                                                                                                                      |
| amounts      | `uint[] memory`      | The input token amount and all subsequent output token amounts.                                                                      |

### swapETHForExactTokens

```solidity
function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
  external
  payable
  returns (uint[] memory amounts);
```

Receive an exact amount of tokens for as little ETH as possible, along the route determined by the path. The first element of path must be [WETH](#weth), the last is the output token and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).

- Leftover ETH, if any, is returned to `msg.sender`.

| Name                      | Type                 |                                                                                                                                      |
| :------------------------ | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| amountOut                 | `uint`               | The amount of tokens to receive.                                                                                                     |
| `msg.value` (amountInMax) | `uint`               | The maximum amount of ETH that can be required before the transaction reverts.                                                       |
| path                      | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to                        | `address`            | Recipient of the output tokens.                                                                                                      |
| deadline                  | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |
|                           |                      |                                                                                                                                      |
| amounts                   | `uint[] memory`      | The input token amount and all subsequent output token amounts.                                                                      |

### quote

See [quote](library#quote).

### getAmountOut

See [getAmountOut](library#getamountout).

### getAmountIn

**This function contains a low severity bug, do not use.**

### getAmountsOut

```solidity
function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts);
```

See [getAmountsOut](library#getamountsout).

### getAmountsIn

```solidity
function getAmountsIn(uint amountOut, address[] memory path) public view returns (uint[] memory amounts);
```

See[getAmountsIn](library#getamountsin).

## Interface

```solidity
import '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol';
```

```solidity
pragma solidity >=0.6.2;

interface IUniswapV2Router01 {
  function factory() external pure returns (address);
  function WETH() external pure returns (address);

  function addLiquidity(
      address tokenA,
      address tokenB,
      uint amountADesired,
      uint amountBDesired,
      uint amountAMin,
      uint amountBMin,
      address to,
      uint deadline
  ) external returns (uint amountA, uint amountB, uint liquidity);
  function addLiquidityETH(
      address token,
      uint amountTokenDesired,
      uint amountTokenMin,
      uint amountETHMin,
      address to,
      uint deadline
  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
  function removeLiquidity(
      address tokenA,
      address tokenB,
      uint liquidity,
      uint amountAMin,
      uint amountBMin,
      address to,
      uint deadline
  ) external returns (uint amountA, uint amountB);
  function removeLiquidityETH(
      address token,
      uint liquidity,
      uint amountTokenMin,
      uint amountETHMin,
      address to,
      uint deadline
  ) external returns (uint amountToken, uint amountETH);
  function removeLiquidityWithPermit(
      address tokenA,
      address tokenB,
      uint liquidity,
      uint amountAMin,
      uint amountBMin,
      address to,
      uint deadline,
      bool approveMax, uint8 v, bytes32 r, bytes32 s
  ) external returns (uint amountA, uint amountB);
  function removeLiquidityETHWithPermit(
      address token,
      uint liquidity,
      uint amountTokenMin,
      uint amountETHMin,
      address to,
      uint deadline,
      bool approveMax, uint8 v, bytes32 r, bytes32 s
  ) external returns (uint amountToken, uint amountETH);
  function swapExactTokensForTokens(
      uint amountIn,
      uint amountOutMin,
      address[] calldata path,
      address to,
      uint deadline
  ) external returns (uint[] memory amounts);
  function swapTokensForExactTokens(
      uint amountOut,
      uint amountInMax,
      address[] calldata path,
      address to,
      uint deadline
  ) external returns (uint[] memory amounts);
  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
      external
      payable
      returns (uint[] memory amounts);
  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
      external
      returns (uint[] memory amounts);
  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
      external
      returns (uint[] memory amounts);
  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
      external
      payable
      returns (uint[] memory amounts);

  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}
```

## ABI

```typescript
import IUniswapV2Router01 from '@uniswap/v2-periphery/build/IUniswapV2Router01.json'
```

[https://unpkg.com/@uniswap/v2-periphery@1.0.0-beta.0/build/IUniswapV2Router01.json](https://unpkg.com/@uniswap/v2-periphery@1.0.0-beta.0/build/IUniswapV2Router01.json)
</file>

<file path="docs/contracts/v2/reference/smart-contracts/06-router02.md">
---
id: router-02
title: Router02
---

Because routers are stateless and do not hold token balances, they can be replaced safely and trustlessly, if necessary. This may happen if more efficient smart contract patterns are discovered, or if additional functionality is desired. For this reason, routers have _release numbers_, starting at `01`. This is currently recommended release, `02`.

## Code

[`UniswapV2Router02.sol`](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router02.sol)

## Address

`UniswapV2Router02` is deployed at `0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D` on the Ethereum [mainnet](https://etherscan.io/address/0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D), and the [Ropsten](https://ropsten.etherscan.io/address/0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D), [Rinkeby](https://rinkeby.etherscan.io/address/0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D), [Görli](https://goerli.etherscan.io/address/0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D), and [Kovan](https://kovan.etherscan.io/address/0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D) testnets. It was built from commit [6961711](https://github.com/Uniswap/uniswap-v2-periphery/tree/69617118cda519dab608898d62aaa79877a61004).

## Read-Only Functions

### factory

```solidity
function factory() external pure returns (address);
```

Returns [factory address](../smart-contracts/factory#address).

### WETH

```solidity
function WETH() external pure returns (address);
```

Returns the [canonical WETH address](https://blog.0xproject.com/canonical-weth-a9aa7d0279dd) on the Ethereum [mainnet](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), or the [Ropsten](https://ropsten.etherscan.io/address/0xc778417e063141139fce010982780140aa0cd5ab), [Rinkeby](https://rinkeby.etherscan.io/address/0xc778417e063141139fce010982780140aa0cd5ab), [Görli](https://goerli.etherscan.io/address/0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6), or [Kovan](https://kovan.etherscan.io/address/0xd0a1e359811322d97991e03f863a0c30c2cf029c) testnets.

### quote

See [quote](../smart-contracts/library#quote).

### getAmountOut

See [getAmountOut](../smart-contracts/library#getamountout).

### getAmountIn

See [getAmountIn](../smart-contracts/library#getamountin).

### getAmountsOut

```solidity
function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts);
```

See [getAmountsOut](../smart-contracts/library#getamountsout).

### getAmountsIn

```solidity
function getAmountsIn(uint amountOut, address[] memory path) public view returns (uint[] memory amounts);
```

See [getAmountsIn](../smart-contracts/library#getamountsin).

## State-Changing Functions

### addLiquidity

```solidity
function addLiquidity(
  address tokenA,
  address tokenB,
  uint amountADesired,
  uint amountBDesired,
  uint amountAMin,
  uint amountBMin,
  address to,
  uint deadline
) external returns (uint amountA, uint amountB, uint liquidity);
```

Adds liquidity to an ERC-20⇄ERC-20 pool.

- To cover all possible scenarios, `msg.sender` should have already given the router an allowance of at least amountADesired/amountBDesired on tokenA/tokenB.
- Always adds assets at the ideal ratio, according to the price when the transaction is executed.
- If a pool for the passed tokens does not exists, one is created automatically, and exactly amountADesired/amountBDesired tokens are added.

| Name           | Type      |                                                                                                                |
| :------------- | :-------- | :------------------------------------------------------------------------------------------------------------- |
| tokenA         | `address` | A pool token.                                                                                                  |
| tokenB         | `address` | A pool token.                                                                                                  |
| amountADesired | `uint`    | The amount of tokenA to add as liquidity if the B/A price is \<= amountBDesired/amountADesired (A depreciates). |
| amountBDesired | `uint`    | The amount of tokenB to add as liquidity if the A/B price is \<= amountADesired/amountBDesired (B depreciates). |
| amountAMin     | `uint`    | Bounds the extent to which the B/A price can go up before the transaction reverts. Must be \<= amountADesired.  |
| amountBMin     | `uint`    | Bounds the extent to which the A/B price can go up before the transaction reverts. Must be \<= amountBDesired.  |
| to             | `address` | Recipient of the liquidity tokens.                                                                             |
| deadline       | `uint`    | Unix timestamp after which the transaction will revert.                                                        |
|                |           |                                                                                                                |
| amountA        | `uint`    | The amount of tokenA sent to the pool.                                                                         |
| amountB        | `uint`    | The amount of tokenB sent to the pool.                                                                         |
| liquidity      | `uint`    | The amount of liquidity tokens minted.                                                                         |

### addLiquidityETH

```solidity
function addLiquidityETH(
  address token,
  uint amountTokenDesired,
  uint amountTokenMin,
  uint amountETHMin,
  address to,
  uint deadline
) external payable returns (uint amountToken, uint amountETH, uint liquidity);
```

Adds liquidity to an ERC-20⇄WETH pool with ETH.

- To cover all possible scenarios, `msg.sender` should have already given the router an allowance of at least amountTokenDesired on token.
- Always adds assets at the ideal ratio, according to the price when the transaction is executed.
- `msg.value` is treated as a amountETHDesired.
- Leftover ETH, if any, is returned to `msg.sender`.
- If a pool for the passed token and WETH does not exists, one is created automatically, and exactly amountTokenDesired/`msg.value` tokens are added.

| Name                           | Type      |                                                                                                                           |
| :----------------------------- | :-------- | :------------------------------------------------------------------------------------------------------------------------ |
| token                          | `address` | A pool token.                                                                                                             |
| amountTokenDesired             | `uint`    | The amount of token to add as liquidity if the WETH/token price is \<= `msg.value`/amountTokenDesired (token depreciates). |
| `msg.value` (amountETHDesired) | `uint`    | The amount of ETH to add as liquidity if the token/WETH price is \<= amountTokenDesired/`msg.value` (WETH depreciates).    |
| amountTokenMin                 | `uint`    | Bounds the extent to which the WETH/token price can go up before the transaction reverts. Must be \<= amountTokenDesired.  |
| amountETHMin                   | `uint`    | Bounds the extent to which the token/WETH price can go up before the transaction reverts. Must be \<= `msg.value`.         |
| to                             | `address` | Recipient of the liquidity tokens.                                                                                        |
| deadline                       | `uint`    | Unix timestamp after which the transaction will revert.                                                                   |
|                                |           |                                                                                                                           |
| amountToken                    | `uint`    | The amount of token sent to the pool.                                                                                     |
| amountETH                      | `uint`    | The amount of ETH converted to WETH and sent to the pool.                                                                 |
| liquidity                      | `uint`    | The amount of liquidity tokens minted.                                                                                    |

### removeLiquidity

```solidity
function removeLiquidity(
  address tokenA,
  address tokenB,
  uint liquidity,
  uint amountAMin,
  uint amountBMin,
  address to,
  uint deadline
) external returns (uint amountA, uint amountB);
```

Removes liquidity from an ERC-20⇄ERC-20 pool.

- `msg.sender` should have already given the router an allowance of at least liquidity on the pool.

| Name       | Type      |                                                                                       |
| :--------- | :-------- | :------------------------------------------------------------------------------------ |
| tokenA     | `address` | A pool token.                                                                         |
| tokenB     | `address` | A pool token.                                                                         |
| liquidity  | `uint`    | The amount of liquidity tokens to remove.                                             |
| amountAMin | `uint`    | The minimum amount of tokenA that must be received for the transaction not to revert. |
| amountBMin | `uint`    | The minimum amount of tokenB that must be received for the transaction not to revert. |
| to         | `address` | Recipient of the underlying assets.                                                   |
| deadline   | `uint`    | Unix timestamp after which the transaction will revert.                               |
|            |           |                                                                                       |
| amountA    | `uint`    | The amount of tokenA received.                                                        |
| amountB    | `uint`    | The amount of tokenB received.                                                        |

### removeLiquidityETH

```solidity
function removeLiquidityETH(
  address token,
  uint liquidity,
  uint amountTokenMin,
  uint amountETHMin,
  address to,
  uint deadline
) external returns (uint amountToken, uint amountETH);
```

Removes liquidity from an ERC-20⇄WETH pool and receive ETH.

- `msg.sender` should have already given the router an allowance of at least liquidity on the pool.

| Name           | Type      |                                                                                      |
| :------------- | :-------- | :----------------------------------------------------------------------------------- |
| token          | `address` | A pool token.                                                                        |
| liquidity      | `uint`    | The amount of liquidity tokens to remove.                                            |
| amountTokenMin | `uint`    | The minimum amount of token that must be received for the transaction not to revert. |
| amountETHMin   | `uint`    | The minimum amount of ETH that must be received for the transaction not to revert.   |
| to             | `address` | Recipient of the underlying assets.                                                  |
| deadline       | `uint`    | Unix timestamp after which the transaction will revert.                              |
|                |           |                                                                                      |
| amountToken    | `uint`    | The amount of token received.                                                        |
| amountETH      | `uint`    | The amount of ETH received.                                                          |

### removeLiquidityWithPermit

```solidity
function removeLiquidityWithPermit(
  address tokenA,
  address tokenB,
  uint liquidity,
  uint amountAMin,
  uint amountBMin,
  address to,
  uint deadline,
  bool approveMax, uint8 v, bytes32 r, bytes32 s
) external returns (uint amountA, uint amountB);
```

Removes liquidity from an ERC-20⇄ERC-20 pool without pre-approval, thanks to [permit](pair-erc-20#permit).

| Name       | Type      |                                                                                       |
| :--------- | :-------- | :------------------------------------------------------------------------------------ |
| tokenA     | `address` | A pool token.                                                                         |
| tokenB     | `address` | A pool token.                                                                         |
| liquidity  | `uint`    | The amount of liquidity tokens to remove.                                             |
| amountAMin | `uint`    | The minimum amount of tokenA that must be received for the transaction not to revert. |
| amountBMin | `uint`    | The minimum amount of tokenB that must be received for the transaction not to revert. |
| to         | `address` | Recipient of the underlying assets.                                                   |
| deadline   | `uint`    | Unix timestamp after which the transaction will revert.                               |
| approveMax | `bool`    | Whether or not the approval amount in the signature is for liquidity or `uint(-1)`.   |
| v          | `uint8`   | The v component of the permit signature.                                              |
| r          | `bytes32` | The r component of the permit signature.                                              |
| s          | `bytes32` | The s component of the permit signature.                                              |
|            |           |                                                                                       |
| amountA    | `uint`    | The amount of tokenA received.                                                        |
| amountB    | `uint`    | The amount of tokenB received.                                                        |

### removeLiquidityETHWithPermit

```solidity
function removeLiquidityETHWithPermit(
  address token,
  uint liquidity,
  uint amountTokenMin,
  uint amountETHMin,
  address to,
  uint deadline,
  bool approveMax, uint8 v, bytes32 r, bytes32 s
) external returns (uint amountToken, uint amountETH);
```

Removes liquidity from an ERC-20⇄WETTH pool and receive ETH without pre-approval, thanks to [permit](pair-erc-20#permit).

| Name           | Type      |                                                                                      |
| :------------- | :-------- | :----------------------------------------------------------------------------------- |
| token          | `address` | A pool token.                                                                        |
| liquidity      | `uint`    | The amount of liquidity tokens to remove.                                            |
| amountTokenMin | `uint`    | The minimum amount of token that must be received for the transaction not to revert. |
| amountETHMin   | `uint`    | The minimum amount of ETH that must be received for the transaction not to revert.   |
| to             | `address` | Recipient of the underlying assets.                                                  |
| deadline       | `uint`    | Unix timestamp after which the transaction will revert.                              |
| approveMax     | `bool`    | Whether or not the approval amount in the signature is for liquidity or `uint(-1)`.  |
| v              | `uint8`   | The v component of the permit signature.                                             |
| r              | `bytes32` | The r component of the permit signature.                                             |
| s              | `bytes32` | The s component of the permit signature.                                             |
|                |           |                                                                                      |
| amountToken    | `uint`    | The amount of token received.                                                        |
| amountETH      | `uint`    | The amount of ETH received.                                                          |

### removeLiquidityETHSupportingFeeOnTransferTokens

```solidity
function removeLiquidityETHSupportingFeeOnTransferTokens(
  address token,
  uint liquidity,
  uint amountTokenMin,
  uint amountETHMin,
  address to,
  uint deadline
) external returns (uint amountETH);
```

Identical to [removeLiquidityETH](#removeliquidityeth), but succeeds for tokens that take a fee on transfer.

- `msg.sender` should have already given the router an allowance of at least liquidity on the pool.

| Name           | Type      |                                                                                      |
| :------------- | :-------- | :----------------------------------------------------------------------------------- |
| token          | `address` | A pool token.                                                                        |
| liquidity      | `uint`    | The amount of liquidity tokens to remove.                                            |
| amountTokenMin | `uint`    | The minimum amount of token that must be received for the transaction not to revert. |
| amountETHMin   | `uint`    | The minimum amount of ETH that must be received for the transaction not to revert.   |
| to             | `address` | Recipient of the underlying assets.                                                  |
| deadline       | `uint`    | Unix timestamp after which the transaction will revert.                              |
|                |           |                                                                                      |
| amountETH      | `uint`    | The amount of ETH received.                                                          |

### removeLiquidityETHWithPermitSupportingFeeOnTransferTokens

```solidity
function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
  address token,
  uint liquidity,
  uint amountTokenMin,
  uint amountETHMin,
  address to,
  uint deadline,
  bool approveMax, uint8 v, bytes32 r, bytes32 s
) external returns (uint amountETH);
```

Identical to [removeLiquidityETHWithPermit](#removeliquidityethwithpermit), but succeeds for tokens that take a fee on transfer.

| Name           | Type      |                                                                                      |
| :------------- | :-------- | :----------------------------------------------------------------------------------- |
| token          | `address` | A pool token.                                                                        |
| liquidity      | `uint`    | The amount of liquidity tokens to remove.                                            |
| amountTokenMin | `uint`    | The minimum amount of token that must be received for the transaction not to revert. |
| amountETHMin   | `uint`    | The minimum amount of ETH that must be received for the transaction not to revert.   |
| to             | `address` | Recipient of the underlying assets.                                                  |
| deadline       | `uint`    | Unix timestamp after which the transaction will revert.                              |
| approveMax     | `bool`    | Whether or not the approval amount in the signature is for liquidity or `uint(-1)`.  |
| v              | `uint8`   | The v component of the permit signature.                                             |
| r              | `bytes32` | The r component of the permit signature.                                             |
| s              | `bytes32` | The s component of the permit signature.                                             |
|                |           |                                                                                      |
| amountETH      | `uint`    | The amount of ETH received.                                                          |

### swapExactTokensForTokens

```solidity
function swapExactTokensForTokens(
  uint amountIn,
  uint amountOutMin,
  address[] calldata path,
  address to,
  uint deadline
) external returns (uint[] memory amounts);
```

Swaps an exact amount of input tokens for as many output tokens as possible, along the route determined by the path. The first element of path is the input token, the last is the output token, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).

- `msg.sender` should have already given the router an allowance of at least amountIn on the input token.

| Name         | Type                 |                                                                                                                                      |
| :----------- | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| amountIn     | `uint`               | The amount of input tokens to send.                                                                                                  |
| amountOutMin | `uint`               | The minimum amount of output tokens that must be received for the transaction not to revert.                                         |
| path         | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to           | `address`            | Recipient of the output tokens.                                                                                                      |
| deadline     | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |
|              |                      |                                                                                                                                      |
| amounts      | `uint[] memory`      | The input token amount and all subsequent output token amounts.                                                                      |

### swapTokensForExactTokens

```solidity
function swapTokensForExactTokens(
  uint amountOut,
  uint amountInMax,
  address[] calldata path,
  address to,
  uint deadline
) external returns (uint[] memory amounts);
```

Receive an exact amount of output tokens for as few input tokens as possible, along the route determined by the path. The first element of path is the input token, the last is the output token, and any intermediate elements represent intermediate tokens to trade through (if, for example, a direct pair does not exist).

- `msg.sender` should have already given the router an allowance of at least amountInMax on the input token.

| Name        | Type                 |                                                                                                                                      |
| :---------- | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| amountOut   | `uint`               | The amount of output tokens to receive.                                                                                              |
| amountInMax | `uint`               | The maximum amount of input tokens that can be required before the transaction reverts.                                              |
| path        | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to          | `address`            | Recipient of the output tokens.                                                                                                      |
| deadline    | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |
|             |                      |                                                                                                                                      |
| amounts     | `uint[] memory`      | The input token amount and all subsequent output token amounts.                                                                      |

### swapExactETHForTokens

```solidity
function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
  external
  payable
  returns (uint[] memory amounts);
```

Swaps an exact amount of ETH for as many output tokens as possible, along the route determined by the path. The first element of path must be [WETH](#weth), the last is the output token, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).

| Name                   | Type                 |                                                                                                                                      |
| :--------------------- | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| `msg.value` (amountIn) | `uint`               | The amount of ETH to send.                                                                                                           |
| amountOutMin           | `uint`               | The minimum amount of output tokens that must be received for the transaction not to revert.                                         |
| path                   | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to                     | `address`            | Recipient of the output tokens.                                                                                                      |
| deadline               | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |
|                        |                      |                                                                                                                                      |
| amounts                | `uint[] memory`      | The input token amount and all subsequent output token amounts.                                                                      |

### swapTokensForExactETH

```solidity
function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
  external
  returns (uint[] memory amounts);
```

Receive an exact amount of ETH for as few input tokens as possible, along the route determined by the path. The first element of path is the input token, the last must be [WETH](#weth), and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).

- `msg.sender` should have already given the router an allowance of at least amountInMax on the input token.
- If the to address is a smart contract, it must have the ability to receive ETH.

| Name        | Type                 |                                                                                                                                      |
| :---------- | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| amountOut   | `uint`               | The amount of ETH to receive.                                                                                                        |
| amountInMax | `uint`               | The maximum amount of input tokens that can be required before the transaction reverts.                                              |
| path        | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to          | `address`            | Recipient of ETH.                                                                                                                    |
| deadline    | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |
|             |                      |                                                                                                                                      |
| amounts     | `uint[] memory`      | The input token amount and all subsequent output token amounts.                                                                      |

### swapExactTokensForETH

```solidity
function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
  external
  returns (uint[] memory amounts);
```

Swaps an exact amount of tokens for as much ETH as possible, along the route determined by the path. The first element of path is the input token, the last must be [WETH](#weth), and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).

- If the to address is a smart contract, it must have the ability to receive ETH.

| Name         | Type                 |                                                                                                                                      |
| :----------- | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| amountIn     | `uint`               | The amount of input tokens to send.                                                                                                  |
| amountOutMin | `uint`               | The minimum amount of output tokens that must be received for the transaction not to revert.                                         |
| path         | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to           | `address`            | Recipient of the ETH.                                                                                                                |
| deadline     | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |
|              |                      |                                                                                                                                      |
| amounts      | `uint[] memory`      | The input token amount and all subsequent output token amounts.                                                                      |

### swapETHForExactTokens

```solidity
function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
  external
  payable
  returns (uint[] memory amounts);
```

Receive an exact amount of tokens for as little ETH as possible, along the route determined by the path. The first element of path must be [WETH](#weth), the last is the output token and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).

- Leftover ETH, if any, is returned to `msg.sender`.

| Name                      | Type                 |                                                                                                                                      |
| :------------------------ | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| amountOut                 | `uint`               | The amount of tokens to receive.                                                                                                     |
| `msg.value` (amountInMax) | `uint`               | The maximum amount of ETH that can be required before the transaction reverts.                                                       |
| path                      | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to                        | `address`            | Recipient of the output tokens.                                                                                                      |
| deadline                  | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |
|                           |                      |                                                                                                                                      |
| amounts                   | `uint[] memory`      | The input token amount and all subsequent output token amounts.                                                                      |

### swapExactTokensForTokensSupportingFeeOnTransferTokens

```solidity
function swapExactTokensForTokensSupportingFeeOnTransferTokens(
  uint amountIn,
  uint amountOutMin,
  address[] calldata path,
  address to,
  uint deadline
) external;
```

Identical to [swapExactTokensForTokens](#swapexacttokensfortokens), but succeeds for tokens that take a fee on transfer.

- `msg.sender` should have already given the router an allowance of at least amountIn on the input token.

| Name         | Type                 |                                                                                                                                      |
| :----------- | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| amountIn     | `uint`               | The amount of input tokens to send.                                                                                                  |
| amountOutMin | `uint`               | The minimum amount of output tokens that must be received for the transaction not to revert.                                         |
| path         | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to           | `address`            | Recipient of the output tokens.                                                                                                      |
| deadline     | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |

### swapExactETHForTokensSupportingFeeOnTransferTokens

```solidity
function swapExactETHForTokensSupportingFeeOnTransferTokens(
  uint amountOutMin,
  address[] calldata path,
  address to,
  uint deadline
) external payable;
```

Identical to [swapExactETHForTokens](#swapexactethfortokens), but succeeds for tokens that take a fee on transfer.

| Name                   | Type                 |                                                                                                                                      |
| :--------------------- | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| `msg.value` (amountIn) | `uint`               | The amount of ETH to send.                                                                                                           |
| amountOutMin           | `uint`               | The minimum amount of output tokens that must be received for the transaction not to revert.                                         |
| path                   | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to                     | `address`            | Recipient of the output tokens.                                                                                                      |
| deadline               | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |

### swapExactTokensForETHSupportingFeeOnTransferTokens

```solidity
function swapExactTokensForETHSupportingFeeOnTransferTokens(
  uint amountIn,
  uint amountOutMin,
  address[] calldata path,
  address to,
  uint deadline
) external;
```

Identical to [swapExactTokensForETH](#swapexacttokensforeth), but succeeds for tokens that take a fee on transfer.

- If the to address is a smart contract, it must have the ability to receive ETH.

| Name         | Type                 |                                                                                                                                      |
| :----------- | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| amountIn     | `uint`               | The amount of input tokens to send.                                                                                                  |
| amountOutMin | `uint`               | The minimum amount of output tokens that must be received for the transaction not to revert.                                         |
| path         | `address[] calldata` | An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity. |
| to           | `address`            | Recipient of the ETH.                                                                                                                |
| deadline     | `uint`               | Unix timestamp after which the transaction will revert.                                                                              |

## Interface

```solidity
import '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';
```

```solidity
pragma solidity >=0.6.2;

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}
```

## ABI

```typescript
import IUniswapV2Router02 from '@uniswap/v2-periphery/build/IUniswapV2Router02.json'
```

[https://unpkg.com/@uniswap/v2-periphery@1.1.0-beta.0/build/IUniswapV2Router02.json](https://unpkg.com/@uniswap/v2-periphery@1.1.0-beta.0/build/IUniswapV2Router02.json)
</file>

<file path="docs/contracts/v2/reference/smart-contracts/07-common-errors.md">
---
id: common-errors
title: Common Errors
---

This document covers a few error codes frequently encountered while building on Uniswap V2.

## UniswapV2: K

This is an error that is frequently encountered, and requires a bit of context to understand it.

The Uniswap constant product formula is “X \* Y = K”. Where X and Y represent the respective reserve balances of two ERC-20 tokens, and “K” represents the product of the reserves. It is this “K” to which the “K” error refers.

In essence, the “K” error means that a trade was attempted that somehow left the trading pair with less reserves than should be there, and as a result the transaction is reverted.

This can have a few different causes.

## Fee On Transfer Tokens

The most common examples are caused by “fee on transfer” tokens.

### Inclusive Fee On Transfer Tokens

In most cases, a fee on transfer token burns or diverts a small portion of every transfer such that the recipient of the transfer ends up with slightly less than the sender gave. This is called an “inclusive” fee on transfer.

In the case of inclusive fee on transfer tokens, you can use the corresponding swap functions in the router contract which end with [“SupportingFeeOnTransfer”](../smart-contracts/router-02#swapexacttokensfortokenssupportingfeeontransfertokens). These functions succeed by adjusting the “amountOutMin” parameter to check the recipient amount rather than the sending amount when calculating the invariant.

### Exclusive Fee On Transfer Tokens

The other type, “exclusive” fee on transfer tokens, work by sending an additional transfer from the sending address after the primary transfer. Because the router contract cannot anticipate this trailing transfer when calculating the invariant, the transaction will either revert, or partially succeed by sending the primary transfer but breaking the pool upon the trailing transfer.

In the case of exclusive fee on transfer tokens, the SupportingFeeOnTransfer functions may work, but there will be some tokens designed in such a way that they fundamentally break the router. If you are still getting a “K” error when using these functions, you may need to make a fork of the router contract that accommodates your token design.

## Rebasing Tokens

The less common instance of the “K” error is as a result of rebasing tokens.

Rebasing tokens can alter the balance of any addresses holding their tokens arbitrarily. This usually works at pre specified intervals and as a result of a handful of variables used in the economics of a rebasing token.

Rebasing tokens typically work in two ways.

### Negative Rebasing Tokens

A negative rebasing token, the more common variant, deflates the balances of token owners. Because the rebasing is not triggered by transfers, the router cannot expect when or how a rebasing will happen. Once it does, the pair reserves will be unbalanced, and the next person to transact with the pair will bear the cost of the delta as a result of the rebasing.

Needless to say, an unenviable position.

Negative rebasing tokens have solved this error by altering their token contract to call [sync](../smart-contracts/pair#sync) on the trading pair at the end of every transaction involving the Uniswap router contract. Those interested in forking the router contract should anticipate that negative rebasing tokens will break the pair until the token contracts are updated to accommodate your new router.

### Positive Rebasing Tokens

Positive rebasing tokens arbitrarily increase the balances of token holders. When a positive rebase happens, it creates a surplus that is unaccounted for in the trading pair. Because the extra tokens are unaccounted for in the trading pair, anyone can call skim() on the trading pair and effectively steal the positive difference from the rebalance.

While positive rebalancing does not break any functionality of Uniswap, those interested in them should be aware that the positive balance found in any pair will be freely available for taking.

### A Note on Rebasing Tokens

For those interested in building a rebasing token, a word of caution: many contracts involving decentralized trading and liquidity provisioning will break upon interacting with your token. An example approach that will lead to much easier integration in future protocols can be found in [CHAI](https://chai.money/about.html). CHAI uses a wrapper function that contains the rebalancing within the wrapper, such that the redeemable token can be easily integrated into many different systems.

# UniswapV2: LOCKED

The LOCKED error is a guard built into the router contract that prevents customized reentrancy contracts from attempting to return malicious code into the router contract at the end of a transaction.

This error is commonly encountered when using Ganache CLI to fork the Ethereum mainnet to a local instance as a part of a development environment. The error is a bug in Ganache-Cli that will hopefully be fixed in a future release by the truffle team.

A temporary fix is available by simply restarting the local fork.

# No Access To Archive Node

This is an error with either Metamask or Ganache-CLI. It usually occurs after a local fork is instantiated and contracts are deployed but there is one failed transaction.

A temporary fix is available by restarting the local fork and resetting metamask.

# UniswapV2: TRANSFER_FAILED

This means the core contract was unable to send tokens to the recipient. This is most likely due to a scam token, where the token owner has maliciously disabled the transfer function in a way that allows users to buy the token, but not sell them.

# UniswapV2: EXPIRED

This is a result of a transaction that took too long to be broadcast to the mainnet.

Uniswap does not set gas prices natively, so most users default to the suggested gas prices in metamask. Sometimes metamask gets it wrong, though, and sets the gas price too low. If a swap takes more than 20 minutes to execute, the core contract won’t allow it to go through.

# Action Requires an Active Reserve

VM Exception While Processing Transaction: Action Requires an Active Reserve

This is potentially a ganache bug encountered when working on flash swaps. We haven't figured out the source of it yet.

# Unable To Approve Transaction On The Front End

There are rare circumstances where users are unable to approve a token on the Uniswap front end.

This is a result of some token contracts taking steps to defend against malicious contracts that attempt to front run approvals and steal a users tokens. It happens only when the user is trying to increase an approval allowance from a preallocated amount to a larger one, and only happens with a few token contracts.

The solution is have the user manually set the router contract approval amount to zero, then to the number they want. The easiest way to do this is through Etherscan.
</file>

<file path="docs/contracts/v2/reference/smart-contracts/08-deployment-addresses.md">
---
id: v2-deployments
title: V2 Deployment Addresses
---

Contract addresses for the [`Uniswap V2 Factory`](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Factory.sol) and the [`Uniswap V2Router02`](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol)

| Network                                              | Factory Contract Address                     | V2Router02 Contract Address                  |
| ---------------------------------------------------- | -------------------------------------------- | -------------------------------------------- |
| Mainnet                                              | `0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f` | `0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D` |
| Sepolia                                              | `0xF62c03E08ada871A0bEb309762E260a7a6a880E6` | `0xeE567Fe1712Faf6149d80dA1E6934E354124CfE3` |
| Unichain                                             | `0x1f98400000000000000000000000000000000002` | `0x284f11109359a7e1306c3e447ef14d38400063ff` |
| Arbitrum                                             | `0xf1D7CC64Fb4452F05c498126312eBE29f30Fbcf9` | `0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24` |
| Avalanche                                            | `0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C` | `0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24` |
| BNB Chain                                            | `0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6` | `0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24` |
| Base                                                 | `0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6` | `0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24` |
| Optimism                                             | `0x0c3c1c532F1e39EdF36BE9Fe0bE1410313E074Bf` | `0x4A7b5Da61326A6379179b40d00F57E5bbDC962c2` |
| Polygon                                              | `0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C` | `0xedf6066a2b290C185783862C7F4776A2C8077AD1` |
| Blast                                                | `0x5C346464d33F90bABaf70dB6388507CC889C1070` | `0xBB66Eb1c5e875933D44DAe661dbD80e5D9B03035` |
| Zora                                                 | `0x0F797dC7efaEA995bB916f268D919d0a1950eE3C` | `0xa00F34A632630EFd15223B1968358bA4845bEEC7` |
| WorldChain                                           | `0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f` | `0x541aB7c31A119441eF3575F6973277DE0eF460bd` |
</file>

<file path="docs/contracts/v2/reference/_category_.json">
{
  "label": "Technical Reference",
  "position": 4,
  "collapsed": false
}
</file>

<file path="docs/contracts/v2/_category_.json">
{
  "label": "v2 Protocol",
  "position": 7,
  "collapsed": true
}
</file>

<file path="docs/contracts/v2/overview.md">
---
id: overview
title: Overview
sidebar_position: 1
---

Welcome to the Uniswap protocol v2 docs.

The pages here contain conceptual and technical documentation of the Uniswap v2 protocol.

If you are new to Uniswap, you might want to check out the [Protocol overview](../V2/concepts/protocol-overview/how-uniswap-works) first.

You can also take a look at the v2 Protocol <a href='/whitepaper.pdf' target='_blank' rel='noopener noreferrer'>Whitepaper</a>.

## Developer links

The v2 Uniswap protocol is separated across two repositories

- [`uniswap-v2-core`](https://github.com/Uniswap/uniswap-v2-core)
- [`uniswap-v2-periphery`](https://github.com/Uniswap/uniswap-v2-periphery)

The v2 SDK, which can assist developers when interacting with the Uniswap v2 Protocol can be found here.

- [`uniswap-sdk`](https://github.com/Uniswap/uniswap-v2-sdk)
- [`uniswap-sdk-core`](https://github.com/Uniswap/uniswap-sdk-core)
</file>

<file path="docs/contracts/v3/concepts/_category_.json">
{
  "label": "Concepts",
  "position": 3
}
</file>

<file path="docs/contracts/v3/concepts/security.md">
---
id: security
title: Security
---

# Audits

In early 2021, ABDK Consulting performed a general security review and thereafter published an audit report for the Uniswap V3 core contracts in March 2021 prior to its release.

> [Read the report](https://github.com/Uniswap/v3-core/blob/main/audits/abdk/audit.pdf)

In April 2021, ABDK Consulting also published an audit report for the Uniswap V3 Periphery contracts.

> [Read the report](https://github.com/Uniswap/v3-periphery/blob/main/audits/abdk/audit.pdf)


During the week of January 4th, 2021 and from February 15th to March 12th, three engineers from Trail of Bits conducted a security review on the Uniswap V3 core contracts and subsequently published an audit report including results from [Echidna end-to-end tests](https://github.com/Uniswap/v3-core/tree/main/audits/tob#end-to-end-testing-with-echidna) and  [verification](https://github.com/Uniswap/v3-core/tree/main/audits/tob#verification-with-manticore) from the symbolic execution tool Manticore.

> [Read the report](https://github.com/Uniswap/v3-core/blob/main/audits/tob/audit.pdf)

# Bug Bounty

Uniswap has an open and ongoing bug [bounty program](https://cantina.xyz/bounties/f9df94db-c7b1-434b-bb06-d1360abdd1be) on Cantina.
</file>

<file path="docs/contracts/v3/guides/flash-integrations/_category_.json">
{
  "label": "Implement Flash Swaps",
  "position": 4
}
</file>

<file path="docs/contracts/v3/guides/flash-integrations/calling-flash.md">
---
id: calling-flash
title: Calling Flash
sidebar_position: 2
---

## Parameter Structs

In order to call `flash`, we will need the flash parameters for the initial call, as well as any parameters we want to pass through to the callback.

The `FlashParams` struct will contain the token addresses and amounts we wish to pull out of the pool, as well as the three fee tiers used to determine which pool we are withdrawing from, and which we will be swapping with.

```solidity
  struct FlashParams {
        address token0;
        address token1;
        uint24 fee1;
        uint256 amount0;
        uint256 amount1;
        uint24 fee2;
        uint24 fee3;
    }
```

The `FlashCallbackData` struct will contain the data we want to send to the callback. This includes `poolKey`, which expresses the sorted tokens with the matched fee tier, returned by the [**PoolAddress**](https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/PoolAddress.sol) library.

```solidity
    struct FlashCallbackData {
        uint256 amount0;
        uint256 amount1;
        address payer;
        PoolAddress.PoolKey poolKey;
        uint24 poolFee2;
        uint24 poolFee3;
    }
```

## Pool Key

Now we'll start our function by assigning the relevant parameters from the `Flashparams` (which we have declared in memory as `params`) to our variable `poolKey`

```solidity
    function initFlash(FlashParams memory params) external {
        PoolAddress.PoolKey memory poolKey =
            PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee1});
    }
```

Next we will declare `pool` as type [**IUniswapV3Pool**], which allows us to call `flash` on our desired pool contract.

```solidity
        IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));
```

## Calling Flash

Finally, we call `flash` on our previously declared `pool`. In the last parameter, we abi.encode the `FlashCallbackData`, which will be decoded in the callback and used to inform the next steps of the transaction.

```solidity
        pool.flash(
            address(this),
            params.amount0,
            params.amount1,
            abi.encode(
                FlashCallbackData({
                    amount0: params.amount0,
                    amount1: params.amount1,
                    payer: msg.sender,
                    poolKey: poolKey,
                    poolFee2: params.fee2,
                    poolFee3: params.fee3
                })
            )
        );
```

The full function:

```solidity
    //fee1 is the fee of the pool from the initial borrow
    //fee2 is the fee of the first pool to arb from
    //fee3 is the fee of the second pool to arb from
    struct FlashParams {
        address token0;
        address token1;
        uint24 fee1;
        uint256 amount0;
        uint256 amount1;
        uint24 fee2;
        uint24 fee3;
    }

    // fee2 and fee3 are the two other fees associated with the two other pools of token0 and token1
    struct FlashCallbackData {
        uint256 amount0;
        uint256 amount1;
        address payer;
        PoolAddress.PoolKey poolKey;
        uint24 poolFee2;
        uint24 poolFee3;
    }

function initFlash(FlashParams memory params) external {
        PoolAddress.PoolKey memory poolKey =
            PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee1});
        IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));
        pool.flash(
            address(this),
            params.amount0,
            params.amount1,
            abi.encode(
                FlashCallbackData({
                    amount0: params.amount0,
                    amount1: params.amount1,
                    payer: msg.sender,
                    poolKey: poolKey,
                    poolFee2: params.fee2,
                    poolFee3: params.fee3
                })
            )
        );
    }
```
</file>

<file path="docs/contracts/v3/guides/flash-integrations/final-contract.md">
---
id: final-contract
title: The Final Contract
sidebar_position: 4
---

## The Full Contract

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;

import '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3FlashCallback.sol';
import '@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol';

import '@uniswap/v3-periphery/contracts/base/PeripheryPayments.sol';
import '@uniswap/v3-periphery/contracts/base/PeripheryImmutableState.sol';
import '@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol';
import '@uniswap/v3-periphery/contracts/libraries/CallbackValidation.sol';
import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';

/// @title Flash contract implementation
/// @notice An example contract using the Uniswap V3 flash function
contract PairFlash is IUniswapV3FlashCallback, PeripheryImmutableState, PeripheryPayments {
    using LowGasSafeMath for uint256;
    using LowGasSafeMath for int256;

    ISwapRouter public immutable swapRouter;

    constructor(
        ISwapRouter _swapRouter,
        address _factory,
        address _WETH9
    ) PeripheryImmutableState(_factory, _WETH9) {
        swapRouter = _swapRouter;
    }

    /// @param fee0 The fee from calling flash for token0
    /// @param fee1 The fee from calling flash for token1
    /// @param data The data needed in the callback passed as FlashCallbackData from `initFlash`
    /// @notice implements the callback called from flash
    /// @dev fails if the flash is not profitable, meaning the amountOut from the flash is less than the amount borrowed
    function uniswapV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external override {
        FlashCallbackData memory decoded = abi.decode(data, (FlashCallbackData));
        CallbackValidation.verifyCallback(factory, decoded.poolKey);

        address token0 = decoded.poolKey.token0;
        address token1 = decoded.poolKey.token1;

        TransferHelper.safeApprove(token0, address(swapRouter), decoded.amount0);
        TransferHelper.safeApprove(token1, address(swapRouter), decoded.amount1);

        // profitable check
        // exactInputSingle will fail if this amount not met
        uint256 amount1Min = LowGasSafeMath.add(decoded.amount1, fee1);
        uint256 amount0Min = LowGasSafeMath.add(decoded.amount0, fee0);

        // call exactInputSingle for swapping token1 for token0 in pool w/fee2
        uint256 amountOut0 =
            swapRouter.exactInputSingle(
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: token1,
                    tokenOut: token0,
                    fee: decoded.poolFee2,
                    recipient: address(this),
                    deadline: block.timestamp,
                    amountIn: decoded.amount1,
                    amountOutMinimum: amount0Min,
                    sqrtPriceLimitX96: 0
                })
            );

        // call exactInputSingle for swapping token0 for token 1 in pool w/fee3
        uint256 amountOut1 =
            swapRouter.exactInputSingle(
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: token0,
                    tokenOut: token1,
                    fee: decoded.poolFee3,
                    recipient: address(this),
                    deadline: block.timestamp,
                    amountIn: decoded.amount0,
                    amountOutMinimum: amount1Min,
                    sqrtPriceLimitX96: 0
                })
            );

        // end up with amountOut0 of token0 from first swap and amountOut1 of token1 from second swap
        uint256 amount0Owed = LowGasSafeMath.add(decoded.amount0, fee0);
        uint256 amount1Owed = LowGasSafeMath.add(decoded.amount1, fee1);

        TransferHelper.safeApprove(token0, address(this), amount0Owed);
        TransferHelper.safeApprove(token1, address(this), amount1Owed);

        if (amount0Owed > 0) pay(token0, address(this), msg.sender, amount0Owed);
        if (amount1Owed > 0) pay(token1, address(this), msg.sender, amount1Owed);

        // if profitable pay profits to payer
        if (amountOut0 > amount0Owed) {
            uint256 profit0 = LowGasSafeMath.sub(amountOut0, amount0Owed);

            TransferHelper.safeApprove(token0, address(this), profit0);
            pay(token0, address(this), decoded.payer, profit0);
        }
        if (amountOut1 > amount1Owed) {
            uint256 profit1 = LowGasSafeMath.sub(amountOut1, amount1Owed);
            TransferHelper.safeApprove(token0, address(this), profit1);
            pay(token1, address(this), decoded.payer, profit1);
        }
    }

    //fee1 is the fee of the pool from the initial borrow
    //fee2 is the fee of the first pool to arb from
    //fee3 is the fee of the second pool to arb from
    struct FlashParams {
        address token0;
        address token1;
        uint24 fee1;
        uint256 amount0;
        uint256 amount1;
        uint24 fee2;
        uint24 fee3;
    }
    // fee2 and fee3 are the two other fees associated with the two other pools of token0 and token1
    struct FlashCallbackData {
        uint256 amount0;
        uint256 amount1;
        address payer;
        PoolAddress.PoolKey poolKey;
        uint24 poolFee2;
        uint24 poolFee3;
    }

    /// @param params The parameters necessary for flash and the callback, passed in as FlashParams
    /// @notice Calls the pools flash function with data needed in `uniswapV3FlashCallback`
    function initFlash(FlashParams memory params) external {
        PoolAddress.PoolKey memory poolKey =
            PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee1});
        IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));
        // recipient of borrowed amounts
        // amount of token0 requested to borrow
        // amount of token1 requested to borrow
        // need amount 0 and amount1 in callback to pay back pool
        // recipient of flash should be THIS contract
        pool.flash(
            address(this),
            params.amount0,
            params.amount1,
            abi.encode(
                FlashCallbackData({
                    amount0: params.amount0,
                    amount1: params.amount1,
                    payer: msg.sender,
                    poolKey: poolKey,
                    poolFee2: params.fee2,
                    poolFee3: params.fee3
                })
            )
        );
    }
}

```
</file>

<file path="docs/contracts/v3/guides/flash-integrations/flash-callback.md">
---
id: flash-callback
title: The Flash Callback
sidebar_position: 3
---

## Setting Up The Callback

Here we will override the flash callback with our custom logic to execute the desired swaps and pay the profits to the original `msg.sender`.

Declare the `uniswapV3FlashCallback` function and override it.

```solidity
    function uniswapV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external override {
```

Declare a variable `decoded` in memory and assign it to the [**decoded data**](https://docs.soliditylang.org/en/v0.7.6/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions) previously encoded into the calldata.

```solidity
        FlashCallbackData memory decoded = abi.decode(data, (FlashCallbackData));
```

Each callback must be validated to verify that the call originated from a genuine V3 pool. Otherwise, the PairFlash contract would be vulnerable to attack via an EOA manipulating the callback function.

```solidity
        CallbackValidation.verifyCallback(factory, decoded.poolKey);
```

Assign local variables of type `address` as `token0` and `token1` to approve the router to interact with the tokens from the flash.

```solidity
        address token0 = decoded.poolKey.token0;
        address token1 = decoded.poolKey.token1;

        TransferHelper.safeApprove(token0, address(swapRouter), decoded.amount0);
        TransferHelper.safeApprove(token1, address(swapRouter), decoded.amount1);
```

Code in a minimum amount out for both of the upcoming swaps, such that the following swaps will revert if we do not receive a profitable trade.

```solidity
        uint256 amount1Min = LowGasSafeMath.add(decoded.amount1, fee1);
        uint256 amount0Min = LowGasSafeMath.add(decoded.amount0, fee0);
```

## Initiating A Swap

Call the first of two swaps, calling `exactInputSingle` on the [**router interface**](../../reference/periphery/interfaces/ISwapRouter.md) contract. In this call, we are using the previously declared `amount0In` as the minimum amount out, and assigning the returned balance of the swap to `amountOut0`.

Most of These function arguments have already been discussed, except for two new introductions:

`sqrtPriceLimitX96`: This value limits the price that the swap can change the pool to. Remember that price is always expressed in the pool contract as `token1` in terms of `token0`. This is useful for circumstances where the user wants to swap _up until_ a specific price. For this example, we will set it to 0, which makes the argument inactive.

`deadline`: this is the timestamp after which the transaction will revert, to protect the transaction from dramatic changes in price environment that can happen if the transaction is pending for too long. For this example, we will set it far in the future for the sake of simplicity.

The first swap takes the `amount1` that we withdrew from the original pool, and passes that amount as the input amount for a single swap that trades a fixed input for the maximum amount of possible output. It calls this function on the pool determined by our previous token pair, but with the next fee tier in our list of three.

```solidity
uint256 amountOut0 =
            swapRouter.exactInputSingle(
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: token1,
                    tokenOut: token0,
                    fee: decoded.poolFee2,
                    recipient: address(this),
                    deadline: block.timestamp + 200,
                    amountIn: decoded.amount1,
                    amountOutMinimum: amount0Min,
                    sqrtPriceLimitX96: 0
                })
            );
```

Populate the second of two swaps, this time with the last fee tier and with the `amount0` that we withdrew from the original pool.

```solidity
uint256 amountOut1 =
            swapRouter.exactInputSingle(
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: token0,
                    tokenOut: token1,
                    fee: decoded.poolFee3,
                    recipient: address(this),
                    deadline: block.timestamp + 200,
                    amountIn: decoded.amount0,
                    amountOutMinimum: amount1Min,
                    sqrtPriceLimitX96: 0
                })
            );
```

## Paying back the pool

To pay the original pool back for the flash transaction, first calculate the balance due to it and approve the router to transfer the tokens in our contract back to the pool.

```solidity
uint256 amount0Owed = LowGasSafeMath.add(decoded.amount0, fee0);
uint256 amount1Owed = LowGasSafeMath.add(decoded.amount1, fee1);

TransferHelper.safeApprove(token0, address(this), amount0Owed);
TransferHelper.safeApprove(token1, address(this), amount1Owed);
```

If there is any balance due to the token, use simple logic to call [pay](../../reference/periphery/base/PeripheryPayments.md#pay). Remember that the callback function is being called by the pool itself, which is why we can call `pay` despite the function being marked `internal`.

```solidity
if (amount0Owed > 0) pay(token0, address(this), msg.sender, amount0Owed);
if (amount1Owed > 0) pay(token1, address(this), msg.sender, amount1Owed);
```

Send the profits to the `payer`: the original `msg.sender` of the `initFlash` function, which executed the flash transaction and in turn triggered the callback.

```solidity
    if (amountOut0 > amount0Owed) {
            uint256 profit0 = LowGasSafeMath.sub(amountOut0, amount0Owed);

            TransferHelper.safeApprove(token0, address(this), profit0);
            pay(token0, address(this), decoded.payer, profit0);
        }

    if (amountOut1 > amount1Owed) {
            uint256 profit1 = LowGasSafeMath.sub(amountOut1, amount1Owed);
            TransferHelper.safeApprove(token0, address(this), profit1);
            pay(token1, address(this), decoded.payer, profit1);
        }
```

## The full function

```solidity
    function uniswapV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external override {
        FlashCallbackData memory decoded = abi.decode(data, (FlashCallbackData));
        CallbackValidation.verifyCallback(factory, decoded.poolKey);

        address token0 = decoded.poolKey.token0;
        address token1 = decoded.poolKey.token1;

        TransferHelper.safeApprove(token0, address(swapRouter), decoded.amount0);
        TransferHelper.safeApprove(token1, address(swapRouter), decoded.amount1);

        // profitable check
        // exactInputSingle will fail if this amount not met
        uint256 amount1Min = LowGasSafeMath.add(decoded.amount1, fee1);
        uint256 amount0Min = LowGasSafeMath.add(decoded.amount0, fee0);

        // call exactInputSingle for swapping token1 for token0 in pool w/fee2
        uint256 amountOut0 =
            swapRouter.exactInputSingle(
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: token1,
                    tokenOut: token0,
                    fee: decoded.poolFee2,
                    recipient: address(this),
                    deadline: block.timestamp + 200,
                    amountIn: decoded.amount1,
                    amountOutMinimum: amount0Min,
                    sqrtPriceLimitX96: 0
                })
            );

        // call exactInputSingle for swapping token0 for token 1 in pool w/fee3
        uint256 amountOut1 =
            swapRouter.exactInputSingle(
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: token0,
                    tokenOut: token1,
                    fee: decoded.poolFee3,
                    recipient: address(this),
                    deadline: block.timestamp + 200,
                    amountIn: decoded.amount0,
                    amountOutMinimum: amount1Min,
                    sqrtPriceLimitX96: 0
                })
            );

        // end up with amountOut0 of token0 from first swap and amountOut1 of token1 from second swap
        uint256 amount0Owed = LowGasSafeMath.add(decoded.amount0, fee0);
        uint256 amount1Owed = LowGasSafeMath.add(decoded.amount1, fee1);

        TransferHelper.safeApprove(token0, address(this), amount0Owed);
        TransferHelper.safeApprove(token1, address(this), amount1Owed);

        if (amount0Owed > 0) pay(token0, address(this), msg.sender, amount0Owed);
        if (amount1Owed > 0) pay(token1, address(this), msg.sender, amount1Owed);

        // if profitable pay profits to payer
        if (amountOut0 > amount0Owed) {
            uint256 profit0 = LowGasSafeMath.sub(amountOut0, amount0Owed);

            TransferHelper.safeApprove(token0, address(this), profit0);
            pay(token0, address(this), decoded.payer, profit0);
        }
        if (amountOut1 > amount1Owed) {
            uint256 profit1 = LowGasSafeMath.sub(amountOut1, amount1Owed);
            TransferHelper.safeApprove(token0, address(this), profit1);
            pay(token1, address(this), decoded.payer, profit1);
        }
    }
```
</file>

<file path="docs/contracts/v3/guides/flash-integrations/Inheritance-constructors.md">
---
id: inheritance-constructors
title: Getting Started
sidebar_position: 1
---

In this guide, we will write a smart contract that calls `flash` on a V3 pool and swaps the full amount withdrawn of `token0` and `token1` in the corresponding pools with the same token pair - but different fee tiers. After the swap, the contract will pay back the first pool and transfer profits to the original calling address.

The ability to make a profit comes from the difference in the price ratio between `token0` and `token1` in the different pools, not necessarily from the different fee tiers. While the fee tiers can affect the overall cost of the trade, the primary factor that allows for profitable swaps is the difference in price ratios.

The contract is designed to withdraw tokens from a V3 pool, swap them in a different V3 pool with the same token pair but different price ratio and fee tier, and then pay back the original pool and transfer any profits to the calling address. By swapping the tokens in a different pool with a different price ratio, the contract is able to take advantage of the price difference and make a profit.

The fees charged by the pools have an impact on the profitability of the trade. Lower fees can make it easier to profit from the trade because the price difference needed to cover the fees and still make a profit is smaller. However, other factors such as the amount of liquidity available in the pools, slippage, gas fees, and market volatility also play a role in determining the profitability of the trade. So while lower fees can make it easier to profit from a trade, it's not the only factor to consider.

This code is intended to be just an example. For this reason, readers should do their own research to avoid losing their funds.

## Flash Transactions Overview

Flash transactions are an approach to transferring tokens on Ethereum that transfer token balances _before_ the necessary conditions are met for those balances to be transferred. In the context of a swap, this would mean the output is sent from the swap before the input is received.

Uniswap V3 introduces a new function, `flash`, within the Pool contract. `Flash` withdraws a specified amount of both `token0` and `token1` to the `recipient` address. The withdrawn amount, plus the swap fees, will be due to the pool at the end of the transaction. `flash` includes a fourth parameter, `data`, which allows the caller to abi.encode any necessary data to be passed through the function and decoded later.

```solidity
    function flash(
        address recipient,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external override lock noDelegateCall {
```

## The Flash Callback

`flash` will withdraw the tokens, but how are they paid back? To understand this, we must look inside the flash function code. midway through the [**flash**](https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/UniswapV3Pool.sol#L791) function, we see this:

```solidity
IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0, fee1, data);
```

This step calls the `FlashCallback` function on `msg.sender` - which passes the fee data needed to calculate the balances due to the pool, as well as any data encoded into the `data` parameter.

In V3 there are three separate callback functions, `uniswapV3SwapCallback`, `uniswapV3MintCallback`, and `uniswapV3FlashCallback`, each available to be overridden with custom logic. To write our arbitrage contract, we'll be calling `flash` and overriding the `uniswapV3FlashCallback` with the steps needed to finish executing our transaction.

## Inheriting The V3 Contracts

Inherit `IUniswapV3FlashCallback` and `PeripheryPayments`, as we will use each in our program. Note these two inherited contracts already extend many other contracts that we will be using, such as [LowGasSafeMath](../../reference/core/libraries/LowGasSafeMath.md) which we [attach](https://docs.soliditylang.org/en/v0.7.6/contracts.html?highlight=using#using-for), to types `uint256` and `int256`.

```solidity
contract PairFlash is IUniswapV3FlashCallback, PeripheryPayments {
    using LowGasSafeMath for uint256;
    using LowGasSafeMath for int256;
```

Declare an immutable public variable `swapRouter` of type `ISwapRouter`:

```solidity
    ISwapRouter public immutable swapRouter;
```

Declare the constructor here, which is executed once when the contract is deployed. Our constructor hardcodes the address of the V3 router, factory, and the address of weth9, the [ERC-20 wrapper](https://weth.io/) for ether.

```solidity
    constructor(
        ISwapRouter _swapRouter,
        address _factory,
        address _WETH9
    ) PeripheryImmutableState(_factory, _WETH9) {
        swapRouter = _swapRouter;
    }
```

The full import section and contract declaration:

```solidity
pragma solidity =0.7.6;
pragma abicoder v2;

import '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3FlashCallback.sol';
import '@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol';

import '@uniswap/v3-periphery/contracts/base/PeripheryPayments.sol';
import '@uniswap/v3-periphery/contracts/base/PeripheryImmutableState.sol';
import '@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol';
import '@uniswap/v3-periphery/contracts/libraries/CallbackValidation.sol';
import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';



contract PairFlash is IUniswapV3FlashCallback, PeripheryPayments {
    using LowGasSafeMath for uint256;
    using LowGasSafeMath for int256;

    ISwapRouter public immutable swapRouter;

    constructor(
        ISwapRouter _swapRouter,
        address _factory,
        address _WETH9
    ) PeripheryImmutableState(_factory, _WETH9) {
        swapRouter = _swapRouter;
    }
}
```
</file>

<file path="docs/contracts/v3/guides/governance/_category_.json">
{
  "label": "Governance Proposals",
  "position": 6
}
</file>

<file path="docs/contracts/v3/guides/governance/license-modifications.md">
---
id: license-modifications
title: License Modifications
---

## Licensing

Please note that Uniswap V3 is under [BUSL license](https://github.com/Uniswap/v3-core#licensing) until the Change Date, currently 2023-04-01. Exceptions to the license may be specified by Uniswap Governance via Additional Use Grants, which can, for example, allow V3 to be deployed on new chains. Please follow the [Uniswap Governance process](https://gov.uniswap.org/t/community-governance-process/7732) to request a DAO vote for exceptions to the license, or to move up the Change Date.

License changes must be enacted via the [ENS domain](https://ens.domains/) uniswap.eth, which is controlled by Uniswap Governance. This means (among other things) that Governance has the power to associate arbitrary text with any subdomain of the form X.uniswap.eth. Modifications of the Change Date should be specified at v3-core-license-date.uniswap.eth, and Additional Use Grants should be specified at v3-core-license-grants.uniswap.eth. The process for associating text with a subdomain is detailed below:

<details>
<summary> ENS Subdomain Details & Process </summary>

If the subdomain does not already exist which can be checked [here](https://app.ens.domains/name/uniswap.eth/subdomains), the [`setSubnodeRecord`](https://docs.ens.domains/contract-api-reference/ens#set-subdomain-record) function of the ENS registry should be called with the following arguments:

- `node`: `namehash('uniswap.eth')` (`0xa2a03459171c76bff45817330c10ef9f8af07011a33005b73b50189bbc7e7132`)
- `label`: `keccak256('v3-core-license-date')` (`0xee55740591b0fd5d7a28a6edc49567f6ff3febbe942ec0e2fa49ee536595085b`) or `keccak256('v3-core-license-grants')` (`0x15ff9b5bd7642701a10e5ea8fb29c957ffda4854cd028e9f6218506e6b509af2`)
- `owner`: [`0x1a9C8182C09F50C8318d769245beA52c32BE35BC`](https://etherscan.io/address/0x1a9c8182c09f50c8318d769245bea52c32be35bc), the Uniswap Governance Timelock
- `resolver`: [`0x4976fb03c32e5b8cfe2b6ccb31c09ba78ebaba41`](https://etherscan.io/address/0x4976fb03c32e5b8cfe2b6ccb31c09ba78ebaba41), the public ENS resolver.
- `ttl`: `0`

2. Then, the [`setText`](https://docs.ens.domains/contract-api-reference/publicresolver#set-text-data) function of the public resolver should be called with the following arguments:

- `node`: `namehash('v3-core-license-date.uniswap.eth')` (`0x0505ec7822d61b4cfb294f137d1a7f0ceedf162f555a4bf2f4be58a07cf266c5`) or `namehash('v3-core-license-grants.uniswap.eth')` (`0xa35d592ec6e5289a387cba1d5f82be794f495bd5a361a1fb314687c6aefea1f4`)
- `key`: A suitable label, such as `notice`.
- `value`: The text of the change. Note that text may already be associated with the subdomain in question. If it does, it can be reviewed at the following URLs for either [v3-core-license-date](https://app.ens.domains/name/v3-core-license-date.uniswap.eth/details) or [v3-core-license-grants](https://app.ens.domains/name/v3-core-license-grants.uniswap.eth/details), and appended to as desired.

Note: [`setContentHash`](https://docs.ens.domains/contract-api-reference/publicresolver#set-content-hash) may also be used to associate text with a subdomain, but `setText` is presented above for simplicity.

These contract function calls should then be encoded into a governance proposal, and approved by Uniswap Governance.

</details>

## Proposals

Proposals are submitted via `GovernorBravoDelegator` @ `0x408ED6354d4973f66138C91495F2f2FCbd8724C3`, a proxy contract currently pointing to the implementation at `0x53a328F4086d7C0F1Fa19e594c9b842125263026`. NPM packages for consuming the governance contract ABIs, and details on previous versions, are available [here](../../../../concepts/governance/overview)

<details>
    <summary> Governor Bravo #propose Parameters </summary>

```solidity
/**
    * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold
    * @param targets Target addresses for proposal calls
    * @param values Eth values for proposal calls
    * @param signatures Function signatures for proposal calls
    * @param calldatas Calldatas for proposal calls
    * @param description String description of the proposal
    * @return Proposal id of new proposal
    */
function propose(
    address[] memory targets,
    uint[] memory values,
    string[] memory signatures,
    bytes[] memory calldatas,
    string memory description
) public returns (uint)

```

</details>

## Populating Proposal Calldata

Below is an example of using a scripting environment to generate a proposal. This is for educational purposes only - that example assumes access to a private key with a sufficient amount of delegated UNI to submit a proposal, which is an insecure practice. There are several ways to generate a proposal transaction and submit it to Ethereum; this example should only be used for reference and not in production.

<details>
<summary> Populating `Propose` Calldata </summary>

```typescript
import { Contract, ethers } from 'ethers'
import { namehash } from '@ethersproject/hash'
import { keccak256 } from '@ethersproject/keccak256'
import { Interface } from '@ethersproject/abi'
// note: contract ABIs should be imported via etherscan
import { GOVERNOR_BRAVO_ABI, ENS_REGISTRY_ABI, ENS_PUBLIC_RESOLVER_ABI } from './utils'

const GOVERNOR_BRAVO_ADDRESS: string = '0x408ED6354d4973f66138C91495F2f2FCbd8724C3'
const ENS_REGISTRY_ADDRESS: string = '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'
const PUBLIC_ENS_RESOLVER_ADDRESS: string = '0x4976fb03c32e5b8cfe2b6ccb31c09ba78ebaba41'
const UNISWAP_GOVERNANCE_TIMELOCK_ADDRESS: string = '0x1a9C8182C09F50C8318d769245beA52c32BE35BC'

const provider = new ethers.providers.JsonRpcProvider('YOUR_RPC_URL_HERE')
const signer = provider.getSigner('YOUR_SIGNER_ADDRESS_HERE')

// note: setting the subnode record should only take place if the subdomain does not already exist
const ensRegistryInterface = new Interface(ENS_REGISTRY_ABI)
const setSubnodeRecordCalldata = ensRegistryInterface.encodeFunctionData('setSubnodeRecord', [
  // node: The parent node
  namehash('uniswap.eth'),
  // label: The hash of the label specifying the subnode
  keccak256('v3-core-license-grants'),
  // owner: The address of the new owner
  UNISWAP_GOVERNANCE_TIMELOCK_ADDRESS,
  // resolver: The address of the resolver
  PUBLIC_ENS_RESOLVER_ADDRESS,
  // ttl: The TTL, i.e., time to live, in seconds
  0,
])

const ensPublicResolverInterface = new Interface(ENS_PUBLIC_RESOLVER_ABI)
const setTextCalldata = ensPublicResolverInterface.encodeFunctionData('setText', [
  // node: The node to update
  namehash('v3-core-license-grants.uniswap.eth'),
  // key: The key to set
  '[your-projects-additional-use-grant-title]',
  // value: The text data value to set
  '[your-additional-use-grant-description]',
])

// Create a new local instance of the governorBravo contract
// Note that in production the abi should be gathered via etherscan
const governorBravo = new Contract(GOVERNOR_BRAVO_ADDRESS, GOVERNOR_BRAVO_ABI, provider)

// the ordered list of target addresses for calls to be made
const targets = [ENS_REGISTRY_ADDRESS, PUBLIC_ENS_RESOLVER_ADDRESS]

// The ordered list of values to be passed to the calls to be made. i.e., the amount of
// ETH values to be transferred within the transaction. as this example does not include
// the transferring of any ETH, this list is empty.
const values = [0, 0]

// The ordered list of function signatures to be called. The signatures arguments
// are optional, if not provided, the function signature will be inferred from the calldata
const signatures = ['', '']

// The ordered list of calldata to be passed to each call in the proposal. The calldata
// in this example takes the place of the function signature arguments.
const calldatas = [setSubnodeRecordCalldata, setTextCalldata]

// the description of the proposal.
const description = '# TITLE ## SECTION_EXPLANATION'

async function main() {
  try {
    const txResponse: ethers.providers.TransactionResponse = await governorBravo
      .connect(signer)
      .propose(targets, values, signatures, calldatas, description)
    console.log(`Proposal transaction sent: ${txResponse.hash}`)
    await txResponse.wait(1)
    console.log(
      `Proposal has been mined at blocknumber: ${txResponse.blockNumber}, transaction hash: ${txResponse.hash}`
    )
  } catch (error) {
    console.error(error)
  }
}

main().then(() => console.log('done'))
```

</details>

## Helpful Links

- [Governor Bravo Proxy](https://etherscan.io/address/0x408ED6354d4973f66138C91495F2f2FCbd8724C3#readProxyContract)
- [Governor Bravo Delegate](https://etherscan.io/address/0x53a328f4086d7c0f1fa19e594c9b842125263026#code)
- [ENS Subnode Record Update Details](https://github.com/Uniswap/deploy-v3#licensing)
</file>

<file path="docs/contracts/v3/guides/liquidity-mining/_category_.json">
{
  "label": "Liquidity Mining",
  "position": 3,
  "collapsed": true
}
</file>

<file path="docs/contracts/v3/guides/liquidity-mining/overview.md">
---
id: overview
title: Overview
sidebar_position: 1
---

## Introduction

As a DeFi project, token creator, or other interested party, you may want to _incentivize in-range liquidity provision_ on a Uniswap V3 pool. This guide describes one particular incentivization scheme at a high level, as implemented in [uniswap-v3-staker](https://github.com/Uniswap/uniswap-v3-staker).

## The Setting

Let's start by defining some terms. We refer to programs which incentivize liquidity as `Incentive`s; they're characterized by the following parameters:

- `rewardToken`: Perhaps the most important parameter, would-be incentivizers must pick the ERC20 token which they would like to distribute as a reward for providing liquidity.
- `pool`: The address of the Uniswap V3 pool in which liquidity must be provided.
- `startTime`: The UNIX timestamp at which rewards start to be distributed.
- `endTime`: The UNIX timestamp at which rewards start to decay.
- `refundee`: The address which has the right to reclaim any leftover rewards after the `Incentive` has concluded.

Finally, every `Incentive` has an associated `reward`, the total amount of `rewardToken`s that are allocated to be distributed over the lifecycle of the program.

## Reward Math

Now that we have an idea of what an `Incentive` looks like, let's explore how rewards are actually allocated to participants. The next section will touch on the participation mechanics, so for now let's abstract this away and just focus on the high-level design.

Recall that `Incentive` creators pick a `reward` amount and a program duration. This directly corresponds to picking _an amount of `rewardToken`s to distribute per second_; let's call this the reward rate. So, for every second between `startTime` and `endTime`, a constant amount of tokens are distributed proportionally _among all in-range liquidity at that second_. Crucially, this counts _all_ liquidity, not just liquidity that opts in to participating in the program. So, incentive creators should pick a reward rate that they deem worthwhile to distribute across (potentially) all in-range LPs for the duration of the program.

## Staking

So, how do users participate in these programs? Note that this section requires a basic understanding of [how Uniswap V3 position NFTs work](../../reference/periphery/NonfungiblePositionManager)

The first action a user must take in order to begin participating in an `Incentive` is to _deposit_ their position NFT into the [canonical staking contract address](https://github.com/Uniswap/uniswap-v3-staker#deployments), effectively temporarily giving custody over their NFT to this contract. This is necessary because, as we'll see later on, the staking contract needs to be able to guarantee that liquidity cannot be removed from NFTs participating in the program.

Once deposited, a user may then _stake_ their NFT into any number of active `Incentive`s for the Uniswap V3 pool their NFT is tied to (note that this can happen atomically with an initial _deposit_). Staked NFTs then immediately start to earn rewards, according to the algorithm outlined above. Users may periodically claim accrued `rewardToken`s while the program is ongoing, or wait to claim until the program has concluded to minimize overhead.

## Program Conclusion

There are two conditions that must be met for a program to be considered concluded:

1. `block.timestamp >= endTime`: In other words, the program's duration must have expired. However, this doesn't mark the official end of the program, as some users may still be participating right up until this `endTime` boundary and beyond, to maximize their rewards. This leads directly to the second condition.
2. All NFTs must be unstaked: A program can conclude only when every NFT which participated in it is unstaked. To ensure this is always possible, after the `endTime` of a program _anyone_ may unstake _any_ NFT (though of course they may not claim outstanding `rewardToken`s due to the NFT owner). This ensures that even if all users do not unstake themselves, someone can unstake them manually so that the program can end.

It's important that most or all programs fully conclude, primarily so that the `refundee` can reclaim any unallocated rewards. What are the conditions under which unallocated rewards will remain? Well, recall that the reward rate is the same across _all_ in-range liquidity. However, only program participants may actually claim accrued tokens, so it's likely that all programs will end up with a balance of `rewardToken`s that cannot be claimed. So, `refundee`s will typically be incentivized to bring programs to an official conclusion. This slightly cumbersome design is a consequence of the difficulty of consistently allocating rewards proportional to Uniswap V3 liquidity.

A final note: stakers who remain in the program after `endTime` may actually see their rewards marginally augmented or (more likely) gradually diluted. The magnitude of these changes depend on stakers' share of the total active liquidity, the time spend staked after `endTime`, and the sequence of unstaking. In the worst case, rewards decay proportionally to the duration. For example, at 2x the duration, ½ of rewards could remain, at 3x, ⅓ could remain, etc. While somewhat complex, this behavior can largely be ignored from a game-theoretic standpoint. Stakers should simply attempt to unstake and claim rewards as soon as possible after `endTime`, an outcome that is likely in any case, as `refundee`s will be eager to reclaim leftover rewards, and mass unstake stragglers.
</file>

<file path="docs/contracts/v3/guides/providing-liquidity/_category_.json">
{
  "label": "Providing Liquidity",
  "position": 2
}
</file>

<file path="docs/contracts/v3/guides/providing-liquidity/collect-fees.md">
---
id: collect-fees
title: Collecting Fees
sidebar_position: 3
---

- Make sure to go through the [first guide](./setting-up-your-contract.md) before continuing to this section.

- For each of these liquidity interaction examples, our contract must be in possession of the liquidity position NFT. Therefore, in any example where the NFT deposit is not coded into a function, the contract is assumed to already be in possession of it.

To collect the fees of an owner position, transfer the NFT from the calling address, assign the relevant variables from the NFT to local variables within our function, and pass those variables to the`nonfungiblePositionManager` to call `collect`.

This function collects all fees, sending them to the original owner of the NFT, while maintaining custody of the position NFT.

```solidity
    /// @notice Collects the fees associated with provided liquidity
    /// @dev The contract must hold the erc721 token before it can collect fees
    /// @param tokenId The id of the erc721 token
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collectAllFees(uint256 tokenId) external returns (uint256 amount0, uint256 amount1) {
        // Caller must own the ERC721 position
        // Call to safeTransfer will trigger `onERC721Received` which must return the selector else transfer will fail
        nonfungiblePositionManager.safeTransferFrom(msg.sender, address(this), tokenId);

        // set amount0Max and amount1Max to uint256.max to collect all fees
        // alternatively can set recipient to msg.sender and avoid another transaction in `sendToOwner`
        INonfungiblePositionManager.CollectParams memory params =
            INonfungiblePositionManager.CollectParams({
                tokenId: tokenId,
                recipient: address(this),
                amount0Max: type(uint128).max,
                amount1Max: type(uint128).max
            });

        (amount0, amount1) = nonfungiblePositionManager.collect(params);

        // send collected feed back to owner
        _sendToOwner(tokenId, amount0, amount1);
    }
```

## Sending Fees To The Calling Address

This internal helper function sends any tokens, in the form of fees or position tokens, to the owner of an NFT.

In `_sendToOwner`, we pass the amount of fees due, previously populated in the last function, as arguments to `safeTransfer`, which transfers the fees to `owner`.

```solidity
    /// @notice Transfers funds to owner of NFT
    /// @param tokenId The id of the erc721
    /// @param amount0 The amount of token0
    /// @param amount1 The amount of token1
    function _sendToOwner(
        uint256 tokenId,
        uint256 amount0,
        uint256 amount1
    ) internal {
        // get owner of contract
        address owner = deposits[tokenId].owner;

        address token0 = deposits[tokenId].token0;
        address token1 = deposits[tokenId].token1;
        // send collected fees to owner
        TransferHelper.safeTransfer(token0, owner, amount0);
        TransferHelper.safeTransfer(token1, owner, amount1);
    }
```
</file>

<file path="docs/contracts/v3/guides/providing-liquidity/decrease-liquidity.md">
---
id: decrease-liquidity
title: Decrease Liquidity
sidebar_position: 4
---

Make sure to go through the [Setting Up Your Contract](./setting-up-your-contract.md) before continuing to this section

Here we decrease the liquidity of our position without withdrawing all of it.

- This example assumes the contract already has possession of the position NFT, and requires the calling address to be the same address that deposited the position NFT to our contract.

- In production, `amount0Min` and `amount1Min` should be adjusted to create slippage protections.

## Decrease Liquidity

```solidity
    /// @notice A function that decreases the current liquidity by half. An example to show how to call the `decreaseLiquidity` function defined in periphery.
    /// @param tokenId The id of the erc721 token
    /// @return amount0 The amount received back in token0
    /// @return amount1 The amount returned back in token1
    function decreaseLiquidityInHalf(uint256 tokenId) external returns (uint256 amount0, uint256 amount1) {
        // caller must be the owner of the NFT
        require(msg.sender == deposits[tokenId].owner, 'Not the owner');
        // get liquidity data for tokenId
        uint128 liquidity = deposits[tokenId].liquidity;
        uint128 halfLiquidity = liquidity / 2;

        // amount0Min and amount1Min are price slippage checks
        // if the amount received after burning is not greater than these minimums, transaction will fail
        INonfungiblePositionManager.DecreaseLiquidityParams memory params =
            INonfungiblePositionManager.DecreaseLiquidityParams({
                tokenId: tokenId,
                liquidity: halfLiquidity,
                amount0Min: 0,
                amount1Min: 0,
                deadline: block.timestamp
            });

        nonfungiblePositionManager.decreaseLiquidity(params);

        (amount0, amount1) = nonfungiblePositionManager.collect(
            INonfungiblePositionManager.CollectParams({
                tokenId: tokenId,
                recipient: address(this),
                amount0Max: type(uint128).max,
                amount1Max: type(uint128).max
            })
        );

        //send liquidity back to owner
        _sendToOwner(tokenId, amount0, amount1);
    }
```

## Sending Fees To The Calling Address

This internal helper function sends any tokens, in the form of fees or position tokens, to the owner of an NFT.

In `_sendToOwner`, we pass the amount of fees due, previously populated in the last function, as arguments to `safeTransfer`, which transfers the fees to `owner`.

```solidity
    /// @notice Transfers funds to owner of NFT
    /// @param tokenId The id of the erc721
    /// @param amount0 The amount of token0
    /// @param amount1 The amount of token1
    function _sendToOwner(
        uint256 tokenId,
        uint256 amount0,
        uint256 amount1
    ) internal {
        // get owner of contract
        address owner = deposits[tokenId].owner;

        address token0 = deposits[tokenId].token0;
        address token1 = deposits[tokenId].token1;
        // send collected fees to owner
        TransferHelper.safeTransfer(token0, owner, amount0);
        TransferHelper.safeTransfer(token1, owner, amount1);
    }
```
</file>

<file path="docs/contracts/v3/guides/providing-liquidity/increase-liquidity.md">
---
id: increase-liquidity
title: Increase Liquidity
sidebar_position: 5
---

## Increase Liquidity Within The Current Range

Make sure to go through the [first guide](./setting-up-your-contract.md) before continuing to this section

- This example assumes the contract already has custody of the NFT.

- We cannot change the boundaries of a given liquidity position using the Uniswap v3 protocol; `increaseLiquidity` can only increase the liquidity of a position.
- In production, `amount0Min` and `amount1Min` should be adjusted to create slippage protections.

```solidity
    /// @notice Increases liquidity in the current range
    /// @dev Pool must be initialized already to add liquidity
    /// @param tokenId The id of the erc721 token
    /// @param amount0 The amount to add of token0
    /// @param amount1 The amount to add of token1
    function increaseLiquidityCurrentRange(
        uint256 tokenId,
        uint256 amountAdd0,
        uint256 amountAdd1
    )
        external
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        )
    {
        INonfungiblePositionManager.IncreaseLiquidityParams memory params =
            INonfungiblePositionManager.IncreaseLiquidityParams({
                tokenId: tokenId,
                amount0Desired: amountAdd0,
                amount1Desired: amountAdd1,
                amount0Min: 0,
                amount1Min: 0,
                deadline: block.timestamp
            });

        (liquidity, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(params);
    }
```
</file>

<file path="docs/contracts/v3/guides/providing-liquidity/mint-a-new-position.md">
---
id: mint-a-position
title: Mint a New Position
sidebar_position: 2
---

## Input Parameters

To mint a new position, we use the `nonFungiblePositionManager` and call `mint`.

For the sake of this example, we're hard coding the token amounts to be minted. In production, this would be a user-configurable function argument.

```solidity
    /// @notice Calls the mint function defined in periphery, mints the same amount of each token. For this example we are providing 1000 DAI and 1000 USDC in liquidity
    /// @return tokenId The id of the newly minted ERC721
    /// @return liquidity The amount of liquidity for the position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mintNewPosition()
        external
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        )
    {
        // For this example, we will provide equal amounts of liquidity in both assets.
        // Providing liquidity in both assets means liquidity will be earning fees and is considered in-range.
        uint256 amount0ToMint = 1000;
        uint256 amount1ToMint = 1000;
```

## Calling Mint

Here we approve the `nonfungiblePositionManager` to use the contracts' tokens, then populate the `MintParams` struct and assign it to a local variable `params` that will be passed to the `nonfungiblePositionManager` when we call `mint`.

- By using `TickMath.MIN_TICK` and `TickMath.MAX_TICK`, we are providing liquidity across the whole range of the pool. These will give a min tick of `-887272` and a max tick of `887272`. This works as is with the 0.01% pool, However other pools will need to use the correct tick spacing for the pool you are working with. Tick spacing for the pools are `0.01% == 1 tick spacing, 0.3% == 60 tick spacing, 0.05 == 10 tick spacing, 1% == 200 tick spacing`. So when setting up a pool with a different tick spacing, you will need to use a tick that is evenly divisible by the spacing. You can get the tick spacing by casting the contract of the pool address, and calling `tickSpacing()`. In production you may want to specify a more concentrated position, where you would take x of these tick spaces around the current active tick range.

```solidity
    tickLower: (TickMath.MIN_TICK / tickSpacing) * tickSpacing,
    tickUpper: (TickMath.MAX_TICK / tickSpacing) * tickSpacing,
```

- We set `amount0Min` and `amount1Min` to zero for the example - but this would be a vulnerability in production. A function calling `mint` with no slippage protection would be vulnerable to a frontrunning attack designed to execute the `mint` call at an inaccurate price.
- For a more secure practice the developer would need to implement a slippage estimation process.

- Note that this function will not initialize a pool where one does not yet exist.

```solidity
        // Approve the position manager
        TransferHelper.safeApprove(DAI, address(nonfungiblePositionManager), amount0ToMint);
        TransferHelper.safeApprove(USDC, address(nonfungiblePositionManager), amount1ToMint);

        INonfungiblePositionManager.MintParams memory params =
            INonfungiblePositionManager.MintParams({
                token0: DAI,
                token1: USDC,
                fee: poolFee,
                tickLower: TickMath.MIN_TICK,
                tickUpper: TickMath.MAX_TICK,
                amount0Desired: amount0ToMint,
                amount1Desired: amount1ToMint,
                amount0Min: 0,
                amount1Min: 0,
                recipient: address(this),
                deadline: block.timestamp
            });

        // Note that the pool defined by DAI/USDC and fee tier 0.3% must already be created and initialized in order to mint
        (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager.mint(params);

```

## Updating The Deposit Mapping And Refunding The Calling Address

Now we can call the internal function we previously wrote in [Setting Up Your Contract](./setting-up-your-contract.md). After that, we can take any liquidity leftover from minting and refund it to `msg.sender`.

```solidity
        // Create a deposit
        _createDeposit(msg.sender, tokenId);

        // Remove allowance and refund in both assets.
        if (amount0 < amount0ToMint) {
            TransferHelper.safeApprove(DAI, address(nonfungiblePositionManager), 0);
            uint256 refund0 = amount0ToMint - amount0;
            TransferHelper.safeTransfer(DAI, msg.sender, refund0);
        }

        if (amount1 < amount1ToMint) {
            TransferHelper.safeApprove(USDC, address(nonfungiblePositionManager), 0);
            uint256 refund1 = amount1ToMint - amount1;
            TransferHelper.safeTransfer(USDC, msg.sender, refund1);
        }
    }
```

## The Full Example

```solidity
    /// @notice Calls the mint function defined in periphery, mints the same amount of each token. For this example we are providing 1000 DAI and 1000 USDC in liquidity
    /// @return tokenId The id of the newly minted ERC721
    /// @return liquidity The amount of liquidity for the position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mintNewPosition()
        external
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        )
    {
        // For this example, we will provide equal amounts of liquidity in both assets.
        // Providing liquidity in both assets means liquidity will be earning fees and is considered in-range.
        uint256 amount0ToMint = 1000;
        uint256 amount1ToMint = 1000;

        // Approve the position manager
        TransferHelper.safeApprove(DAI, address(nonfungiblePositionManager), amount0ToMint);
        TransferHelper.safeApprove(USDC, address(nonfungiblePositionManager), amount1ToMint);

        INonfungiblePositionManager.MintParams memory params =
            INonfungiblePositionManager.MintParams({
                token0: DAI,
                token1: USDC,
                fee: poolFee,
                tickLower: TickMath.MIN_TICK,
                tickUpper: TickMath.MAX_TICK,
                amount0Desired: amount0ToMint,
                amount1Desired: amount1ToMint,
                amount0Min: 0,
                amount1Min: 0,
                recipient: address(this),
                deadline: block.timestamp
            });

        // Note that the pool defined by DAI/USDC and fee tier 0.3% must already be created and initialized in order to mint
        (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager.mint(params);

        // Create a deposit
        _createDeposit(msg.sender, tokenId);

        // Remove allowance and refund in both assets.
        if (amount0 < amount0ToMint) {
            TransferHelper.safeApprove(DAI, address(nonfungiblePositionManager), 0);
            uint256 refund0 = amount0ToMint - amount0;
            TransferHelper.safeTransfer(DAI, msg.sender, refund0);
        }

        if (amount1 < amount1ToMint) {
            TransferHelper.safeApprove(USDC, address(nonfungiblePositionManager), 0);
            uint256 refund1 = amount1ToMint - amount1;
            TransferHelper.safeTransfer(USDC, msg.sender, refund1);
        }
    }
```
</file>

<file path="docs/contracts/v3/guides/providing-liquidity/setting-up-your-contract.md">
---
id: setting-up
title: Set Up Your Contract
sidebar_position: 1
---

## Setting up the Contract

This guide is an example of a custodial contract Uniswap V3 positions, which allows interaction with the Uniswap V3 Periphery by minting a position, adding liquidity to a position, decreasing liquidity, and collecting fees.

First, declare the solidity version used to compile the contract and `abicoder v2` to allow arbitrary nested arrays and structs to be encoded and decoded in calldata, a feature we use when transacting with a pool.

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;
```

Import the contracts needed from the npm package installation.

```solidity
import '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';
import '@uniswap/v3-core/contracts/libraries/TickMath.sol';
import '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';
import '@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol';
import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';
import '@uniswap/v3-periphery/contracts/base/LiquidityManagement.sol';
```

Create a contract called `LiquidityExamples` and inherit both `IERC721Receiver` and `LiquidityManagement`.

We've chosen to hardcode the token contract addresses and pool fee tiers for our example. In production, you would likely use an input parameter for this, allowing you to change the pools and tokens you are interacting with on a per transaction basis.

```solidity
contract LiquidityExamples is IERC721Receiver {

    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    uint24 public constant poolFee = 3000;
```

Declare an immutable public variable `nonfungiblePositionManager` of type `INonfungiblePositionManager`.

```solidity
    INonfungiblePositionManager public immutable nonfungiblePositionManager;
```

## Allowing ERC721 Interactions

Every [NFT](https://ethereum.org/en/nft/) is identified by a unique uint256 ID inside the ERC-721 smart contract, declared as the `tokenId`

To allow deposits of ERC721 expressions of liquidity, create a struct called `Deposit`, a mapping of `uint256` to the `Deposit` struct, then declare that mapping as a public variable `deposits`.

```solidity
    struct Deposit {
        address owner;
        uint128 liquidity;
        address token0;
        address token1;
    }

    mapping(uint256 => Deposit) public deposits;
```

## The Constructor

Declare the constructor here, which is executed once when the contract is deployed. Our constructor hard codes the address of the nonfungible position manager interface, V3 router, and the periphery immutable state constructor, which requires the factory and the address of weth9 (the [ERC-20 wrapper](https://weth.io/) for ether).

```solidity
    constructor(
        INonfungiblePositionManager _nonfungiblePositionManager,
        address _factory,
        address _WETH9
    ) PeripheryImmutableState(_factory, _WETH9) {
        nonfungiblePositionManager = _nonfungiblePositionManager;
    }
```

## Allowing custody of ERC721 tokens

To allow the contract to custody ERC721 tokens, implement the `onERC721Received` function within the inherited `IERC721Receiver.sol` [contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/IERC721Receiver.sol).

The `from` identifier may be omitted because it is not used.

```solidity
    function onERC721Received(
        address operator,
        address,
        uint256 tokenId,
        bytes calldata
    ) external override returns (bytes4) {
        // get position information
        _createDeposit(operator, tokenId);
        return this.onERC721Received.selector;
    }
```

## Creating a Deposit

To add a `Deposit` instance to the `deposits` mapping, create an internal function called `_createDeposit` that destructures the `positions` struct returned by `positions` in `nonfungiblePositionManager.sol`. Pass the relevant variables `token0` `token1` and `liquidity` to the `deposits` mapping.

```solidity
    function _createDeposit(address owner, uint256 tokenId) internal {
        (, , address token0, address token1, , , , uint128 liquidity, , , , ) =
            nonfungiblePositionManager.positions(tokenId);

        // set the owner and data for position
        // operator is msg.sender
        deposits[tokenId] = Deposit({owner: owner, liquidity: liquidity, token0: token0, token1: token1});
    }

```

## The Full Contract Setup

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;

import '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';
import '@uniswap/v3-core/contracts/libraries/TickMath.sol';
import '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';
import '../libraries/TransferHelper.sol';
import '../interfaces/INonfungiblePositionManager.sol';
import '../base/LiquidityManagement.sol';

contract LiquidityExamples is IERC721Receiver {
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    uint24 public constant poolFee = 3000;

    INonfungiblePositionManager public immutable nonfungiblePositionManager;

    /// @notice Represents the deposit of an NFT
    struct Deposit {
        address owner;
        uint128 liquidity;
        address token0;
        address token1;
    }

    /// @dev deposits[tokenId] => Deposit
    mapping(uint256 => Deposit) public deposits;

    constructor(
        INonfungiblePositionManager _nonfungiblePositionManager
    ) {
        nonfungiblePositionManager = _nonfungiblePositionManager;
    }

    // Implementing `onERC721Received` so this contract can receive custody of erc721 tokens
    function onERC721Received(
        address operator,
        address,
        uint256 tokenId,
        bytes calldata
    ) external override returns (bytes4) {
        // get position information

        _createDeposit(operator, tokenId);

        return this.onERC721Received.selector;
    }

    function _createDeposit(address owner, uint256 tokenId) internal {
        (, , address token0, address token1, , , , uint128 liquidity, , , , ) =
            nonfungiblePositionManager.positions(tokenId);

        // set the owner and data for position
        // operator is msg.sender
        deposits[tokenId] = Deposit({owner: owner, liquidity: liquidity, token0: token0, token1: token1});
    }
}
```
</file>

<file path="docs/contracts/v3/guides/providing-liquidity/the-full-contract.md">
---
id: the-full-contract
title: The Full Contract
sidebar_position: 6
---

Below we have the complete functioning code example: a contract that can custody Uniswap V3 position NFT's and manipulate the positions and liquidity therein by collecting fees, increasing or decreasing liquidity, and minting new positions. View on github [here](https://github.com/Uniswap/uniswap-docs/blob/main/examples/smart-contracts/LiquidityExamples.sol).

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;

import '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';
import '@uniswap/v3-core/contracts/libraries/TickMath.sol';
import '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';
import '../libraries/TransferHelper.sol';
import '../interfaces/INonfungiblePositionManager.sol';
import '../base/LiquidityManagement.sol';

contract LiquidityExamples is IERC721Receiver {
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    uint24 public constant poolFee = 3000;

    INonfungiblePositionManager public immutable nonfungiblePositionManager;

    /// @notice Represents the deposit of an NFT
    struct Deposit {
        address owner;
        uint128 liquidity;
        address token0;
        address token1;
    }

    /// @dev deposits[tokenId] => Deposit
    mapping(uint256 => Deposit) public deposits;

    constructor(
        INonfungiblePositionManager _nonfungiblePositionManager
    ) {
        nonfungiblePositionManager = _nonfungiblePositionManager;
    }

    // Implementing `onERC721Received` so this contract can receive custody of erc721 tokens
    function onERC721Received(
        address operator,
        address,
        uint256 tokenId,
        bytes calldata
    ) external override returns (bytes4) {
        // get position information

        _createDeposit(operator, tokenId);

        return this.onERC721Received.selector;
    }

    function _createDeposit(address owner, uint256 tokenId) internal {
        (, , address token0, address token1, , , , uint128 liquidity, , , , ) =
            nonfungiblePositionManager.positions(tokenId);

        // set the owner and data for position
        // operator is msg.sender
        deposits[tokenId] = Deposit({owner: owner, liquidity: liquidity, token0: token0, token1: token1});
    }

    /// @notice Calls the mint function defined in periphery, mints the same amount of each token.
    /// For this example we are providing 1000 DAI and 1000 USDC in liquidity
    /// @return tokenId The id of the newly minted ERC721
    /// @return liquidity The amount of liquidity for the position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mintNewPosition()
        external
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        )
    {
        // For this example, we will provide equal amounts of liquidity in both assets.
        // Providing liquidity in both assets means liquidity will be earning fees and is considered in-range.
        uint256 amount0ToMint = 1000;
        uint256 amount1ToMint = 1000;

        // transfer tokens to contract
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amount0ToMint);
        TransferHelper.safeTransferFrom(USDC, msg.sender, address(this), amount1ToMint);

        // Approve the position manager
        TransferHelper.safeApprove(DAI, address(nonfungiblePositionManager), amount0ToMint);
        TransferHelper.safeApprove(USDC, address(nonfungiblePositionManager), amount1ToMint);

        INonfungiblePositionManager.MintParams memory params =
            INonfungiblePositionManager.MintParams({
                token0: DAI,
                token1: USDC,
                fee: poolFee,
                tickLower: TickMath.MIN_TICK,
                tickUpper: TickMath.MAX_TICK,
                amount0Desired: amount0ToMint,
                amount1Desired: amount1ToMint,
                amount0Min: 0,
                amount1Min: 0,
                recipient: address(this),
                deadline: block.timestamp
            });

        // Note that the pool defined by DAI/USDC and fee tier 0.3% must already be created and initialized in order to mint
        (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager.mint(params);

        // Create a deposit
        _createDeposit(msg.sender, tokenId);

        // Remove allowance and refund in both assets.
        if (amount0 < amount0ToMint) {
            TransferHelper.safeApprove(DAI, address(nonfungiblePositionManager), 0);
            uint256 refund0 = amount0ToMint - amount0;
            TransferHelper.safeTransfer(DAI, msg.sender, refund0);
        }

        if (amount1 < amount1ToMint) {
            TransferHelper.safeApprove(USDC, address(nonfungiblePositionManager), 0);
            uint256 refund1 = amount1ToMint - amount1;
            TransferHelper.safeTransfer(USDC, msg.sender, refund1);
        }
    }

    /// @notice Collects the fees associated with provided liquidity
    /// @dev The contract must hold the erc721 token before it can collect fees
    /// @param tokenId The id of the erc721 token
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collectAllFees(uint256 tokenId) external returns (uint256 amount0, uint256 amount1) {
        // Caller must own the ERC721 position, meaning it must be a deposit

        // set amount0Max and amount1Max to uint256.max to collect all fees
        // alternatively can set recipient to msg.sender and avoid another transaction in `sendToOwner`
        INonfungiblePositionManager.CollectParams memory params =
            INonfungiblePositionManager.CollectParams({
                tokenId: tokenId,
                recipient: address(this),
                amount0Max: type(uint128).max,
                amount1Max: type(uint128).max
            });

        (amount0, amount1) = nonfungiblePositionManager.collect(params);

        // send collected feed back to owner
        _sendToOwner(tokenId, amount0, amount1);
    }

    /// @notice A function that decreases the current liquidity by half. An example to show how to call the `decreaseLiquidity` function defined in periphery.
    /// @param tokenId The id of the erc721 token
    /// @return amount0 The amount received back in token0
    /// @return amount1 The amount returned back in token1
    function decreaseLiquidityInHalf(uint256 tokenId) external returns (uint256 amount0, uint256 amount1) {
        // caller must be the owner of the NFT
        require(msg.sender == deposits[tokenId].owner, 'Not the owner');
        // get liquidity data for tokenId
        uint128 liquidity = deposits[tokenId].liquidity;
        uint128 halfLiquidity = liquidity / 2;

        // amount0Min and amount1Min are price slippage checks
        // if the amount received after burning is not greater than these minimums, transaction will fail
        INonfungiblePositionManager.DecreaseLiquidityParams memory params =
            INonfungiblePositionManager.DecreaseLiquidityParams({
                tokenId: tokenId,
                liquidity: halfLiquidity,
                amount0Min: 0,
                amount1Min: 0,
                deadline: block.timestamp
            });

        (amount0, amount1) = nonfungiblePositionManager.decreaseLiquidity(params);

        //send liquidity back to owner
        _sendToOwner(tokenId, amount0, amount1);
    }

    /// @notice Increases liquidity in the current range
    /// @dev Pool must be initialized already to add liquidity
    /// @param tokenId The id of the erc721 token
    /// @param amount0 The amount to add of token0
    /// @param amount1 The amount to add of token1
    function increaseLiquidityCurrentRange(
        uint256 tokenId,
        uint256 amountAdd0,
        uint256 amountAdd1
    )
        external
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        ) {

        TransferHelper.safeTransferFrom(deposits[tokenId].token0, msg.sender, address(this), amountAdd0);
        TransferHelper.safeTransferFrom(deposits[tokenId].token1, msg.sender, address(this), amountAdd1);

        TransferHelper.safeApprove(deposits[tokenId].token0, address(nonfungiblePositionManager), amountAdd0);
        TransferHelper.safeApprove(deposits[tokenId].token1, address(nonfungiblePositionManager), amountAdd1);

        INonfungiblePositionManager.IncreaseLiquidityParams memory params = INonfungiblePositionManager.IncreaseLiquidityParams({
            tokenId: tokenId,
            amount0Desired: amountAdd0,
            amount1Desired: amountAdd1,
            amount0Min: 0,
            amount1Min: 0,
            deadline: block.timestamp
        });

        (liquidity, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(params);

    }

    /// @notice Transfers funds to owner of NFT
    /// @param tokenId The id of the erc721
    /// @param amount0 The amount of token0
    /// @param amount1 The amount of token1
    function _sendToOwner(
        uint256 tokenId,
        uint256 amount0,
        uint256 amount1
    ) internal {
        // get owner of contract
        address owner = deposits[tokenId].owner;

        address token0 = deposits[tokenId].token0;
        address token1 = deposits[tokenId].token1;
        // send collected fees to owner
        TransferHelper.safeTransfer(token0, owner, amount0);
        TransferHelper.safeTransfer(token1, owner, amount1);
    }

    /// @notice Transfers the NFT to the owner
    /// @param tokenId The id of the erc721
    function retrieveNFT(uint256 tokenId) external {
        // must be the owner of the NFT
        require(msg.sender == deposits[tokenId].owner, 'Not the owner');
        // transfer ownership to original owner
        nonfungiblePositionManager.safeTransferFrom(address(this), msg.sender, tokenId);
        //remove information related to tokenId
        delete deposits[tokenId];
    }
}
```
</file>

<file path="docs/contracts/v3/guides/swaps/_category_.json">
{
  "label": "Implement A Swap",
  "position": 1,
  "collapsed": true
}
</file>

<file path="docs/contracts/v3/guides/swaps/multihop-swaps.md">
---
id: multihop-swaps
title: Multihop Swaps
sidebar_position: 2
---

## Introduction

The examples below are implementations of the two styles of multi-hop swapping available on v3. The examples below are not production ready code, and are implemented in a simplistic manner for the purpose of learning.

## Setting up the Contract

Declare the solidity version that will be used to compile the contract, and the `abicoder v2` to allow arbitrary nested arrays and structs
to be encoded and decoded in calldata, a feature we use when executing a swap.

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;
```

Import the two needed contracts from the npm package installation.

```solidity
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';
import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';
```

Create a contract called `SwapExamples`, and declare an immutable public variable `swapRouter` of type `ISwapRouter`.
This allows us to call functions in the `ISwapRouter` interface.

```solidity
contract SwapExamples {
    // For the scope of these swap examples,
    // we will detail the design considerations when using `exactInput`, `exactInputSingle`, `exactOutput`, and  `exactOutputSingle`.
    // It should be noted that for the sake of these examples we pass in the swap router as a constructor argument instead of inheriting it.
    // More advanced example contracts will detail how to inherit the swap router safely.
    // This example swaps DAI/WETH9 for single path swaps and DAI/USDC/WETH9 for multi path swaps.

    ISwapRouter public immutable swapRouter;
```

Hardcode the token contract addresses and pool fee tiers for the example. In production, you would likely use an input parameter for this and pass the input into a memory variable, allowing the contract to change the pools and tokens it interacts with on a per transaction basis, but for conceptual simplicity, we are hardcoding them here.

```solidity
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // For this example, we will set the pool fee to 0.3%.
    uint24 public constant poolFee = 3000;

    constructor(ISwapRouter _swapRouter) {
        swapRouter = _swapRouter;
    }
```

## Exact Input Multi Hop Swaps

Exact input multi hop swaps will swap a fixed amount on a given input token for the maximum amount possible for a given output, and can include an arbitrary number of intermediary swaps.

### Input Parameters

- `path`: The path is a sequence of (`tokenAddress` - `fee` - `tokenAddress`), which are the variables needed to compute each pool contract address in our sequence of swaps. The multihop swap router code will automatically find the correct pool with these variables, and execute the swap needed within each pool in our sequence.
- `recipient`: the destination address of the outbound asset.
- `deadline`: the unix time after which a transaction will be reverted, to protect against long delays and the increased chance of large price swings therein.
- `amountIn`: the amount of the inbound asset
- `amountOutMin`: the minimum amount of the outbound asset, less than which will cause the transaction to revert. For the sake of this example we will set it to `0`, in production one will need to use the SDK to quote an expected price, or an on chain price oracle for more advanced manipulation resistant systems.

### Calling the function

```solidity
    /// @notice swapExactInputMultihop swaps a fixed amount of DAI for a maximum possible amount of WETH9 through an intermediary pool.
    /// For this example, we will swap DAI to USDC, then USDC to WETH9 to achieve our desired output.
    /// @dev The calling address must approve this contract to spend at least `amountIn` worth of its DAI for this function to succeed.
    /// @param amountIn The amount of DAI to be swapped.
    /// @return amountOut The amount of WETH9 received after the swap.
    function swapExactInputMultihop(uint256 amountIn) external returns (uint256 amountOut) {
        // Transfer `amountIn` of DAI to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountIn);

        // Approve the router to spend DAI.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountIn);

        // Multiple pool swaps are encoded through bytes called a `path`. A path is a sequence of token addresses and poolFees that define the pools used in the swaps.
        // The format for pool encoding is (tokenIn, fee, tokenOut/tokenIn, fee, tokenOut) where tokenOut/tokenIn parameter is the shared token across the pools.
        // Since we are swapping DAI to USDC and then USDC to WETH9 the path encoding is (DAI, 0.3%, USDC, 0.3%, WETH9).
        ISwapRouter.ExactInputParams memory params =
            ISwapRouter.ExactInputParams({
                path: abi.encodePacked(DAI, poolFee, USDC, poolFee, WETH9),
                recipient: msg.sender,
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: 0
            });

        // Executes the swap.
        amountOut = swapRouter.exactInput(params);
    }
```

## Exact Output Multihop Swap

An exact output swap will swap a variable amount of the input token for a fixed amount of the outbound token. This is the less common technique for multihop swaps. The code for swapping is largely the same except for one notable difference, the `Path` is encoded backwards, as an exact output swap is executed in reverse order to pass down the necessary variables for the chain of transactions

### Input Parameters

- `path`: The path is a sequence of `tokenAddress` `Fee` `tokenAddress`, _encoded in reverse order_, which are the variables needed to compute each pool contract address in our sequence of swaps. The multihop swap router code will automatically find the correct pool with these variables, and execute the swap needed within each pool in our sequence.
- `recipient`: the destination address of the outbound asset.
- `deadline`: the unix time after which a transaction will be reverted, to protect against long delays and the increased chance of large price swings therein.
- `amountOut`: The desired amount of WETH9.
- `amountInMaximum`: The maximum amount of DAI willing to be swapped for the specified amountOut of WETH9.

### Calling the function

```solidity
    /// @notice swapExactOutputMultihop swaps a minimum possible amount of DAI for a fixed amount of WETH through an intermediary pool.
    /// For this example, we want to swap DAI for WETH9 through a USDC pool but we specify the desired amountOut of WETH9. Notice how the path encoding is slightly different in for exact output swaps.
    /// @dev The calling address must approve this contract to spend its DAI for this function to succeed. As the amount of input DAI is variable,
    /// the calling address will need to approve for a slightly higher amount, anticipating some variance.
    /// @param amountOut The desired amount of WETH9.
    /// @param amountInMaximum The maximum amount of DAI willing to be swapped for the specified amountOut of WETH9.
    /// @return amountIn The amountIn of DAI actually spent to receive the desired amountOut.
    function swapExactOutputMultihop(uint256 amountOut, uint256 amountInMaximum) external returns (uint256 amountIn) {
        // Transfer the specified `amountInMaximum` to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountInMaximum);
        // Approve the router to spend  `amountInMaximum`.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountInMaximum);

        // The parameter path is encoded as (tokenOut, fee, tokenIn/tokenOut, fee, tokenIn)
        // The tokenIn/tokenOut field is the shared token between the two pools used in the multiple pool swap. In this case USDC is the "shared" token.
        // For an exactOutput swap, the first swap that occurs is the swap which returns the eventual desired token.
        // In this case, our desired output token is WETH9 so that swap happens first, and is encoded in the path accordingly.
        ISwapRouter.ExactOutputParams memory params =
            ISwapRouter.ExactOutputParams({
                path: abi.encodePacked(WETH9, poolFee, USDC, poolFee, DAI),
                recipient: msg.sender,
                deadline: block.timestamp,
                amountOut: amountOut,
                amountInMaximum: amountInMaximum
            });

        // Executes the swap, returning the amountIn actually spent.
        amountIn = swapRouter.exactOutput(params);

        // If the swap did not require the full amountInMaximum to achieve the exact amountOut then we refund msg.sender and approve the router to spend 0.
        if (amountIn < amountInMaximum) {
            TransferHelper.safeApprove(DAI, address(swapRouter), 0);
            TransferHelper.safeTransfer(DAI, msg.sender, amountInMaximum - amountIn);
        }
    }
```

## The Full Contract

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;

import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';

contract SwapExamples {
    // For the scope of these swap examples,
    // we will detail the design considerations when using
    // `exactInput`, `exactInputSingle`, `exactOutput`, and  `exactOutputSingle`.

    // It should be noted that for the sake of these examples, we purposefully pass in the swap router instead of inherit the swap router for simplicity.
    // More advanced example contracts will detail how to inherit the swap router safely.

    ISwapRouter public immutable swapRouter;

    // This example swaps DAI/WETH9 for single path swaps and DAI/USDC/WETH9 for multi path swaps.

    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // For this example, we will set the pool fee to 0.3%.
    uint24 public constant poolFee = 3000;

    constructor(ISwapRouter _swapRouter) {
        swapRouter = _swapRouter;
    }

    /// @notice swapInputMultiplePools swaps a fixed amount of DAI for a maximum possible amount of WETH9 through an intermediary pool.
    /// For this example, we will swap DAI to USDC, then USDC to WETH9 to achieve our desired output.
    /// @dev The calling address must approve this contract to spend at least `amountIn` worth of its DAI for this function to succeed.
    /// @param amountIn The amount of DAI to be swapped.
    /// @return amountOut The amount of WETH9 received after the swap.
    function swapExactInputMultihop(uint256 amountIn) external returns (uint256 amountOut) {
        // Transfer `amountIn` of DAI to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountIn);

        // Approve the router to spend DAI.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountIn);

        // Multiple pool swaps are encoded through bytes called a `path`. A path is a sequence of token addresses and poolFees that define the pools used in the swaps.
        // The format for pool encoding is (tokenIn, fee, tokenOut/tokenIn, fee, tokenOut) where tokenOut/tokenIn parameter is the shared token across the pools.
        // Since we are swapping DAI to USDC and then USDC to WETH9 the path encoding is (DAI, 0.3%, USDC, 0.3%, WETH9).
        ISwapRouter.ExactInputParams memory params =
            ISwapRouter.ExactInputParams({
                path: abi.encodePacked(DAI, poolFee, USDC, poolFee, WETH9),
                recipient: msg.sender,
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: 0
            });

        // Executes the swap.
        amountOut = swapRouter.exactInput(params);
    }

    /// @notice swapExactOutputMultihop swaps a minimum possible amount of DAI for a fixed amount of WETH through an intermediary pool.
    /// For this example, we want to swap DAI for WETH9 through a USDC pool but we specify the desired amountOut of WETH9. Notice how the path encoding is slightly different in for exact output swaps.
    /// @dev The calling address must approve this contract to spend its DAI for this function to succeed. As the amount of input DAI is variable,
    /// the calling address will need to approve for a slightly higher amount, anticipating some variance.
    /// @param amountOut The desired amount of WETH9.
    /// @param amountInMaximum The maximum amount of DAI willing to be swapped for the specified amountOut of WETH9.
    /// @return amountIn The amountIn of DAI actually spent to receive the desired amountOut.
    function swapExactOutputMultihop(uint256 amountOut, uint256 amountInMaximum) external returns (uint256 amountIn) {
        // Transfer the specified `amountInMaximum` to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountInMaximum);
        // Approve the router to spend  `amountInMaximum`.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountInMaximum);

        // The parameter path is encoded as (tokenOut, fee, tokenIn/tokenOut, fee, tokenIn)
        // The tokenIn/tokenOut field is the shared token between the two pools used in the multiple pool swap. In this case USDC is the "shared" token.
        // For an exactOutput swap, the first swap that occurs is the swap which returns the eventual desired token.
        // In this case, our desired output token is WETH9 so that swap happens first, and is encoded in the path accordingly.
        ISwapRouter.ExactOutputParams memory params =
            ISwapRouter.ExactOutputParams({
                path: abi.encodePacked(WETH9, poolFee, USDC, poolFee, DAI),
                recipient: msg.sender,
                deadline: block.timestamp,
                amountOut: amountOut,
                amountInMaximum: amountInMaximum
            });

        // Executes the swap, returning the amountIn actually spent.
        amountIn = swapRouter.exactOutput(params);

        // If the swap did not require the full amountInMaximum to achieve the exact amountOut then we refund msg.sender and approve the router to spend 0.
        if (amountIn < amountInMaximum) {
            TransferHelper.safeApprove(DAI, address(swapRouter), 0);
            TransferHelper.safeTransfer(DAI, msg.sender, amountInMaximum - amountIn);
        }
    }
}
```
</file>

<file path="docs/contracts/v3/guides/swaps/single-swaps.md">
---
id: single-swaps
title: Single Swaps
sidebar_position: 1
---

Swaps are the most common interaction with the Uniswap protocol. The following example shows you how to implement a single-path swap contract that uses two functions that you create:

- `swapExactInputSingle`
- `swapExactOutputSingle`

The `swapExactInputSingle` function is for performing _exact input_ swaps, which swap a fixed amount of one token for a maximum possible amount of another token. This function uses the `ExactInputSingleParams` struct and the `exactInputSingle` function from the [ISwapRouter](../../reference/periphery/interfaces/ISwapRouter.md) interface.

The `swapExactOutputSingle` function is for performing _exact output_ swaps, which swap a minimum possible amount of one token for a fixed amount of another token. This function uses the `ExactOutputSingleParams` struct and the `exactOutputSingle` function from the [ISwapRouter](../../reference/periphery/interfaces/ISwapRouter.md) interface.

For simplification, the example hardcodes the token contract addresses, but as explained further below the contract could be modified to change pools and tokens on a per transaction basis.

When trading from a smart contract, the most important thing to keep in mind is that access to an external price source is required. Without this, trades can be frontrun for considerable loss.

**Note:** The swap examples are not production ready code, and are implemented in a simplistic manner for the purpose of learning.

## Set Up the Contract

Declare the solidity version used to compile the contract, and `abicoder v2` to allow arbitrary nested arrays and structs
to be encoded and decoded in calldata, a feature used when executing a swap.

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;
```

Import the two relevant contracts from the npm package installation

```solidity
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';
import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';
```

Create a contract called `SwapExamples`, and declare an immutable public variable `swapRouter` of type `ISwapRouter`.
This allows us to call functions in the `ISwapRouter` interface.

```solidity
contract SwapExamples {
    // For the scope of these swap examples,
    // we will detail the design considerations when using `exactInput`, `exactInputSingle`, `exactOutput`, and  `exactOutputSingle`.
    // It should be noted that for the sake of these examples we pass in the swap router as a constructor argument instead of inheriting it.
    // More advanced example contracts will detail how to inherit the swap router safely.
    // This example swaps DAI/WETH9 for single path swaps and DAI/USDC/WETH9 for multi path swaps.

    ISwapRouter public immutable swapRouter;
```

Hardcode the token contract addresses and pool fee tiers for the example. In production, you would likely use an input parameter for this and pass the input into a memory variable, allowing the contract to change the pools and tokens it interacts with on a per transaction basis, but for conceptual simplicity, we are hardcoding them here.

```solidity
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // For this example, we will set the pool fee to 0.3%.
    uint24 public constant poolFee = 3000;

    constructor(ISwapRouter _swapRouter) {
        swapRouter = _swapRouter;
    }
```

## Exact Input Swaps

The caller must `approve` the contract to withdraw the tokens from the calling address's account to execute a swap. Remember that because
our contract is a contract itself and not an extension of the caller (us); we must also approve the Uniswap protocol router contract to use the tokens that our contract will be in possession of after they have been withdrawn from the calling address (us).

Then, transfer the `amount` of Dai from the calling address into our contract, and use `amount` as the value passed to the second `approve`.

```solidity
    /// @notice swapExactInputSingle swaps a fixed amount of DAI for a maximum possible amount of WETH9
    /// using the DAI/WETH9 0.3% pool by calling `exactInputSingle` in the swap router.
    /// @dev The calling address must approve this contract to spend at least `amountIn` worth of its DAI for this function to succeed.
    /// @param amountIn The exact amount of DAI that will be swapped for WETH9.
    /// @return amountOut The amount of WETH9 received.
    function swapExactInputSingle(uint256 amountIn) external returns (uint256 amountOut) {
        // msg.sender must approve this contract

        // Transfer the specified amount of DAI to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountIn);

        // Approve the router to spend DAI.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountIn);

```

### Swap Input Parameters

To execute the swap function, we need to populate the `ExactInputSingleParams` with the necessary swap data. These parameters are found in the smart contract interfaces, which can be browsed [here](../../reference/periphery/interfaces/ISwapRouter.md).

A brief overview of the parameters:

- `tokenIn` The contract address of the inbound token
- `tokenOut` The contract address of the outbound token
- `fee` The fee tier of the pool, used to determine the correct pool contract in which to execute the swap
- `recipient` the destination address of the outbound token
- `deadline`: the unix time after which a swap will fail, to protect against long-pending transactions and wild swings in prices
- `amountOutMinimum`: we are setting to zero, but this is a significant risk in production. For a real deployment, this value should be calculated using our SDK or an onchain price oracle - this helps protect against getting an unusually bad price for a trade due to a front running sandwich or another type of price manipulation
- `sqrtPriceLimitX96`: We set this to zero - which makes this parameter inactive. In production, this value can be used to set the limit for the price the swap will push the pool to, which can help protect against price impact or for setting up logic in a variety of price-relevant mechanisms. 

  **WARNING: Passing in a non-zero `sqrtPriceLimitX96` can mean that less tokens that the amount specified by `amountIn` are swapped**. Any contract that uses a non-zero `sqrtPriceLimitX96` parameter will need to refund any unswapped tokens. 

### Call the function

```solidity
        // Naively set amountOutMinimum to 0. In production, use an oracle or other data source to choose a safer value for amountOutMinimum.
        // We also set the sqrtPriceLimitx96 to be 0 to ensure we swap our exact input amount.
        ISwapRouter.ExactInputSingleParams memory params =
            ISwapRouter.ExactInputSingleParams({
                tokenIn: DAI,
                tokenOut: WETH9,
                fee: poolFee,
                recipient: msg.sender,
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            });

        // The call to `exactInputSingle` executes the swap.
        amountOut = swapRouter.exactInputSingle(params);
    }
```

## Exact Output Swaps

Exact Output swaps a minimum possible amount of the input token for a fixed amount of the outbound token. This is the less common swap style - but useful in a variety of circumstances.

Because this example transfers in the inbound asset in anticipation of the swap - its possible that some of the inbound token will be left over after the swap is executed, which is why we pay it back to the calling address at the end of the swap.

### Call the function

```solidity
/// @notice swapExactOutputSingle swaps a minimum possible amount of DAI for a fixed amount of WETH.
/// @dev The calling address must approve this contract to spend its DAI for this function to succeed. As the amount of input DAI is variable,
/// the calling address will need to approve for a slightly higher amount, anticipating some variance.
/// @param amountOut The exact amount of WETH9 to receive from the swap.
/// @param amountInMaximum The amount of DAI we are willing to spend to receive the specified amount of WETH9.
/// @return amountIn The amount of DAI actually spent in the swap.
function swapExactOutputSingle(uint256 amountOut, uint256 amountInMaximum) external returns (uint256 amountIn) {
        // Transfer the specified amount of DAI to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountInMaximum);

        // Approve the router to spend the specified `amountInMaximum` of DAI.
        // In production, you should choose the maximum amount to spend based on oracles or other data sources to achieve a better swap.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountInMaximum);

        ISwapRouter.ExactOutputSingleParams memory params =
            ISwapRouter.ExactOutputSingleParams({
                tokenIn: DAI,
                tokenOut: WETH9,
                fee: poolFee,
                recipient: msg.sender,
                deadline: block.timestamp,
                amountOut: amountOut,
                amountInMaximum: amountInMaximum,
                sqrtPriceLimitX96: 0
            });

        // Executes the swap returning the amountIn needed to spend to receive the desired amountOut.
        amountIn = swapRouter.exactOutputSingle(params);

        // For exact output swaps, the amountInMaximum may not have all been spent.
        // If the actual amount spent (amountIn) is less than the specified maximum amount, we must refund the msg.sender and approve the swapRouter to spend 0.
        if (amountIn < amountInMaximum) {
            TransferHelper.safeApprove(DAI, address(swapRouter), 0);
            TransferHelper.safeTransfer(DAI, msg.sender, amountInMaximum - amountIn);
        }
    }

```

## A Complete Single Swap Contract

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;

import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';
import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';

contract SwapExamples {
    // For the scope of these swap examples,
    // we will detail the design considerations when using
    // `exactInput`, `exactInputSingle`, `exactOutput`, and  `exactOutputSingle`.

    // It should be noted that for the sake of these examples, we purposefully pass in the swap router instead of inherit the swap router for simplicity.
    // More advanced example contracts will detail how to inherit the swap router safely.

    ISwapRouter public immutable swapRouter;

    // This example swaps DAI/WETH9 for single path swaps and DAI/USDC/WETH9 for multi path swaps.

    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;

    // For this example, we will set the pool fee to 0.3%.
    uint24 public constant poolFee = 3000;

    constructor(ISwapRouter _swapRouter) {
        swapRouter = _swapRouter;
    }

    /// @notice swapExactInputSingle swaps a fixed amount of DAI for a maximum possible amount of WETH9
    /// using the DAI/WETH9 0.3% pool by calling `exactInputSingle` in the swap router.
    /// @dev The calling address must approve this contract to spend at least `amountIn` worth of its DAI for this function to succeed.
    /// @param amountIn The exact amount of DAI that will be swapped for WETH9.
    /// @return amountOut The amount of WETH9 received.
    function swapExactInputSingle(uint256 amountIn) external returns (uint256 amountOut) {
        // msg.sender must approve this contract

        // Transfer the specified amount of DAI to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountIn);

        // Approve the router to spend DAI.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountIn);

        // Naively set amountOutMinimum to 0. In production, use an oracle or other data source to choose a safer value for amountOutMinimum.
        // We also set the sqrtPriceLimitx96 to be 0 to ensure we swap our exact input amount.
        ISwapRouter.ExactInputSingleParams memory params =
            ISwapRouter.ExactInputSingleParams({
                tokenIn: DAI,
                tokenOut: WETH9,
                fee: poolFee,
                recipient: msg.sender,
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            });

        // The call to `exactInputSingle` executes the swap.
        amountOut = swapRouter.exactInputSingle(params);
    }

    /// @notice swapExactOutputSingle swaps a minimum possible amount of DAI for a fixed amount of WETH.
    /// @dev The calling address must approve this contract to spend its DAI for this function to succeed. As the amount of input DAI is variable,
    /// the calling address will need to approve for a slightly higher amount, anticipating some variance.
    /// @param amountOut The exact amount of WETH9 to receive from the swap.
    /// @param amountInMaximum The amount of DAI we are willing to spend to receive the specified amount of WETH9.
    /// @return amountIn The amount of DAI actually spent in the swap.
    function swapExactOutputSingle(uint256 amountOut, uint256 amountInMaximum) external returns (uint256 amountIn) {
        // Transfer the specified amount of DAI to this contract.
        TransferHelper.safeTransferFrom(DAI, msg.sender, address(this), amountInMaximum);

        // Approve the router to spend the specified `amountInMaximum` of DAI.
        // In production, you should choose the maximum amount to spend based on oracles or other data sources to achieve a better swap.
        TransferHelper.safeApprove(DAI, address(swapRouter), amountInMaximum);

        ISwapRouter.ExactOutputSingleParams memory params =
            ISwapRouter.ExactOutputSingleParams({
                tokenIn: DAI,
                tokenOut: WETH9,
                fee: poolFee,
                recipient: msg.sender,
                deadline: block.timestamp,
                amountOut: amountOut,
                amountInMaximum: amountInMaximum,
                sqrtPriceLimitX96: 0
            });

        // Executes the swap returning the amountIn needed to spend to receive the desired amountOut.
        amountIn = swapRouter.exactOutputSingle(params);

        // For exact output swaps, the amountInMaximum may not have all been spent.
        // If the actual amount spent (amountIn) is less than the specified maximum amount, we must refund the msg.sender and approve the swapRouter to spend 0.
        if (amountIn < amountInMaximum) {
            TransferHelper.safeApprove(DAI, address(swapRouter), 0);
            TransferHelper.safeTransfer(DAI, msg.sender, amountInMaximum - amountIn);
        }
    }
}
```
</file>

<file path="docs/contracts/v3/guides/_category_.json">
{
  "label": "Guides",
  "position": 4,
  "collapsed": false
}
</file>

<file path="docs/contracts/v3/guides/local-environment.mdx">
---
id: local-environment
title: Set Up Your Local Environment
sidebar_position: 0.5
---

One of the most common questions we get asked is what development toolset to use to build on-chain integrations with Uniswap. There’s no right answer to this question but for this guide we’ll recommend a common one: `Node.js` , `NPM` and `Hardhat`.

At the end of this guide you’ll have a development environment set up that you can use to build the rest of the examples in the Guides section of the docs, or start your own integration project!

To get you started as quickly as possible, we have provided the `Quick Start` section below where you can clone some boiler plate and get building. To start from scratch and learn the underlying concepts, jump to the `Start from Scratch` section.

## Quick Start

The Uniswap [boilerplate repo](https://github.com/Uniswap/uniswap-first-contract-example) provides a basic Hardhat environment with required imports already pre-loaded for you. You can simply clone it and install the dependencies:

```bash
git clone https://github.com/Uniswap/uniswap-first-contract-example
cd uniswap-first-contract-example
npm install
```

Then hop to the `Local Node with a Mainnet Fork` to complete your set up and start developing.

## Start from Scratch

In the following sections, we’ll walk through the steps to create the same environment set up as the boiler plate from scratch and learn the underlying concepts.

### Set Up Dependencies

Node is one of the most common Javascript runtimes. For our purposes it will provide scripting we can use to compile and test our contracts. If you haven’t already, install NodeJS and its package manager NPM ([instructions](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)). Once those dependencies are set up, we can initialize our project:

```bash
$ npm init
```

[Hardhat](https://hardhat.org/) is an Ethereum development toolset that provides a number of powerful features including Solidity compilation, testing and deployment, all in a single convenient wrapper. We’ll use NPM to add Hardhat to our project:

```bash
$ npm add --save-dev hardhat
```

With Hardhat installed we can invoke it to scaffold our development environment. When you first run Hardhat you’ll have the option of starting with a templated Javascript or Typescript project or an empty project. Since Hardhat relies heavily on folder structure, we recommend starting  with either of the templated options. Initialize Hardhat and follow the prompts to make your selection and answer yes to the follow up prompts:

```bash
$ npx hardhat init
```

Once the Hardhat initialization completes, take a look around at what got set up. The folder structure should be intuitive, `./contracts` is where you’ll write your Solidity contracts, `./test` is where you’ll write your tests and `./scripts` is where you can write scripts to perform actions like deploying. Out of the box, Hardhat is configured to use this folder structure so don’t change it unless you know what you’re doing!

Next we’ll use NPM to add the Uniswap V3 contracts which will allow us to seamlessly integrate with the protocol in our new contracts:

```bash
$ npm add @uniswap/v3-periphery @uniswap/v3-core
```

The Uniswap V3 contracts were written using a past version of the solidity compiler. Since we’re building integrations on V3 we have to tell Hardhat to use the correct compiler to build these files. Go to the `./hardhat.config.js` file and change the Solidity version to “0.7.6”:

```jsx
// ...
module.exports = {
  solidity: "0.7.6",
};
```

That’s it! You should now have a functional development environment to start building on chain Uniswap integrations. Let’s run a quick test to confirm everything is set up properly.

## Compile a Basic Contract

To confirm that our environment is configured correctly we’ll attempt to compile a basic Swap contract. Create a new file, `./contracts/Swap.sol` and paste the following code into it (a detailed guide to this contract can be found [here](./swaps/single-swaps)):

```jsx
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.7.6;
pragma abicoder v2;

import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';
import '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';

contract SimpleSwap {
    ISwapRouter public immutable swapRouter;
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    uint24 public constant feeTier = 3000;

    constructor(ISwapRouter _swapRouter) {
        swapRouter = _swapRouter;
    }

    function swapWETHForDAI(uint256 amountIn) external returns (uint256 amountOut) {

        // Transfer the specified amount of WETH9 to this contract.
        TransferHelper.safeTransferFrom(WETH9, msg.sender, address(this), amountIn);
        // Approve the router to spend WETH9.
        TransferHelper.safeApprove(WETH9, address(swapRouter), amountIn);
        // Note: To use this example, you should explicitly set slippage limits, omitting for simplicity
        uint256 minOut = /* Calculate min output */ 0;
        uint160 priceLimit = /* Calculate price limit */ 0;
        // Create the params that will be used to execute the swap
        ISwapRouter.ExactInputSingleParams memory params =
            ISwapRouter.ExactInputSingleParams({
                tokenIn: WETH9,
                tokenOut: DAI,
                fee: feeTier,
                recipient: msg.sender,
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: minOut,
                sqrtPriceLimitX96: priceLimit
            });
        // The call to `exactInputSingle` executes the swap.
        amountOut = swapRouter.exactInputSingle(params);
    }
}
```

To compile all the contracts in the `./contracts` folder, we’ll use the Hardhat compile command:

```bash
$ npx hardhat compile
```

If the environment is compiled correctly you should see the message:

```bash
Compiled { x } Solidity files successfully
```

## Local Node with a Mainnet Fork

When building and testing integrations with on chain protocols, developers often hit a problem: the liquidity on the live chain is critical to thoroughly testing their code but testing against a live network like Mainnet can be extremely expensive.

See [the SDK getting started guide](../../../sdk/v3/guides/local-development) for a full example on how to use forks.

With your local node up and running, you can use the `--network localhost` flag in tests to point the Hardhat testing suite to that local node:

```bash
$ npx hardhat test --network localhost
```

## Next Steps

With your environment set up you’re ready to start building. Jump over to the guides section to learn about the Uniswap functions you can integrate with. Remember to add all contracts (.sol files) to the `./contracts` folder and their subsequent tests to the `./tests` folder. You can then test them against your local forked node by running:

```bash
$ npx hardhat test --network localhost
```
</file>

<file path="docs/contracts/v3/reference/core/interfaces/callback/IUniswapV3FlashCallback.md">
Any contract that calls IUniswapV3PoolActions#flash must implement this interface

## Functions

### uniswapV3FlashCallback

```solidity
  function uniswapV3FlashCallback(
    uint256 fee0,
    uint256 fee1,
    bytes data
  ) external
```

Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.

In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.
The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.

#### Parameters:

| Name   | Type    | Description                                                                    |
| :----- | :------ | :----------------------------------------------------------------------------- |
| `fee0` | uint256 | The fee amount in token0 due to the pool by the end of the flash               |
| `fee1` | uint256 | The fee amount in token1 due to the pool by the end of the flash               |
| `data` | bytes   | Any data passed through by the caller via the IUniswapV3PoolActions#flash call |
</file>

<file path="docs/contracts/v3/reference/core/interfaces/callback/IUniswapV3MintCallback.md">
Any contract that calls IUniswapV3PoolActions#mint must implement this interface

## Functions

### uniswapV3MintCallback

```solidity
  function uniswapV3MintCallback(
    uint256 amount0Owed,
    uint256 amount1Owed,
    bytes data
  ) external
```

Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.

In the implementation you must pay the pool tokens owed for the minted liquidity.
The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.

#### Parameters:

| Name          | Type    | Description                                                                   |
| :------------ | :------ | :---------------------------------------------------------------------------- |
| `amount0Owed` | uint256 | The amount of token0 due to the pool for the minted liquidity                 |
| `amount1Owed` | uint256 | The amount of token1 due to the pool for the minted liquidity                 |
| `data`        | bytes   | Any data passed through by the caller via the IUniswapV3PoolActions#mint call |
</file>

<file path="docs/contracts/v3/reference/core/interfaces/callback/IUniswapV3SwapCallback.md">
Any contract that calls IUniswapV3PoolActions#swap must implement this interface

## Functions

### uniswapV3SwapCallback

```solidity
  function uniswapV3SwapCallback(
    int256 amount0Delta,
    int256 amount1Delta,
    bytes data
  ) external
```

Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.

In the implementation you must pay the pool tokens owed for the swap.
The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
amount0Delta and amount1Delta can both be 0 if no tokens were swapped.

#### Parameters:

| Name           | Type   | Description                                                                                                                                                                             |
| :------------- | :----- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `amount0Delta` | int256 | The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool. |
| `amount1Delta` | int256 | The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool. |
| `data`         | bytes  | Any data passed through by the caller via the IUniswapV3PoolActions#swap call.                                                                                                          |
</file>

<file path="docs/contracts/v3/reference/core/interfaces/pool/_category_.json">
{
  "label": "Pool"
}
</file>

<file path="docs/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolActions.md">
Contains pool methods that can be called by anyone

## Functions

### initialize

```solidity
  function initialize(
    uint160 sqrtPriceX96
  ) external
```

Sets the initial price for the pool

Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value

#### Parameters:

| Name           | Type    | Description                                    |
| :------------- | :------ | :--------------------------------------------- |
| `sqrtPriceX96` | uint160 | the initial sqrt price of the pool as a Q64.96 |

### mint

```solidity
  function mint(
    address recipient,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount,
    bytes data
  ) external returns (uint256 amount0, uint256 amount1)
```

Adds liquidity for the given recipient/tickLower/tickUpper position

The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
on tickLower, tickUpper, the amount of liquidity, and the current price.

#### Parameters:

| Name        | Type    | Description                                              |
| :---------- | :------ | :------------------------------------------------------- |
| `recipient` | address | The address for which the liquidity will be created      |
| `tickLower` | int24   | The lower tick of the position in which to add liquidity |
| `tickUpper` | int24   | The upper tick of the position in which to add liquidity |
| `amount`    | uint128 | The amount of liquidity to mint                          |
| `data`      | bytes   | Any data that should be passed through to the callback   |

#### Return Values:

| Name      | Type    | Description                                                                                                 |
| :-------- | :------ | :---------------------------------------------------------------------------------------------------------- |
| `amount0` | uint256 | The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback |
| `amount1` | uint256 | The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback |

### collect

```solidity
  function collect(
    address recipient,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount0Requested,
    uint128 amount1Requested
  ) external returns (uint128 amount0, uint128 amount1)
```

Collects tokens owed to a position

Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.

#### Parameters:

| Name               | Type    | Description                                              |
| :----------------- | :------ | :------------------------------------------------------- |
| `recipient`        | address | The address which should receive the fees collected      |
| `tickLower`        | int24   | The lower tick of the position for which to collect fees |
| `tickUpper`        | int24   | The upper tick of the position for which to collect fees |
| `amount0Requested` | uint128 | How much token0 should be withdrawn from the fees owed   |
| `amount1Requested` | uint128 | How much token1 should be withdrawn from the fees owed   |

#### Return Values:

| Name      | Type    | Description                            |
| :-------- | :------ | :------------------------------------- |
| `amount0` | uint128 | The amount of fees collected in token0 |
| `amount1` | uint128 | The amount of fees collected in token1 |

### burn

```solidity
  function burn(
    int24 tickLower,
    int24 tickUpper,
    uint128 amount
  ) external returns (uint256 amount0, uint256 amount1)
```

Burn liquidity from the sender and account tokens owed for the liquidity to the position

Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
Fees must be collected separately via a call to #collect

#### Parameters:

| Name        | Type    | Description                                                |
| :---------- | :------ | :--------------------------------------------------------- |
| `tickLower` | int24   | The lower tick of the position for which to burn liquidity |
| `tickUpper` | int24   | The upper tick of the position for which to burn liquidity |
| `amount`    | uint128 | How much liquidity to burn                                 |

#### Return Values:

| Name      | Type    | Description                                |
| :-------- | :------ | :----------------------------------------- |
| `amount0` | uint256 | The amount of token0 sent to the recipient |
| `amount1` | uint256 | The amount of token1 sent to the recipient |

### swap

```solidity
  function swap(
    address recipient,
    bool zeroForOne,
    int256 amountSpecified,
    uint160 sqrtPriceLimitX96,
    bytes data
  ) external returns (int256 amount0, int256 amount1)
```

Swap token0 for token1, or token1 for token0

The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback

#### Parameters:

| Name                | Type    | Description                                                                                                        |
| :------------------ | :------ | :----------------------------------------------------------------------------------------------------------------- |
| `recipient`         | address | The address to receive the output of the swap                                                                      |
| `zeroForOne`        | bool    | The direction of the swap, true for token0 to token1, false for token1 to token0                                   |
| `amountSpecified`   | int256  | The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative) |
| `sqrtPriceLimitX96` | uint160 | The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap                                                                                                            |
| `data` | bytes   | Any data passed through to the callback                                                                                         |

#### Return Values:

| Name      | Type   | Description                                                                                |
| :-------- | :----- | :----------------------------------------------------------------------------------------- |
| `amount0` | int256 | The delta of the balance of token0 of the pool, exact when negative, minimum when positive |
| `amount1` | int256 | The delta of the balance of token1 of the pool, exact when negative, minimum when positive |

### flash

```solidity
  function flash(
    address recipient,
    uint256 amount0,
    uint256 amount1,
    bytes data
  ) external
```

Receive token0 and/or token1 and pay it back, plus a fee, in the callback

The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback
Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling
with 0 amount{0,1} and sending the donation amount(s) from the callback

#### Parameters:

| Name        | Type    | Description                                                  |
| :---------- | :------ | :----------------------------------------------------------- |
| `recipient` | address | The address which will receive the token0 and token1 amounts |
| `amount0`   | uint256 | The amount of token0 to send                                 |
| `amount1`   | uint256 | The amount of token1 to send                                 |
| `data`      | bytes   | Any data to be passed through to the callback                |

### increaseObservationCardinalityNext

```solidity
  function increaseObservationCardinalityNext(
    uint16 observationCardinalityNext
  ) external
```

Increase the maximum number of price and liquidity observations that this pool will store

This method is no-op if the pool already has an observationCardinalityNext greater than or equal to
the input observationCardinalityNext.

#### Parameters:

| Name                         | Type   | Description                                                      |
| :--------------------------- | :----- | :--------------------------------------------------------------- |
| `observationCardinalityNext` | uint16 | The desired minimum number of observations for the pool to store |
</file>

<file path="docs/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolDerivedState.md">
Contains view functions to provide information about the pool that is computed rather than stored on the
blockchain. The functions here may have variable gas costs.

## Functions

### observe

```solidity
  function observe(
    uint32[] secondsAgos
  ) external view returns (int56[] tickCumulatives, uint160[] secondsPerLiquidityCumulativeX128s)
```

Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp

To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
you must call it with secondsAgos = [3600, 0].
The time weighted average tick represents the geometric time weighted average price of the pool, in
log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.

#### Parameters:

| Name          | Type     | Description                                                                   |
| :------------ | :------- | :---------------------------------------------------------------------------- |
| `secondsAgos` | uint32[] | From how long ago each cumulative tick and liquidity value should be returned |

#### Return Values:

| Name                                 | Type      | Description                                                                                     |
| :----------------------------------- | :-------- | :---------------------------------------------------------------------------------------------- |
| `tickCumulatives`                    | int56[]   | Cumulative tick values as of each `secondsAgos` from the current block timestamp                |
| `secondsPerLiquidityCumulativeX128s` | uint160[] | Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block |

timestamp

### snapshotCumulativesInside

```solidity
  function snapshotCumulativesInside(
    int24 tickLower,
    int24 tickUpper
  ) external returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside)
```

Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range

Snapshots must only be compared to other snapshots, taken over a period for which a position existed.
I.e., snapshots cannot be compared if a position is not held for the entire period between when the first
snapshot is taken and the second snapshot is taken.

#### Parameters:

| Name        | Type  | Description                 |
| :---------- | :---- | :-------------------------- |
| `tickLower` | int24 | The lower tick of the range |
| `tickUpper` | int24 | The upper tick of the range |

#### Return Values:

| Name                            | Type    | Description                                         |
| :------------------------------ | :------ | :-------------------------------------------------- |
| `tickCumulativeInside`          | int56   | The snapshot of the tick accumulator for the range  |
| `secondsPerLiquidityInsideX128` | uint160 | The snapshot of seconds per liquidity for the range |
| `secondsInside`                 | uint32  | The snapshot of seconds per liquidity for the range |
</file>

<file path="docs/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolEvents.md">
Contains all events emitted by the pool

## Events

### Initialize

```solidity
  event Initialize(
    uint160 sqrtPriceX96,
    int24 tick
  )
```

Emitted exactly once by a pool when #initialize is first called on the pool

Mint/Burn/Swap cannot be emitted by the pool before Initialize

#### Parameters:

| Name           | Type    | Description                                                                          |
| :------------- | :------ | :----------------------------------------------------------------------------------- |
| `sqrtPriceX96` | uint160 | The initial sqrt price of the pool, as a Q64.96                                      |
| `tick`         | int24   | The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool |

### Mint

```solidity
  event Mint(
    address sender,
    address owner,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount,
    uint256 amount0,
    uint256 amount1
  )
```

Emitted when liquidity is minted for a given position

#### Parameters:

| Name        | Type    | Description                                                     |
| :---------- | :------ | :-------------------------------------------------------------- |
| `sender`    | address | The address that minted the liquidity                           |
| `owner`     | address | The owner of the position and recipient of any minted liquidity |
| `tickLower` | int24   | The lower tick of the position                                  |
| `tickUpper` | int24   | The upper tick of the position                                  |
| `amount`    | uint128 | The amount of liquidity minted to the position range            |
| `amount0`   | uint256 | How much token0 was required for the minted liquidity           |
| `amount1`   | uint256 | How much token1 was required for the minted liquidity           |

### Collect

```solidity
  event Collect(
    address owner,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount0,
    uint128 amount1
  )
```

Emitted when fees are collected by the owner of a position

Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees

#### Parameters:

| Name        | Type    | Description                                            |
| :---------- | :------ | :----------------------------------------------------- |
| `owner`     | address | The owner of the position for which fees are collected |
| `tickLower` | int24   | The lower tick of the position                         |
| `tickUpper` | int24   | The upper tick of the position                         |
| `amount0`   | uint128 | The amount of token0 fees collected                    |
| `amount1`   | uint128 | The amount of token1 fees collected                    |

### Burn

```solidity
  event Burn(
    address owner,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount,
    uint256 amount0,
    uint256 amount1
  )
```

Emitted when a position's liquidity is removed

Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect

#### Parameters:

| Name        | Type    | Description                                              |
| :---------- | :------ | :------------------------------------------------------- |
| `owner`     | address | The owner of the position for which liquidity is removed |
| `tickLower` | int24   | The lower tick of the position                           |
| `tickUpper` | int24   | The upper tick of the position                           |
| `amount`    | uint128 | The amount of liquidity to remove                        |
| `amount0`   | uint256 | The amount of token0 withdrawn                           |
| `amount1`   | uint256 | The amount of token1 withdrawn                           |

### Swap

```solidity
  event Swap(
    address sender,
    address recipient,
    int256 amount0,
    int256 amount1,
    uint160 sqrtPriceX96,
    uint128 liquidity,
    int24 tick
  )
```

Emitted by the pool for any swaps between token0 and token1

#### Parameters:

| Name           | Type    | Description                                                              |
| :------------- | :------ | :----------------------------------------------------------------------- |
| `sender`       | address | The address that initiated the swap call, and that received the callback |
| `recipient`    | address | The address that received the output of the swap                         |
| `amount0`      | int256  | The delta of the token0 balance of the pool                              |
| `amount1`      | int256  | The delta of the token1 balance of the pool                              |
| `sqrtPriceX96` | uint160 | The sqrt(price) of the pool after the swap, as a Q64.96                  |
| `liquidity`    | uint128 | The liquidity of the pool after the swap                                 |
| `tick`         | int24   | The log base 1.0001 of price of the pool after the swap                  |

### Flash

```solidity
  event Flash(
    address sender,
    address recipient,
    uint256 amount0,
    uint256 amount1,
    uint256 paid0,
    uint256 paid1
  )
```

Emitted by the pool for any flashes of token0/token1

#### Parameters:

| Name        | Type    | Description                                                                        |
| :---------- | :------ | :--------------------------------------------------------------------------------- |
| `sender`    | address | The address that initiated the swap call, and that received the callback           |
| `recipient` | address | The address that received the tokens from flash                                    |
| `amount0`   | uint256 | The amount of token0 that was flashed                                              |
| `amount1`   | uint256 | The amount of token1 that was flashed                                              |
| `paid0`     | uint256 | The amount of token0 paid for the flash, which can exceed the amount0 plus the fee |
| `paid1`     | uint256 | The amount of token1 paid for the flash, which can exceed the amount1 plus the fee |

### IncreaseObservationCardinalityNext

```solidity
  event IncreaseObservationCardinalityNext(
    uint16 observationCardinalityNextOld,
    uint16 observationCardinalityNextNew
  )
```

Emitted by the pool for increases to the number of observations that can be stored

observationCardinalityNext is not the observation cardinality until an observation is written at the index
just before a mint/swap/burn.

#### Parameters:

| Name                            | Type   | Description                                            |
| :------------------------------ | :----- | :----------------------------------------------------- |
| `observationCardinalityNextOld` | uint16 | The previous value of the next observation cardinality |
| `observationCardinalityNextNew` | uint16 | The updated value of the next observation cardinality  |

### SetFeeProtocol

```solidity
  event SetFeeProtocol(
    uint8 feeProtocol0Old,
    uint8 feeProtocol1Old,
    uint8 feeProtocol0New,
    uint8 feeProtocol1New
  )
```

Emitted when the protocol fee is changed by the pool

#### Parameters:

| Name              | Type  | Description                                   |
| :---------------- | :---- | :-------------------------------------------- |
| `feeProtocol0Old` | uint8 | The previous value of the token0 protocol fee |
| `feeProtocol1Old` | uint8 | The previous value of the token1 protocol fee |
| `feeProtocol0New` | uint8 | The updated value of the token0 protocol fee  |
| `feeProtocol1New` | uint8 | The updated value of the token1 protocol fee  |

### CollectProtocol

```solidity
  event CollectProtocol(
    address sender,
    address recipient,
    uint128 amount0,
    uint128 amount1
  )
```

Emitted when the collected protocol fees are withdrawn by the factory owner

#### Parameters:

| Name        | Type    | Description                                           |
| :---------- | :------ | :---------------------------------------------------- |
| `sender`    | address | The address that collects the protocol fees           |
| `recipient` | address | The address that receives the collected protocol fees |
| `amount0`   | uint128 | The amount of token0 protocol fees that is withdrawn  |
| `amount1`   | uint128 | The amount of token1 protocol fees that is withdrawn  |
</file>

<file path="docs/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolImmutables.md">
These parameters are fixed for a pool forever, i.e., the methods will always return the same values

## Functions

### factory

```solidity
  function factory(
  ) external view returns (address)
```

The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface

#### Return Values:

| Type    | Description      |
| :------ | :--------------- |
| address | contract address |

### token0

```solidity
  function token0(
  ) external view returns (address)
```

The first of the two tokens of the pool, sorted by address

#### Return Values:

| Type    | Description            |
| :------ | :--------------------- |
| address | token contract address |

### token1

```solidity
  function token1(
  ) external view returns (address)
```

The second of the two tokens of the pool, sorted by address

#### Return Values:

| Type    | Description            |
| :------ | :--------------------- |
| address | token contract address |

### fee

```solidity
  function fee(
  ) external view returns (uint24)
```

The pool's fee in hundredths of a bip, i.e. 1e-6

#### Return Values:

| Type   | Description |
| :----- | :---------- |
| uint24 | fee         |

### tickSpacing

```solidity
  function tickSpacing(
  ) external view returns (int24)
```

The pool tick spacing

Ticks can only be used at multiples of this value, minimum of 1 and always positive
e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
This value is an int24 to avoid casting even though it is always positive.

#### Return Values:

| Type  | Description  |
| :---- | :----------- |
| int24 | tick spacing |

### maxLiquidityPerTick

```solidity
  function maxLiquidityPerTick(
  ) external view returns (uint128)
```

The maximum amount of position liquidity that can use any tick in the range

This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool

#### Return Values:

| Type    | Description                      |
| :------ | :------------------------------- |
| uint128 | max amount of liquidity per tick |
</file>

<file path="docs/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolOwnerActions.md">
Contains pool methods that may only be called by the factory owner

## Functions

### setFeeProtocol

```solidity
  function setFeeProtocol(
    uint8 feeProtocol0,
    uint8 feeProtocol1
  ) external
```

Set the denominator of the protocol's % share of the fees

#### Parameters:

| Name           | Type  | Description                             |
| :------------- | :---- | :-------------------------------------- |
| `feeProtocol0` | uint8 | new protocol fee for token0 of the pool |
| `feeProtocol1` | uint8 | new protocol fee for token1 of the pool |

### collectProtocol

```solidity
  function collectProtocol(
    address recipient,
    uint128 amount0Requested,
    uint128 amount1Requested
  ) external returns (uint128 amount0, uint128 amount1)
```

Collect the protocol fee accrued to the pool

#### Parameters:

| Name               | Type    | Description                                                                   |
| :----------------- | :------ | :---------------------------------------------------------------------------- |
| `recipient`        | address | The address to which collected protocol fees should be sent                   |
| `amount0Requested` | uint128 | The maximum amount of token0 to send, can be 0 to collect fees in only token1 |
| `amount1Requested` | uint128 | The maximum amount of token1 to send, can be 0 to collect fees in only token0 |

#### Return Values:

| Name      | Type    | Description                          |
| :-------- | :------ | :----------------------------------- |
| `amount0` | uint128 | The protocol fee collected in token0 |
| `amount1` | uint128 | The protocol fee collected in token1 |
</file>

<file path="docs/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolState.md">
These methods compose the pool's state, and can change with any frequency including multiple times
per transaction

## Functions

### slot0

```solidity
  function slot0(
  ) external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked)
```

The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
when accessed externally.

#### Return Values:

| Name                         | Type    | Description                                                                                                                                                                                                                                                                |
| :--------------------------- | :------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `sqrtPriceX96`               | uint160 | The current price of the pool as a sqrt(token1/token0) Q64.96 value                                                                                                                                                                                                        |
| `tick`                       | int24   | The current tick of the pool, i.e. according to the last tick transition that was run. This value may not always be equal to SqrtTickMath getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick boundary.                                                             |
| `observationIndex`           | uint16  | The index of the last oracle observation that was written,                                                                                                                                                                                                                 |
| `observationCardinality`     | uint16  | The current maximum number of observations stored in the pool,                                                                                                                                                                                                             |
| `observationCardinalityNext` | uint16  | The next maximum number of observations, to be updated when the observation.                                                                                                                                                                                               |
| `feeProtocol`                | uint8   | The protocol fee for both tokens of the pool. Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0is the lower 4 bits.Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee. |
| `unlocked`                   | bool    | Whether the pool is currently locked to reentrancy                                                                                                                                                                                                                         |

### feeGrowthGlobal0X128

```solidity
  function feeGrowthGlobal0X128(
  ) external view returns (uint256)
```

The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool

This value can overflow the uint256

### feeGrowthGlobal1X128

```solidity
  function feeGrowthGlobal1X128(
  ) external view returns (uint256)
```

The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool

This value can overflow the uint256

### protocolFees

```solidity
  function protocolFees(
  ) external view returns (uint128 token0, uint128 token1)
```

The amounts of token0 and token1 that are owed to the protocol

Protocol fees will never exceed uint128 max in either token

### liquidity

```solidity
  function liquidity(
  ) external view returns (uint128)
```

The currently in range liquidity available to the pool

This value has no relationship to the total liquidity across all ticks

### ticks

```solidity
  function ticks(
    int24 tick
  ) external view returns (uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128, int56 tickCumulativeOutside, uint160 secondsPerLiquidityOutsideX128, uint32 secondsOutside, bool initialized)
```

Look up information about a specific tick in the pool

#### Parameters:

| Name   | Type  | Description         |
| :----- | :---- | :------------------ |
| `tick` | int24 | The tick to look up |

#### Return Values:

| Name                             | Type    | Description                                                                                                                                                                                                                                                                     |
| :------------------------------- | :------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `liquidityGross`                 | uint128 | the total amount of position liquidity that uses the pool either as tick lower or tick upper,                                                                                                                                                                                   |
| `liquidityNet`                   | int128  | how much liquidity changes when the pool price crosses the tick,                                                                                                                                                                                                                |
| `feeGrowthOutside0X128`          | uint256 | the fee growth on the other side of the tick from the current tick in token0,                                                                                                                                                                                                   |
| `feeGrowthOutside1X128`          | uint256 | the fee growth on the other side of the tick from the current tick in token1, feeGrowthOutsideX128 values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0. In addition, these values are only relative and are used to compute snapshots. |
| `tickCumulativeOutside`          | int56   |                                                                                                                                                                                                                                                                                 |
| `secondsPerLiquidityOutsideX128` | uint160 |                                                                                                                                                                                                                                                                                 |
| `secondsOutside`                 | uint32  |                                                                                                                                                                                                                                                                                 |
| `initialized`                    | bool    |                                                                                                                                                                                                                                                                                 |

a specific position.

### tickBitmap

```solidity
  function tickBitmap(
      int16 wordPosition
  ) external view returns (uint256)
```

Returns 256 packed tick initialized boolean values. See TickBitmap for more information

### positions

```solidity
  function positions(
    bytes32 key
  ) external view returns (uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1)
```

Returns the information about a position by the position's key

#### Parameters:

| Name  | Type    | Description                                                                               |
| :---- | :------ | :---------------------------------------------------------------------------------------- |
| `key` | bytes32 | The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper |

#### Return Values:

| Name                       | Type    | Description                                                                       |
| :------------------------- | :------ | :-------------------------------------------------------------------------------- |
| `_liquidity`               | bytes32 | The amount of liquidity in the position,                                          |
| `feeGrowthInside0LastX128` | uint256 | fee growth of token0 inside the tick range as of the last mint/burn/poke,         |
| `feeGrowthInside1LastX128` | uint256 | fee growth of token1 inside the tick range as of the last mint/burn/poke,         |
| `tokensOwed0`              | uint128 | the computed amount of token0 owed to the position as of the last mint/burn/poke, |
| `tokensOwed1`              | uint128 | the computed amount of token1 owed to the position as of the last mint/burn/poke  |

### observations

```solidity
  function observations(
    uint256 index
  ) external view returns (uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized)
```

Returns data about a specific observation index

You most likely want to use #observe() instead of this method to get an observation as of some amount of time
ago, rather than at a specific index in the array.

#### Parameters:

| Name    | Type    | Description                                    |
| :------ | :------ | :--------------------------------------------- |
| `index` | uint256 | The element of the observations array to fetch |

#### Return Values:

| Name                                | Type    | Description                                                                                      |
| :---------------------------------- | :------ | :----------------------------------------------------------------------------------------------- |
| `blockTimestamp`                    | uint256 | The timestamp of the observation,                                                                |
| `tickCumulative`                    | int56   | the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp, |
| `secondsPerLiquidityCumulativeX128` | uint160 | the seconds per in range liquidity for the life of the pool as of the observation timestamp      |
| `initialized`                       | bool    | whether the observation has been initialized and the values are safe to use                      |
</file>

<file path="docs/contracts/v3/reference/core/interfaces/_category_.json">
{
  "label": "Interfaces"
}
</file>

<file path="docs/contracts/v3/reference/core/interfaces/IERC20Minimal.md">
Contains a subset of the full ERC20 interface that is used in Uniswap V3

## Functions

### balanceOf

```solidity
  function balanceOf(
    address account
  ) external view returns (uint256)
```

Returns the balance of a token

#### Parameters:

| Name      | Type    | Description                                                                    |
| :-------- | :------ | :----------------------------------------------------------------------------- |
| `account` | address | The account for which to look up the number of tokens it has, i.e. its balance |

#### Return Values:

| Type    | Description                          |
| :------ | :----------------------------------- |
| uint256 | number of tokens held by the account |

### transfer

```solidity
  function transfer(
    address recipient,
    uint256 amount
  ) external returns (bool)
```

Transfers the amount of token from the `msg.sender` to the recipient

#### Parameters:

| Name        | Type    | Description                                                   |
| :---------- | :------ | :------------------------------------------------------------ |
| `recipient` | address | The account that will receive the amount transferred          |
| `amount`    | uint256 | The number of tokens to send from the sender to the recipient |

#### Return Values:

| Type | Description                                                        |
| :--- | :----------------------------------------------------------------- |
| bool | true for a successful transfer, false for an unsuccessful transfer |

### allowance

```solidity
  function allowance(
    address owner,
    address spender
  ) external view returns (uint256)
```

Returns the current allowance given to a spender by an owner

#### Parameters:

| Name      | Type    | Description                      |
| :-------- | :------ | :------------------------------- |
| `owner`   | address | The account of the token owner   |
| `spender` | address | The account of the token spender |

#### Return Values:

| Type    | Description                                       |
| :------ | :------------------------------------------------ |
| uint256 | current allowance granted by `owner` to `spender` |

### approve

```solidity
  function approve(
    address spender,
    uint256 amount
  ) external returns (bool)
```

Sets the allowance of a spender from the `msg.sender` to the value `amount`

#### Parameters:

| Name      | Type    | Description                                                                    |
| :-------- | :------ | :----------------------------------------------------------------------------- |
| `spender` | address | The account which will be allowed to spend a given amount of the owners tokens |
| `amount`  | uint256 | The amount of tokens allowed to be used by `spender`                           |

#### Return Values:

| Type | Description                                            |
| :--- | :----------------------------------------------------- |
| bool | true for a successful approval, false for unsuccessful |

### transferFrom

```solidity
  function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) external returns (bool)
```

Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`

#### Parameters:

| Name        | Type    | Description                                           |
| :---------- | :------ | :---------------------------------------------------- |
| `sender`    | address | The account from which the transfer will be initiated |
| `recipient` | address | The recipient of the transfer                         |
| `amount`    | uint256 | The amount of the transfer                            |

#### Return Values:

| Type | Description                                            |
| :--- | :----------------------------------------------------- |
| bool | true for a successful transfer, false for unsuccessful |

## Events

### Transfer

```solidity
  event Transfer(
    address from,
    address to,
    uint256 value
  )
```

Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.

#### Parameters:

| Name    | Type    | Description                                                             |
| :------ | :------ | :---------------------------------------------------------------------- |
| `from`  | address | The account from which the tokens were sent, i.e. the balance decreased |
| `to`    | address | The account to which the tokens were sent, i.e. the balance increased   |
| `value` | uint256 | The amount of tokens that were transferred                              |

### Approval

```solidity
  event Approval(
    address owner,
    address spender,
    uint256 value
  )
```

Event emitted when the approval amount for the spender of a given owner's tokens changes.

#### Parameters:

| Name      | Type    | Description                                               |
| :-------- | :------ | :-------------------------------------------------------- |
| `owner`   | address | The account that approved spending of its tokens          |
| `spender` | address | The account for which the spending allowance was modified |
| `value`   | uint256 | The new allowance from the owner to the spender           |
</file>

<file path="docs/contracts/v3/reference/core/interfaces/IUniswapV3Factory.md">
The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees

## Functions

### owner

```solidity
  function owner(
  ) external view returns (address)
```

Returns the current owner of the factory

Can be changed by the current owner via setOwner

#### Return Values:

| Type    | Description                  |
| :------ | :--------------------------- |
| address | address of the factory owner |

### feeAmountTickSpacing

```solidity
  function feeAmountTickSpacing(
    uint24 fee
  ) external view returns (int24)
```

Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled

A fee amount can never be removed, so this value should be hard coded or cached in the calling context

#### Parameters:

| Name  | Type   | Description                                                                             |
| :---- | :----- | :-------------------------------------------------------------------------------------- |
| `fee` | uint24 | The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee |

#### Return Values:

| Type  | Description  |
| :---- | :----------- |
| int24 | tick spacing |

### getPool

```solidity
  function getPool(
    address tokenA,
    address tokenB,
    uint24 fee
  ) external view returns (address pool)
```

Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist

tokenA and tokenB may be passed in either token0/token1 or token1/token0 order

#### Parameters:

| Name     | Type    | Description                                                                       |
| :------- | :------ | :-------------------------------------------------------------------------------- |
| `tokenA` | address | The contract address of either token0 or token1                                   |
| `tokenB` | address | The contract address of the other token                                           |
| `fee`    | uint24  | The fee collected upon every swap in the pool, denominated in hundredths of a bip |

#### Return Values:

| Name   | Type    | Description      |
| :----- | :------ | :--------------- |
| `pool` | address | The pool address |

### createPool

```solidity
  function createPool(
    address tokenA,
    address tokenB,
    uint24 fee
  ) external returns (address pool)
```

Creates a pool for the given two tokens and fee

tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
are invalid.

#### Parameters:

| Name     | Type    | Description                                     |
| :------- | :------ | :---------------------------------------------- |
| `tokenA` | address | One of the two tokens in the desired pool       |
| `tokenB` | address | The other of the two tokens in the desired pool |
| `fee`    | uint24  | The desired fee for the pool                    |

#### Return Values:

| Name   | Type    | Description                           |
| :----- | :------ | :------------------------------------ |
| `pool` | address | The address of the newly created pool |

### setOwner

```solidity
  function setOwner(
    address _owner
  ) external
```

Updates the owner of the factory

Must be called by the current owner

#### Parameters:

| Name     | Type    | Description                  |
| :------- | :------ | :--------------------------- |
| `_owner` | address | The new owner of the factory |

### enableFeeAmount

```solidity
  function enableFeeAmount(
    uint24 fee,
    int24 tickSpacing
  ) external
```

Enables a fee amount with the given tickSpacing

Fee amounts may never be removed once enabled

#### Parameters:

| Name          | Type   | Description                                                                              |
| :------------ | :----- | :--------------------------------------------------------------------------------------- |
| `fee`         | uint24 | The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)                 |
| `tickSpacing` | int24  | The spacing between ticks to be enforced for all pools created with the given fee amount |

## Events

### OwnerChanged

```solidity
  event OwnerChanged(
    address oldOwner,
    address newOwner
  )
```

Emitted when the owner of the factory is changed

#### Parameters:

| Name       | Type    | Description                            |
| :--------- | :------ | :------------------------------------- |
| `oldOwner` | address | The owner before the owner was changed |
| `newOwner` | address | The owner after the owner was changed  |

### PoolCreated

```solidity
  event PoolCreated(
    address token0,
    address token1,
    uint24 fee,
    int24 tickSpacing,
    address pool
  )
```

Emitted when a pool is created

#### Parameters:

| Name          | Type    | Description                                                                       |
| :------------ | :------ | :-------------------------------------------------------------------------------- |
| `token0`      | address | The first token of the pool by address sort order                                 |
| `token1`      | address | The second token of the pool by address sort order                                |
| `fee`         | uint24  | The fee collected upon every swap in the pool, denominated in hundredths of a bip |
| `tickSpacing` | int24   | The minimum number of ticks between initialized ticks                             |
| `pool`        | address | The address of the created pool                                                   |

### FeeAmountEnabled

```solidity
  event FeeAmountEnabled(
    uint24 fee,
    int24 tickSpacing
  )
```

Emitted when a new fee amount is enabled for pool creation via the factory

#### Parameters:

| Name          | Type   | Description                                                                                |
| :------------ | :----- | :----------------------------------------------------------------------------------------- |
| `fee`         | uint24 | The enabled fee, denominated in hundredths of a bip                                        |
| `tickSpacing` | int24  | The minimum number of ticks between initialized ticks for pools created with the given fee |
</file>

<file path="docs/contracts/v3/reference/core/interfaces/IUniswapV3Pool.md">
A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
to the ERC20 specification

The pool interface is broken up into many smaller pieces
</file>

<file path="docs/contracts/v3/reference/core/interfaces/IUniswapV3PoolDeployer.md">
A contract that constructs a pool must implement this to pass arguments to the pool

This is used to avoid having constructor arguments in the pool contract, which results in the init code hash
of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain

## Functions

### parameters

```solidity
  function parameters(
  ) external view returns (address factory, address token0, address token1, uint24 fee, int24 tickSpacing)
```

Get the parameters to be used in constructing the pool, set transiently during pool creation.

#### Return Values :

| Name          | Type    | Description                                                                       |
| :------------ | :------ | :-------------------------------------------------------------------------------- |
| `factory `    | address | The factory address                                                               |
| `token0`      | address | The first token of the pool by address sort order                                 |
| `token1`      | address | The second token of the pool by address sort order                                |
| `fee `        | uint24  | The fee collected upon every swap in the pool, denominated in hundredths of a bip |
| `tickSpacing` | int24   | The minimum number of ticks between initialized ticks                             |
</file>

<file path="docs/contracts/v3/reference/core/libraries/_category_.json">
{
  "label": "Libraries"
}
</file>

<file path="docs/contracts/v3/reference/core/libraries/BitMath.md">
This library provides functionality for computing bit properties of an unsigned integer

## Functions

### mostSignificantBit

```solidity
  function mostSignificantBit(
    uint256 x
  ) internal pure returns (uint8 r)
```

Returns the index of the most significant bit of the number,
where the least significant bit is at index 0 and the most significant bit is at index 255

The function satisfies the property:
x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)

#### Parameters:

| Name | Type    | Description                                                                     |
| :--- | :------ | :------------------------------------------------------------------------------ |
| `x`  | uint256 | the value for which to compute the most significant bit, must be greater than 0 |

#### Return Values:

| Name | Type  | Description                           |
| :--- | :---- | :------------------------------------ |
| `r`  | unit8 | the index of the most significant bit |

### leastSignificantBit

```solidity
  function leastSignificantBit(
    uint256 x
  ) internal pure returns (uint8 r)
```

Returns the index of the least significant bit of the number,
where the least significant bit is at index 0 and the most significant bit is at index 255

The function satisfies the property:
(x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)

#### Parameters:

| Name | Type    | Description                                                                      |
| :--- | :------ | :------------------------------------------------------------------------------- |
| `x`  | uint256 | the value for which to compute the least significant bit, must be greater than 0 |

#### Return Values:

| Name | Type  | Description                            |
| :--- | :---- | :------------------------------------- |
| `r`  | unit8 | the index of the least significant bit |
</file>

<file path="docs/contracts/v3/reference/core/libraries/FixedPoint128.md">
A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
</file>

<file path="docs/contracts/v3/reference/core/libraries/FixedPoint96.md">
A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)

Used in SqrtPriceMath.sol
</file>

<file path="docs/contracts/v3/reference/core/libraries/FullMath.md">
Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision

Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits

## Functions

### mulDiv

```solidity
  function mulDiv(
    uint256 a,
    uint256 b,
    uint256 denominator
  ) internal pure returns (uint256 result)
```

Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0

Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv

#### Parameters:

| Name          | Type    | Description      |
| :------------ | :------ | :--------------- |
| `a`           | uint256 | The multiplicand |
| `b`           | uint256 | The multiplier   |
| `denominator` | uint256 | The divisor      |

#### Return Values:

| Name     | Type    | Description        |
| :------- | :------ | :----------------- |
| `result` | uint256 | The 256-bit result |

### mulDivRoundingUp

```solidity
  function mulDivRoundingUp(
    uint256 a,
    uint256 b,
    uint256 denominator
  ) internal pure returns (uint256 result)
```

Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0

#### Parameters:

| Name          | Type    | Description      |
| :------------ | :------ | :--------------- |
| `a`           | uint256 | The multiplicand |
| `b`           | uint256 | The multiplier   |
| `denominator` | uint256 | The divisor      |

#### Return Values:

| Name     | Type    | Description        |
| :------- | :------ | :----------------- |
| `result` | uint256 | The 256-bit result |
</file>

<file path="docs/contracts/v3/reference/core/libraries/LiquidityMath.md">
## Functions

### addDelta

```solidity
  function addDelta(
    uint128 x,
    int128 y
  ) internal pure returns (uint128 z)
```

Add a signed liquidity delta to liquidity and revert if it overflows or underflows

#### Parameters:

| Name | Type    | Description                                    |
| :--- | :------ | :--------------------------------------------- |
| `x`  | uint128 | The liquidity before change                    |
| `y`  | int128  | The delta by which liquidity should be changed |

#### Return Values:

| Name | Type    | Description         |
| :--- | :------ | :------------------ |
| `z`  | uint128 | The liquidity delta |
</file>

<file path="docs/contracts/v3/reference/core/libraries/LowGasSafeMath.md">
Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost

## Functions

### add

```solidity
  function add(
    uint256 x,
    uint256 y
  ) internal pure returns (uint256 z)
```

Returns x + y, reverts if sum overflows uint256

#### Parameters:

| Name | Type    | Description |
| :--- | :------ | :---------- |
| `x`  | uint256 | The augend  |
| `y`  | uint256 | The addend  |

#### Return Values:

| Name | Type    | Description        |
| :--- | :------ | :----------------- |
| `z`  | uint256 | The sum of x and y |

### sub

```solidity
  function sub(
    uint256 x,
    uint256 y
  ) internal pure returns (uint256 z)
```

Returns x - y, reverts if underflows

#### Parameters:

| Name | Type    | Description    |
| :--- | :------ | :------------- |
| `x`  | uint256 | The minuend    |
| `y`  | uint256 | The subtrahend |

#### Return Values:

| Name | Type    | Description               |
| :--- | :------ | :------------------------ |
| `z`  | uint256 | The difference of x and y |

### mul

```solidity
  function mul(
    uint256 x,
    uint256 y
  ) internal pure returns (uint256 z)
```

Returns x \* y, reverts if overflows

#### Parameters:

| Name | Type    | Description      |
| :--- | :------ | :--------------- |
| `x`  | uint256 | The multiplicand |
| `y`  | uint256 | The multiplier   |

#### Return Values:

| Name | Type    | Description            |
| :--- | :------ | :--------------------- |
| `z`  | uint256 | The product of x and y |

### add

```solidity
  function add(
    int256 x,
    int256 y
  ) internal pure returns (int256 z)
```

Returns x + y, reverts if overflows or underflows

#### Parameters:

| Name | Type   | Description |
| :--- | :----- | :---------- |
| `x`  | int256 | The augend  |
| `y`  | int256 | The addend  |

#### Return Values:

| Name | Type   | Description        |
| :--- | :----- | :----------------- |
| `z`  | int256 | The sum of x and y |

### sub

```solidity
  function sub(
    int256 x,
    int256 y
  ) internal pure returns (int256 z)
```

Returns x - y, reverts if overflows or underflows

#### Parameters:

| Name | Type   | Description    |
| :--- | :----- | :------------- |
| `x`  | int256 | The minuend    |
| `y`  | int256 | The subtrahend |

#### Return Values:

| Name | Type   | Description               |
| :--- | :----- | :------------------------ |
| `z`  | int256 | The difference of x and y |
</file>

<file path="docs/contracts/v3/reference/core/libraries/Oracle.md">
Provides price and liquidity data useful for a wide variety of system designs

Instances of stored oracle data, "observations", are collected in the oracle array
Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the
maximum length of the oracle array. New slots will be added when the array is fully populated.
Observations are overwritten when the full length of the oracle array is populated.
The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()

## Functions

### initialize

```solidity
  function initialize(
    struct Oracle.Observation[65535] self,
    uint32 time
  ) internal returns (uint16 cardinality, uint16 cardinalityNext)
```

Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array

#### Parameters:

| Name   | Type                             | Description                                                                    |
| :----- | :------------------------------- | :----------------------------------------------------------------------------- |
| `self` | struct Oracle.Observation[65535] | The stored oracle array                                                        |
| `time` | uint32                           | The time of the oracle initialization, via block.timestamp truncated to uint32 |

#### Return Values:

| Name              | Type   | Description                                                   |
| :---------------- | :----- | :------------------------------------------------------------ |
| `cardinality`     | uint16 | The number of populated elements in the oracle array          |
| `cardinalityNext` | uint16 | The new length of the oracle array, independent of population |

### write

```solidity
  function write(
    struct Oracle.Observation[65535] self,
    uint16 index,
    uint32 blockTimestamp,
    int24 tick,
    uint128 liquidity,
    uint16 cardinality,
    uint16 cardinalityNext
  ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated)
```

Writes an oracle observation to the array

Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.
If the index is at the end of the allowable array length (according to cardinality), and the next cardinality
is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.

#### Parameters:

| Name              | Type                             | Description                                                     |
| :---------------- | :------------------------------- | :-------------------------------------------------------------- |
| `self`            | struct Oracle.Observation[65535] | The stored oracle array                                         |
| `index`           | uint16                           | The location of the most recently updated observation           |
| `blockTimestamp`  | uint32                           | The timestamp of the new observation                            |
| `tick`            | int24                            | The active tick at the time of the new observation              |
| `liquidity`       | uint128                          | The total in-range liquidity at the time of the new observation |
| `cardinality`     | uint16                           | The number of populated elements in the oracle array            |
| `cardinalityNext` | uint16                           | The new length of the oracle array, independent of population   |

#### Return Values:

| Name                 | Type   | Description                                                            |
| :------------------- | :----- | :--------------------------------------------------------------------- |
| `indexUpdated`       | uint16 | The new index of the most recently written element in the oracle array |
| `cardinalityUpdated` | uint16 | The new cardinality of the oracle array                                |

### grow

```solidity
  function grow(
    struct Oracle.Observation[65535] self,
    uint16 current,
    uint16 next
  ) internal returns (uint16)
```

Prepares the oracle array to store up to `next` observations

#### Parameters:

| Name      | Type                             | Description                                                               |
| :-------- | :------------------------------- | :------------------------------------------------------------------------ |
| `self`    | struct Oracle.Observation[65535] | The stored oracle array                                                   |
| `current` | uint16                           | The current next cardinality of the oracle array                          |
| `next`    | uint16                           | The proposed next cardinality which will be populated in the oracle array |

#### Return Values:

| Name   | Type   | Description                                                      |
| :----- | :----- | :--------------------------------------------------------------- |
| `next` | uint16 | The next cardinality which will be populated in the oracle array |

### observe

```solidity
  function observe(
    struct Oracle.Observation[65535] self,
    uint32 time,
    uint32[] secondsAgos,
    int24 tick,
    uint16 index,
    uint128 liquidity,
    uint16 cardinality
  ) internal view returns (int56[] tickCumulatives, uint160[] liquidityCumulatives)
```

Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`

Reverts if `secondsAgos` > oldest observation

#### Parameters:

| Name          | Type                             | Description                                                                           |
| :------------ | :------------------------------- | :------------------------------------------------------------------------------------ |
| `self`        | struct Oracle.Observation[65535] | The stored oracle array                                                               |
| `time`        | uint32                           | The current block.timestamp                                                           |
| `secondsAgos` | uint32[]                         | Each amount of time to look back, in seconds, at which point to return an observation |
| `tick`        | int24                            | The current tick                                                                      |
| `index`       | uint16                           | The location of a given observation within the oracle array                           |
| `liquidity`   | uint128                          | The current in-range pool liquidity                                                   |
| `cardinality` | uint16                           | The number of populated elements in the oracle array                                  |

#### Return Values:

| Name                   | Type      | Description                                                                                 |
| :--------------------- | :-------- | :------------------------------------------------------------------------------------------ |
| `tickCumulatives`      | int56[]   | The tick \* time elapsed since the pool was first initialized, as of each `secondsAgo`      |
| `liquidityCumulatives` | uint160[] | The liquidity \* time elapsed since the pool was first initialized, as of each `secondsAgo` |
</file>

<file path="docs/contracts/v3/reference/core/libraries/Position.md">
Positions represent an owner address' liquidity between a lower and upper tick boundary

Positions store additional state for tracking fees owed to the position

## Functions

### get

```solidity
  function get(
    mapping(bytes32 => struct Position.Info) self,
    address owner,
    int24 tickLower,
    int24 tickUpper
  ) internal view returns (struct Position.Info position)
```

Returns the Info struct of a position, given an owner and position boundaries

#### Parameters:

| Name        | Type                                     | Description                               |
| :---------- | :--------------------------------------- | :---------------------------------------- |
| `self`      | mapping(bytes32 => struct Position.Info) | The mapping containing all user positions |
| `owner`     | address                                  | The address of the position owner         |
| `tickLower` | int24                                    | The lower tick boundary of the position   |
| `tickUpper` | int24                                    | The upper tick boundary of the position   |

#### Return Values:

| Name       | Type                 | Description                                            |
| :--------- | :------------------- | :----------------------------------------------------- |
| `position` | struct Position.Info | The position info struct of the given owners' position |

### update

```solidity
  function update(
    struct Position.Info self,
    int128 liquidityDelta,
    uint256 feeGrowthInside0X128,
    uint256 feeGrowthInside1X128
  ) internal
```

Credits accumulated fees to a user's position

#### Parameters:

| Name                   | Type                 | Description                                                                                     |
| :--------------------- | :------------------- | :---------------------------------------------------------------------------------------------- |
| `self`                 | struct Position.Info | The mapping containing all user positions                                                       |
| `liquidityDelta`       | int128               | The change in pool liquidity as a result of the position update                                 |
| `feeGrowthInside0X128` | uint256              | The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries |
| `feeGrowthInside1X128` | uint256              | The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries |
</file>

<file path="docs/contracts/v3/reference/core/libraries/SafeCast.md">
Contains methods for safely casting between types

## Functions

### toUint160

```solidity
  function toUint160(
    uint256 y
  ) internal pure returns (uint160 z)
```

Cast a uint256 to a uint160, revert on overflow

#### Parameters:

| Name | Type    | Description                  |
| :--- | :------ | :--------------------------- |
| `y`  | uint256 | The uint256 to be downcasted |

#### Return Values:

| Name | Type    | Description                              |
| :--- | :------ | :--------------------------------------- |
| `z`  | uint160 | The downcasted integer, now type uint160 |

### toInt128

```solidity
  function toInt128(
    int256 y
  ) internal pure returns (int128 z)
```

Cast a int256 to a int128, revert on overflow or underflow

#### Parameters:

| Name | Type   | Description                 |
| :--- | :----- | :-------------------------- |
| `y`  | int256 | The int256 to be downcasted |

#### Return Values:

| Name | Type   | Description                             |
| :--- | :----- | :-------------------------------------- |
| `z`  | int128 | The downcasted integer, now type int128 |

### toInt256

```solidity
  function toInt256(
    uint256 y
  ) internal pure returns (int256 z)
```

Cast a uint256 to a int256, revert on overflow

#### Parameters:

| Name | Type    | Description              |
| :--- | :------ | :----------------------- |
| `y`  | uint256 | The uint256 to be casted |

#### Return Values:

| Name | Type   | Description                         |
| :--- | :----- | :---------------------------------- |
| `z`  | int256 | The casted integer, now type int256 |
</file>

<file path="docs/contracts/v3/reference/core/libraries/SecondsOutside.md">
Contains methods for working with a mapping from tick to 32 bit timestamp values, specifically seconds
spent outside the tick.

The mapping uses int24 for keys since ticks are represented as int24 and there are 8 (2^3) values per word.
Note "seconds outside" is always a relative measurement, only consistent for as long as a the lower tick and upper tick
have gross liquidity greater than 0.

## Functions

### initialize

```solidity
  function initialize(
    mapping(int24 => uint256) self,
    int24 tick,
    int24 tickCurrent,
    int24 tickSpacing,
    uint32 time
  ) internal
```

Called the first time a tick is used to set the seconds outside value. Assumes the tick is not
initialized.

#### Parameters:

| Name          | Type                      | Description                                   |
| :------------ | :------------------------ | :-------------------------------------------- |
| `self`        | mapping(int24 => uint256) | the packed mapping of tick to seconds outside |
| `tick`        | int24                     | the tick to be initialized                    |
| `tickCurrent` | int24                     | the current tick                              |
| `tickSpacing` | int24                     | the spacing between usable ticks              |
| `time`        | uint32                    | the current timestamp                         |

### clear

```solidity
  function clear(
    mapping(int24 => uint256) self,
    int24 tick,
    int24 tickSpacing
  ) internal
```

Called when a tick is no longer used, to clear the seconds outside value of the tick

#### Parameters:

| Name          | Type                      | Description                                   |
| :------------ | :------------------------ | :-------------------------------------------- |
| `self`        | mapping(int24 => uint256) | the packed mapping of tick to seconds outside |
| `tick`        | int24                     | the tick to be cleared                        |
| `tickSpacing` | int24                     | the spacing between usable ticks              |

### cross

```solidity
  function cross(
    mapping(int24 => uint256) self,
    int24 tick,
    int24 tickSpacing,
    uint32 time
  ) internal
```

Called when an initialized tick is crossed to update the seconds outside for that tick. Must be called
every time an initialized tick is crossed

#### Parameters:

| Name          | Type                      | Description                                      |
| :------------ | :------------------------ | :----------------------------------------------- |
| `self`        | mapping(int24 => uint256) | the packed mapping of tick to seconds outside    |
| `tick`        | int24                     | the tick to be crossed                           |
| `tickSpacing` | int24                     | the spacing between usable ticks                 |
| `time`        | uint32                    | the current block timestamp truncated to 32 bits |

### get

```solidity
  function get(
    mapping(int24 => uint256) self,
    int24 tick,
    int24 tickSpacing
  ) internal view returns (uint32)
```

Get the seconds outside for an initialized tick. Should be called only on initialized ticks.

#### Parameters:

| Name          | Type                      | Description                                   |
| :------------ | :------------------------ | :-------------------------------------------- |
| `self`        | mapping(int24 => uint256) | the packed mapping of tick to seconds outside |
| `tick`        | int24                     | the tick to get the seconds outside value for |
| `tickSpacing` | int24                     | the spacing between usable ticks              |

#### Return Values:

| Type   | Description                         |
| :----- | :---------------------------------- |
| uint32 | seconds outside value for that tick |

### secondsInside

```solidity
  function secondsInside(
    mapping(int24 => uint256) self,
    int24 tickLower,
    int24 tickUpper,
    int24 tickCurrent,
    int24 tickSpacing
  ) internal view returns (uint32)
```

Get the seconds inside a tick range, assuming both tickLower and tickUpper are initialized

#### Parameters:

| Name          | Type                      | Description                                    |
| :------------ | :------------------------ | :--------------------------------------------- |
| `self`        | mapping(int24 => uint256) | the packed mapping of tick to seconds outside  |
| `tickLower`   | int24                     | the lower tick for which to get seconds inside |
| `tickUpper`   | int24                     | the upper tick for which to get seconds inside |
| `tickCurrent` | int24                     | the current tick                               |
| `tickSpacing` | int24                     | the spacing between usable ticks               |

#### Return Values:

| Name | Type   | Description                                                                                       |
| :--- | :----- | :------------------------------------------------------------------------------------------------ |
| `a`  | uint32 | relative seconds inside value that can be snapshotted and compared to a later snapshot to compute |

time spent between tickLower and tickUpper, i.e. time that a position's liquidity was in use.
</file>

<file path="docs/contracts/v3/reference/core/libraries/SqrtPriceMath.md">
Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas

## Functions

### getNextSqrtPriceFromAmount0RoundingUp

```solidity
  function getNextSqrtPriceFromAmount0RoundingUp(
    uint160 sqrtPX96,
    uint128 liquidity,
    uint256 amount,
    bool add
  ) internal pure returns (uint160)
```

Gets the next sqrt price given a delta of token0

Always rounds up, because in the exact output case (increasing price) we need to move the price at least
far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the
price less in order to not send too much output.
The most precise formula for this is *liquidity \* sqrtPX96 / (liquidity +- amount \* sqrtPX96)*,
if this is impossible because of overflow, we calculate *liquidity / (liquidity / sqrtPX96 +- amount)*.

#### Parameters:

| Name        | Type    | Description                                                     |
| :---------- | :------ | :-------------------------------------------------------------- |
| `sqrtPX96`  | uint160 | The starting price, i.e. before accounting for the token0 delta |
| `liquidity` | uint128 | The amount of usable liquidity                                  |
| `amount`    | uint256 | How much of token0 to add or remove from virtual reserves       |
| `add`       | bool    | Whether to add or remove the amount of token0                   |

#### Return Values:

| Type    | Description                                             |
| :------ | :------------------------------------------------------ |
| uint160 | price after adding or removing amount, depending on add |

### getNextSqrtPriceFromAmount1RoundingDown

```solidity
  function getNextSqrtPriceFromAmount1RoundingDown(
    uint160 sqrtPX96,
    uint128 liquidity,
    uint256 amount,
    bool add
  ) internal pure returns (uint160)
```

Gets the next sqrt price given a delta of token1

Always rounds down, because in the exact output case (decreasing price) we need to move the price at least
far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the
price less in order to not send too much output.
The formula we compute is within \<1 wei of the lossless version: *sqrtPX96 +- amount / liquidity*

#### Parameters:

| Name        | Type    | Description                                                      |
| :---------- | :------ | :--------------------------------------------------------------- |
| `sqrtPX96`  | uint160 | The starting price, i.e., before accounting for the token1 delta |
| `liquidity` | uint128 | The amount of usable liquidity                                   |
| `amount`    | uint256 | How much of token1 to add, or remove, from virtual reserves      |
| `add`       | bool    | Whether to add, or remove, the amount of token1                  |

#### Return Values:

| Type    | Description                             |
| :------ | :-------------------------------------- |
| uint160 | price after adding or removing `amount` |

### getNextSqrtPriceFromInput

```solidity
  function getNextSqrtPriceFromInput(
    uint160 sqrtPX96,
    uint128 liquidity,
    uint256 amountIn,
    bool zeroForOne
  ) internal pure returns (uint160 sqrtQX96)
```

Gets the next sqrt price given an input amount of token0 or token1

Throws if price or liquidity are 0, or if the next price is out of bounds

#### Parameters:

| Name         | Type    | Description                                                      |
| :----------- | :------ | :--------------------------------------------------------------- |
| `sqrtPX96`   | uint160 | The starting price, i.e., before accounting for the input amount |
| `liquidity`  | uint128 | The amount of usable liquidity                                   |
| `amountIn`   | uint256 | How much of token0, or token1, is being swapped in               |
| `zeroForOne` | bool    | Whether the amount in is token0 or token1                        |

#### Return Values:

| Name       | Type    | Description                                                 |
| :--------- | :------ | :---------------------------------------------------------- |
| `sqrtQX96` | uint160 | The price after adding the input amount to token0 or token1 |

### getNextSqrtPriceFromOutput

```solidity
  function getNextSqrtPriceFromOutput(
    uint160 sqrtPX96,
    uint128 liquidity,
    uint256 amountOut,
    bool zeroForOne
  ) internal pure returns (uint160 sqrtQX96)
```

Gets the next sqrt price given an output amount of token0 or token1

Throws if price or liquidity are 0 or the next price is out of bounds

#### Parameters:

| Name         | Type    | Description                                                |
| :----------- | :------ | :--------------------------------------------------------- |
| `sqrtPX96`   | uint160 | The starting price before accounting for the output amount |
| `liquidity`  | uint128 | The amount of usable liquidity                             |
| `amountOut`  | uint256 | How much of token0, or token1, is being swapped out        |
| `zeroForOne` | bool    | Whether the amount out is token0 or token1                 |

#### Return Values:

| Name       | Type    | Description                                                    |
| :--------- | :------ | :------------------------------------------------------------- |
| `sqrtQX96` | uint160 | The price after removing the output amount of token0 or token1 |

### getAmount0Delta

```solidity
  function getAmount0Delta(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint128 liquidity,
    bool roundUp
  ) internal pure returns (uint256 amount0)
```

Gets the amount0 delta between two prices

Calculates *liquidity / sqrt(lower) - liquidity / sqrt(upper)*,
i.e. *liquidity \* (sqrt(upper) - sqrt(lower)) / (sqrt(upper) \* sqrt(lower))*

#### Parameters:

| Name            | Type    | Description                            |
| :-------------- | :------ | :------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price                           |
| `sqrtRatioBX96` | uint160 | Another sqrt price                     |
| `liquidity`     | uint128 | The amount of usable liquidity         |
| `roundUp`       | bool    | Whether to round the amount up or down |

#### Return Values:

| Name      | Type    | Description                                                                                   |
| :-------- | :------ | :-------------------------------------------------------------------------------------------- |
| `amount0` | uint256 | Amount of token0 required to cover a position of size liquidity between the two passed prices |

### getAmount1Delta

```solidity
  function getAmount1Delta(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint128 liquidity,
    bool roundUp
  ) internal pure returns (uint256 amount1)
```

Gets the amount1 delta between two prices

Calculates *liquidity \* (sqrt(upper) - sqrt(lower))*

#### Parameters:

| Name            | Type    | Description                             |
| :-------------- | :------ | :-------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price                            |
| `sqrtRatioBX96` | uint160 | Another sqrt price                      |
| `liquidity`     | uint128 | The amount of usable liquidity          |
| `roundUp`       | bool    | Whether to round the amount up, or down |

#### Return Values:

| Name      | Type    | Description                                                                                   |
| :-------- | :------ | :-------------------------------------------------------------------------------------------- |
| `amount1` | uint256 | Amount of token1 required to cover a position of size liquidity between the two passed prices |

### getAmount0Delta

```solidity
  function getAmount0Delta(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    int128 liquidity
  ) internal pure returns (int256 amount0)
```

Helper that gets signed token0 delta

#### Parameters:

| Name            | Type    | Description                                                    |
| :-------------- | :------ | :------------------------------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price                                                   |
| `sqrtRatioBX96` | uint160 | Another sqrt price                                             |
| `liquidity`     | int128  | The change in liquidity for which to compute the amount0 delta |

#### Return Values:

| Name      | Type   | Description                                                                        |
| :-------- | :----- | :--------------------------------------------------------------------------------- |
| `amount0` | int256 | Amount of token0 corresponding to the passed liquidityDelta between the two prices |

### getAmount1Delta

```solidity
  function getAmount1Delta(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    int128 liquidity
  ) internal pure returns (int256 amount1)
```

Helper that gets signed token1 delta

#### Parameters:

| Name            | Type    | Description                                                    |
| :-------------- | :------ | :------------------------------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price                                                   |
| `sqrtRatioBX96` | uint160 | Another sqrt price                                             |
| `liquidity`     | int128  | The change in liquidity for which to compute the amount1 delta |

#### Return Values:

| Name      | Type   | Description                                                                        |
| :-------- | :----- | :--------------------------------------------------------------------------------- |
| `amount1` | int256 | Amount of token1 corresponding to the passed liquidityDelta between the two prices |
</file>

<file path="docs/contracts/v3/reference/core/libraries/SwapMath.md">
Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.

## Functions

### computeSwapStep

```solidity
  function computeSwapStep(
    uint160 sqrtRatioCurrentX96,
    uint160 sqrtRatioTargetX96,
    uint128 liquidity,
    int256 amountRemaining,
    uint24 feePips
  ) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount)
```

Computes the result of swapping some amount in, or amount out, given the parameters of the swap

The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive

#### Parameters:

| Name                  | Type    | Description                                                                         |
| :-------------------- | :------ | :---------------------------------------------------------------------------------- |
| `sqrtRatioCurrentX96` | uint160 | The current sqrt price of the pool                                                  |
| `sqrtRatioTargetX96`  | uint160 | The price that cannot be exceeded, from which the direction of the swap is inferred |
| `liquidity`           | uint128 | The usable liquidity                                                                |
| `amountRemaining`     | int256  | How much input or output amount is remaining to be swapped in/out                   |
| `feePips`             | uint24  | The fee taken from the input amount, expressed in hundredths of a bip               |

#### Return Values:

| Name               | Type    | Description                                                                                 |
| :----------------- | :------ | :------------------------------------------------------------------------------------------ |
| `sqrtRatioNextX96` | uint160 | The price after swapping the amount in/out, not to exceed the price target                  |
| `amountIn`         | uint256 | The amount to be swapped in, of either token0 or token1, based on the direction of the swap |
| `amountOut`        | uint256 | The amount to be received, of either token0 or token1, based on the direction of the swap   |
| `feeAmount`        | uint256 | The amount of input that will be taken as a fee                                             |
</file>

<file path="docs/contracts/v3/reference/core/libraries/Tick.md">
Contains functions for managing tick processes and relevant calculations

## Functions

### tickSpacingToMaxLiquidityPerTick

```solidity
  function tickSpacingToMaxLiquidityPerTick(
    int24 tickSpacing
  ) internal pure returns (uint128)
```

Derives max liquidity per tick from given tick spacing

Executed within the pool constructor

#### Parameters:

| Name          | Type  | Description                                                                                                                                                                             |
| :------------ | :---- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `tickSpacing` | int24 | The amount of required tick separation, realized in multiples of `tickSpacing` e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ... |

#### Return Values:

| Type    | Description            |
| :------ | :--------------------- |
| uint128 | max liquidity per tick |

### getFeeGrowthInside

```solidity
  function getFeeGrowthInside(
    mapping(int24 => struct Tick.Info) self,
    int24 tickLower,
    int24 tickUpper,
    int24 tickCurrent,
    uint256 feeGrowthGlobal0X128,
    uint256 feeGrowthGlobal1X128
  ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)
```

Retrieves fee growth data

#### Parameters:

| Name                   | Type                               | Description                                                       |
| :--------------------- | :--------------------------------- | :---------------------------------------------------------------- |
| `self`                 | mapping(int24 => struct Tick.Info) | The mapping containing all tick information for initialized ticks |
| `tickLower`            | int24                              | The lower tick boundary of the position                           |
| `tickUpper`            | int24                              | The upper tick boundary of the position                           |
| `tickCurrent`          | int24                              | The current tick                                                  |
| `feeGrowthGlobal0X128` | uint256                            | The all-time global fee growth, per unit of liquidity, in token0  |
| `feeGrowthGlobal1X128` | uint256                            | The all-time global fee growth, per unit of liquidity, in token1  |

#### Return Values:

| Name                   | Type    | Description                                                                                     |
| :--------------------- | :------ | :---------------------------------------------------------------------------------------------- |
| `feeGrowthInside0X128` | uint256 | The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries |
| `feeGrowthInside1X128` | uint256 | The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries |

### update

```solidity
  function update(
    mapping(int24 => struct Tick.Info) self,
    int24 tick,
    int24 tickCurrent,
    int128 liquidityDelta,
    uint256 feeGrowthGlobal0X128,
    uint256 feeGrowthGlobal1X128,
    bool upper,
    uint128 maxLiquidity
  ) internal returns (bool flipped)
```

Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa

#### Parameters:

| Name                   | Type                               | Description                                                                                                |
| :--------------------- | :--------------------------------- | :--------------------------------------------------------------------------------------------------------- |
| `self`                 | mapping(int24 => struct Tick.Info) | The mapping containing all tick information for initialized ticks                                          |
| `tick`                 | int24                              | The tick that will be updated                                                                              |
| `tickCurrent`          | int24                              | The current tick                                                                                           |
| `liquidityDelta`       | int128                             | A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left) |
| `feeGrowthGlobal0X128` | uint256                            | The all-time global fee growth, per unit of liquidity, in token0                                           |
| `feeGrowthGlobal1X128` | uint256                            | The all-time global fee growth, per unit of liquidity, in token1                                           |
| `upper`                | bool                               | true for updating a position's upper tick, or false for updating a position's lower tick                   |
| `maxLiquidity`         | uint128                            | The maximum liquidity allocation for a single tick                                                         |

#### Return Values:

| Name      | Type | Description                                                                   |
| :-------- | :--- | :---------------------------------------------------------------------------- |
| `flipped` | bool | Whether the tick was flipped from initialized to uninitialized, or vice versa |

### clear

```solidity
  function clear(
    mapping(int24 => struct Tick.Info) self,
    int24 tick
  ) internal
```

Clears tick data

#### Parameters:

| Name   | Type                               | Description                                                                   |
| :----- | :--------------------------------- | :---------------------------------------------------------------------------- |
| `self` | mapping(int24 => struct Tick.Info) | The mapping containing all initialized tick information for initialized ticks |
| `tick` | int24                              | The tick that will be cleared                                                 |

### cross

```solidity
  function cross(
    mapping(int24 => struct Tick.Info) self,
    int24 tick,
    uint256 feeGrowthGlobal0X128,
    uint256 feeGrowthGlobal1X128
  ) internal returns (int128 liquidityNet)
```

Transitions to next tick as needed by price movement

#### Parameters:

| Name                   | Type                               | Description                                                       |
| :--------------------- | :--------------------------------- | :---------------------------------------------------------------- |
| `self`                 | mapping(int24 => struct Tick.Info) | The mapping containing all tick information for initialized ticks |
| `tick`                 | int24                              | The destination tick of the transition                            |
| `feeGrowthGlobal0X128` | uint256                            | The all-time global fee growth, per unit of liquidity, in token0  |
| `feeGrowthGlobal1X128` | uint256                            | The all-time global fee growth, per unit of liquidity, in token1  |

#### Return Values:

| Name           | Type   | Description                                                                                        |
| :------------- | :----- | :------------------------------------------------------------------------------------------------- |
| `liquidityNet` | int128 | The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left) |
</file>

<file path="docs/contracts/v3/reference/core/libraries/TickBitmap.md">
Stores a packed mapping of tick index to its initialized state

The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.

## Functions

### flipTick

```solidity
  function flipTick(
    mapping(int16 => uint256) self,
    int24 tick,
    int24 tickSpacing
  ) internal
```

Flips the initialized state for a given tick from false to true, or vice versa

#### Parameters:

| Name          | Type                      | Description                           |
| :------------ | :------------------------ | :------------------------------------ |
| `self`        | mapping(int16 => uint256) | The mapping in which to flip the tick |
| `tick`        | int24                     | The tick to flip                      |
| `tickSpacing` | int24                     | The spacing between usable ticks      |

### nextInitializedTickWithinOneWord

```solidity
  function nextInitializedTickWithinOneWord(
    mapping(int16 => uint256) self,
    int24 tick,
    int24 tickSpacing,
    bool lte
  ) internal view returns (int24 next, bool initialized)
```

Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either
to the left (less than or equal to) or right (greater than) of the given tick

#### Parameters:

| Name          | Type                      | Description                                                                                           |
| :------------ | :------------------------ | :---------------------------------------------------------------------------------------------------- |
| `self`        | mapping(int16 => uint256) | The mapping in which to compute the next initialized tick                                             |
| `tick`        | int24                     | The starting tick                                                                                     |
| `tickSpacing` | int24                     | The spacing between usable ticks                                                                      |
| `lte`         | bool                      | Whether to search for the next initialized tick to the left (less than or equal to the starting tick) |

#### Return Values:

| Name          | Type  | Description                                                                                |
| :------------ | :---- | :----------------------------------------------------------------------------------------- |
| `next`        | int24 | The next initialized or uninitialized tick up to 256 ticks away from the current tick      |
| `initialized` | bool  | Whether the next tick is initialized, as the function only searches within up to 256 ticks |
</file>

<file path="docs/contracts/v3/reference/core/libraries/TickMath.md">
Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
prices between 2**-128 and 2**128

## Functions

### getSqrtRatioAtTick

```solidity
  function getSqrtRatioAtTick(
    int24 tick
  ) internal pure returns (uint160 sqrtPriceX96)
```

Calculates sqrt(1.0001^tick) \* 2^96

Throws if |tick| > max tick

#### Parameters:

| Name   | Type  | Description                          |
| :----- | :---- | :----------------------------------- |
| `tick` | int24 | The input tick for the above formula |

#### Return Values:

| Name           | Type    | Description                                                                                      |
| :------------- | :------ | :----------------------------------------------------------------------------------------------- |
| `sqrtPriceX96` | uint160 | A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0) |

at the given tick

### getTickAtSqrtRatio

```solidity
  function getTickAtSqrtRatio(
    uint160 sqrtPriceX96
  ) internal pure returns (int24 tick)
```

Calculates the greatest tick value such that getRatioAtTick(tick) \<= ratio

Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
ever return.

#### Parameters:

| Name           | Type    | Description                                              |
| :------------- | :------ | :------------------------------------------------------- |
| `sqrtPriceX96` | uint160 | The sqrt ratio for which to compute the tick as a Q64.96 |

#### Return Values:

| Name   | Type  | Description                                                                    |
| :----- | :---- | :----------------------------------------------------------------------------- |
| `tick` | int24 | The greatest tick for which the ratio is less than or equal to the input ratio |
</file>

<file path="docs/contracts/v3/reference/core/libraries/TransferHelper.md">
Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false

## Functions

### safeTransfer

```solidity
  function safeTransfer(
    address token,
    address to,
    uint256 value
  ) internal
```

Transfers tokens from msg.sender to a recipient

Calls transfer on token contract, errors with TF if transfer fails

#### Parameters:

| Name    | Type    | Description                                                 |
| :------ | :------ | :---------------------------------------------------------- |
| `token` | address | The contract address of the token which will be transferred |
| `to`    | address | The recipient of the transfer                               |
| `value` | uint256 | The value of the transfer                                   |
</file>

<file path="docs/contracts/v3/reference/core/libraries/UnsafeMath.md">
Contains methods that perform common math functions but do not do any overflow or underflow checks

## Functions

### divRoundingUp

```solidity
  function divRoundingUp(
    uint256 x,
    uint256 y
  ) internal pure returns (uint256 z)
```

Returns ceil(x / y)

panics if y == 0

#### Parameters:

| Name | Type    | Description  |
| :--- | :------ | :----------- |
| `x`  | uint256 | The dividend |
| `y`  | uint256 | The divisor  |

#### Return Values:

| Name | Type    | Description               |
| :--- | :------ | :------------------------ |
| `z`  | uint256 | The quotient, ceil(x / y) |
</file>

<file path="docs/contracts/v3/reference/core/_category_.json">
{
  "label": "Core",
  "position": 2
}
</file>

<file path="docs/contracts/v3/reference/core/UniswapV3Factory.md">
Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees

## Functions

### createPool

```solidity
  function createPool(
    address tokenA,
    address tokenB,
    uint24 fee
  ) external returns (address pool)
```

Creates a pool for the given two tokens and fee

tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
are invalid.

#### Parameters:

| Name     | Type    | Description                                     |
| :------- | :------ | :---------------------------------------------- |
| `tokenA` | address | One of the two tokens in the desired pool       |
| `tokenB` | address | The other of the two tokens in the desired pool |
| `fee`    | uint24  | The desired fee for the pool                    |

#### Return Values:

| Name   | Type    | Description                           |
| :----- | :------ | :------------------------------------ |
| `pool` | address | The address of the newly created pool |

### setOwner

```solidity
  function setOwner(
    address _owner
  ) external
```

Updates the owner of the factory

Must be called by the current owner

#### Parameters:

| Name     | Type    | Description                  |
| :------- | :------ | :--------------------------- |
| `_owner` | address | The new owner of the factory |

### enableFeeAmount

```solidity
  function enableFeeAmount(
    uint24 fee,
    int24 tickSpacing
  ) public
```

Enables a fee amount with the given tickSpacing

Fee amounts may never be removed once enabled

#### Parameters:

| Name          | Type   | Description                                                                              |
| :------------ | :----- | :--------------------------------------------------------------------------------------- |
| `fee`         | uint24 | The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)                 |
| `tickSpacing` | int24  | The spacing between ticks to be enforced for all pools created with the given fee amount |
</file>

<file path="docs/contracts/v3/reference/core/UniswapV3Pool.md">
## Functions

### \_blockTimestamp

```solidity
  function _blockTimestamp(
  ) internal view virtual returns (uint32)
```

Returns the block timestamp truncated to 32 bits, i.e. mod 2\*\*32. This method is overridden in tests.

### snapshotCumulativesInside

```solidity
  function snapshotCumulativesInside(
    int24 tickLower,
    int24 tickUpper
  ) external view override noDelegateCall returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside)
```

Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range

Snapshots must only be compared to other snapshots, taken over a period for which a position existed.
I.e., snapshots cannot be compared if a position is not held for the entire period between when the first
snapshot is taken and the second snapshot is taken.

#### Parameters:

| Name        | Type  | Description                 |
| :---------- | :---- | :-------------------------- |
| `tickLower` | int24 | The lower tick of the range |
| `tickUpper` | int24 | The upper tick of the range |

#### Return Values:

| Name                            | Type    | Description                                         |
| :------------------------------ | :------ | :-------------------------------------------------- |
| `tickCumulativeInside`          | int56   | The snapshot of the tick accumulator for the range  |
| `secondsPerLiquidityInsideX128` | uint160 | The snapshot of seconds per liquidity for the range |
| `secondsInside`                 | uint32  | The snapshot of seconds per liquidity for the range |

### observe

```solidity
  function observe(
    uint32[] secondsAgos
  ) external view override noDelegateCall returns (int56[] tickCumulatives, uint160[] secondsPerLiquidityCumulativeX128s)
```

Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp

To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
you must call it with secondsAgos = [3600, 0].
The time weighted average tick represents the geometric time weighted average price of the pool, in
log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.

#### Parameters:

| Name          | Type     | Description                                                                   |
| :------------ | :------- | :---------------------------------------------------------------------------- |
| `secondsAgos` | uint32[] | From how long ago each cumulative tick and liquidity value should be returned |

#### Return Values:

| Name                                 | Type      | Description                                                                                     |
| :----------------------------------- | :-------- | :---------------------------------------------------------------------------------------------- |
| `tickCumulatives`                    | int56[]   | Cumulative tick values as of each `secondsAgos` from the current block timestamp                |
| `secondsPerLiquidityCumulativeX128s` | uint160[] | Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block |

timestamp

### increaseObservationCardinalityNext

```solidity
  function increaseObservationCardinalityNext(
    uint16 observationCardinalityNext
  ) external override lock noDelegateCall
```

Increase the maximum number of price and liquidity observations that this pool will store

This method is no-op if the pool already has an observationCardinalityNext greater than or equal to
the input observationCardinalityNext.

#### Parameters:

| Name                         | Type   | Description                                                      |
| :--------------------------- | :----- | :--------------------------------------------------------------- |
| `observationCardinalityNext` | uint16 | The desired minimum number of observations for the pool to store |

### initialize

```solidity
  function initialize(
    uint160 sqrtPriceX96
  ) external override
```

Sets the initial price for the pool

not locked because it initializes unlocked

#### Parameters:

| Name           | Type    | Description                                    |
| :------------- | :------ | :--------------------------------------------- |
| `sqrtPriceX96` | uint160 | the initial sqrt price of the pool as a Q64.96 |

### mint

```solidity
  function mint(
    address recipient,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount,
    bytes data
  ) external override lock returns (uint256 amount0, uint256 amount1)
```

Adds liquidity for the given recipient/tickLower/tickUpper position

noDelegateCall is applied indirectly via \_modifyPosition

#### Parameters:

| Name        | Type    | Description                                              |
| :---------- | :------ | :------------------------------------------------------- |
| `recipient` | address | The address for which the liquidity will be created      |
| `tickLower` | int24   | The lower tick of the position in which to add liquidity |
| `tickUpper` | int24   | The upper tick of the position in which to add liquidity |
| `amount`    | uint128 | The amount of liquidity to mint                          |
| `data`      | bytes   | Any data that should be passed through to the callback   |

#### Return Values:

| Name      | Type    | Description                                                                                                 |
| :-------- | :------ | :---------------------------------------------------------------------------------------------------------- |
| `amount0` | uint256 | The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback |
| `amount1` | uint256 | The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback |

### collect

```solidity
  function collect(
    address recipient,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount0Requested,
    uint128 amount1Requested
  ) external override lock returns (uint128 amount0, uint128 amount1)
```

Collects tokens owed to a position

Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.

#### Parameters:

| Name               | Type    | Description                                              |
| :----------------- | :------ | :------------------------------------------------------- |
| `recipient`        | address | The address which should receive the fees collected      |
| `tickLower`        | int24   | The lower tick of the position for which to collect fees |
| `tickUpper`        | int24   | The upper tick of the position for which to collect fees |
| `amount0Requested` | uint128 | How much token0 should be withdrawn from the fees owed   |
| `amount1Requested` | uint128 | How much token1 should be withdrawn from the fees owed   |

#### Return Values:

| Name      | Type    | Description                            |
| :-------- | :------ | :------------------------------------- |
| `amount0` | uint128 | The amount of fees collected in token0 |
| `amount1` | uint128 | The amount of fees collected in token1 |

### burn

```solidity
  function burn(
    int24 tickLower,
    int24 tickUpper,
    uint128 amount
  ) external override lock returns (uint256 amount0, uint256 amount1)
```

Burn liquidity from the sender and account tokens owed for the liquidity to the position

noDelegateCall is applied indirectly via \_modifyPosition

#### Parameters:

| Name        | Type    | Description                                                |
| :---------- | :------ | :--------------------------------------------------------- |
| `tickLower` | int24   | The lower tick of the position for which to burn liquidity |
| `tickUpper` | int24   | The upper tick of the position for which to burn liquidity |
| `amount`    | uint128 | How much liquidity to burn                                 |

#### Return Values:

| Name      | Type    | Description                                |
| :-------- | :------ | :----------------------------------------- |
| `amount0` | uint256 | The amount of token0 sent to the recipient |
| `amount1` | uint256 | The amount of token1 sent to the recipient |

### swap

```solidity
  function swap(
    address recipient,
    bool zeroForOne,
    int256 amountSpecified,
    uint160 sqrtPriceLimitX96,
    bytes data
  ) external override noDelegateCall returns (int256 amount0, int256 amount1)
```

Swap token0 for token1, or token1 for token0

The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback

#### Parameters:

| Name                | Type    | Description                                                                                                                                                                        |
| :------------------ | :------ | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `recipient`         | address | The address to receive the output of the swap                                                                                                                                      |
| `zeroForOne`        | bool    | The direction of the swap, true for token0 to token1, false for token1 to token0                                                                                                   |
| `amountSpecified`   | int256  | The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)                                                                 |
| `sqrtPriceLimitX96` | uint160 | The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap |
| `data`              | bytes   | Any data to be passed through to the callback                                                                                                                                      |

#### Return Values:

| Name      | Type   | Description                                                                                |
| :-------- | :----- | :----------------------------------------------------------------------------------------- |
| `amount0` | int256 | The delta of the balance of token0 of the pool, exact when negative, minimum when positive |
| `amount1` | int256 | The delta of the balance of token1 of the pool, exact when negative, minimum when positive |

### flash

```solidity
  function flash(
    address recipient,
    uint256 amount0,
    uint256 amount1,
    bytes data
  ) external override lock noDelegateCall
```

Receive token0 and/or token1 and pay it back, plus a fee, in the callback

The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback
Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling
with 0 amount{0,1} and sending the donation amount(s) from the callback

#### Parameters:

| Name        | Type    | Description                                                  |
| :---------- | :------ | :----------------------------------------------------------- |
| `recipient` | address | The address which will receive the token0 and token1 amounts |
| `amount0`   | uint256 | The amount of token0 to send                                 |
| `amount1`   | uint256 | The amount of token1 to send                                 |
| `data`      | bytes   | Any data to be passed through to the callback                |

### setFeeProtocol

```solidity
  function setFeeProtocol(
    uint8 feeProtocol0,
    uint8 feeProtocol1
  ) external override lock onlyFactoryOwner
```

Set the denominator of the protocol's % share of the fees

#### Parameters:

| Name           | Type  | Description                             |
| :------------- | :---- | :-------------------------------------- |
| `feeProtocol0` | uint8 | new protocol fee for token0 of the pool |
| `feeProtocol1` | uint8 | new protocol fee for token1 of the pool |

### collectProtocol

```solidity
  function collectProtocol(
    address recipient,
    uint128 amount0Requested,
    uint128 amount1Requested
  ) external override lock onlyFactoryOwner returns (uint128 amount0, uint128 amount1)
```

Collect the protocol fee accrued to the pool

#### Parameters:

| Name               | Type    | Description                                                                   |
| :----------------- | :------ | :---------------------------------------------------------------------------- |
| `recipient`        | address | The address to which collected protocol fees should be sent                   |
| `amount0Requested` | uint128 | The maximum amount of token0 to send, can be 0 to collect fees in only token1 |
| `amount1Requested` | uint128 | The maximum amount of token1 to send, can be 0 to collect fees in only token0 |

#### Return Values:

| Name      | Type    | Description                          |
| :-------- | :------ | :----------------------------------- |
| `amount0` | uint128 | The protocol fee collected in token0 |
| `amount1` | uint128 | The protocol fee collected in token1 |
</file>

<file path="docs/contracts/v3/reference/core/UniswapV3PoolDeployer.md">
## Functions

### deploy

```solidity
  function deploy(
    address factory,
    address token0,
    address token1,
    uint24 fee,
    int24 tickSpacing
  ) internal returns (address pool)
```

Deploys a pool with the given parameters by transiently setting the parameters storage slot and then
clearing it after deploying the pool.

#### Parameters:

| Name          | Type    | Description                                                                       |
| :------------ | :------ | :-------------------------------------------------------------------------------- |
| `factory`     | address | The contract address of the Uniswap V3 factory                                    |
| `token0`      | address | The first token of the pool by address sort order                                 |
| `token1`      | address | The second token of the pool by address sort order                                |
| `fee`         | uint24  | The fee collected upon every swap in the pool, denominated in hundredths of a bip |
| `tickSpacing` | int24   | The spacing between usable ticks                                                  |
</file>

<file path="docs/contracts/v3/reference/deployments/_category_.json">
{
    "label": "Deployments",
    "position": 5,
    "collapsed": true
  }
</file>

<file path="docs/contracts/v3/reference/deployments/Arbitrum-Deployments.md">
---
id: arbitrum-deployments
title: Arbitrum Deployments
---

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                                                                                                                     | Arbitrum Addresses                           | Arbitrum Sepolia Addresses                   |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol)                                                    | `0x1F98431c8aD98523631AE4a59f267346ea31F984` | `0x248AB79Bbb9bC29bB72f7Cd42F17e054Fc40188e` |
| [Multicall](https://arbiscan.io/address/0xadF885960B47eA2CD9B55E6DAc6B42b7Cb2806dB#code)                                                                     | `0xadF885960B47eA2CD9B55E6DAc6B42b7Cb2806dB` | `0x2B718b475e385eD29F56775a66aAB1F5cC6B2A0A` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol)                                   | `0xB753548F6E010e7e680BA186F9Ca1BdAB2E90cf2` | ``                                           |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol)                                                          | `0xbfd8137f7d1516D3ea5cA83523914859ec47F573` | `0x0fd18587734e5C2dcE2dccDcC7DD1EC89ba557d9` |
| [Quoter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/Quoter.sol)                                                              | `0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6` | ``                                           |
| [SwapRouter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/SwapRouter.sol)                                                           | `0xE592427A0AEce92De3Edee1F18E0157C05861564` | ``                                           |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol)                                           | `0x42B24A95702b9986e82d421cC3568932790A48Ec` | ``                                           |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol)           | `0x91ae842A5Ffd8d12023116943e72A606179294f3` | ``                                           |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xEe6A57eC80ea46401049E92587E52f5Ec1c24785` | ``                                           |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol)                           | `0xC36442b4a4522E871399CD717aBDD847Ab11FE88` | `0x6b2937Bde17889EDCf8fbD8dE31C3C2a70Bc4d65` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol)                                                           | `0xA5644E29708357803b5A882D272c41cC0dF92B34` | `0x398f43ef2c67B941147157DA1c5a868E906E043D` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol)                                                                    | `0x61fFE014bA17989E743c5F6cB21bF9697530B21e` | `0x2779a0CC1c3e0E44D2542EC3e79e3864Ae93Ef0B` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol)                                                        | `0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45` | `0x101F443B4d1b059569D643917553c771E1b9663E` |
| [Permit2](https://github.com/Uniswap/permit2)                                                                                                                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router)                                                                                               | `0xa51afafe0263b40edaef0df8781ea9aa03e381a3` | `0x4A7b5Da61326A6379179b40d00F57E5bbDC962c2` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)                                                                                                      | `0xe34139463bA50bD61336E0c446Bd8C0867c6fE65` | ``                                           |


These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](../core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```

## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network             | ChainId  | Wrapped Native Token | Address                                      |
| ------------------- | -------- | -------------------- | -------------------------------------------- |
| Arbitrum            | `42161`  | WETH                 | `0x82aF49447D8a07e3bd95BD0d56f35241523fBab1` |
| Arbitrum Sepolia    | `421614` | WETH                 | `0x980B62Da83eFf3D4576C647993b0c1D7faf17c73` |
</file>

<file path="docs/contracts/v3/reference/deployments/AVAX-Deployments.md">
---
id: avax-deployments
title: AVAX Deployments
---

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                                                                                                                     | AVAX Avalanche C-Chain Addresses              |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol)                                                    | `0x740b1c1de25031C31FF4fC9A62f554A55cdC1baD` |
| [Multicall](https://snowtrace.io/address/0x0139141Cd4Ee88dF3Cdb65881D411bAE271Ef0C2/contract/43114/code)                                                     | `0x0139141Cd4Ee88dF3Cdb65881D411bAE271Ef0C2` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol)                                   | `0x9AdA7D7879214073F40183F3410F2b3f088c6381` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol)                                                          | `0xEB9fFC8bf81b4fFd11fb6A63a6B0f098c6e21950` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol)                                           | `0x27Dd7eE7fE723e83Bf3612a75a034951fe299E99` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol)           | `0xe89B7C295d73FCCe88eF263F86e7310925DaEBAF` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xE1f93a7cB6fFa2dB4F9d5A2FD43158A428993C09` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol)                           | `0x655C406EBFa14EE2006250925e54ec43AD184f8B` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol)                                                           | `0x44f5f1f5E452ea8d29C890E8F6e893fC0f1f0f97` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol)                                                                    | `0xbe0F5544EC67e9B3b2D979aaA43f18Fd87E6257F` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol)                                                        | `0xbb00FF08d01D300023C629E8fFfFcb65A5a578cE` |
| [Permit2](https://github.com/Uniswap/permit2)                                                                                                                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router)                                                                                               | `0x94b75331ae8d42c1b61065089b7d48fe14aa73b7` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)                                                                                                      | `0xCA9D0668C600c4dd07ca54Be1615FE5CDFd76Ac3` |


These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)


## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](../core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```

## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network | ChainId  | Wrapped Native Token | Address                                      |
| ------- | -------- | -------------------- | -------------------------------------------- |
| AVAX    | `43114`  | WAVAX                | `0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7` |
</file>

<file path="docs/contracts/v3/reference/deployments/Base-Deployments.md">
---
id: base-deployments
title: Base Deployments
---

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                                                                                                                     |  Base Address                                | Base Sepolia Address                         |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol)                                                    | `0x33128a8fC17869897dcE68Ed026d694621f6FDfD` | `0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24` |
| [Multicall](https://basescan.org/address/0x091e99cb1c49331a94dd62755d168e941abd0693#code)                                                                    | `0x091e99cb1C49331a94dD62755D168E941AbD0693` | `0xd867e273eAbD6c853fCd0Ca0bFB6a3aE6491d2C1` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol)                                   | `0x3334d83e224aF5ef9C2E7DDA7c7C98Efd9621fA9` | `0xD7303474Baca835743B54D73799688990f24a79D` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol)                                                          | `0x0CdeE061c75D43c82520eD998C23ac2991c9ac6d` | `0xedf6066a2b290C185783862C7F4776A2C8077AD1` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol)                                           | `0xF9d1077fd35670d4ACbD27af82652a8d84577d9F` | `0x4e0caFF1Df1cCd7CF782FDdeD77f020699B57f1a` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol)           | `0x4f225937EDc33EFD6109c4ceF7b560B2D6401009` | `0xd7c6e867591608D32Fe476d0DbDc95d0cf584c8F` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0x4615C383F85D0a2BbED973d83ccecf5CB7121463` | `0x1E2A708040Eb6Ed08893E27E35D399e8E8e7857E` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol)                           | `0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1` | `0x27F971cb582BF9E50F397e4d29a5C7A34f11faA2` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol)                                                           | `0x23cF10b1ee3AdfCA73B0eF17C07F7577e7ACd2d7` | `0xCbf8b7f80800bd4888Fbc7bf1713B80FE4E23E10` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol)                                                                    | `0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a` | `0xC5290058841028F1614F3A6F0F5816cAd0df5E27` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol)                                                        | `0x2626664c2603336E57B271c5C0b26F421741e481` | `0x94cC0AaC535CCDB3C01d6787D6413C739ae12bc4` |
| [Permit2](https://github.com/Uniswap/permit2)                                                                                                                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router)                                                                                               | `0x6fF5693b99212Da76ad316178A184AB56D299b43` | `0x492E6456D9528771018DeB9E87ef7750EF184104` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)                                                                                                      | `0x42bE4D6527829FeFA1493e1fb9F3676d2425C3C1` | ``                                           |


These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](../core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```

## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network             | ChainId  | Wrapped Native Token | Address                                      |
| ------------------- | -------- | -------------------- | -------------------------------------------- |
| Base                | `8453`   | WETH                 | `0x4200000000000000000000000000000000000006` |
| Base Sepolia        | `84532`  | WETH                 | `0x4200000000000000000000000000000000000006` |
</file>

<file path="docs/contracts/v3/reference/deployments/Blast-Deployments.md">
---
id: blast-deployments
title: Blast Deployments
---

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                                                                                                                     | Blast addresses                              |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol)                                                    | `0x792edAdE80af5fC680d96a2eD80A44247D2Cf6Fd` |
| [Multicall](https://blastscan.io/address/0xdc7f370de7631ce9e2c2e1dcda6b3b5744cf4705#code)                                                                    | `0xdC7f370de7631cE9e2c2e1DCDA6B3B5744Cf4705` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol)                                   | `0x7C9cAa4ac84C8FAD8Bd504DBF90e791F91f41705` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol)                                                          | `0x2E95185bCdD928a3e984B7e2D6560Ab1b17d7274` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol)                                           | `0xAa32bD3926097fd04d22b4433e9867417EE79333` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol)           | `0x497089D9450BB58f536c38c1C0d0A37472303508` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xB22Ef02E13B1900EBF10391e57162402c11BfF05` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol)                           | `0xB218e4f7cF0533d4696fDfC419A0023D33345F28` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol)                                                           | `0x15CA7043CD84C5D21Ae76Ba0A1A967d42c40ecE0` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol)                                                                    | `0x6Cdcd65e03c1CEc3730AeeCd45bc140D57A25C77` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol)                                                        | `0x549FEB8c9bd4c12Ad2AB27022dA12492aC452B66` |
| [Permit2](https://github.com/Uniswap/permit2)                                                                                                                | `0x000000000022d473030f116ddee9f6b43ac78ba3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router)                                                                                               | `0xeabbcb3e8e415306207ef514f660a3f820025be3` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)                                                                                                      | `0xEcAF7c276f746170642e97De961f2f0361e1aCc8` |


These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)


## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](../core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```

## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network | ChainId | Wrapped Native Token | Address                                      |
| ------- | ------- | -------------------- | -------------------------------------------- |
| Blast   | `81457` | WETH                 | `0x4300000000000000000000000000000000000004` |
</file>

<file path="docs/contracts/v3/reference/deployments/BNB-Binance-Deployments.md">
---
id: bnb-deployments
title: BNB Deployments
---

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                                                                                                                     | BNB Address                                  |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol)                                                    | `0xdB1d10011AD0Ff90774D0C6Bb92e5C5c8b4461F7` |
| [Multicall](https://bscscan.com/address/0x963Df249eD09c358A4819E39d9Cd5736c3087184#code)                                                                     | `0x963Df249eD09c358A4819E39d9Cd5736c3087184` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol)                                   | `0xC9A7f5b73E853664044ab31936D0E6583d8b1c79` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol)                                                          | `0xD9270014D396281579760619CCf4c3af0501A47C` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol)                                           | `0x831d93E55AF23A2977E4DA892d5005f4F2995071` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol)           | `0x0281E98322e4e8E53491D576Ee6A2BFCE644C55C` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xAec98e489AE35F243eB63452f6ad233A6c97eE97` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol)                           | `0x7b8A01B39D58278b5DE7e48c8449c9f4F5170613` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol)                                                           | `0x32681814957e0C13117ddc0c2aba232b5c9e760f` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol)                                                                    | `0x78D78E420Da98ad378D7799bE8f4AF69033EB077` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol)                                                        | `0xB971eF87ede563556b2ED4b1C0b0019111Dd85d2` |
| [Permit2](https://github.com/Uniswap/permit2)                                                                                                                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router)                                                                                               | `0x1906c1d672b88cd1b9ac7593301ca990f94eae07` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)                                                                                                      | `0x49B53C35AF9072fC71767577BF6380a88EE32C71` |


These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](../core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```

## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network             | ChainId  | Wrapped Native Token | Address                                      |
| ------------------- | -------- | -------------------- | -------------------------------------------- |
| Binance Smart Chain | `56`     | WBNB                 | `0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c` |
</file>

<file path="docs/contracts/v3/reference/deployments/Celo-Deployments.md">
---
id: celo-deployments
title: CELO Deployments
---

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                                                                                                                     | CELO Address                                 | Alfajores Address                            |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol)                                                    | `0xAfE208a311B21f13EF87E33A90049fC17A7acDEc` | `0x229Fd76DA9062C1a10eb4193768E192bdEA99572` |
| [Multicall2](https://celoscan.io/address/0x633987602de5c4f337e3dbf265303a1080324204#code)                                                                    | `0x633987602DE5C4F337e3DbF265303A1080324204` | `0x692A12C7C167c44e54c3d381CA3EE91F058Dc404` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol)                                   | `0xc1b262Dd7643D4B7cA9e51631bBd900a564BF49A` | `0xE4d1eBb97Fe5fabFaBbB8C004C424EE12dE8A07d` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol)                                                          | `0x5f115D9113F88e0a0Db1b5033D90D4a9690AcD3D` | `0xFdACaEfB0f85C9BE9d319023453cC85C812d7e1E` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol)                                           | `0xa9Fd765d85938D278cb0b108DbE4BF7186831186` | `0xE3da4F834D45b27AF95600e6546991dC3B50adAC` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol)           | `0x644023b316bB65175C347DE903B60a756F6dd554` | `0xB00B8C3aB078EB0f7DeC6cE19c1a1da5bf4f8d7e` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0x505B43c452AA4443e0a6B84bb37771494633Fde9` | `0x9ddD6325FBE93A715B422883cED853CD843f217C` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol)                           | `0x3d79EdAaBC0EaB6F08ED885C05Fc0B014290D95A` | `0x0eC9d3C06Bc0A472A80085244d897bb604548824` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol)                                                           | `0x3cFd4d48EDfDCC53D3f173F596f621064614C582` | `0x245d3F47F55c532dbE9340368855Be631B162cfd` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol)                                                                    | `0x82825d0554fA07f7FC52Ab63c961F330fdEFa8E8` | `0x3c1FCF8D6f3A579E98F4AE75EB0adA6de70f5673` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol)                                                        | `0x5615CDAb10dc425a742d643d949a7F474C01abc4` | `0x8C456F41A3883bA0ba99f810F7A2Da54D9Ea3EF0` |
| [Permit2](https://github.com/Uniswap/permit2)                                                                                                                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router)                                                                                               | `0x643770E279d5D0733F21d6DC03A8efbABf3255B4` | `0x84904B9E85F76a421223565be7b596d7d9A8b8Ce` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)                                                                                                      | `0x6586FB35393abF7Ff454977a9b3c912d218791C6` | `0x8AC47D3e65a3e6aD14596ee7d18ad1d1aA53208F` |
 

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](../core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```

## CELO Native Asset

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

**Note: CELO is the native asset, it is a token and will work as a token, needing approval for routers to manage.*

| Network | ChainId | Wrapped Native Token | Address                                      |
| ------- | ------- | -------------------- | -------------------------------------------- |
| CELO    | `42220` | CELO Native Asset    | `0x471EcE3750Da237f93B8E339c536989b8978a438` |
</file>

<file path="docs/contracts/v3/reference/deployments/deployments.md">
---
id: deployments
title: Deployment Addresses
---

## Uniswap v3 Contract Deployments

The Uniswap Protocol is made up of multiple contracts on many networks.

Please do not assume contracts are deployed to the same addresses across chains, and be extremely careful to confirm addresses before using a contract.

- [`Ethereum`](./Ethereum-Deployments.md)
- [`Unichain`](./Unichain-Deployments.md)
- [`Arbitrum`](./Arbitrum-Deployments.md)
- [`Optimism`](./Optimism-Deployments.md)
- [`Polygon`](./Polygon-Deployments.md)
- [`Base`](./Base-Deployments.md)
- [`BNB`](./BNB-Binance-Deployments.md)
- [`Avalanche C-Chain`](./AVAX-Deployments.md)
- [`CELO`](./Celo-Deployments.md)
- [`Blast`](./Blast-Deployments.md)
- [`ZKsync`](./ZKsync-Deployments.md)
- [`Zora`](./Zora-Deployments.md)
- [`WorldChain`](./WorldChain-Deployments.md)

These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)


## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](../core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```
</file>

<file path="docs/contracts/v3/reference/deployments/Ethereum-Deployments.md">
---
id: ethereum-deployments
title: Ethereum Deployments
---

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                                                                                                                     | Mainnet                                      | Ethereum Sepolia Addresses                   |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol)                                                    | `0x1F98431c8aD98523631AE4a59f267346ea31F984` | `0x0227628f3F023bb0B980b67D528571c95c6DaC1c` |
| [Multicall](https://etherscan.io/address/0x1F98415757620B543A52E61c46B32eB19261F984#code)                                                                    | `0x1F98415757620B543A52E61c46B32eB19261F984` | ``                                           |
| [Multicall2](https://etherscan.io/address/0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696#code)                                                                   | `0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696` | `0xD7F33bCdb21b359c8ee6F0251d30E94832baAd07` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol)                                   | `0xB753548F6E010e7e680BA186F9Ca1BdAB2E90cf2` | `0x0b343475d44EC2b4b8243EBF81dc888BF0A14b36` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol)                                                          | `0xbfd8137f7d1516D3ea5cA83523914859ec47F573` | ``                                           |
| [Quoter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/Quoter.sol)                                                              | `0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6` | ``                                           |
| [SwapRouter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/SwapRouter.sol)                                                           | `0xE592427A0AEce92De3Edee1F18E0157C05861564` | ``                                           |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol)                                           | `0x42B24A95702b9986e82d421cC3568932790A48Ec` | `0x3B5E3c5E595D85fbFBC2a42ECC091e183E76697C` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol)           | `0x91ae842A5Ffd8d12023116943e72A606179294f3` | `0x5bE4DAa6982C69aD20A57F1e68cBcA3D37de6207` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xEe6A57eC80ea46401049E92587E52f5Ec1c24785` | ``                                           |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol)                           | `0xC36442b4a4522E871399CD717aBDD847Ab11FE88` | `0x1238536071E1c677A632429e3655c799b22cDA52` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol)                                                           | `0xA5644E29708357803b5A882D272c41cC0dF92B34` | `0x729004182cF005CEC8Bd85df140094b6aCbe8b15` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol)                                                                    | `0x61fFE014bA17989E743c5F6cB21bF9697530B21e` | `0xEd1f6473345F45b75F8179591dd5bA1888cf2FB3` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol)                                                        | `0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45` | `0x3bFA4769FB09eefC5a80d6E87c3B9C650f7Ae48E` |
| [Permit2](https://github.com/Uniswap/permit2)                                                                                                                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router)                                                                                               | `0x66a9893cc07d91d95644aedd05d03f95e1dba8af` | `0x3A9D48AB9751398BbFa63ad67599Bb04e4BdF98b` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)                                                                                                      | `0xe34139463bA50bD61336E0c446Bd8C0867c6fE65` | ``                                           |


These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](../core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```

## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network             | ChainId     | Wrapped Native Token | Address                                      |
| ------------------- | ----------- | -------------------- | -------------------------------------------- |
| Ethereum            | `1`         | WETH                 | `0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2` |
| Sepolia             | `11155111`  | WETH                 | `0xfff9976782d46cc05630d1f6ebab18b2324d6b14` |
</file>

<file path="docs/contracts/v3/reference/deployments/Optimism-Deployments.md">
---
id: optimism-deployments
title: Optimism Deployments
---

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                                                                                                                     | Optimism Addresses                           | OP Sepolia Addresses  SDK-Core               | OP Sepolia Addresses                         |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol)                                                    | `0x1F98431c8aD98523631AE4a59f267346ea31F984` | `0x8CE191193D15ea94e11d327b4c7ad8bbE520f6aF` | `0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24` |
| [Multicall](https://optimistic.etherscan.io/address/0x1F98415757620B543A52E61c46B32eB19261F984#code)                                                         | `0x1F98415757620B543A52E61c46B32eB19261F984` | `0x80e4e06841bb76AA9735E0448cB8d003C0EF009a` | `0xd867e273eAbD6c853fCd0Ca0bFB6a3aE6491d2C1` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol)                                   | `0xB753548F6E010e7e680BA186F9Ca1BdAB2E90cf2` | `0xD7303474Baca835743B54D73799688990f24a79D` | `0xD7303474Baca835743B54D73799688990f24a79D` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol)                                                          | `0xbfd8137f7d1516D3ea5cA83523914859ec47F573` | `0xCb7f54747F58F8944973cea5b8f4ac2209BadDC5` | `0xedf6066a2b290C185783862C7F4776A2C8077AD1` |
| [Quoter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/Quoter.sol)                                                              | `0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6` | ``                                           | ``                                           |
| [SwapRouter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/SwapRouter.sol)                                                           | `0xE592427A0AEce92De3Edee1F18E0157C05861564` | ``                                           | ``                                           |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol)                                           | `0x42B24A95702b9986e82d421cC3568932790A48Ec` | `0x4e0caFF1Df1cCd7CF782FDdeD77f020699B57f1a` | `0x4e0caFF1Df1cCd7CF782FDdeD77f020699B57f1a` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol)           | `0x91ae842A5Ffd8d12023116943e72A606179294f3` | `0xd7c6e867591608D32Fe476d0DbDc95d0cf584c8F` | `0xd7c6e867591608D32Fe476d0DbDc95d0cf584c8F` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xEe6A57eC80ea46401049E92587E52f5Ec1c24785` | `0x1E2A708040Eb6Ed08893E27E35D399e8E8e7857E` | `0x1E2A708040Eb6Ed08893E27E35D399e8E8e7857E` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol)                           | `0xC36442b4a4522E871399CD717aBDD847Ab11FE88` | `0xdA75cEf1C93078e8b736FCA5D5a30adb97C8957d` | `0x27F971cb582BF9E50F397e4d29a5C7A34f11faA2` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol)                                                           | ``                                           | `0xE7EcbAAaA54D007A00dbb6c1d2f150066D69dA07` | `0xCbf8b7f80800bd4888Fbc7bf1713B80FE4E23E10` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol)                                                                    | `0x61fFE014bA17989E743c5F6cB21bF9697530B21e` | `0x0FBEa6cf957d95ee9313490050F6A0DA68039404` | `0xC5290058841028F1614F3A6F0F5816cAd0df5E27` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol)                                                        | `0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45` | `0x94cC0AaC535CCDB3C01d6787D6413C739ae12bc4` | `0x94cC0AaC535CCDB3C01d6787D6413C739ae12bc4` |
| [Permit2](https://github.com/Uniswap/permit2)                                                                                                                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` | `0x000000000022D473030F116dDEE9F6B43aC78BA3` | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router)                                                                                               | `0x851116d9223fabed8e56c0e6b8ad0c31d98b3507` | `0xD5bBa708b39537d33F2812E5Ea032622456F1A95` | `0xD5bBa708b39537d33F2812E5Ea032622456F1A95` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)                                                                                                      | `0xe34139463bA50bD61336E0c446Bd8C0867c6fE65` | `0x78eF13931e5625C828ef8Ec455ba7fa09fDa9808` | ``                                           |


These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](../core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```

## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network             | ChainId    | Wrapped Native Token | Address                                      |
| ------------------- | ---------- | -------------------- | -------------------------------------------- |
| Optimism            | `10`       | WETH                 | `0x4200000000000000000000000000000000000006` |
| Optimism Sepolia    | `11155420` | WETH                 | `0x4200000000000000000000000000000000000006` |
</file>

<file path="docs/contracts/v3/reference/deployments/Polygon-Deployments.md">
---
id: polygon-deployments
title: Polygon Deployments
---

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                                                                                                                     | Polygon Addresses                            |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol)                                                    | `0x1F98431c8aD98523631AE4a59f267346ea31F984` |
| [Multicall](https://polygonscan.com/address/0x1F98415757620B543A52E61c46B32eB19261F984#code)                                                                 | `0x1F98415757620B543A52E61c46B32eB19261F984` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol)                                   | `0xB753548F6E010e7e680BA186F9Ca1BdAB2E90cf2` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol)                                                          | `0xbfd8137f7d1516D3ea5cA83523914859ec47F573` |
| [Quoter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/Quoter.sol)                                                              | `0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6` |
| [SwapRouter](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/SwapRouter.sol)                                                           | `0xE592427A0AEce92De3Edee1F18E0157C05861564` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol)                                           | `0x42B24A95702b9986e82d421cC3568932790A48Ec` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol)           | `0x91ae842A5Ffd8d12023116943e72A606179294f3` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xEe6A57eC80ea46401049E92587E52f5Ec1c24785` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol)                           | `0xC36442b4a4522E871399CD717aBDD847Ab11FE88` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol)                                                           | `0xA5644E29708357803b5A882D272c41cC0dF92B34` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol)                                                                    | `0x61fFE014bA17989E743c5F6cB21bF9697530B21e` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol)                                                        | `0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45` |
| [Permit2](https://github.com/Uniswap/permit2)                                                                                                                | `0x000000000022D473030F116dDEE9F6B43aC78BA3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router)                                                                                               | `0x1095692A6237d83C6a72F3F5eFEdb9A670C49223` |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)                                                                                                      | `0xe34139463bA50bD61336E0c446Bd8C0867c6fE65` |

> **Note**: Polygon Mumbai testnet was deprecated in April 2024. For testing, developers should use Polygon Amoy testnet. Deployment addresses for Amoy are not yet available.


These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](../core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```

## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network             | ChainId  | Wrapped Native Token | Address                                      |
| ------------------- | -------- | -------------------- | -------------------------------------------- |
| Polygon             | `137`    | WMATIC               | `0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270` |
</file>

<file path="docs/contracts/v3/reference/deployments/Unichain-Deployments.md">
---
id: unichain-deployments
title: Unichain Deployments
---

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                                                                                                                     | Unichain Addresses                           | Unichain Sepolia Addresses                   |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol)                                                    | [`0x1f98400000000000000000000000000000000003`](https://uniscan.xyz/address/0x1f98400000000000000000000000000000000003) | [`0x1F98431c8aD98523631AE4a59f267346ea31F984`](https://sepolia.uniscan.xyz/address/0x1F98431c8aD98523631AE4a59f267346ea31F984) |
| [UniswapInterfaceMulticall](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/UniswapInterfaceMulticall.sol)                                | [`0xb7610f9b733e7d45184be3a1bc966960ccc54f0b`](https://uniscan.xyz/address/0xb7610f9b733e7d45184be3a1bc966960ccc54f0b) | [`0x9D0F15f2cf58655fDDcD1EE6129C547fDaeD01b1`](https://sepolia.uniscan.xyz/address/0x9D0F15f2cf58655fDDcD1EE6129C547fDaeD01b1) |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol)                                                          | [`0xd5d76fa166ab8d8ad4c9f61aaa81457b66cbe443`](https://uniscan.xyz/address/0xd5d76fa166ab8d8ad4c9f61aaa81457b66cbe443) | [`0x5f739c790a48E97eec0efb81bab5D152c0A0ecA0`](https://sepolia.uniscan.xyz/address/0x5f739c790a48E97eec0efb81bab5D152c0A0ecA0) |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol)                                                                    | [`0x385a5cf5f83e99f7bb2852b6a19c3538b9fa7658`](https://uniscan.xyz/address/0x385a5cf5f83e99f7bb2852b6a19c3538b9fa7658) | [`0x6Dd37329A1A225a6Fca658265D460423DCafBF89`](https://sepolia.uniscan.xyz/address/0x6Dd37329A1A225a6Fca658265D460423DCafBF89) |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol)                                                        | [`0x73855d06de49d0fe4a9c42636ba96c62da12ff9c`](https://uniscan.xyz/address/0x73855d06de49d0fe4a9c42636ba96c62da12ff9c) | [`0xd1AAE39293221B77B0C71fBD6dCb7Ea29Bb5B166`](https://sepolia.uniscan.xyz/address/0xd1AAE39293221B77B0C71fBD6dCb7Ea29Bb5B166) |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol)                           | [`0x943e6e07a7e8e791dafc44083e54041d743c46e9`](https://uniscan.xyz/address/0x943e6e07a7e8e791dafc44083e54041d743c46e9) | [`0xB7F724d6dDDFd008eFf5cc2834edDE5F9eF0d075`](https://sepolia.uniscan.xyz/address/0xB7F724d6dDDFd008eFf5cc2834edDE5F9eF0d075) |
| [NFT Descriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol)                                           | [`0x0dfa04b28ab68ffd0e6e17fac6ec16d4846a2004`](https://uniscan.xyz/address/0x0dfa04b28ab68ffd0e6e17fac6ec16d4846a2004) | [`0x2B6221E68D48cDC10CF2e52D913f9380D62555BA`](https://sepolia.uniscan.xyz/address/0x2B6221E68D48cDC10CF2e52D913f9380D62555BA) |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol)                                                           | [`0xb9d0c246f306b1aaf02ae6ba112d5ef25e5b60dc`](https://uniscan.xyz/address/0xb9d0c246f306b1aaf02ae6ba112d5ef25e5b60dc) | [`0xb5FA244C9d6D04B2FBac84418b3c4910ED1Ae5f2`](https://sepolia.uniscan.xyz/address/0xb5FA244C9d6D04B2FBac84418b3c4910ED1Ae5f2) |
| [UniswapV3Staker](https://github.com/Uniswap/v3-staker)                                                                                                      | -                                            | [`0xd693d8df6CF768248c16f98745Ee0c8E06460487`](https://sepolia.uniscan.xyz/address/0xd693d8df6CF768248c16f98745Ee0c8E06460487) |


These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)

## Uniswap v3 Staker

An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/v3-staker/releases/tag/v1.0.2) for the `UniswapV3Staker` contract.

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/universal-router/tree/main/deploy-addresses).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](../reference/core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```

## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH, the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract.

| Network          | ChainId | Wrapped Native Token | Address                                      |
| ---------------- | ------- | -------------------- | -------------------------------------------- |
| Unichain         | `130`  | WETH                 | [`0x4200000000000000000000000000000000000006`](https://unichain.blockscout.com/token/0x4200000000000000000000000000000000000006) |
| Unichain Sepolia | `1301`  | WETH                 | [`0x4200000000000000000000000000000000000006`](https://unichain-sepolia.blockscout.com/token/0x4200000000000000000000000000000000000006) |
</file>

<file path="docs/contracts/v3/reference/deployments/WorldChain-Deployments.md">
---
id: WorldChain-deployments
title: WorldChain Deployments
---

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                                                                                                                     | WorldChain                                           |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol)                                                    | `0x7a5028BDa40e7B173C278C5342087826455ea25a`         |
| [Multicall2](https://worldchain-mainnet.explorer.alchemy.com/address/0x0a22c04215c97E3F532F4eF30e0aD9458792dAB9)                                             | `0x0a22c04215c97E3F532F4eF30e0aD9458792dAB9`         |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol)                                   | `0x8B52DaCB7B5d9A959CDcD5419061c0eDD1296c29`         |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol)                                                          | `0xE61df0CaC9d85876aCE5E3037005D80943570623`         |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol)                                           | `0x38c68A1D60C47973EcE5bc1725B65D8Bec438192`         |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol)           | `0x70410a302c4a5c52C659b780941c947Abd437FeB`         |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xe6FcB4952b2d3Fab6DA4BC165831f5575e093feC`         |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol)                           | `0xec12a9F9a09f50550686363766Cc153D03c27b5e`         |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol)                                                           | `0x9EBDdCBa71C9027E1eB45135672a30bcFEec9de3`         |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol)                                                                    | `0x10158D43e6cc414deE1Bd1eB0EfC6a5cBCfF244c`         |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol)                                                        | `0x091AD9e2e6e5eD44c1c66dB50e49A601F9f36cF6`         |
| [Permit2](https://github.com/Uniswap/permit2)                                                                                                                | `0x000000000022D473030F116dDEE9F6B43aC78BA3`         |
| [UniversalRouter](https://github.com/Uniswap/universal-router)                                                                                               | `0x8ac7bee993bb44dab564ea4bc9ea67bf9eb5e743`         |


These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)


## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/sdks/blob/main/sdks/universal-router-sdk/src/utils/constants.ts).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](../reference/core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```

## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network             | ChainId  | Wrapped Native Token | Address                                      |
| ------------------- | -------- | -------------------- | -------------------------------------------- |
| WorldChain          | `480`    | WETH                 | `0x4200000000000000000000000000000000000006` |
</file>

<file path="docs/contracts/v3/reference/deployments/ZKsync-Deployments.md">
---
id: ZKsync-deployments
title: ZKsync Deployments
---

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                                                                                                                                      | ZKsync Mainnet                               |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/uniswap-zksync/era-uniswap-v3-core/blob/v1.0.0-zksync-era/contracts/UniswapV3Factory.sol)                                               | `0x8FdA5a7a8dCA67BBcDd10F02Fa0649A937215422` |
| [Multicall2](https://explorer.zksync.io/address/0x0c68a7C72f074d1c45C16d41fa74eEbC6D16a65C#contract)                                                                          | `0x0c68a7C72f074d1c45C16d41fa74eEbC6D16a65C` |
| [ProxyAdmin](https://github.com/uniswap-zksync/era-openzeppelin-contracts/blob/v3.4.1-solc-0.7-2-zksync-era/contracts/proxy/ProxyAdmin.sol)                                   | `0xBb79274aD9C7f68A5B6a7E31F431175BB889b557` |
| [TickLens](https://github.com/uniswap-zksync/era-uniswap-v3-periphery/blob/v1.1.1-zksync-era/contracts/lens/TickLens.sol)                                                     | `0xe10FF11b809f8EE07b056B452c3B2caa7FE24f89` |
| [NFTDescriptor](https://github.com/uniswap-zksync/era-uniswap-v3-periphery/blob/v1.3.0-zksync-era/contracts/libraries/NFTDescriptor.sol)                                      | `0x7d67b8Ff4AbFfc020641F5e430fbeEd03897674d` |
| [NonfungibleTokenPositionDescriptor](https://github.com/uniswap-zksync/era-uniswap-v3-periphery/blob/v1.3.0-zksync-era/contracts/NonfungibleTokenPositionDescriptor.sol)      | `0xa819De78cAB1163F8605809392068EdE3BFcDd1E` |
| [TransparentUpgradeableProxy](https://github.com/uniswap-zksync/era-openzeppelin-contracts/blob/v3.4.1-solc-0.7-2-zksync-era/contracts/proxy/TransparentUpgradeableProxy.sol) | `0xAeaBf2d69698C6810D2596fAE86099790A13Ee81` |
| [NonfungiblePositionManager](https://github.com/uniswap-zksync/era-uniswap-v3-periphery/blob/v1.1.1-zksync-era/contracts/NonfungiblePositionManager.sol)                      | `0x0616e5762c1E7Dc3723c50663dF10a162D690a86` |
| [V3Migrator](https://github.com/uniswap-zksync/era-uniswap-v3-periphery/blob/v1.1.1-zksync-era/contracts/V3Migrator.sol)                                                      | `0x611841b24E43C4ACfd290B427a3D6cf1A59dac8E` |
| [QuoterV2](https://github.com/uniswap-zksync/era-uniswap-swap-router-contracts/blob/v1.1.0-zksync-era/contracts/lens/QuoterV2.sol)                                            | `0x8Cb537fc92E26d8EBBb760E632c95484b6Ea3e28` |
| [SwapRouter02](https://github.com/uniswap-zksync/era-uniswap-swap-router-contracts/blob/v1.1.0-zksync-era/contracts/SwapRouter02.sol)                                         | `0x99c56385daBCE3E81d8499d0b8d0257aBC07E8A3` |
| [Permit2](https://github.com/uniswap-zksync/era-permit2/blob/0x000000000022D473030F116dDEE9F6B43aC78BA3-zksync-era/src/Permit2.sol)                                           | `0x0000000000225e31d15943971f47ad3022f714fa` |
| [UniversalRouter](https://github.com/uniswap-zksync/era-universal-router/tree/v1.2.2-zksync-era)                                                                              | `0x28731BCC616B5f51dD52CF2e4dF0E78dD1136C06` |
| [v3StakerAddress](https://github.com/uniswap-zksync/era-uniswap-v3-staker/blob/v1.0.2-zksync-era/contracts/UniswapV3Staker.sol)                                               | `0xf84268FA8EB857c2e4298720C1C617178F5e78e1` |


These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core`](https://github.com/uniswap-zksync/era-uniswap-v3-core/tree/v1.0.0-zksync-era)
- [`@uniswap/v3-periphery`](https://github.com/uniswap-zksync/era-uniswap-v3-periphery)
- [`@uniswap/swap-router-contracts`](https://github.com/uniswap-zksync/era-uniswap-swap-router-contracts)

*Note:*
ZKsync contracts are also using the [`ZKsync fork of OpenZeppelin`](https://github.com/uniswap-zksync/era-openzeppelin-contracts#v3.4.1-solc-0.7-2-zksync-era).

## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/sdks/blob/main/sdks/universal-router-sdk/src/utils/constants.ts).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://app.uniswap.org/explore) or by calling the [`getPool`](../core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```

## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network           | ChainId  | Wrapped Native Token | Address                                      |
| ----------------- | -------- | -------------------- | -------------------------------------------- |
| ZKsync            | `324`    | WETH                 | `0x5aea5775959fbc2557cc8789bc1bf90a239d9a91` |
</file>

<file path="docs/contracts/v3/reference/deployments/Zora-Deployments.md">
---
id: Zora-deployments
title:  Zora Deployments
---

The latest version of `@uniswap/v3-core`, `@uniswap/v3-periphery`, and `@uniswap/swap-router-contracts` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

| Contract                                                                                                                                                     | Zora                                         | Zora Sepolia                                 |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |
| [UniswapV3Factory](https://github.com/Uniswap/uniswap-v3-core/blob/v1.0.0/contracts/UniswapV3Factory.sol)                                                    | `0x7145F8aeef1f6510E92164038E1B6F8cB2c42Cbb` | `0x4324A677D74764f46f33ED447964252441aA8Db6` |
| [Multicall2](https://explorer.zora.energy/address/0xA51c76bEE6746cB487a7e9312E43e2b8f4A37C15)                                                                 | `0xA51c76bEE6746cB487a7e9312E43e2b8f4A37C15` | `0xA1E7e3A69671C4494EC59Dbd442de930a93F911A` |
| [ProxyAdmin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/ProxyAdmin.sol)                                   | `0xd4109824FC80dD41ca6ee8D304ec74B8bEdEd03b` | `0x561896C035abFB3C72f754f10fD35f6c450Ffe16` |
| [TickLens](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/lens/TickLens.sol)                                                          | `0x209AAda09D74Ad3B8D0E92910Eaf85D2357e3044` | `0x23C0F71877a1Fc4e20A78018f9831365c85f3064` |
| [NFTDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/libraries/NFTDescriptor.sol)                                           | `0xffF2BffC03474F361B7f92cCfF2fD01CFBBDCdd1` | `0xf70C8a20496a5201Fd8D01F627c93aE39cDa1999` |
| [NonfungibleTokenPositionDescriptor](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungibleTokenPositionDescriptor.sol)           | `0xf15D9e794d39A3b4Ea9EfC2376b2Cd9562996422` | `0x5BC936a151Fb4CEBD14467Ca9CBf598b7E645fc0` |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.1-solc-0.7-2/contracts/proxy/TransparentUpgradeableProxy.sol) | `0x843b0b03c3B3B0434B9cb00AD9cD1D9218E7741b` | `0x68EF3669bEd58213edf9Da598f4E1307680839B2` |
| [NonfungiblePositionManager](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/NonfungiblePositionManager.sol)                           | `0xbC91e8DfA3fF18De43853372A3d7dfe585137D78` | `0xB8458EaAe43292e3c1F7994EFd016bd653d23c20` |
| [V3Migrator](https://github.com/Uniswap/uniswap-v3-periphery/blob/v1.0.0/contracts/V3Migrator.sol)                                                           | `0x048352d8dCF13686982C799da63fA6426a9D0b60` | `0x65ef259b31bf1d977c37e9434658694267674897` |
| [QuoterV2](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol)                                                                    | `0x11867e1b3348F3ce4FcC170BC5af3d23E07E64Df` | `0xC195976fEF0985886E37036E2DF62bF371E12Df0` |
| [SwapRouter02](https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/SwapRouter02.sol)                                                        | `0x7De04c96BE5159c3b5CeffC82aa176dc81281557` | `0x6B36d761981d82B1e07cF3c4daF4cB4615c4850a` |
| [Permit2](https://github.com/Uniswap/permit2)                                                                                                                | `0x000000000022d473030f116ddee9f6b43ac78ba3` | `0x000000000022d473030f116ddee9f6b43ac78ba3` |
| [UniversalRouter](https://github.com/Uniswap/universal-router)                                                                                               | `0x3315ef7ca28db74abadc6c44570efdf06b04b020` | ``                                           |
| [v3StakerAddress](https://github.com/Uniswap/v3-staker)                                                                                                      | `0x5eF5A6923d2f566F65f363b78EF7A88ab1E4206f` | `0x5d298AAf21058d14436DBD36940dcB5542b8aFE8` |


These addresses are final and were deployed from these npm package versions:

- [`@uniswap/v3-core@1.0.0`](https://github.com/Uniswap/uniswap-v3-core/tree/v1.0.0)
- [`@uniswap/v3-periphery@1.0.0`](https://github.com/Uniswap/uniswap-v3-periphery/tree/v1.0.0)
- [`@uniswap/swap-router-contracts@1.1.0`](https://github.com/Uniswap/swap-router-contracts/tree/v1.1.0)


## Universal Router

The `UniversalRouter` contract is the current preferred entrypoint for ERC20 and NFT swaps, replacing, among other contracts, `SwapRouter02`. An up-to-date list of [deploy addresses by chain is hosted on GitHub](https://github.com/Uniswap/sdks/blob/main/sdks/universal-router-sdk/src/utils/constants.ts).

## Uniswap Pool Deployments

Every Uniswap pool is a unique instance of the `UniswapV3Pool` contract and is deployed at its own unique address. The contract source code of the pool will be auto-verified on etherscan. For example, here is the [ETH/USDC 0.3% pool](https://etherscan.io/address/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8) on Ethereum mainnet.

You can look up the address of an existing pool on [Uniswap Info](https://info.uniswap.org/#/) or by calling the [`getPool`](../core/interfaces/IUniswapV3Factory.md#getpool) function on the `UniswapV3Factory` contract.

```solidity
getPool("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 3000)
```

## Wrapped Native Token Addresses

The Uniswap Protocol supports trading of ERC20 tokens. In order to swap a native asset like ETH (or MATIC on Polygon), the Uniswap protocol wraps these assets in an ERC20 wrapped native token contract. The protocol uses the following WETH9 addresses on Ethereum and WMATIC addresses on Polygon.

| Network      | ChainId     | Wrapped Native Token | Address                                      |
| ------------ | ----------- | -------------------- | -------------------------------------------- |
| Zora         | `7777777`   | WETH                 | `0x4200000000000000000000000000000000000006` |
| Zora Sepolia | `999999999` | WETH                 | `0x4200000000000000000000000000000000000006` |
</file>

<file path="docs/contracts/v3/reference/governance/_category_.json">
{
  "label": "Governance",
  "position": 2
}
</file>

<file path="docs/contracts/v3/reference/governance/overview.md">
---
id: overview
title: Overview
---

> The updated reference for the newly deployed Governor Bravo is available via [Etherscan](https://etherscan.io/address/0x408ED6354d4973f66138C91495F2f2FCbd8724C3), some of the reference material below may be out of date.

The Uniswap protocol is governed and upgraded by UNI token holders, using three distinct components; the UNI token, governance module, and Timelock. Together, these contracts allow the community to propose, vote, and implement changes to the uniswap protocol.

Any addresses with more than 2.5M UNI (0.25% of total supply) delegated to it may propose governance actions, which contain finished, executable code. When a proposal is created, the community can cast their votes during a 7 day voting period. If there are more 'For' votes than 'Against' (i.e. a simple majority), and the number of 'For' votes >40M (meeting the quorum), it is queued in the Timelock, and may be executed in a minimum of 2 days.

## Timelock

The Timelock contract can modify system parameters, logic, and contracts in a 'time-delayed, opt-out' upgrade pattern. Timelock has a hard-coded minimum delay of 2 days, which is the least amount of notice possible for a governance action. Each proposed action will be published at a minimum of 2 days in the future from the time of announcement. Major upgrades, such as changing the risk system, may have up to a 30 day delay. Timelock is controlled by the governance module; pending and completed governance actions can be monitored on the Timelock Dashboard.

![](./images/gov_diagram-1.png)

## Key Events

### DelegateChanged

```solidity
DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate)
```

Emitted when an account changes its delegate.

### DelegateVotesChanged

```solidity
DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance)
```

Emitted when a delegate account's vote balance changes.

### ProposalCreated

```solidity
ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description)
```

Emitted when a new proposal is created.

### VoteCast

```solidity
VoteCast(address voter, uint proposalId, bool support, uint votes)
```

Emitted when a vote has been cast on a proposal.

### ProposalCanceled

```solidity
ProposalCanceled(uint id)
```

Emitted when a proposal has been canceled.

### ProposalQueued

```solidity
ProposalQueued(uint id, uint eta)
```

Emitted when a proposal has been queued in the Timelock.

### ProposalExecuted

```solidity
ProposalExecuted(uint id)
```

Emitted when a proposal has been executed in the Timelock.

## Read-Only Functions: UNI

### Get Current Votes

```solidity
function getCurrentVotes(address account) returns (uint96)
```

Returns the balance of votes for an account as of the current block.

| Name    | Type      |                                                                  |
| :------ | :-------- | :--------------------------------------------------------------- |
| account | `address` | Address of the account of which to retrieve the number of votes. |

### Get Prior Votes

```solidity
function getPriorVotes(address account, uint blockNumber) returns (uint96)
```

Returns the prior number of votes for an account at a specific block number. The block number passed must be a finalized block or the function will revert.

| Name        | Type      |                                                                        |
| :---------- | :-------- | :--------------------------------------------------------------------- |
| account     | `address` | Address of the account of which to retrieve the prior number of votes. |
| blocknumber | `uint`    | The block number at which to retrieve the prior number of votes.       |
|             |           |                                                                        |
| unnamed     | `uint96`  | The number of prior votes                                              |

## State-Changing Functions: UNI

### Delegate

```solidity
function delegate(address delegatee)
```

Delegate votes from the sender to the delegatee. Users can delegate to 1 address at a time, and the number of votes added to the delegatee’s vote count is equivalent to the balance of UNI in the user’s account. Votes are delegated from the current block and onward, until the sender delegates again, or transfers their UNI.

| Name      | Type      |                                                                    |
| :-------- | :-------- | :----------------------------------------------------------------- |
| delegatee | `address` | The address to which msg.sender wishes to delegate their votes to. |

### Delegate By Signature

```solidity
function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s)
```

Delegate votes from the sender to the delegatee. Users can delegate to 1 address at a time, and the number of votes added to the delegatee’s vote count is equivalent to the balance of UNI in the user’s account. Votes are delegated from the current block and onward, until the sender delegates again, or transfers their UNI.

| Name      | Type      |                                                                                                                     |
| :-------- | :-------- | :------------------------------------------------------------------------------------------------------------------ |
| delegatee | `address` | The address to which msg.sender wishes to delegate their vote to                                                    |
| nonce     | `uint`    | The contract state required to match the signature. This can be retrieved from the contract’s public nonces mapping |
| expiry    | `uint`    | The time when the signature expires. A block timestamp in seconds since the unix epoch.                             |
| v         | `uint`    | The recovery byte of the signature.                                                                                 |
| r         | `bytes32` | Half of the ECDSA signature pair.                                                                                   |
| s         | `bytes32` | Half of the ECDSA signature pair.                                                                                   |

## Read-Only Functions: Governor Alpha

### Quorum Votes

```solidity
function quorumVotes() public pure returns (uint)
```

Returns the minimum number of votes required for a proposal to succeed.

### Proposal Threshold

```solidity
function proposalThreshold() returns (uint)
```

Returns the minimum number of votes required for an account to create a proposal.

### Proposal Max Operations

```solidity
function proposalMaxOperations() returns (uint)
```

Returns the maximum number of actions that can be included in a proposal. Actions are functions calls that will be made when a proposal succeeds and executes.

### Voting Delay

```solidity
function votingDelay() returns (uint)
```

Returns the number of blocks to wait before voting on a proposal may begin. This value is added to the current block number when a proposal is created.

### Voting Period

```solidity
function votingPeriod() returns (uint)
```

Returns the duration of voting on a proposal, in blocks.

### Get Actions

```solidity
function getActions(uint proposalId) returns (uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas)
```

Gets the actions of a selected proposal. Pass a proposal ID and get the targets, values, signatures and calldatas of that proposal.

| Name       | Type   |                    |
| :--------- | :----- | :----------------- |
| proposalId | `uint` | ID of the proposal |

Returns:

- Array of addresses of contracts the proposal calls.
- Array of unsigned integers the proposal uses as values.
- Array of strings of the proposal’s signatures.
- Array of calldata bytes of the proposal.

### Get Receipt

```solidity
function getReceipt(uint proposalId, address voter) returns (Receipt memory)
```

Returns a proposal ballot receipt of a given voter.

| Name       | Type      |                                                              |
| :--------- | :-------- | :----------------------------------------------------------- |
| proposalId | `uint`    | ID of the proposal in which to get a voter’s ballot receipt. |
| voter      | `address` | Address of the account of a proposal voter.                  |
|            |           |                                                              |
| Receipt    | `struct`  | A Receipt struct for the ballot of the voter address.        |

### State

```solidity
function state(uint proposalId) returns (ProposalState)
```

Returns enum of type ProposalState, possible types are:
- Pending
- Active
- Canceled
- Defeated
- Succeeded
- Queued
- Expired
- Executed

| Name       | Type   |                    |
| :--------- | :----- | :----------------- |
| proposalId | `uint` | ID of the proposal |

## State-Changing Functions: Governor Alpha

### Propose

```solidity
function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) returns (uint)
```

Creates a Proposal to change the protocol.

Proposals will be voted on by delegated voters. If there is sufficient support before the voting period ends, the proposal shall be automatically enacted. Enacted proposals are queued and executed in the Timelock contract.

The sender must hold more UNI than the current proposal threshold (proposalThreshold()) as of the immediately previous block. The proposal can have up to 10 actions (based on proposalMaxOperations()).

The proposer cannot create another proposal if they currently have a pending or active proposal. It is not possible to queue two identical actions in the same block (due to a restriction in the Timelock), therefore actions in a single proposal must be unique, and unique proposals that share an identical action must be queued in different blocks.

| Name        | Type      |                                                                                                                                                                                         |
| :---------- | :-------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| targets     | `address` | The ordered list of target addresses for calls to be made during proposal execution. This array must be the same length as all other array parameters in this function.                 |
| values      | `uint`    | The ordered list of values (i.e. msg.value) to be passed to the calls made during proposal execution. This array must be the same length as all other array parameters in this function |
| signatures  | `string`  | The ordered list of function signatures to be passed during execution. This array must be the same length as all other array parameters in this function.                               |
| calldatas   | `bytes`   | The ordered list of data to be passed to each individual function call during proposal execution. This array must be the same length as all other array parameters in this function.    |
| description | `string`  | A human readable description of the proposal and the changes it will enact.                                                                                                             |
|             |           |                                                                                                                                                                                         |
| Unnamed     | `uint`    | Returns ID of the new proposal                                                                                                                                                          |

### Queue

```solidity
function queue(uint proposalId)
```

After a proposal has succeeded, any address can call the queue method to move the proposal into the Timelock queue. A proposal can only be queued if it has succeeded.

| Name       | Type   |                                   |
| :--------- | :----- | :-------------------------------- |
| proposalId | `uint` | ID of a given successful proposal |

### Execute

```solidity
function execute(uint proposalId) payable
```

After the Timelock delay period, any account may invoke the execute method to apply the changes from the proposal to the target contracts. This will invoke each of the actions described in the proposal.
This function is payable so the Timelock contract can invoke payable functions that were selected in the proposal.

| Name       | Type   |                                   |
| :--------- | :----- | :-------------------------------- |
| proposalId | `uint` | ID of a given successful proposal |

### Cancel

```solidity
function cancel(uint proposalId)
```

Cancel a proposal that has not yet been executed. The Guardian is the only one who may execute this unless the proposer does not maintain the delegates required to create a proposal. If the proposer does not have more delegates than the proposal threshold, anyone can cancel the proposal.

| Name       | Type   |                            |
| :--------- | :----- | :------------------------- |
| proposalId | `uint` | ID of a proposal to cancel |

### Cast Vote

```solidity
function castVote(uint proposalId, bool support)
```

Cast a vote on a proposal. The account's voting weight is determined by it's number of delegated votes at the time the proposal becomes active.

| Name       | Type   |                                                                     |
| :--------- | :----- | :------------------------------------------------------------------ |
| proposalId | `uint` | ID of a given successful proposal                                   |
| support    | `bool` | A boolean of true for 'yes' or false for 'no' on the proposal vote. |

### Cast Vote By Signature

```solidity
function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s)
```

Cast a vote on a proposal. The account's voting weight is determined by its number of delegated votes at the time the proposal became active. This method has the same purpose as Cast Vote, but instead enables offline signatures to participate in governance voting. For more details on how to create an offline signature, review EIP-712.

| Name       | Type      |                                                                                         |
| :--------- | :-------- | :-------------------------------------------------------------------------------------- |
| proposalId | `uint`    | ID of a given successful proposal                                                       |
| support    | `bool`    | A boolean of true for 'yes' or false for 'no' on the proposal vote.                     |
| expiry     | `uint`    | The time when the signature expires. A block timestamp in seconds since the unix epoch. |
| v          | `uint`    | The recovery byte of the signature.                                                     |
| r          | `bytes32` | Half of the ECDSA signature pair.                                                       |
| s          | `bytes32` | Half of the ECDSA signature pair.                                                       |
</file>

<file path="docs/contracts/v3/reference/periphery/base/_category_.json">
{
  "label": "Base",
  "position": 1
}
</file>

<file path="docs/contracts/v3/reference/periphery/base/BlockTimestamp.md">
Base contract that is overridden for tests

## Functions

### \_blockTimestamp

```solidity
  function _blockTimestamp(
  ) internal view returns (uint256)
```

Method that exists purely to be overridden for tests

#### Return Values:

| Type    | Description             |
| :------ | :---------------------- |
| uint256 | current block timestamp |
</file>

<file path="docs/contracts/v3/reference/periphery/base/ERC721Permit.md">
Nonfungible tokens that support an approve via signature, i.e. permit

## Functions

### \_getAndIncrementNonce

```solidity
  function _getAndIncrementNonce(
    uint256 tokenId
  ) internal virtual returns (uint256)
```

Gets the current nonce for a token ID and then increments it, returning the original value

### constructor

```solidity
  function constructor(
    string memory name_,
    string memory symbol_,
    string memory version_
  ) internal
```

Computes the nameHash and versionHash

### DOMAIN_SEPARATOR

```solidity
  function DOMAIN_SEPARATOR(
  ) public view override returns (bytes32)
```

The domain separator used in the permit signature

#### Return Values:

| Type    | Description                                           |
| :------ | :---------------------------------------------------- |
| bytes32 | domain seperator used in encoding of permit signature |

### permit

```solidity
  function permit(
    address spender,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```

Approve of a specific token ID for spending by spender via signature

#### Parameters:

| Name       | Type    | Description                                                                    |
| :--------- | :------ | :----------------------------------------------------------------------------- |
| `spender`  | address | The account that is being approved                                             |
| `tokenId`  | uint256 | The ID of the token that is being approved for spending                        |
| `deadline` | uint256 | The deadline timestamp by which the call must be mined for the approve to work |
| `v`        | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s`  |
| `r`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s`  |
| `s`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v`  |
</file>

<file path="docs/contracts/v3/reference/periphery/base/LiquidityManagement.md">
Internal functions for safely managing liquidity in Uniswap V3

## Parameter Structs

### AddLiquidityParams

```solidity
    struct AddLiquidityParams {
        address token0;
        address token1;
        uint24 fee;
        address recipient;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
    }
```

## Functions

### uniswapV3MintCallback

```solidity
  function uniswapV3MintCallback(
    uint256 amount0Owed,
    uint256 amount1Owed,
    bytes data
  ) external
```

Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.

In the implementation you must pay the pool tokens owed for the minted liquidity.
The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.

#### Parameters:

| Name          | Type    | Description                                                                   |
| :------------ | :------ | :---------------------------------------------------------------------------- |
| `amount0Owed` | uint256 | The amount of token0 due to the pool for the minted liquidity                 |
| `amount1Owed` | uint256 | The amount of token1 due to the pool for the minted liquidity                 |
| `data`        | bytes   | Any data passed through by the caller via the IUniswapV3PoolActions#mint call |

### addLiquidity

```solidity
  function addLiquidity(
    AddLiquidityParams memory params
  ) internal returns (uint128 liquidity, uint256 amount0, uint256 amount1, contract IUniswapV3Pool pool)
```

Add liquidity to an initialized pool
</file>

<file path="docs/contracts/v3/reference/periphery/base/Multicall.md">
Enables calling multiple methods in a single call to the contract

## Functions

### multicall

```solidity
  function multicall(
    bytes[] data
  ) external payable override returns (bytes[] results)
```

Call multiple functions in the current contract and return the data from all of them if they all succeed

The `msg.value` should not be trusted for any method callable from multicall.

#### Parameters:

| Name   | Type    | Description                                                              |
| :----- | :------ | :----------------------------------------------------------------------- |
| `data` | bytes[] | The encoded function data for each of the calls to make to this contract |

#### Return Values:

| Name      | Type    | Description                                           |
| :-------- | :------ | :---------------------------------------------------- |
| `results` | bytes[] | The results from each of the calls passed in via data |
</file>

<file path="docs/contracts/v3/reference/periphery/base/PeripheryImmutableState.md">
Immutable state used by periphery contracts

## Functions

### constructor

```solidity
  function constructor(
    address _factory, address _WETH9
  ) internal
```
</file>

<file path="docs/contracts/v3/reference/periphery/base/PeripheryPayments.md">
## Functions

### receive

```solidity
  function receive(
  ) external
```

### unwrapWETH9

```solidity
  function unwrapWETH9(
    uint256 amountMinimum,
    address recipient
  ) external
```

Unwraps the contract's WETH9 balance and sends it to recipient as ETH.

The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.

#### Parameters:

| Name            | Type    | Description                           |
| :-------------- | :------ | :------------------------------------ |
| `amountMinimum` | uint256 | The minimum amount of WETH9 to unwrap |
| `recipient`     | address | The address receiving ETH             |

### sweepToken

```solidity
  function sweepToken(
    address token,
    uint256 amountMinimum,
    address recipient
  ) external
```

Transfers the full amount of a token held by this contract to recipient

The amountMinimum parameter prevents malicious contracts from stealing the token from users

#### Parameters:

| Name            | Type    | Description                                                                |
| :-------------- | :------ | :------------------------------------------------------------------------- |
| `token`         | address | The contract address of the token which will be transferred to `recipient` |
| `amountMinimum` | uint256 | The minimum amount of token required for a transfer                        |
| `recipient`     | address | The destination address of the token                                       |

### refundETH

```solidity
  function refundETH(
  ) external
```

Refunds any ETH balance held by this contract to the `msg.sender`

Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps
that use ether for the input amount

### pay

```solidity
  function pay(
    address token,
    address payer,
    address recipient,
    uint256 value
  ) internal
```

#### Parameters:

| Name        | Type    | Description                          |
| :---------- | :------ | :----------------------------------- |
| `token`     | address | The token to pay                     |
| `payer`     | address | The entity that must pay             |
| `recipient` | address | The entity that will receive payment |
| `value`     | uint256 | The amount to pay                    |
</file>

<file path="docs/contracts/v3/reference/periphery/base/PeripheryPaymentsWithFee.md">
## Functions

### unwrapWETH9WithFee

```solidity
  function unwrapWETH9WithFee(
        uint256 amountMinimum,
        address recipient,
        uint256 feeBips,
        address feeRecipient
  ) public
```

Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between
0 (exclusive), and 1 (inclusive) going to feeRecipient

The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.

### sweepTokenWithFee

```solidity
  function sweepTokenWithFee(
        address token,
        uint256 amountMinimum,
        address recipient,
        uint256 feeBips,
        address feeRecipient
  ) public
```

Transfers the full amount of a token held by this contract to recipient, with a percentage between
0 (exclusive) and 1 (inclusive) going to feeRecipient

The amountMinimum parameter prevents malicious contracts from stealing the token from users
</file>

<file path="docs/contracts/v3/reference/periphery/base/PoolInitializer.md">
## Functions

### createAndInitializePoolIfNecessary

```solidity
  function createAndInitializePoolIfNecessary(
    address token0,
    address token1,
    uint24 fee,
    uint160 sqrtPriceX96
  ) external returns (address pool)
```

Creates a new pool if it does not exist, then initializes if not initialized

This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool

#### Parameters:

| Name           | Type    | Description                                                 |
| :------------- | :------ | :---------------------------------------------------------- |
| `token0`       | address | The contract address of token0 of the pool                  |
| `token1`       | address | The contract address of token1 of the pool                  |
| `fee`          | uint24  | The fee amount of the v3 pool for the specified token pair  |
| `sqrtPriceX96` | uint160 | The initial square root price of the pool as a Q64.96 value |

#### Return Values:

| Name   | Type    | Description                                                                                                           |
| :----- | :------ | :-------------------------------------------------------------------------------------------------------------------- |
| `pool` | address | Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary |
</file>

<file path="docs/contracts/v3/reference/periphery/base/SelfPermit.md">
Functionality to call permit on any EIP-2612-compliant token for use in the route

These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function
that requires an approval in a single transaction.

## Functions

### selfPermit

```solidity
  function selfPermit(
    address token,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public
```

Permits this contract to spend a given token from `msg.sender`

The `owner` is always msg.sender and the `spender` is always address(this).

#### Parameters:

| Name       | Type    | Description                                                                     |
| :--------- | :------ | :------------------------------------------------------------------------------ |
| `token`    | address | The address of the token spent                                                  |
| `value`    | uint256 | The amount that can be spent of token                                           |
| `deadline` | uint256 | A timestamp, the current blocktime must be less than or equal to this timestamp |
| `v`        | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s`   |
| `r`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s`   |
| `s`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v`   |

### selfPermitIfNecessary

```solidity
  function selfPermitIfNecessary(
    address token,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```

Permits this contract to spend a given token from `msg.sender`

The `owner` is always msg.sender and the `spender` is always address(this).
Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit

#### Parameters:

| Name       | Type    | Description                                                                     |
| :--------- | :------ | :------------------------------------------------------------------------------ |
| `token`    | address | The address of the token spent                                                  |
| `value`    | uint256 | The amount that can be spent of token                                           |
| `deadline` | uint256 | A timestamp, the current blocktime must be less than or equal to this timestamp |
| `v`        | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s`   |
| `r`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s`   |
| `s`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v`   |

### selfPermitAllowed

```solidity
  function selfPermitAllowed(
    address token,
    uint256 nonce,
    uint256 expiry,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public
```

Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter

The `owner` is always msg.sender and the `spender` is always address(this)

#### Parameters:

| Name     | Type    | Description                                                                   |
| :------- | :------ | :---------------------------------------------------------------------------- |
| `token`  | address | The address of the token spent                                                |
| `nonce`  | uint256 | The current nonce of the owner                                                |
| `expiry` | uint256 | The timestamp at which the permit is no longer valid                          |
| `v`      | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |

### selfPermitAllowedIfNecessary

```solidity
  function selfPermitAllowedIfNecessary(
    address token,
    uint256 nonce,
    uint256 expiry,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```

Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter

The `owner` is always msg.sender and the `spender` is always address(this)
Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.

#### Parameters:

| Name     | Type    | Description                                                                   |
| :------- | :------ | :---------------------------------------------------------------------------- |
| `token`  | address | The address of the token spent                                                |
| `nonce`  | uint256 | The current nonce of the owner                                                |
| `expiry` | uint256 | The timestamp at which the permit is no longer valid                          |
| `v`      | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/external/IERC1271.md">
Interface that verifies provided signature for the data

Interface defined by EIP-1271

## Functions

### isValidSignature

```solidity
  function isValidSignature(
    bytes32 hash,
    bytes signature
  ) external returns (bytes4 magicValue)
```

Returns whether the provided signature is valid for the provided data

MUST return the bytes4 magic value 0x1626ba7e when function passes.
MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).
MUST allow external calls.

#### Parameters:

| Name        | Type    | Description                                 |
| :---------- | :------ | :------------------------------------------ |
| `hash`      | bytes32 | Hash of the data to be signed               |
| `signature` | bytes   | Signature byte array associated with \_data |

#### Return Values:

| Name         | Type    | Description                       |
| :----------- | :------ | :-------------------------------- |
| `magicValue` | bytes32 | The bytes4 magic value 0x1626ba7e |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/external/IERC20PermitAllowed.md">
Interface used by DAI/CHAI for permit

## Functions

### permit

```solidity
  function permit(
    address holder,
    address spender,
    uint256 nonce,
    uint256 expiry,
    bool allowed,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```

Approve the spender to spend some tokens via the holder signature

This is the permit interface used by DAI and CHAI

#### Parameters:

| Name      | Type    | Description                                                                   |
| :-------- | :------ | :---------------------------------------------------------------------------- |
| `holder`  | address | The address of the token holder, the token owner                              |
| `spender` | address | The address of the token spender                                              |
| `nonce`   | uint256 | The holder's nonce, increases at each call to permit                          |
| `expiry`  | uint256 | The timestamp at which the permit is no longer valid                          |
| `allowed` | bool    | Boolean that sets approval amount, true for type(uint256).max and false for 0 |
| `v`       | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`       | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`       | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/external/IWETH9.md">
## Functions

### deposit

```solidity
  function deposit(
  ) external
```

Deposit ether to get wrapped ether

### withdraw

```solidity
  function withdraw(
  ) external
```

Withdraw wrapped ether to get ether
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/_category_.json">
{
  "label": "Interfaces",
  "position": 1
}
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/IERC20Metadata.md">
Extension to IERC20 that includes token metadata

## Functions

### name

```solidity
  function name(
  ) external returns (string)
```

#### Return Values:

| Type   | Description       |
| :----- | :---------------- |
| string | name of the token |

### symbol

```solidity
  function symbol(
  ) external returns (string)
```

#### Return Values:

| Type   | Description         |
| :----- | :------------------ |
| string | symbol of the token |

### decimals

```solidity
  function decimals(
  ) external returns (uint8)
```

#### Return Values:

| Type  | Description                            |
| :---- | :------------------------------------- |
| uint8 | number of decimal places the token has |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/IERC721Permit.md">
Extension to ERC721 that includes a permit function for signature based approvals

## Functions

### PERMIT_TYPEHASH

```solidity
  function PERMIT_TYPEHASH(
  ) external returns (bytes32)
```

The permit typehash used in the permit signature

#### Return Values:

| Type    | Description             |
| :------ | :---------------------- |
| bytes32 | typehash for the permit |

### DOMAIN_SEPARATOR

```solidity
  function DOMAIN_SEPARATOR(
  ) external returns (bytes32)
```

The domain separator used in the permit signature

#### Return Values:

| Name  | Type | Description                                           |
| :---- | :--- | :---------------------------------------------------- |
| `The` |      | domain seperator used in encoding of permit signature |

### permit

```solidity
  function permit(
    address spender,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```

Approve of a specific token ID for spending by spender via signature

#### Parameters:

| Name       | Type    | Description                                                                    |
| :--------- | :------ | :----------------------------------------------------------------------------- |
| `spender`  | address | The account that is being approved                                             |
| `tokenId`  | uint256 | The ID of the token that is being approved for spending                        |
| `deadline` | uint256 | The deadline timestamp by which the call must be mined for the approve to work |
| `v`        | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s`  |
| `r`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s`  |
| `s`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v`  |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/IMulticall.md">
Enables calling multiple methods in a single call to the contract

## Functions

### multicall

```solidity
  function multicall(
    bytes[] data
  ) external returns (bytes[] results)
```

Call multiple functions in the current contract and return the data from all of them if they all succeed

The `msg.value` should not be trusted for any method callable from multicall.

#### Parameters:

| Name   | Type    | Description                                                              |
| :----- | :------ | :----------------------------------------------------------------------- |
| `data` | bytes[] | The encoded function data for each of the calls to make to this contract |

#### Return Values:

| Name      | Type    | Description                                           |
| :-------- | :------ | :---------------------------------------------------- |
| `results` | bytes[] | The results from each of the calls passed in via data |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/INonfungiblePositionManager.md">
Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred
and authorized.

## Parameter Structs

### MintParams

```solidity
  struct MintParams {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        address recipient;
        uint256 deadline;
    }
```

### IncreaseLiquidityParams

```solidity
   struct IncreaseLiquidityParams {
        uint256 tokenId;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }
```

### DecreaseLiquidityParams

```solidity
    struct DecreaseLiquidityParams {
        uint256 tokenId;
        uint128 liquidity;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }
```

### CollectParams

```solidity
    struct CollectParams {
        uint256 tokenId;
        address recipient;
        uint128 amount0Max;
        uint128 amount1Max;
    }
```

## Functions

### positions

```solidity
  function positions(
    uint256 tokenId
  ) external view returns (uint96 nonce, address operator, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1)
```

Returns the position information associated with a given token ID.

Throws if the token ID is not valid.

#### Parameters:

| Name      | Type    | Description                                      |
| :-------- | :------ | :----------------------------------------------- |
| `tokenId` | uint256 | The ID of the token that represents the position |

#### Return Values:

| Name                       | Type    | Description                                                                      |
| :------------------------- | :------ | :------------------------------------------------------------------------------- |
| `nonce`                    | uint96  | The nonce for permits                                                            |
| `operator`                 | address | The address that is approved for spending                                        |
| `token0`                   | address | The address of the token0 for a specific pool                                    |
| `token1`                   | address | The address of the token1 for a specific pool                                    |
| `fee`                      | uint24  | The fee associated with the pool                                                 |
| `tickLower`                | int24   | The lower end of the tick range for the position                                 |
| `tickUpper`                | int24   | The higher end of the tick range for the position                                |
| `liquidity`                | uint128 | The liquidity of the position                                                    |
| `feeGrowthInside0LastX128` | uint256 | The fee growth of token0 as of the last action on the individual position        |
| `feeGrowthInside1LastX128` | uint256 | The fee growth of token1 as of the last action on the individual position        |
| `tokensOwed0`              | uint128 | The uncollected amount of token0 owed to the position as of the last computation |
| `tokensOwed1`              | uint128 | The uncollected amount of token1 owed to the position as of the last computation |

### createAndInitializePoolIfNecessary

```solidity
  function createAndInitializePoolIfNecessary(
    address tokenA,
    address tokenB,
    uint24 fee,
    uint160 sqrtPriceX96
  ) external returns (address pool)
```

Creates a new pool if it does not exist, then initializes if not initialized

This method can be bundled with mint for the first mint of a pool to create, initialize a pool and mint at the same time

#### Parameters:

| Name           | Type    | Description                                                 |
| :------------- | :------ | :---------------------------------------------------------- |
| `tokenA`       | address | The contract address of either token0 or token1             |
| `tokenB`       | address | The contract address of the other token                     |
| `fee`          | uint24  | The fee amount of the v3 pool for the specified token pair  |
| `sqrtPriceX96` | uint160 | The initial square root price of the pool as a Q64.96 value |

We use tokenA and tokenB when we are referring to unsorted, or unordered tokens

#### Return Values:

| Name   | Type    | Description                                                                                                           |
| :----- | :------ | :-------------------------------------------------------------------------------------------------------------------- |
| `pool` | address | Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary |

### mint

```solidity
  function mint(
    struct INonfungiblePositionManager.MintParams params
  ) external returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1)
```

Creates a new position wrapped in a NFT

Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
a method does not exist, i.e. the pool is assumed to be initialized.

#### Parameters:

| Name     | Type                                          | Description                                                                  |
| :------- | :-------------------------------------------- | :--------------------------------------------------------------------------- |
| `params` | struct INonfungiblePositionManager.MintParams | The params necessary to mint a position, encoded as `MintParams` in calldata |

#### Return Values:

| Name        | Type    | Description                                             |
| :---------- | :------ | :------------------------------------------------------ |
| `tokenId`   | uint256 | The ID of the token that represents the minted position |
| `liquidity` | uint128 | The amount of liquidity for this position               |
| `amount0`   | uint256 | The amount of token0                                    |
| `amount1`   | uint256 | The amount of token1                                    |

### increaseLiquidity

```solidity
  function increaseLiquidity(
    struct INonfungiblePositionManager.IncreaseLiquidityParams params
  ) external returns (uint128 liquidity, uint256 amount0, uint256 amount1)
```

Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`

#### Parameters:

| Name     | Type                                                       | Description                                                         |
| :------- | :--------------------------------------------------------- | :------------------------------------------------------------------ |
| `params` | struct INonfungiblePositionManager.IncreaseLiquidityParams | tokenId The ID of the token for which liquidity is being increased, |

#### Return Values:

| Name        | Type    | Description                                          |
| :---------- | :------ | :--------------------------------------------------- |
| `liquidity` | uint128 | The new liquidity amount as a result of the increase |
| `amount0`   | uint256 | The amount of token0 to acheive resulting liquidity  |
| `amount1`   | uint256 | The amount of token1 to acheive resulting liquidity  |

### decreaseLiquidity

```solidity
  function decreaseLiquidity(
    struct INonfungiblePositionManager.DecreaseLiquidityParams params
  ) external returns (uint256 amount0, uint256 amount1)
```

Decreases the amount of liquidity in a position and accounts it to the position

#### Parameters:

| Name     | Type                                                       | Description                                                        |
| :------- | :--------------------------------------------------------- | :----------------------------------------------------------------- |
| `params` | struct INonfungiblePositionManager.DecreaseLiquidityParams | tokenId The ID of the token for which liquidity is being decreased |

#### Return Values:

| Name      | Type    | Description                            |
| :-------- | :------ | :------------------------------------- |
| `amount0` | uint256 | The amount of token0 sent to recipient |
| `amount1` | uint256 | The amount of token1 sent to recipient |

### collect

```solidity
  function collect(
    struct INonfungiblePositionManager.CollectParams params
  ) external returns (uint256 amount0, uint256 amount1)
```

Collects up to a maximum amount of fees owed to a specific position to the recipient

#### Parameters:

| Name     | Type                                             | Description                                                     |
| :------- | :----------------------------------------------- | :-------------------------------------------------------------- |
| `params` | struct INonfungiblePositionManager.CollectParams | tokenId The ID of the NFT for which tokens are being collected, |

#### Return Values:

| Name      | Type    | Description                            |
| :-------- | :------ | :------------------------------------- |
| `amount0` | uint256 | The amount of fees collected in token0 |
| `amount1` | uint256 | The amount of fees collected in token1 |

### burn

```solidity
  function burn(
    uint256 tokenId
  ) external
```

Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
must be collected first.

#### Parameters:

| Name      | Type    | Description                              |
| :-------- | :------ | :--------------------------------------- |
| `tokenId` | uint256 | The ID of the token that is being burned |

## Events

### IncreaseLiquidity

```solidity
  event IncreaseLiquidity(
    uint256 tokenId,
    uint128 liquidity,
    uint256 amount0,
    uint256 amount1
  )
```

Emitted when liquidity is increased for a position NFT

Also emitted when a token is minted

#### Parameters:

| Name        | Type    | Description                                                      |
| :---------- | :------ | :--------------------------------------------------------------- |
| `tokenId`   | uint256 | The ID of the token for which liquidity was increased            |
| `liquidity` | uint128 | The amount by which liquidity for the NFT position was increased |
| `amount0`   | uint256 | The amount of token0 that was paid for the increase in liquidity |
| `amount1`   | uint256 | The amount of token1 that was paid for the increase in liquidity |

### DecreaseLiquidity

```solidity
  event DecreaseLiquidity(
    uint256 tokenId,
    uint128 liquidity,
    uint256 amount0,
    uint256 amount1
  )
```

Emitted when liquidity is decreased for a position NFT

#### Parameters:

| Name        | Type    | Description                                                           |
| :---------- | :------ | :-------------------------------------------------------------------- |
| `tokenId`   | uint256 | The ID of the token for which liquidity was decreased                 |
| `liquidity` | uint128 | The amount by which liquidity for the NFT position was decreased      |
| `amount0`   | uint256 | The amount of token0 that was accounted for the decrease in liquidity |
| `amount1`   | uint256 | The amount of token1 that was accounted for the decrease in liquidity |

### Collect

```solidity
  event Collect(
    uint256 tokenId,
    address recipient,
    uint256 amount0,
    uint256 amount1
  )
```

Emitted when tokens are collected for a position NFT

The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior

#### Parameters:

| Name        | Type    | Description                                                    |
| :---------- | :------ | :------------------------------------------------------------- |
| `tokenId`   | uint256 | The ID of the token for which underlying tokens were collected |
| `recipient` | address | The address of the account that received the collected tokens  |
| `amount0`   | uint256 | The amount of token0 owed to the position that was collected   |
| `amount1`   | uint256 | The amount of token1 owed to the position that was collected   |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/INonfungibleTokenPositionDescriptor.md">
## Functions

### tokenURI

```solidity
  function tokenURI(
    contract INonfungiblePositionManager positionManager,
    uint256 tokenId
  ) external returns (string)
```

Produces the URI describing a particular token ID for a position manager

Note this URI may be a data: URI with the JSON contents directly inlined

#### Parameters:

| Name              | Type                                 | Description                                                                    |
| :---------------- | :----------------------------------- | :----------------------------------------------------------------------------- |
| `positionManager` | contract INonfungiblePositionManager | The position manager for which to describe the token                           |
| `tokenId`         | uint256                              | The ID of the token for which to produce a description, which may not be valid |

#### Return Values:

| Type   | Description                          |
| :----- | :----------------------------------- |
| string | URI of the ERC721-compliant metadata |

## Events

### UpdateTokenRatioPriority

```solidity
  event UpdateTokenRatioPriority(
    address token,
    int256 priority
  )
```

Emitted when a token is given a new priority order in the displayed price ratio

#### Parameters:

| Name       | Type    | Description                                                           |
| :--------- | :------ | :-------------------------------------------------------------------- |
| `token`    | address | The token being given priority order                                  |
| `priority` | int256  | Represents priority in ratio - higher integers get numerator priority |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/IPeripheryImmutableState.md">
Functions that return immutable state of the router

## Functions

### factory

```solidity
  function factory(
  ) external returns (address)
```

#### Return Values:

| Type    | Description                           |
| :------ | :------------------------------------ |
| address | the address of the Uniswap V3 factory |

### WETH9

```solidity
  function WETH9(
  ) external returns (address)
```

#### Return Values:

| Type    | Description          |
| :------ | :------------------- |
| address | the address of WETH9 |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/IPeripheryPayments.md">
Functions to ease deposits and withdrawals of ETH

## Functions

### unwrapWETH9

```solidity
  function unwrapWETH9(
    uint256 amountMinimum,
    address recipient
  ) external
```

Unwraps the contract's WETH9 balance and sends it to recipient as ETH.

The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.

#### Parameters:

| Name            | Type    | Description                           |
| :-------------- | :------ | :------------------------------------ |
| `amountMinimum` | uint256 | The minimum amount of WETH9 to unwrap |
| `recipient`     | address | The address receiving ETH             |

### refundETH

```solidity
  function refundETH(
  ) external
```

Refunds any ETH balance held by this contract to the `msg.sender`

Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps
that use ether for the input amount

### sweepToken

```solidity
  function sweepToken(
    address token,
    uint256 amountMinimum,
    address recipient
  ) external
```

Transfers the full amount of a token held by this contract to recipient

The amountMinimum parameter prevents malicious contracts from stealing the token from users

#### Parameters:

| Name            | Type    | Description                                                                |
| :-------------- | :------ | :------------------------------------------------------------------------- |
| `token`         | address | The contract address of the token which will be transferred to `recipient` |
| `amountMinimum` | uint256 | The minimum amount of token required for a transfer                        |
| `recipient`     | address | The destination address of the token                                       |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/IPeripheryPaymentsWithFee.md">
Functions to ease deposits and withdrawals of ETH

## Functions

### unwrapWETH9WithFee

```solidity
  function unwrapWETH9WithFee(
  ) external
```

Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between
0 (exclusive), and 1 (inclusive) going to feeRecipient

The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.

### sweepTokenWithFee

```solidity
  function sweepTokenWithFee(
  ) external
```

Transfers the full amount of a token held by this contract to recipient, with a percentage between
0 (exclusive) and 1 (inclusive) going to feeRecipient

The amountMinimum parameter prevents malicious contracts from stealing the token from users
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/IPoolInitializer.md">
Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that
require the pool to exist.

## Functions

### createAndInitializePoolIfNecessary

```solidity
  function createAndInitializePoolIfNecessary(
    address token0,
    address token1,
    uint24 fee,
    uint160 sqrtPriceX96
  ) external returns (address pool)
```

Creates a new pool if it does not exist, then initializes if not initialized

This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool

#### Parameters:

| Name           | Type    | Description                                                 |
| :------------- | :------ | :---------------------------------------------------------- |
| `token0`       | address | The contract address of token0 of the pool                  |
| `token1`       | address | The contract address of token1 of the pool                  |
| `fee`          | uint24  | The fee amount of the v3 pool for the specified token pair  |
| `sqrtPriceX96` | uint160 | The initial square root price of the pool as a Q64.96 value |

#### Return Values:

| Name   | Type    | Description                                                                                                           |
| :----- | :------ | :-------------------------------------------------------------------------------------------------------------------- |
| `pool` | address | Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/IQuoter.md">
Supports quoting the calculated amounts from exact input or exact output swaps

These functions are not marked view because they rely on calling non-view functions and reverting
to compute the result. They are also not gas efficient and should not be called on-chain.

## Functions

### quoteExactInput

```solidity
  function quoteExactInput(
    bytes path,
    uint256 amountIn
  ) external returns (uint256 amountOut)
```

Returns the amount out received for a given exact input swap without executing the swap

#### Parameters:

| Name       | Type    | Description                                                 |
| :--------- | :------ | :---------------------------------------------------------- |
| `path`     | bytes   | The path of the swap, i.e. each token pair and the pool fee |
| `amountIn` | uint256 | The amount of the first token to swap                       |

#### Return Values:

| Name        | Type    | Description                                         |
| :---------- | :------ | :-------------------------------------------------- |
| `amountOut` | uint256 | The amount of the last token that would be received |

### quoteExactInputSingle

```solidity
  function quoteExactInputSingle(
    address tokenIn,
    address tokenOut,
    uint24 fee,
    uint256 amountIn,
    uint160 sqrtPriceLimitX96
  ) external returns (uint256 amountOut)
```

Returns the amount out received for a given exact input but for a swap of a single pool

#### Parameters:

| Name                | Type    | Description                                                     |
| :------------------ | :------ | :-------------------------------------------------------------- |
| `tokenIn`           | address | The token being swapped in                                      |
| `tokenOut`          | address | The token being swapped out                                     |
| `fee`               | uint24  | The fee of the token pool to consider for the pair              |
| `amountIn`          | uint256 | The desired input amount                                        |
| `sqrtPriceLimitX96` | uint160 | The price limit of the pool that cannot be exceeded by the swap |

#### Return Values:

| Name        | Type    | Description                                     |
| :---------- | :------ | :---------------------------------------------- |
| `amountOut` | uint256 | The amount of `tokenOut` that would be received |

### quoteExactOutput

```solidity
  function quoteExactOutput(
    bytes path,
    uint256 amountOut
  ) external returns (uint256 amountIn)
```

Returns the amount in required for a given exact output swap without executing the swap

#### Parameters:

| Name        | Type    | Description                                                 |
| :---------- | :------ | :---------------------------------------------------------- |
| `path`      | bytes   | The path of the swap, i.e. each token pair and the pool fee |
| `amountOut` | uint256 | The amount of the last token to receive                     |

#### Return Values:

| Name       | Type    | Description                                   |
| :--------- | :------ | :-------------------------------------------- |
| `amountIn` | uint256 | The amount of first token required to be paid |

### quoteExactOutputSingle

```solidity
  function quoteExactOutputSingle(
    address tokenIn,
    address tokenOut,
    uint24 fee,
    uint256 amountOut,
    uint160 sqrtPriceLimitX96
  ) external returns (uint256 amountIn)
```

Returns the amount in required to receive the given exact output amount but for a swap of a single pool

#### Parameters:

| Name                | Type    | Description                                                     |
| :------------------ | :------ | :-------------------------------------------------------------- |
| `tokenIn`           | address | The token being swapped in                                      |
| `tokenOut`          | address | The token being swapped out                                     |
| `fee`               | uint24  | The fee of the token pool to consider for the pair              |
| `amountOut`         | uint256 | The desired output amount                                       |
| `sqrtPriceLimitX96` | uint160 | The price limit of the pool that cannot be exceeded by the swap |

#### Return Values:

| Name       | Type    | Description                                                                   |
| :--------- | :------ | :---------------------------------------------------------------------------- |
| `amountIn` | uint256 | The amount required as the input for the swap in order to receive `amountOut` |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/IQuoterV2.md">
Supports quoting the calculated amounts from exact input or exact output swaps.
For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.

These functions are not marked view because they rely on calling non-view functions and reverting
to compute the result. They are also not gas efficient and should not be called on-chain.

## Functions

### quoteExactInput

```solidity
  function quoteExactInput(
    bytes path,
    uint256 amountIn
  ) external returns (uint256 amountOut, uint160[] sqrtPriceX96AfterList, uint32[] initializedTicksCrossedList, uint256 gasEstimate)
```

Returns the amount out received for a given exact input swap without executing the swap

#### Parameters:

| Name       | Type    | Description                                                 |
| :--------- | :------ | :---------------------------------------------------------- |
| `path`     | bytes   | The path of the swap, i.e. each token pair and the pool fee |
| `amountIn` | uint256 | The amount of the first token to swap                       |

#### Return Values:

| Name                          | Type    | Description                                                                   |
| :---------------------------- | :------ | :---------------------------------------------------------------------------- |
| `amountOut`                   | bytes   | The amount of the last token that would be received                           |
| `sqrtPriceX96AfterList`       | uint256 | List of the sqrt price after the swap for each pool in the path               |
| `initializedTicksCrossedList` |         | List of the initialized ticks that the swap crossed for each pool in the path |
| `gasEstimate`                 |         | The estimate of the gas that the swap consumes                                |

### quoteExactInputSingle

```solidity
  function quoteExactInputSingle(
    struct IQuoterV2.QuoteExactInputSingleParams params
  ) external returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)
```

Returns the amount out received for a given exact input but for a swap of a single pool

#### Parameters:

| Name     | Type                                         | Description                                                        |
| :------- | :------------------------------------------- | :----------------------------------------------------------------- |
| `params` | struct IQuoterV2.QuoteExactInputSingleParams | The params for the quote, encoded as `QuoteExactInputSingleParams` |

tokenIn The token being swapped in
tokenOut The token being swapped out
fee The fee of the token pool to consider for the pair
amountIn The desired input amount
sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap

#### Return Values:

| Name                      | Type                                         | Description                                           |
| :------------------------ | :------------------------------------------- | :---------------------------------------------------- |
| `amountOut`               | struct IQuoterV2.QuoteExactInputSingleParams | The amount of `tokenOut` that would be received       |
| `sqrtPriceX96After`       |                                              | The sqrt price of the pool after the swap             |
| `initializedTicksCrossed` |                                              | The number of initialized ticks that the swap crossed |
| `gasEstimate`             |                                              | The estimate of the gas that the swap consumes        |

### quoteExactOutput

```solidity
  function quoteExactOutput(
    bytes path,
    uint256 amountOut
  ) external returns (uint256 amountIn, uint160[] sqrtPriceX96AfterList, uint32[] initializedTicksCrossedList, uint256 gasEstimate)
```

Returns the amount in required for a given exact output swap without executing the swap

#### Parameters:

| Name        | Type    | Description                                                                                         |
| :---------- | :------ | :-------------------------------------------------------------------------------------------------- |
| `path`      | bytes   | The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order |
| `amountOut` | uint256 | The amount of the last token to receive                                                             |

#### Return Values:

| Name                          | Type    | Description                                                                   |
| :---------------------------- | :------ | :---------------------------------------------------------------------------- |
| `amountIn`                    | bytes   | The amount of first token required to be paid                                 |
| `sqrtPriceX96AfterList`       | uint256 | List of the sqrt price after the swap for each pool in the path               |
| `initializedTicksCrossedList` |         | List of the initialized ticks that the swap crossed for each pool in the path |
| `gasEstimate`                 |         | The estimate of the gas that the swap consumes                                |

### quoteExactOutputSingle

```solidity
  function quoteExactOutputSingle(
    struct IQuoterV2.QuoteExactOutputSingleParams params
  ) external returns (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)
```

Returns the amount in required to receive the given exact output amount but for a swap of a single pool

#### Parameters:

| Name     | Type                                          | Description                                                         |
| :------- | :-------------------------------------------- | :------------------------------------------------------------------ |
| `params` | struct IQuoterV2.QuoteExactOutputSingleParams | The params for the quote, encoded as `QuoteExactOutputSingleParams` |

tokenIn The token being swapped in
tokenOut The token being swapped out
fee The fee of the token pool to consider for the pair
amountOut The desired output amount
sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap

#### Return Values:

| Name                      | Type                                          | Description                                                                   |
| :------------------------ | :-------------------------------------------- | :---------------------------------------------------------------------------- |
| `amountIn`                | struct IQuoterV2.QuoteExactOutputSingleParams | The amount required as the input for the swap in order to receive `amountOut` |
| `sqrtPriceX96After`       |                                               | The sqrt price of the pool after the swap                                     |
| `initializedTicksCrossed` |                                               | The number of initialized ticks that the swap crossed                         |
| `gasEstimate`             |                                               | The estimate of the gas that the swap consumes                                |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/ISelfPermit.md">
Functionality to call permit on any EIP-2612-compliant token for use in the route

## Functions

### selfPermit

```solidity
  function selfPermit(
    address token,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```

Permits this contract to spend a given token from `msg.sender`

The `owner` is always msg.sender and the `spender` is always address(this).

#### Parameters:

| Name       | Type    | Description                                                                     |
| :--------- | :------ | :------------------------------------------------------------------------------ |
| `token`    | address | The address of the token spent                                                  |
| `value`    | uint256 | The amount that can be spent of token                                           |
| `deadline` | uint256 | A timestamp, the current blocktime must be less than or equal to this timestamp |
| `v`        | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s`   |
| `r`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s`   |
| `s`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v`   |

### selfPermitIfNecessary

```solidity
  function selfPermitIfNecessary(
    address token,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```

Permits this contract to spend a given token from `msg.sender`

The `owner` is always msg.sender and the `spender` is always address(this).
Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit

#### Parameters:

| Name       | Type    | Description                                                                     |
| :--------- | :------ | :------------------------------------------------------------------------------ |
| `token`    | address | The address of the token spent                                                  |
| `value`    | uint256 | The amount that can be spent of token                                           |
| `deadline` | uint256 | A timestamp, the current blocktime must be less than or equal to this timestamp |
| `v`        | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s`   |
| `r`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s`   |
| `s`        | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v`   |

### selfPermitAllowed

```solidity
  function selfPermitAllowed(
    address token,
    uint256 nonce,
    uint256 expiry,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```

Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter

The `owner` is always msg.sender and the `spender` is always address(this)

#### Parameters:

| Name     | Type    | Description                                                                   |
| :------- | :------ | :---------------------------------------------------------------------------- |
| `token`  | address | The address of the token spent                                                |
| `nonce`  | uint256 | The current nonce of the owner                                                |
| `expiry` | uint256 | The timestamp at which the permit is no longer valid                          |
| `v`      | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |

### selfPermitAllowedIfNecessary

```solidity
  function selfPermitAllowedIfNecessary(
    address token,
    uint256 nonce,
    uint256 expiry,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external
```

Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter

The `owner` is always msg.sender and the `spender` is always address(this)
Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.

#### Parameters:

| Name     | Type    | Description                                                                   |
| :------- | :------ | :---------------------------------------------------------------------------- |
| `token`  | address | The address of the token spent                                                |
| `nonce`  | uint256 | The current nonce of the owner                                                |
| `expiry` | uint256 | The timestamp at which the permit is no longer valid                          |
| `v`      | uint8   | Must produce valid secp256k1 signature from the holder along with `r` and `s` |
| `r`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `v` and `s` |
| `s`      | bytes32 | Must produce valid secp256k1 signature from the holder along with `r` and `v` |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/ISwapRouter.md">
Functions for swapping tokens via Uniswap V3

## Parameter Structs

Note that `fee` is in hundredths of basis points (e.g. the `fee` for a pool at the 0.3% tier is 3000; the `fee` for a pool at the 0.01% tier is 100).

### ExactInputSingleParams

```solidity
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }
```

### ExactInputParams

```solidity
   struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }
```

### ExactOutputSingleParams

```solidity
    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }
```

### ExactOutputParams

```solidity
    struct ExactOutputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
    }
```

## Functions

### exactInputSingle

```solidity
  function exactInputSingle(
    struct ISwapRouter.ExactInputSingleParams params
  ) external returns (uint256 amountOut)
```

Swaps `amountIn` of one token for as much as possible of another token

#### Parameters:

| Name     | Type                                      | Description                                                                            |
| :------- | :---------------------------------------- | :------------------------------------------------------------------------------------- |
| `params` | struct ISwapRouter.ExactInputSingleParams | The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata |

#### Return Values:

| Name        | Type                                      | Description                      |
| :---------- | :---------------------------------------- | :------------------------------- |
| `amountOut` | struct ISwapRouter.ExactInputSingleParams | The amount of the received token |

### exactInput

```solidity
  function exactInput(
    struct ISwapRouter.ExactInputParams params
  ) external returns (uint256 amountOut)
```

Swaps `amountIn` of one token for as much as possible of another along the specified path

#### Parameters:

| Name     | Type                                | Description                                                                                |
| :------- | :---------------------------------- | :----------------------------------------------------------------------------------------- |
| `params` | struct ISwapRouter.ExactInputParams | The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata |

#### Return Values:

| Name        | Type                                | Description                      |
| :---------- | :---------------------------------- | :------------------------------- |
| `amountOut` | struct ISwapRouter.ExactInputParams | The amount of the received token |

### exactOutputSingle

```solidity
  function exactOutputSingle(
    struct ISwapRouter.ExactOutputSingleParams params
  ) external returns (uint256 amountIn)
```

Swaps as little as possible of one token for `amountOut` of another token

#### Parameters:

| Name     | Type                                       | Description                                                                             |
| :------- | :----------------------------------------- | :-------------------------------------------------------------------------------------- |
| `params` | struct ISwapRouter.ExactOutputSingleParams | The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata |

#### Return Values:

| Name       | Type                                       | Description                   |
| :--------- | :----------------------------------------- | :---------------------------- |
| `amountIn` | struct ISwapRouter.ExactOutputSingleParams | The amount of the input token |

### exactOutput

```solidity
  function exactOutput(
    struct ISwapRouter.ExactOutputParams params
  ) external returns (uint256 amountIn)
```

Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)

#### Parameters:

| Name     | Type                                 | Description                                                                                 |
| :------- | :----------------------------------- | :------------------------------------------------------------------------------------------ |
| `params` | struct ISwapRouter.ExactOutputParams | The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata |

#### Return Values:

| Name       | Type                                 | Description                   |
| :--------- | :----------------------------------- | :---------------------------- |
| `amountIn` | struct ISwapRouter.ExactOutputParams | The amount of the input token |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/ITickLens.md">
Provides functions for fetching chunks of tick data for a pool

This avoids the waterfall of fetching the tick bitmap, parsing the bitmap to know which ticks to fetch, and
then sending additional multicalls to fetch the tick data

## Functions

### getPopulatedTicksInWord

```solidity
  function getPopulatedTicksInWord(
    address pool,
    int16 tickBitmapIndex
  ) external returns (struct ITickLens.PopulatedTick[] populatedTicks)
```

Get all the tick data for the populated ticks from a word of the tick bitmap of a pool

#### Parameters:

| Name              | Type    | Description                                                                                              |
| :---------------- | :------ | :------------------------------------------------------------------------------------------------------- |
| `pool`            | address | The address of the pool for which to fetch populated tick data                                           |
| `tickBitmapIndex` | int16   | The index of the word in the tick bitmap for which to parse the bitmap and fetch all the populated ticks |

#### Return Values:

| Name             | Type                      | Description                                                 |
| :--------------- | :------------------------ | :---------------------------------------------------------- |
| `populatedTicks` | ITickLens.PopulatedTick[] | An array of tick data for the given word in the tick bitmap |
</file>

<file path="docs/contracts/v3/reference/periphery/interfaces/IV3Migrator.md">
Enables migration of liqudity from Uniswap v2-compatible pairs into Uniswap v3 pools

## Functions

### migrate

```solidity
  function migrate(
    struct IV3Migrator.MigrateParams params
  ) external
```

Migrates liquidity to v3 by burning v2 liquidity and minting a new position for v3

Slippage protection is enforced via `amount{0,1}Min`, which should be a discount of the expected values of
the maximum amount of v3 liquidity that the v2 liquidity can get. For the special case of migrating to an
out-of-range position, `amount{0,1}Min` may be set to 0, enforcing that the position remains out of range

#### Parameters:

| Name     | Type                             | Description                                                                          |
| :------- | :------------------------------- | :----------------------------------------------------------------------------------- |
| `params` | struct IV3Migrator.MigrateParams | The params necessary to migrate v2 liquidity, encoded as `MigrateParams` in calldata |
</file>

<file path="docs/contracts/v3/reference/periphery/lens/_category_.json">
{
  "label": "Lens",
  "position": 3
}
</file>

<file path="docs/contracts/v3/reference/periphery/lens/Quoter.md">
Allows getting the expected amount out or amount in for a given swap without executing the swap

These functions are not gas efficient and should _not_ be called on chain. Instead, optimistically execute
the swap and check the amounts in the callback.

## Functions

### constructor

```solidity
  function constructor(
  ) public
```

### uniswapV3SwapCallback

```solidity
  function uniswapV3SwapCallback(
    int256 amount0Delta,
    int256 amount1Delta,
    bytes data
  ) external
```

Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.

In the implementation you must pay the pool tokens owed for the swap.
The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
amount0Delta and amount1Delta can both be 0 if no tokens were swapped.

#### Parameters:

| Name           | Type   | Description                                                                                 |
| :------------- | :----- | :------------------------------------------------------------------------------------------ |
| `amount0Delta` | int256 | The amount of token0 that was sent (negative) or must be received (positive) by the pool by |

the end of the swap. If positive, the callback must send that amount of token0 to the pool.
|`amount1Delta` | int256 | The amount of token1 that was sent (negative) or must be received (positive) by the pool by
the end of the swap. If positive, the callback must send that amount of token1 to the pool.
|`data` | bytes | Any data passed through by the caller via the IUniswapV3PoolActions#swap call

### quoteExactInputSingle

```solidity
  function quoteExactInputSingle(
    address tokenIn,
    address tokenOut,
    uint24 fee,
    uint256 amountIn,
    uint160 sqrtPriceLimitX96
  ) public returns (uint256 amountOut)
```

Returns the amount out received for a given exact input but for a swap of a single pool

#### Parameters:

| Name                | Type    | Description                                                     |
| :------------------ | :------ | :-------------------------------------------------------------- |
| `tokenIn`           | address | The token being swapped in                                      |
| `tokenOut`          | address | The token being swapped out                                     |
| `fee`               | uint24  | The fee of the token pool to consider for the pair              |
| `amountIn`          | uint256 | The desired input amount                                        |
| `sqrtPriceLimitX96` | uint160 | The price limit of the pool that cannot be exceeded by the swap |

#### Return Values:

| Name        | Type    | Description                                     |
| :---------- | :------ | :---------------------------------------------- |
| `amountOut` | uint256 | The amount of `tokenOut` that would be received |

### quoteExactInput

```solidity
  function quoteExactInput(
    bytes path,
    uint256 amountIn
  ) external returns (uint256 amountOut)
```

Returns the amount out received for a given exact input swap without executing the swap

#### Parameters:

| Name       | Type    | Description                                                 |
| :--------- | :------ | :---------------------------------------------------------- |
| `path`     | bytes   | The path of the swap, i.e. each token pair and the pool fee |
| `amountIn` | uint256 | The amount of the first token to swap                       |

#### Return Values:

| Name        | Type    | Description                                         |
| :---------- | :------ | :-------------------------------------------------- |
| `amountOut` | uint256 | The amount of the last token that would be received |

### quoteExactOutputSingle

```solidity
  function quoteExactOutputSingle(
    address tokenIn,
    address tokenOut,
    uint24 fee,
    uint256 amountOut,
    uint160 sqrtPriceLimitX96
  ) public returns (uint256 amountIn)
```

Returns the amount in required to receive the given exact output amount but for a swap of a single pool

#### Parameters:

| Name                | Type    | Description                                                     |
| :------------------ | :------ | :-------------------------------------------------------------- |
| `tokenIn`           | address | The token being swapped in                                      |
| `tokenOut`          | address | The token being swapped out                                     |
| `fee`               | uint24  | The fee of the token pool to consider for the pair              |
| `amountOut`         | uint256 | The desired output amount                                       |
| `sqrtPriceLimitX96` | uint160 | The price limit of the pool that cannot be exceeded by the swap |

#### Return Values:

| Name       | Type    | Description                                                                   |
| :--------- | :------ | :---------------------------------------------------------------------------- |
| `amountIn` | uint256 | The amount required as the input for the swap in order to receive `amountOut` |

### quoteExactOutput

```solidity
  function quoteExactOutput(
    bytes path,
    uint256 amountOut
  ) external returns (uint256 amountIn)
```

Returns the amount in required for a given exact output swap without executing the swap

#### Parameters:

| Name        | Type    | Description                                                 |
| :---------- | :------ | :---------------------------------------------------------- |
| `path`      | bytes   | The path of the swap, i.e. each token pair and the pool fee |
| `amountOut` | uint256 | The amount of the last token to receive                     |

#### Return Values:

| Name       | Type    | Description                                   |
| :--------- | :------ | :-------------------------------------------- |
| `amountIn` | uint256 | The amount of first token required to be paid |
</file>

<file path="docs/contracts/v3/reference/periphery/lens/QuoterV2.md">
Allows getting the expected amount out or amount in for a given swap without executing the swap

These functions are not gas efficient and should _not_ be called on chain. Instead, optimistically execute
the swap and check the amounts in the callback.

## Functions

### constructor

```solidity
  function constructor(
  ) public
```

### uniswapV3SwapCallback

```solidity
  function uniswapV3SwapCallback(
    int256 amount0Delta,
    int256 amount1Delta,
    bytes data
  ) external view override
```

Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.

In the implementation you must pay the pool tokens owed for the swap.
The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
amount0Delta and amount1Delta can both be 0 if no tokens were swapped.

#### Parameters:

| Name           | Type   | Description                                                                                 |
| :------------- | :----- | :------------------------------------------------------------------------------------------ |
| `amount0Delta` | int256 | The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool. |
|`amount1Delta` | int256 | The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool. |
|`data` | bytes | Any data passed through by the caller via the IUniswapV3PoolActions#swap call. |

### quoteExactInputSingle

```solidity
  function quoteExactInputSingle(
  ) public override returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)
```

### quoteExactInput

```solidity
  function quoteExactInput(
  ) public override returns (uint256 amountOut, uint160[] sqrtPriceX96AfterList, uint32[] initializedTicksCrossedList, uint256 gasEstimate)
```

### quoteExactOutputSingle

```solidity
  function quoteExactOutputSingle(
  ) public override returns (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)
```

### quoteExactOutput

```solidity
  function quoteExactOutput(
  ) public override returns (uint256 amountIn, uint160[] sqrtPriceX96AfterList, uint32[] initializedTicksCrossedList, uint256 gasEstimate)
```
</file>

<file path="docs/contracts/v3/reference/periphery/lens/TickLens.md">
## Functions

### getPopulatedTicksInWord

```solidity
  function getPopulatedTicksInWord(
    address pool,
    int16 tickBitmapIndex
  ) public returns (struct ITickLens.PopulatedTick[] populatedTicks)
```

Get all the tick data for the populated ticks from a word of the tick bitmap of a pool

#### Parameters:

| Name              | Type    | Description                                                                                              |
| :---------------- | :------ | :------------------------------------------------------------------------------------------------------- |
| `pool`            | address | The address of the pool for which to fetch populated tick data                                           |
| `tickBitmapIndex` | int16   | The index of the word in the tick bitmap for which to parse the bitmap and fetch all the populated ticks |

#### Return Values:

| Name             | Type                      | Description                                                 |
| :--------------- | :------------------------ | :---------------------------------------------------------- |
| `populatedTicks` | ITickLens.PopulatedTick[] | An array of tick data for the given word in the tick bitmap |
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/_category_.json">
{
  "label": "Libraries",
  "position": 4
}
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/Base64.md">
Provides a function for encoding some bytes in base64

## Functions

### encode

```solidity
  function encode(
  ) internal returns (string)
```

Encodes some bytes to the base64 representation
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/BytesLib.md">
## Functions

### slice

```solidity
  function slice(
  ) internal returns (bytes)
```

### toAddress

```solidity
  function toAddress(
  ) internal returns (address)
```

### toUint24

```solidity
  function toUint24(
  ) internal returns (uint24)
```
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/CallbackValidation.md">
Provides validation for callbacks from Uniswap V3 Pools

## Functions

### verifyCallback

```solidity
  function verifyCallback(
    address factory,
    address tokenA,
    address tokenB,
    uint24 fee
  ) internal returns (contract IUniswapV3Pool pool)
```

Returns the address of a valid Uniswap V3 Pool

#### Parameters:

| Name      | Type    | Description                                                                       |
| :-------- | :------ | :-------------------------------------------------------------------------------- |
| `factory` | address | The contract address of the Uniswap V3 factory                                    |
| `tokenA`  | address | The contract address of either token0 or token1                                   |
| `tokenB`  | address | The contract address of the other token                                           |
| `fee`     | uint24  | The fee collected upon every swap in the pool, denominated in hundredths of a bip |

#### Return Values:

| Name   | Type           | Description                  |
| :----- | :------------- | :--------------------------- |
| `pool` | IUniswapV3Pool | The V3 pool contract address |

### verifyCallback

```solidity
  function verifyCallback(
    address factory,
    struct PoolAddress.PoolKey poolKey
  ) internal returns (contract IUniswapV3Pool pool)
```

Returns the address of a valid Uniswap V3 Pool

#### Parameters:

| Name      | Type                       | Description                                    |
| :-------- | :------------------------- | :--------------------------------------------- |
| `factory` | address                    | The contract address of the Uniswap V3 factory |
| `poolKey` | struct PoolAddress.PoolKey | The identifying key of the V3 pool             |

#### Return Values:

| Name   | Type           | Description                  |
| :----- | :------------- | :--------------------------- |
| `pool` | IUniswapV3Pool | The V3 pool contract address |
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/ChainId.md">
## Functions

### get

```solidity
  function get(
  ) internal returns (uint256 chainId)
```

Gets the current chain ID

#### Return Values:

| Name      | Type    | Description          |
| :-------- | :------ | :------------------- |
| `chainId` | uint256 | The current chain ID |
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/HexStrings.md">
## Functions

### toHexString

```solidity
  function toHexString(
  ) internal returns (string)
```

Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

Credit to Open Zeppelin under MIT license https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55

### toHexStringNoPrefix

```solidity
  function toHexStringNoPrefix(
  ) internal returns (string)
```
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/LiquidityAmounts.md">
Provides functions for computing liquidity amounts from token amounts and prices

## Functions

### getLiquidityForAmount0

```solidity
  function getLiquidityForAmount0(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint256 amount0
  ) internal returns (uint128 liquidity)
```

Computes the amount of liquidity received for a given amount of token0 and price range

Calculates amount0 _ (sqrt(upper) _ sqrt(lower)) / (sqrt(upper) - sqrt(lower))

#### Parameters:

| Name            | Type    | Description                                        |
| :-------------- | :------ | :------------------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price representing the first tick boundary  |
| `sqrtRatioBX96` | uint160 | A sqrt price representing the second tick boundary |
| `amount0`       | uint256 | The amount0 being sent in                          |

#### Return Values:

| Name        | Type    | Description                      |
| :---------- | :------ | :------------------------------- |
| `liquidity` | uint128 | The amount of returned liquidity |

### getLiquidityForAmount1

```solidity
  function getLiquidityForAmount1(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint256 amount1
  ) internal returns (uint128 liquidity)
```

Computes the amount of liquidity received for a given amount of token1 and price range

Calculates amount1 / (sqrt(upper) - sqrt(lower)).

#### Parameters:

| Name            | Type    | Description                                        |
| :-------------- | :------ | :------------------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price representing the first tick boundary  |
| `sqrtRatioBX96` | uint160 | A sqrt price representing the second tick boundary |
| `amount1`       | uint256 | The amount1 being sent in                          |

#### Return Values:

| Name        | Type    | Description                      |
| :---------- | :------ | :------------------------------- |
| `liquidity` | uint128 | The amount of returned liquidity |

### getLiquidityForAmounts

```solidity
  function getLiquidityForAmounts(
    uint160 sqrtRatioX96,
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint256 amount0,
    uint256 amount1
  ) internal returns (uint128 liquidity)
```

Computes the maximum amount of liquidity received for a given amount of token0, token1, the current
pool prices and the prices at the tick boundaries

#### Parameters:

| Name            | Type    | Description                                        |
| :-------------- | :------ | :------------------------------------------------- |
| `sqrtRatioX96`  | uint160 | A sqrt price representing the current pool prices  |
| `sqrtRatioAX96` | uint160 | A sqrt price representing the first tick boundary  |
| `sqrtRatioBX96` | uint160 | A sqrt price representing the second tick boundary |
| `amount0`       | uint256 | The amount of token0 being sent in                 |
| `amount1`       | uint256 | The amount of token1 being sent in                 |

#### Return Values:

| Name        | Type    | Description                              |
| :---------- | :------ | :--------------------------------------- |
| `liquidity` | uint128 | The maximum amount of liquidity received |

### getAmount0ForLiquidity

```solidity
  function getAmount0ForLiquidity(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint128 liquidity
  ) internal returns (uint256 amount0)
```

Computes the amount of token0 for a given amount of liquidity and a price range

#### Parameters:

| Name            | Type    | Description                                        |
| :-------------- | :------ | :------------------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price representing the first tick boundary  |
| `sqrtRatioBX96` | uint160 | A sqrt price representing the second tick boundary |
| `liquidity`     | uint128 | The liquidity being valued                         |

#### Return Values:

| Name      | Type    | Description          |
| :-------- | :------ | :------------------- |
| `amount0` | uint256 | The amount of token0 |

### getAmount1ForLiquidity

```solidity
  function getAmount1ForLiquidity(
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint128 liquidity
  ) internal returns (uint256 amount1)
```

Computes the amount of token1 for a given amount of liquidity and a price range

#### Parameters:

| Name            | Type    | Description                                        |
| :-------------- | :------ | :------------------------------------------------- |
| `sqrtRatioAX96` | uint160 | A sqrt price representing the first tick boundary  |
| `sqrtRatioBX96` | uint160 | A sqrt price representing the second tick boundary |
| `liquidity`     | uint128 | The liquidity being valued                         |

#### Return Values:

| Name      | Type    | Description          |
| :-------- | :------ | :------------------- |
| `amount1` | uint256 | The amount of token1 |

### getAmountsForLiquidity

```solidity
  function getAmountsForLiquidity(
    uint160 sqrtRatioX96,
    uint160 sqrtRatioAX96,
    uint160 sqrtRatioBX96,
    uint128 liquidity
  ) internal returns (uint256 amount0, uint256 amount1)
```

Computes the token0 and token1 value for a given amount of liquidity, the current
pool prices and the prices at the tick boundaries

#### Parameters:

| Name            | Type    | Description                                        |
| :-------------- | :------ | :------------------------------------------------- |
| `sqrtRatioX96`  | uint160 | A sqrt price representing the current pool prices  |
| `sqrtRatioAX96` | uint160 | A sqrt price representing the first tick boundary  |
| `sqrtRatioBX96` | uint160 | A sqrt price representing the second tick boundary |
| `liquidity`     | uint128 | The liquidity being valued                         |

#### Return Values:

| Name      | Type    | Description          |
| :-------- | :------ | :------------------- |
| `amount0` | uint256 | The amount of token0 |
| `amount1` | uint256 | The amount of token1 |
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/NFTDescriptor.md">
## Functions

### constructTokenURI

```solidity
  function constructTokenURI(
  ) public returns (string)
```

### escapeQuotes

```solidity
  function escapeQuotes(
  ) internal returns (string)
```

### tickToDecimalString

```solidity
  function tickToDecimalString(
  ) internal returns (string)
```

### fixedPointToDecimalString

```solidity
  function fixedPointToDecimalString(
  ) internal returns (string)
```

### feeToPercentString

```solidity
  function feeToPercentString(
  ) internal returns (string)
```

### addressToString

```solidity
  function addressToString(
  ) internal returns (string)
```

### generateSVGImage

```solidity
  function generateSVGImage(
  ) internal returns (string svg)
```

### tokenToColorHex

```solidity
  function tokenToColorHex(
  ) internal returns (string str)
```

### getCircleCoord

```solidity
  function getCircleCoord(
  ) internal returns (uint256)
```

### sliceTokenHex

```solidity
  function sliceTokenHex(
  ) internal returns (uint256)
```
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/NFTSVG.md">
Provides a function for generating an SVG associated with a Uniswap NFT

## Functions

### generateSVG

```solidity
  function generateSVG(
  ) internal returns (string svg)
```

### getCurve

```solidity
  function getCurve(
  ) internal returns (string curve)
```

### generateSVGCurveCircle

```solidity
  function generateSVGCurveCircle(
  ) internal returns (string svg)
```

### rangeLocation

```solidity
  function rangeLocation(
  ) internal returns (string, string)
```

### isRare

```solidity
  function isRare(
  ) internal returns (bool)
```
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/OracleLibrary.md">
Provides functions to integrate with V3 pool oracle

## Functions

### consult

```solidity
  function consult(
    address pool,
    uint32 period
  ) internal view returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)
```

Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool

#### Parameters:

| Name     | Type    | Description                                                              |
| :------- | :------ | :----------------------------------------------------------------------- |
| `pool`   | address | Address of Uniswap V3 pool that we want to observe                       |
| `period` | uint32  | Number of seconds in the past to start calculating time-weighted average |

#### Return Values:

| Name                      | Type    | Description                                                                        |
| :------------------------ | :------ | :--------------------------------------------------------------------------------- |
| `arithmeticMeanTick`      | int24   | The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp    |
| `harmonicMeanLiquidity`   | uint128 | The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp |


### getQuoteAtTick

```solidity
  function getQuoteAtTick(
    int24 tick,
    uint128 baseAmount,
    address baseToken,
    address quoteToken
  ) internal pure returns (uint256 quoteAmount)
```

Given a tick and a token amount, calculates the amount of token received in exchange

#### Parameters:

| Name         | Type    | Description                                                             |
| :----------- | :------ | :---------------------------------------------------------------------- |
| `tick`       | int24   | Tick value used to calculate the quote                                  |
| `baseAmount` | uint128 | Amount of token to be converted                                         |
| `baseToken`  | address | Address of an ERC20 token contract used as the baseAmount denomination  |
| `quoteToken` | address | Address of an ERC20 token contract used as the quoteAmount denomination |

#### Return Values:

| Name          | Type    | Description                                               |
| :------------ | :------ | :-------------------------------------------------------- |
| `quoteAmount` | uint256 | Amount of quoteToken received for baseAmount of baseToken |
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/Path.md">
## Functions

### hasMultiplePools

```solidity
  function hasMultiplePools(
    bytes path
  ) internal returns (bool)
```

Returns true iff the path contains two or more pools

#### Parameters:

| Name   | Type  | Description           |
| :----- | :---- | :-------------------- |
| `path` | bytes | The encoded swap path |

#### Return Values:

| Type | Description                                         |
| :--- | :-------------------------------------------------- |
| bool | if path contains two or more pools, otherwise false |

### decodeFirstPool

```solidity
  function decodeFirstPool(
    bytes path
  ) internal returns (address tokenA, address tokenB, uint24 fee)
```

Decodes the first pool in path

#### Parameters:

| Name   | Type  | Description                 |
| :----- | :---- | :-------------------------- |
| `path` | bytes | The bytes encoded swap path |

#### Return Values:

| Name     | Type    | Description                        |
| :------- | :------ | :--------------------------------- |
| `tokenA` | address | The first token of the given pool  |
| `tokenB` | address | The second token of the given pool |
| `fee`    | uint24  | The fee level of the pool          |

### getFirstPool

```solidity
  function getFirstPool(
    bytes path
  ) internal returns (bytes)
```

Gets the segment corresponding to the first pool in the path

#### Parameters:

| Name   | Type  | Description                 |
| :----- | :---- | :-------------------------- |
| `path` | bytes | The bytes encoded swap path |

#### Return Values:

| Type  | Description                                                                |
| :---- | :------------------------------------------------------------------------- |
| bytes | segment containing all data necessary to target the first pool in the path |

### skipToken

```solidity
  function skipToken(
    bytes path
  ) internal returns (bytes)
```

Skips a token + fee element from the buffer and returns the remainder

#### Parameters:

| Name   | Type  | Description   |
| :----- | :---- | :------------ |
| `path` | bytes | The swap path |

#### Return Values:

| Type  | Description                                |
| :---- | :----------------------------------------- |
| bytes | remaining token + fee elements in the path |
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/PoolAddress.md">
## Functions

### getPoolKey

```solidity
  function getPoolKey(
    address tokenA,
    address tokenB,
    uint24 fee
  ) internal returns (struct PoolAddress.PoolKey)
```

Returns PoolKey: the ordered tokens with the matched fee levels

#### Parameters:

| Name     | Type    | Description                          |
| :------- | :------ | :----------------------------------- |
| `tokenA` | address | The first token of a pool, unsorted  |
| `tokenB` | address | The second token of a pool, unsorted |
| `fee`    | uint24  | The fee level of the pool            |

#### Return Values:

| Name      | Type                | Description                                                 |
| :-------- | :------------------ | :---------------------------------------------------------- |
| `Poolkey` | PoolAddress.PoolKey | The pool details with ordered token0 and token1 assignments |

### computeAddress

```solidity
  function computeAddress(
    address factory,
    struct PoolAddress.PoolKey key
  ) internal returns (address pool)
```

Deterministically computes the pool address given the factory and PoolKey

#### Parameters:

| Name      | Type                       | Description                             |
| :-------- | :------------------------- | :-------------------------------------- |
| `factory` | address                    | The Uniswap V3 factory contract address |
| `key`     | struct PoolAddress.PoolKey | The PoolKey                             |

#### Return Values:

| Name   | Type    | Description                         |
| :----- | :------ | :---------------------------------- |
| `pool` | address | The contract address of the V3 pool |
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/PoolTicksCounter.md">
## Functions

### countInitializedTicksCrossed

```solidity
  function countInitializedTicksCrossed(
  ) internal view returns (uint32 initializedTicksCrossed)
```

This function counts the number of initialized ticks that would incur a gas cost between tickBefore and tickAfter.
When tickBefore and/or tickAfter themselves are initialized, the logic over whether we should count them depends on the
direction of the swap. If we are swapping upwards (tickAfter > tickBefore) we don't want to count tickBefore but we do
want to count tickAfter. The opposite is true if we are swapping downwards.
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/PositionKey.md">
## Functions

### compute

```solidity
  function compute(
  ) internal returns (bytes32)
```

Returns the key of the position in the core library
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/TokenRatioSortOrder.md">
# TokenRatioSortOrder

```solidity
library TokenRatioSortOrder {
    int256 constant NUMERATOR_MOST = 300;
    int256 constant NUMERATOR_MORE = 200;
    int256 constant NUMERATOR = 100;
    int256 constant DENOMINATOR_MOST = -300;
    int256 constant DENOMINATOR_MORE = -200;
    int256 constant DENOMINATOR = -100;
}
```
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/TransferHelper.md">
## Functions

### safeTransferFrom

```solidity
  function safeTransferFrom(
    address token,
    address from,
    address to,
    uint256 value
  ) internal
```

Transfers tokens from the targeted address to the given destination
Errors with 'STF' if transfer fails

#### Parameters:

| Name    | Type    | Description                                                       |
| :------ | :------ | :---------------------------------------------------------------- |
| `token` | address | The contract address of the token to be transferred               |
| `from`  | address | The originating address from which the tokens will be transferred |
| `to`    | address | The destination address of the transfer                           |
| `value` | uint256 | The amount to be transferred                                      |

### safeTransfer

```solidity
  function safeTransfer(
    address token,
    address to,
    uint256 value
  ) internal
```

Transfers tokens from msg.sender to a recipient

Errors with ST if transfer fails

#### Parameters:

| Name    | Type    | Description                                                 |
| :------ | :------ | :---------------------------------------------------------- |
| `token` | address | The contract address of the token which will be transferred |
| `to`    | address | The recipient of the transfer                               |
| `value` | uint256 | The value of the transfer                                   |

### safeApprove

```solidity
  function safeApprove(
    address token,
    address to,
    uint256 value
  ) internal
```

Approves the stipulated contract to spend the given allowance in the given token

Errors with 'SA' if transfer fails

#### Parameters:

| Name    | Type    | Description                                                       |
| :------ | :------ | :---------------------------------------------------------------- |
| `token` | address | The contract address of the token to be approved                  |
| `to`    | address | The target of the approval                                        |
| `value` | uint256 | The amount of the given token the target will be allowed to spend |

### safeTransferETH

```solidity
  function safeTransferETH(
    address to,
    uint256 value
  ) internal
```

Transfers ETH to the recipient address

Fails with `STE`

#### Parameters:

| Name    | Type    | Description                     |
| :------ | :------ | :------------------------------ |
| `to`    | address | The destination of the transfer |
| `value` | uint256 | The value to be transferred     |
</file>

<file path="docs/contracts/v3/reference/periphery/libraries/WeightedOracleLibrary.md">
Provides functions to integrate with different tier oracles of the same V3 pair

## Functions

### consult

```solidity
  function consult(
    address pool,
    uint32 period
  ) internal view returns (struct WeightedOracleLibrary.PeriodObservation observation)
```

Fetches a time-weighted observation for a given Uniswap V3 pool

#### Parameters:

| Name     | Type    | Description                                                                      |
| :------- | :------ | :------------------------------------------------------------------------------- |
| `pool`   | address | Address of the pool that we want to observe                                      |
| `period` | uint32  | Number of seconds in the past to start calculating the time-weighted observation |

#### Return Values:

| Name          | Type    | Description                                                                                   |
| :------------ | :------ | :-------------------------------------------------------------------------------------------- |
| `observation` | address | An observation that has been time-weighted from (block.timestamp - period) to block.timestamp |

### getArithmeticMeanTickWeightedByLiquidity

```solidity
  function getArithmeticMeanTickWeightedByLiquidity(
    struct WeightedOracleLibrary.PeriodObservation[] observations
  ) internal pure returns (int24 arithmeticMeanWeightedTick)
```

Given some time-weighted observations, calculates the arithmetic mean tick, weighted by liquidity

In most scenarios, each entry of `observations` should share the same `period` and underlying `pool` tokens.
If `period` differs across observations, the result becomes difficult to interpret and is likely biased/manipulable.
If the underlying `pool` tokens differ across observations, extreme care must be taken to ensure that both prices and liquidity values are comparable.
Even if prices are commensurate (e.g. two different USD-stable assets against ETH), liquidity values may not be, as decimals can differ between tokens.

#### Parameters:

| Name           | Type                                             | Description                          |
| :------------- | :----------------------------------------------- | :----------------------------------- |
| `observations` | struct WeightedOracleLibrary.PeriodObservation[] | A list of time-weighted observations |

#### Return Values:

| Name                         | Type                                             | Description                                                                                      |
| :--------------------------- | :----------------------------------------------- | :----------------------------------------------------------------------------------------------- |
| `arithmeticMeanWeightedTick` | struct WeightedOracleLibrary.PeriodObservation[] | The arithmetic mean tick, weighted by the observations' time-weighted harmonic average liquidity |
</file>

<file path="docs/contracts/v3/reference/periphery/staker/interfaces/_category_.json">
{
  "label": "Interfaces",
  "position": 3
}
</file>

<file path="docs/contracts/v3/reference/periphery/staker/interfaces/IUniswapV3Staker.md">
Allows staking nonfungible liquidity tokens in exchange for reward tokens

## Functions

### factory

```solidity
  function factory(
  ) external view returns (contract IUniswapV3Factory)
```

The Uniswap V3 Factory

### nonfungiblePositionManager

```solidity
  function nonfungiblePositionManager(
  ) external view returns (contract INonfungiblePositionManager)
```

The nonfungible position manager with which this staking contract is compatible

### maxIncentiveDuration

```solidity
  function maxIncentiveDuration(
  ) external view returns (uint256)
```

The max duration of an incentive in seconds

### maxIncentiveStartLeadTime

```solidity
  function maxIncentiveStartLeadTime(
  ) external view returns (uint256)
```

The max amount of seconds into the future the incentive startTime can be set

### incentives

```solidity
  function incentives(
    bytes32 incentiveId
  ) external view returns (uint256 totalRewardUnclaimed, uint160 totalSecondsClaimedX128, uint96 numberOfStakes)
```

Represents a staking incentive

#### Parameters:

| Name          | Type    | Description                                          |
| :------------ | :------ | :--------------------------------------------------- |
| `incentiveId` | bytes32 | The ID of the incentive computed from its parameters |

#### Return Values:

| Name                      | Type    | Description                                                       |
| :------------------------ | :------ | :---------------------------------------------------------------- |
| `totalRewardUnclaimed`    | uint256 | The amount of reward token not yet claimed by users               |
| `totalSecondsClaimedX128` | uint160 | Total liquidity-seconds claimed, represented as a UQ32.128        |
| `numberOfStakes`          | uint96  | The count of deposits that are currently staked for the incentive |

### deposits

```solidity
  function deposits(
  ) external view returns (address owner, uint48 numberOfStakes, int24 tickLower, int24 tickUpper)
```

Returns information about a deposited NFT

#### Return Values:

| Name             | Type    | Description                                                      |
| :--------------- | :------ | :--------------------------------------------------------------- |
| `owner`          | address | The owner of the deposited NFT                                   |
| `numberOfStakes` | uint48  | Counter of how many incentives for which the liquidity is staked |
| `tickLower`      | int24   | The lower tick of the range                                      |
| `tickUpper`      | int24   | The upper tick of the range                                      |

### stakes

```solidity
  function stakes(
    uint256 tokenId,
    bytes32 incentiveId
  ) external view returns (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity)
```

Returns information about a staked liquidity NFT

#### Parameters:

| Name          | Type    | Description                                           |
| :------------ | :------ | :---------------------------------------------------- |
| `tokenId`     | uint256 | The ID of the staked token                            |
| `incentiveId` | bytes32 | The ID of the incentive for which the token is staked |

#### Return Values:

| Name                                   | Type    | Description                                                                      |
| :------------------------------------- | :------ | :------------------------------------------------------------------------------- |
| `secondsPerLiquidityInsideInitialX128` | uint160 | secondsPerLiquidity represented as a UQ32.128                                    |
| `liquidity`                            | uint128 | The amount of liquidity in the NFT as of the last time the rewards were computed |

### rewards

```solidity
  function rewards(
    contract IERC20Minimal rewardToken,
    address owner
  ) external view returns (uint256 rewardsOwed)
```

Returns amounts of reward tokens owed to a given address according to the last time all stakes were updated

#### Parameters:

| Name          | Type                   | Description                                      |
| :------------ | :--------------------- | :----------------------------------------------- |
| `rewardToken` | contract IERC20Minimal | The token for which to check rewards             |
| `owner`       | address                | The owner for which the rewards owed are checked |

#### Return Values:

| Name          | Type    | Description                                           |
| :------------ | :------ | :---------------------------------------------------- |
| `rewardsOwed` | uint256 | The amount of the reward token claimable by the owner |

### createIncentive

```solidity
  function createIncentive(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 reward
  ) external
```

Creates a new liquidity mining incentive program

#### Parameters:

| Name     | Type                                 | Description                                   |
| :------- | :----------------------------------- | :-------------------------------------------- |
| `key`    | struct IUniswapV3Staker.IncentiveKey | Details of the incentive to create            |
| `reward` | uint256                              | The amount of reward tokens to be distributed |

### endIncentive

```solidity
  function endIncentive(
    struct IUniswapV3Staker.IncentiveKey key
  ) external returns (uint256 refund)
```

Ends an incentive after the incentive end time has passed and all stakes have been withdrawn

#### Parameters:

| Name  | Type                                 | Description                     |
| :---- | :----------------------------------- | :------------------------------ |
| `key` | struct IUniswapV3Staker.IncentiveKey | Details of the incentive to end |

#### Return Values:

| Name     | Type    | Description                                             |
| :------- | :------ | :------------------------------------------------------ |
| `refund` | uint256 | The remaining reward tokens when the incentive is ended |

### transferDeposit

```solidity
  function transferDeposit(
    uint256 tokenId,
    address to
  ) external
```

Transfers ownership of a deposit from the sender to the given recipient

#### Parameters:

| Name      | Type    | Description                                       |
| :-------- | :------ | :------------------------------------------------ |
| `tokenId` | uint256 | The ID of the token (and the deposit) to transfer |
| `to`      | address | The new owner of the deposit                      |

### withdrawToken

```solidity
  function withdrawToken(
    uint256 tokenId,
    address to,
    bytes data
  ) external
```

Withdraws a Uniswap V3 LP token `tokenId` from this contract to the recipient `to`

#### Parameters:

| Name      | Type    | Description                                                                                       |
| :-------- | :------ | :------------------------------------------------------------------------------------------------ |
| `tokenId` | uint256 | The unique identifier of an Uniswap V3 LP token                                                   |
| `to`      | address | The address where the LP token will be sent                                                       |
| `data`    | bytes   | An optional data array that will be passed along to the `to` address via the NFT safeTransferFrom |

### stakeToken

```solidity
  function stakeToken(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 tokenId
  ) external
```

Stakes a Uniswap V3 LP token

#### Parameters:

| Name      | Type                                 | Description                                         |
| :-------- | :----------------------------------- | :-------------------------------------------------- |
| `key`     | struct IUniswapV3Staker.IncentiveKey | The key of the incentive for which to stake the NFT |
| `tokenId` | uint256                              | The ID of the token to stake                        |

### unstakeToken

```solidity
  function unstakeToken(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 tokenId
  ) external
```

Unstakes a Uniswap V3 LP token

#### Parameters:

| Name      | Type                                 | Description                                           |
| :-------- | :----------------------------------- | :---------------------------------------------------- |
| `key`     | struct IUniswapV3Staker.IncentiveKey | The key of the incentive for which to unstake the NFT |
| `tokenId` | uint256                              | The ID of the token to unstake                        |

### claimReward

```solidity
  function claimReward(
    contract IERC20Minimal rewardToken,
    address to,
    uint256 amountRequested
  ) external returns (uint256 reward)
```

Transfers `amountRequested` of accrued `rewardToken` rewards from the contract to the recipient `to`

#### Parameters:

| Name              | Type                   | Description                                                                    |
| :---------------- | :--------------------- | :----------------------------------------------------------------------------- |
| `rewardToken`     | contract IERC20Minimal | The token being distributed as a reward                                        |
| `to`              | address                | The address where claimed rewards will be sent to                              |
| `amountRequested` | uint256                | The amount of reward tokens to claim. Claims entire reward amount if set to 0. |

#### Return Values:

| Name     | Type    | Description                         |
| :------- | :------ | :---------------------------------- |
| `reward` | uint256 | The amount of reward tokens claimed |

### getRewardInfo

```solidity
  function getRewardInfo(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 tokenId
  ) external returns (uint256 reward, uint160 secondsInsideX128)
```

Calculates the reward amount that will be received for the given stake

#### Parameters:

| Name      | Type                                 | Description              |
| :-------- | :----------------------------------- | :----------------------- |
| `key`     | struct IUniswapV3Staker.IncentiveKey | The key of the incentive |
| `tokenId` | uint256                              | The ID of the token      |

#### Return Values:

| Name                | Type    | Description                                                    |
| :------------------ | :------ | :------------------------------------------------------------- |
| `reward`            | uint256 | The reward accrued to the NFT for the given incentive thus far |
| `secondsInsideX128` | uint160 | The seconds inside the tick range                              |

## Events

### IncentiveCreated

```solidity
  event IncentiveCreated(
    contract IERC20Minimal rewardToken,
    contract IUniswapV3Pool pool,
    uint256 startTime,
    uint256 endTime,
    address refundee,
    uint256 reward
  )
```

Event emitted when a liquidity mining incentive has been created

#### Parameters:

| Name          | Type                    | Description                                                               |
| :------------ | :---------------------- | :------------------------------------------------------------------------ |
| `rewardToken` | contract IERC20Minimal  | The token being distributed as a reward                                   |
| `pool`        | contract IUniswapV3Pool | The Uniswap V3 pool                                                       |
| `startTime`   | uint256                 | The time when the incentive program begins                                |
| `endTime`     | uint256                 | The time when rewards stop accruing                                       |
| `refundee`    | address                 | The address which receives any remaining reward tokens after the end time |
| `reward`      | uint256                 | The amount of reward tokens to be distributed                             |

### IncentiveEnded

```solidity
  event IncentiveEnded(
    bytes32 incentiveId,
    uint256 refund
  )
```

Event that can be emitted when a liquidity mining incentive has ended

#### Parameters:

| Name          | Type    | Description                          |
| :------------ | :------ | :----------------------------------- |
| `incentiveId` | bytes32 | The incentive which is ending        |
| `refund`      | uint256 | The amount of reward tokens refunded |

### DepositTransferred

```solidity
  event DepositTransferred(
    uint256 tokenId,
    address oldOwner,
    address newOwner
  )
```

Emitted when ownership of a deposit changes

#### Parameters:

| Name       | Type    | Description                                                 |
| :--------- | :------ | :---------------------------------------------------------- |
| `tokenId`  | uint256 | The ID of the deposit (and token) that is being transferred |
| `oldOwner` | address | The owner before the deposit was transferred                |
| `newOwner` | address | The owner after the deposit was transferred                 |

### TokenStaked

```solidity
  event TokenStaked(
    uint256 tokenId,
    bytes32 liquidity,
    uint128 incentiveId
  )
```

Event emitted when a Uniswap V3 LP token has been staked

#### Parameters:

| Name          | Type    | Description                                     |
| :------------ | :------ | :---------------------------------------------- |
| `tokenId`     | uint256 | The unique identifier of an Uniswap V3 LP token |
| `liquidity`   | bytes32 | The amount of liquidity staked                  |
| `incentiveId` | uint128 | The incentive in which the token is staking     |

### TokenUnstaked

```solidity
  event TokenUnstaked(
    uint256 tokenId,
    bytes32 incentiveId
  )
```

Event emitted when a Uniswap V3 LP token has been unstaked

#### Parameters:

| Name          | Type    | Description                                     |
| :------------ | :------ | :---------------------------------------------- |
| `tokenId`     | uint256 | The unique identifier of an Uniswap V3 LP token |
| `incentiveId` | bytes32 | The incentive in which the token is staking     |

### RewardClaimed

```solidity
  event RewardClaimed(
    address to,
    uint256 reward
  )
```

Event emitted when a reward token has been claimed

#### Parameters:

| Name     | Type    | Description                                    |
| :------- | :------ | :--------------------------------------------- |
| `to`     | address | The address where claimed rewards were sent to |
| `reward` | uint256 | The amount of reward tokens claimed            |
</file>

<file path="docs/contracts/v3/reference/periphery/staker/libraries/_category_.json">
{
  "label": "Libraries",
  "position": 4
}
</file>

<file path="docs/contracts/v3/reference/periphery/staker/libraries/IncentiveId.md">
## Functions

### compute

```solidity
  function compute(
    struct IUniswapV3Staker.IncentiveKey key
  ) internal pure returns (bytes32 incentiveId)
```

Calculate the key for a staking incentive

#### Parameters:

| Name  | Type                                 | Description                                             |
| :---- | :----------------------------------- | :------------------------------------------------------ |
| `key` | struct IUniswapV3Staker.IncentiveKey | The components used to compute the incentive identifier |

#### Return Values:

| Name          | Type    | Description                      |
| :------------ | :------ | :------------------------------- |
| `incentiveId` | bytes32 | The identifier for the incentive |
</file>

<file path="docs/contracts/v3/reference/periphery/staker/libraries/NFTPositionInfo.md">
Encapsulates the logic for getting info about a NFT token ID

## Functions

### getPositionInfo

```solidity
  function getPositionInfo(
    contract IUniswapV3Factory factory,
    contract INonfungiblePositionManager nonfungiblePositionManager,
    uint256 tokenId
  ) internal view returns (contract IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity)
```

#### Parameters:

| Name                         | Type                                 | Description                                                              |
| :--------------------------- | :----------------------------------- | :----------------------------------------------------------------------- |
| `factory`                    | contract IUniswapV3Factory           | The address of the Uniswap V3 Factory used in computing the pool address |
| `nonfungiblePositionManager` | contract INonfungiblePositionManager | The address of the nonfungible position manager to query                 |
| `tokenId`                    | uint256                              | The unique identifier of an Uniswap V3 LP token                          |

#### Return Values:

| Name        | Type           | Description                               |
| :---------- | :------------- | :---------------------------------------- |
| `pool`      | IUniswapV3Pool | The address of the Uniswap V3 pool        |
| `tickLower` | int24          | The lower tick of the Uniswap V3 position |
| `tickUpper` | int24          | The upper tick of the Uniswap V3 position |
| `liquidity` | uint128        | The amount of liquidity staked            |
</file>

<file path="docs/contracts/v3/reference/periphery/staker/libraries/RewardMath.md">
Allows computing rewards given some parameters of stakes and incentives

## Functions

### computeRewardAmount

```solidity
  function computeRewardAmount(
    uint256 totalRewardUnclaimed,
    uint160 totalSecondsClaimedX128,
    uint256 startTime,
    uint256 endTime,
    uint128 liquidity,
    uint160 secondsPerLiquidityInsideInitialX128,
    uint160 secondsPerLiquidityInsideX128,
    uint256 currentTime
  ) internal pure returns (uint256 reward, uint160 secondsInsideX128)
```

Compute the amount of rewards owed given parameters of the incentive and stake

#### Parameters:

| Name                                   | Type    | Description                                                                                           |
| :------------------------------------- | :------ | :---------------------------------------------------------------------------------------------------- |
| `totalRewardUnclaimed`                 | uint256 | The total amount of unclaimed rewards left for an incentive                                           |
| `totalSecondsClaimedX128`              | uint160 | How many full liquidity-seconds have been already claimed for the incentive                           |
| `startTime`                            | uint256 | When the incentive rewards began in epoch seconds                                                     |
| `endTime`                              | uint256 | When rewards are no longer being dripped out in epoch seconds                                         |
| `liquidity`                            | uint128 | The amount of liquidity, assumed to be constant over the period over which the snapshots are measured |
| `secondsPerLiquidityInsideInitialX128` | uint160 | The seconds per liquidity of the liquidity tick range as of the beginning of the period               |
| `secondsPerLiquidityInsideX128`        | uint160 | The seconds per liquidity of the liquidity tick range as of the current block timestamp               |
| `currentTime`                          | uint256 | The current block timestamp, which must be greater than or equal to the start time                    |

#### Return Values:

| Name                | Type    | Description                                                                           |
| :------------------ | :------ | :------------------------------------------------------------------------------------ |
| `reward`            | uint256 | The amount of rewards owed                                                            |
| `secondsInsideX128` | uint160 | The total liquidity seconds inside the position's range for the duration of the stake |
</file>

<file path="docs/contracts/v3/reference/periphery/staker/_category_.json">
{
  "label": "Staker",
  "position": 4
}
</file>

<file path="docs/contracts/v3/reference/periphery/staker/Design.md">
---
sidebar_label: Uniswap V3 Staker Design
sidebar_position: 1
---

The liquidity mining staker design is comprised of one canonical position staking contract, Staker. The technical reference for this contract is [here](../../periphery/staker/UniswapV3Staker.md) and the source code is [here](https://github.com/Uniswap/uniswap-v3-staker).

## Data Structures

```solidity
struct Incentive {
  uint128 totalRewardUnclaimed;
  uint128 numberOfStakes;
  uint160 totalSecondsClaimedX128;
}

struct Deposit {
  address owner;
  uint96 numberOfStakes;
}

struct Stake {
  uint160 secondsPerLiquidityInsideInitialX128;
  uint128 liquidity;
}

struct IncentiveKey {
        IERC20Minimal rewardToken;
        IUniswapV3Pool pool;
        uint256 startTime;
        uint256 endTime;
        address refundee;
}
```

State:

```solidity
IUniswapV3Factory public immutable factory;
INonfungiblePositionManager public immutable nonfungiblePositionManager;

/// @dev bytes32 refers to the return value of IncentiveId.compute
mapping(bytes32 => Incentive) public incentives;

/// @dev deposits[tokenId] => Deposit
mapping(uint256 => Deposit) public deposits;

/// @dev stakes[tokenId][incentiveHash] => Stake
mapping(uint256 => mapping(bytes32 => Stake)) public stakes;

/// @dev rewards[rewardToken][msg.sender] => uint256
mapping(address => mapping(address => uint256)) public rewards;
```

Params:

```solidity
struct CreateIncentiveParams {
  address rewardToken;
  address pool;
  uint256 startTime;
  uint256 endTime;
  uint128 totalReward;
}

struct EndIncentiveParams {
  address creator;
  address rewardToken;
  address pool;
  uint256 startTime;
  uint256 endTime;
}

```

## Incentives

### `createIncentive(CreateIncentiveParams memory params)`

`createIncentive` creates a liquidity mining incentive program. The key used to look up an Incentive is the hash of its immutable properties.

**Check:**

- Incentive with these params does not already exist
- Timestamps: `params.endTime >= params.startTime`, `params.startTime >= block.timestamp`
- Incentive with this ID does not already exist.

**Effects:**

- Sets `incentives[key] = Incentive(totalRewardUnclaimed=totalReward, totalSecondsClaimedX128=0, rewardToken=rewardToken)`

**Interaction:**

- Transfers `params.totalReward` from `msg.sender` to self.
  - Make sure there is a check here and it fails if the transfer fails
- Emits `IncentiveCreated`

### `endIncentive(EndIncentiveParams memory params)`

`endIncentive` can be called by anyone to end an Incentive after the `endTime` has passed, transferring `totalRewardUnclaimed` of `rewardToken` back to `refundee`.

**Check:**

- `block.timestamp > params.endTime`
- Incentive exists (`incentive.totalRewardUnclaimed != 0`)

**Effects:**

- deletes `incentives[key]` (This is a new change)

**Interactions:**

- safeTransfers `totalRewardUnclaimed` of `rewardToken` to the incentive creator `msg.sender`
- emits `IncentiveEnded`

## Deposit/Withdraw Token

**Interactions**

- `nonfungiblePositionManager.safeTransferFrom(sender, this, tokenId)`
  - This transfer triggers the onERC721Received hook

### `onERC721Received(address, address from, uint256 tokenId, bytes calldata data)`

**Check:**

- Make sure sender is univ3 nft

**Effects:**

- Creates a deposit for the token setting deposit `owner` to `from`.
  - Setting `owner` to `from` ensures that the owner of the token also owns the deposit. Approved addresses and operators may first transfer the token to themselves before depositing for deposit ownership.
- If `data.length>0`, stakes the token in one or more incentives

### `withdrawToken(uint256 tokenId, address to, bytes memory data)`

**Checks**

- Check that a Deposit exists for the token and that `msg.sender` is the `owner` on that Deposit.
- Check that `numberOfStakes` on that Deposit is 0.

**Effects**

- Delete the Deposit `delete deposits[tokenId]`.

**Interactions**

- `safeTransferFrom` the token to `to` with `data`.
- emit `DepositTransferred(token, deposit.owner, address(0))`

## Stake/Unstake/Rewards

### `stakeToken`

**Check:**

- `deposits[params.tokenId].owner == msg.sender`
- Make sure incentive actually exists and has reward that could be claimed (incentive.rewardToken != address(0))
  - Check if this check can check totalRewardUnclaimed instead
- Make sure token not already staked

### `claimReward`

**Interactions**

- `msg.sender` to withdraw all of their reward balance in a specific token to a specified `to` address.

- emit RewardClaimed(to, reward)

### `unstakeToken`

To unstake an NFT, you call `unstakeToken`, which takes all the same arguments as `stake`.

**Checks**

- It checks that you are the owner of the Deposit
- It checks that there exists a `Stake` for the provided key (with exists=true).

**Effects**

- Deletes the Stake.
- Decrements `numberOfStakes` for the Deposit by 1.
- `totalRewardsUnclaimed` is decremented by `reward`.
- `totalSecondsClaimed` is incremented by `seconds`.
- Increments `rewards[rewardToken][msg.sender]` by the amount given by `getRewardInfo`.

### `getRewardInfo`

- It computes `secondsInsideX128` (the total liquidity seconds for which rewards are owed) for a given Stake, by:
  - using`snapshotCumulativesInside` from the Uniswap v3 core contract to get `secondsPerLiquidityInRangeX128`, and subtracting `secondsPerLiquidityInRangeInitialX128`.
  - Multiplying that by `stake.liquidity` to get the total seconds accrued by the liquidity in that period
- Note that X128 means it's a `UQ32X128`.

- It computes `totalSecondsUnclaimed` by taking `max(endTime, block.timestamp) - startTime`, casting it as a Q128, and subtracting `totalSecondsClaimedX128`.

- It computes `rewardRate` for the Incentive casting `incentive.totalRewardUnclaimed` as a Q128, then dividing it by `totalSecondsUnclaimedX128`.

- `reward` is then calculated as `secondsInsideX128` times the `rewardRate`, scaled down to a regular uint128.
</file>

<file path="docs/contracts/v3/reference/periphery/staker/UniswapV3Staker.md">
---
sidebar_label: Uniswap V3 Staker Contract
sidebar_position: 2
---

Below is the technical reference for the staker contract, [`UniswapV3Staker.sol`](https://github.com/Uniswap/uniswap-v3-staker/blob/main/contracts/UniswapV3Staker.sol). A technical guide for interacting with this staking contract will be released soon.

## Functions

### stakes

```solidity
  function stakes(
    uint256 tokenId,
    bytes32 incentiveId
  ) public view override returns (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity)
```

Returns information about a staked liquidity NFT

#### Parameters:

| Name          | Type    | Description                                           |
| :------------ | :------ | :---------------------------------------------------- |
| `tokenId`     | uint256 | The ID of the staked token                            |
| `incentiveId` | bytes32 | The ID of the incentive for which the token is staked |

#### Return Values:

| Name                                   | Type    | Description                                                                      |
| :------------------------------------- | :------ | :------------------------------------------------------------------------------- |
| `secondsPerLiquidityInsideInitialX128` | uint160 | secondsPerLiquidity represented as a UQ32.128                                    |
| `liquidity`                            | bytes32 | The amount of liquidity in the NFT as of the last time the rewards were computed |

### constructor

```solidity
  function constructor(
    contract IUniswapV3Factory _factory,
    contract INonfungiblePositionManager _nonfungiblePositionManager,
    uint256 _maxIncentiveStartLeadTime,
    uint256 _maxIncentiveDuration
  ) public
```

#### Parameters:

| Name                          | Type                                 | Description                                                                  |
| :---------------------------- | :----------------------------------- | :--------------------------------------------------------------------------- |
| `_factory`                    | contract IUniswapV3Factory           | the Uniswap V3 factory                                                       |
| `_nonfungiblePositionManager` | contract INonfungiblePositionManager | the NFT position manager contract address                                    |
| `_maxIncentiveStartLeadTime`  | uint256                              | the max duration of an incentive in seconds                                  |
| `_maxIncentiveDuration`       | uint256                              | the max amount of seconds into the future the incentive startTime can be set |

### createIncentive

```solidity
  function createIncentive(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 reward
  ) external
```

Creates a new liquidity mining incentive program

#### Parameters:

| Name     | Type                                 | Description                                   |
| :------- | :----------------------------------- | :-------------------------------------------- |
| `key`    | struct IUniswapV3Staker.IncentiveKey | Details of the incentive to create            |
| `reward` | uint256                              | The amount of reward tokens to be distributed |

### endIncentive

```solidity
  function endIncentive(
    struct IUniswapV3Staker.IncentiveKey key
  ) external returns (uint256 refund)
```

Ends an incentive after the incentive end time has passed and all stakes have been withdrawn

#### Parameters:

| Name  | Type                                 | Description                     |
| :---- | :----------------------------------- | :------------------------------ |
| `key` | struct IUniswapV3Staker.IncentiveKey | Details of the incentive to end |

#### Return Values:

| Name     | Type    | Description                                             |
| :------- | :------ | :------------------------------------------------------ |
| `refund` | uint256 | The remaining reward tokens when the incentive is ended |

### onERC721Received

```solidity
  function onERC721Received(
  ) external returns (bytes4)
```

Upon receiving a Uniswap V3 ERC721, creates the token deposit setting owner to `from`. Also stakes token
in one or more incentives if properly formatted `data` has a length > 0.

Whenever an \{IERC721\} `tokenId` token is transferred to this contract via \{IERC721-safeTransferFrom\}
by `operator` from `from`, this function is called.
It must return its Solidity selector to confirm the token transfer.
If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.

### transferDeposit

```solidity
  function transferDeposit(
    uint256 tokenId,
    address to
  ) external
```

Transfers ownership of a deposit from the sender to the given recipient

#### Parameters:

| Name      | Type    | Description                                       |
| :-------- | :------ | :------------------------------------------------ |
| `tokenId` | uint256 | The ID of the token (and the deposit) to transfer |
| `to`      | address | The new owner of the deposit                      |

### withdrawToken

```solidity
  function withdrawToken(
    uint256 tokenId,
    address to,
    bytes data
  ) external
```

Withdraws a Uniswap V3 LP token `tokenId` from this contract to the recipient `to`

#### Parameters:

| Name      | Type    | Description                                                                                       |
| :-------- | :------ | :------------------------------------------------------------------------------------------------ |
| `tokenId` | uint256 | The unique identifier of an Uniswap V3 LP token                                                   |
| `to`      | address | The address where the LP token will be sent                                                       |
| `data`    | bytes   | An optional data array that will be passed along to the `to` address via the NFT safeTransferFrom |

### stakeToken

```solidity
  function stakeToken(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 tokenId
  ) external
```

Stakes a Uniswap V3 LP token

#### Parameters:

| Name      | Type                                 | Description                                         |
| :-------- | :----------------------------------- | :-------------------------------------------------- |
| `key`     | struct IUniswapV3Staker.IncentiveKey | The key of the incentive for which to stake the NFT |
| `tokenId` | uint256                              | The ID of the token to stake                        |

### unstakeToken

```solidity
  function unstakeToken(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 tokenId
  ) external
```

Unstakes a Uniswap V3 LP token

#### Parameters:

| Name      | Type                                 | Description                                           |
| :-------- | :----------------------------------- | :---------------------------------------------------- |
| `key`     | struct IUniswapV3Staker.IncentiveKey | The key of the incentive for which to unstake the NFT |
| `tokenId` | uint256                              | The ID of the token to unstake                        |

### claimReward

```solidity
  function claimReward(
    contract IERC20Minimal rewardToken,
    address to,
    uint256 amountRequested
  ) external override returns (uint256 reward)
```

Transfers `amountRequested` of accrued `rewardToken` rewards from the contract to the recipient `to`

#### Parameters:

| Name              | Type                   | Description                                                                    |
| :---------------- | :--------------------- | :----------------------------------------------------------------------------- |
| `rewardToken`     | contract IERC20Minimal | The token being distributed as a reward                                        |
| `to`              | address                | The address where claimed rewards will be sent to                              |
| `amountRequested` | uint256                | The amount of reward tokens to claim. Claims entire reward amount if set to 0. |

#### Return Values:

| Name     | Type    | Description                         |
| :------- | :------ | :---------------------------------- |
| `reward` | uint256 | The amount of reward tokens claimed |

### getRewardInfo

```solidity
  function getRewardInfo(
    struct IUniswapV3Staker.IncentiveKey key,
    uint256 tokenId
  ) external view override returns (uint256 reward, uint160 secondsInsideX128)
```

Calculates the reward amount that will be received for the given stake

#### Parameters:

| Name      | Type                                 | Description              |
| :-------- | :----------------------------------- | :----------------------- |
| `key`     | struct IUniswapV3Staker.IncentiveKey | The key of the incentive |
| `tokenId` | uint256                              | The ID of the token      |

#### Return Values:

| Name                | Type    | Description                                                    |
| :------------------ | :------ | :------------------------------------------------------------- |
| `reward`            | uint256 | The reward accrued to the NFT for the given incentive thus far |
| `secondsInsideX128` | uint160 | The seconds inside the tick range                              |
</file>

<file path="docs/contracts/v3/reference/periphery/test/_category_.json">
{
  "label": "Test",
  "position": 4
}
</file>

<file path="docs/contracts/v3/reference/periphery/test/Base64Test.md">
## Functions

### encode

```solidity
  function encode(
  ) external returns (string)
```

### getGasCostOfEncode

```solidity
  function getGasCostOfEncode(
  ) external returns (uint256)
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/LiquidityAmountsTest.md">
## Functions

### getLiquidityForAmount0

```solidity
  function getLiquidityForAmount0(
  ) external returns (uint128 liquidity)
```

### getGasCostOfGetLiquidityForAmount0

```solidity
  function getGasCostOfGetLiquidityForAmount0(
  ) external returns (uint256)
```

### getLiquidityForAmount1

```solidity
  function getLiquidityForAmount1(
  ) external returns (uint128 liquidity)
```

### getGasCostOfGetLiquidityForAmount1

```solidity
  function getGasCostOfGetLiquidityForAmount1(
  ) external returns (uint256)
```

### getLiquidityForAmounts

```solidity
  function getLiquidityForAmounts(
  ) external returns (uint128 liquidity)
```

### getGasCostOfGetLiquidityForAmounts

```solidity
  function getGasCostOfGetLiquidityForAmounts(
  ) external returns (uint256)
```

### getAmount0ForLiquidity

```solidity
  function getAmount0ForLiquidity(
  ) external returns (uint256 amount0)
```

### getGasCostOfGetAmount0ForLiquidity

```solidity
  function getGasCostOfGetAmount0ForLiquidity(
  ) external returns (uint256)
```

### getAmount1ForLiquidity

```solidity
  function getAmount1ForLiquidity(
  ) external returns (uint256 amount1)
```

### getGasCostOfGetAmount1ForLiquidity

```solidity
  function getGasCostOfGetAmount1ForLiquidity(
  ) external returns (uint256)
```

### getAmountsForLiquidity

```solidity
  function getAmountsForLiquidity(
  ) external returns (uint256 amount0, uint256 amount1)
```

### getGasCostOfGetAmountsForLiquidity

```solidity
  function getGasCostOfGetAmountsForLiquidity(
  ) external returns (uint256)
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/MockTimeNonfungiblePositionManager.md">
## Functions

### constructor

```solidity
  function constructor(
  ) public
```

### \_blockTimestamp

```solidity
  function _blockTimestamp(
  ) internal returns (uint256)
```

### setTime

```solidity
  function setTime(
  ) external
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/MockTimeSwapRouter.md">
## Functions

### constructor

```solidity
  function constructor(
  ) public
```

### \_blockTimestamp

```solidity
  function _blockTimestamp(
  ) internal returns (uint256)
```

### setTime

```solidity
  function setTime(
  ) external
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/NFTDescriptorTest.md">
## Functions

### constructTokenURI

```solidity
  function constructTokenURI(
  ) public returns (string)
```

### getGasCostOfConstructTokenURI

```solidity
  function getGasCostOfConstructTokenURI(
  ) public returns (uint256)
```

### tickToDecimalString

```solidity
  function tickToDecimalString(
  ) public returns (string)
```

### fixedPointToDecimalString

```solidity
  function fixedPointToDecimalString(
  ) public returns (string)
```

### feeToPercentString

```solidity
  function feeToPercentString(
  ) public returns (string)
```

### addressToString

```solidity
  function addressToString(
  ) public returns (string)
```

### generateSVGImage

```solidity
  function generateSVGImage(
  ) public returns (string)
```

### tokenToColorHex

```solidity
  function tokenToColorHex(
  ) public returns (string)
```

### sliceTokenHex

```solidity
  function sliceTokenHex(
  ) public returns (uint256)
```

### rangeLocation

```solidity
  function rangeLocation(
  ) public returns (string, string)
```

### isRare

```solidity
  function isRare(
  ) public returns (bool)
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/PathTest.md">
## Functions

### hasMultiplePools

```solidity
  function hasMultiplePools(
  ) public returns (bool)
```

### decodeFirstPool

```solidity
  function decodeFirstPool(
  ) public returns (address tokenA, address tokenB, uint24 fee)
```

### getFirstPool

```solidity
  function getFirstPool(
  ) public returns (bytes)
```

### skipToken

```solidity
  function skipToken(
  ) public returns (bytes)
```

### getGasCostOfDecodeFirstPool

```solidity
  function getGasCostOfDecodeFirstPool(
  ) public returns (uint256)
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/PeripheryImmutableStateTest.md">
## Functions

### constructor

```solidity
  function constructor(
  ) public
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/PoolAddressTest.md">
## Functions

### POOL_INIT_CODE_HASH

```solidity
  function POOL_INIT_CODE_HASH(
  ) external returns (bytes32)
```

### computeAddress

```solidity
  function computeAddress(
  ) external returns (address)
```

### getGasCostOfComputeAddress

```solidity
  function getGasCostOfComputeAddress(
  ) external returns (uint256)
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/SelfPermitTest.md">
Same as SelfPermit but not abstract
</file>

<file path="docs/contracts/v3/reference/periphery/test/TestCallbackValidation.md">
## Functions

### verifyCallback

```solidity
  function verifyCallback(
  ) external returns (contract IUniswapV3Pool pool)
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/TestERC20.md">
## Functions

### constructor

```solidity
  function constructor(
  ) public
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/TestERC20Metadata.md">
## Functions

### constructor

```solidity
  function constructor(
  ) public
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/TestERC20PermitAllowed.md">
## Functions

### constructor

```solidity
  function constructor(
  ) public
```

### permit

```solidity
  function permit(
  ) external
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/TestMulticall.md">
## Functions

### functionThatRevertsWithError

```solidity
  function functionThatRevertsWithError(
  ) external
```

### functionThatReturnsTuple

```solidity
  function functionThatReturnsTuple(
  ) external returns (struct TestMulticall.Tuple tuple)
```

### pays

```solidity
  function pays(
  ) external
```

### returnSender

```solidity
  function returnSender(
  ) external returns (address)
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/TestPositionNFTOwner.md">
## Functions

### setOwner

```solidity
  function setOwner(
  ) external
```

### isValidSignature

```solidity
  function isValidSignature(
  ) external returns (bytes4 magicValue)
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/TestUniswapV3Callee.md">
## Functions

### swapExact0For1

```solidity
  function swapExact0For1(
  ) external
```

### swap0ForExact1

```solidity
  function swap0ForExact1(
  ) external
```

### swapExact1For0

```solidity
  function swapExact1For0(
  ) external
```

### swap1ForExact0

```solidity
  function swap1ForExact0(
  ) external
```

### uniswapV3SwapCallback

```solidity
  function uniswapV3SwapCallback(
  ) external
```
</file>

<file path="docs/contracts/v3/reference/periphery/test/TickLensTest.md">
## Functions

### getGasCostOfGetPopulatedTicksInWord

```solidity
  function getGasCostOfGetPopulatedTicksInWord(
  ) external returns (uint256)
```
</file>

<file path="docs/contracts/v3/reference/periphery/_category_.json">
{
  "label": "Periphery",
  "position": 2
}
</file>

<file path="docs/contracts/v3/reference/periphery/NonfungiblePositionManager.md">
Wraps Uniswap V3 positions in the ERC721 non-fungible token interface

## Functions

### constructor

```solidity
  function constructor(
  ) public
```

### positions

```solidity
  function positions(
    uint256 tokenId
  ) external view returns (uint96 nonce, address operator, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1)
```

Returns the position information associated with a given token ID.

Throws if the token ID is not valid.

#### Parameters:

| Name      | Type    | Description                                      |
| :-------- | :------ | :----------------------------------------------- |
| `tokenId` | uint256 | The ID of the token that represents the position |

#### Return Values:

| Name                       | Type    | Description                                                                      |
| :------------------------- | :------ | :------------------------------------------------------------------------------- |
| `nonce`                    | uint96  | The nonce for permits                                                            |
| `operator`                 | address | The address that is approved for spending                                        |
| `token0`                   | address | The address of the token0 for a specific pool                                    |
| `token1`                   | address | The address of the token1 for a specific pool                                    |
| `fee`                      | uint24  | The fee associated with the pool                                                 |
| `tickLower`                | int24   | The lower end of the tick range for the position                                 |
| `tickUpper`                | int24   | The higher end of the tick range for the position                                |
| `liquidity`                | uint128 | The liquidity of the position                                                    |
| `feeGrowthInside0LastX128` | uint256 | The fee growth of token0 as of the last action on the individual position        |
| `feeGrowthInside1LastX128` | uint256 | The fee growth of token1 as of the last action on the individual position        |
| `tokensOwed0`              | uint128 | The uncollected amount of token0 owed to the position as of the last computation |
| `tokensOwed1`              | uint128 | The uncollected amount of token1 owed to the position as of the last computation |

### mint

```solidity
  function mint(
    struct INonfungiblePositionManager.MintParams params
  ) external returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1)
```

Creates a new position wrapped in a NFT

Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
a method does not exist, i.e. the pool is assumed to be initialized.

#### Parameters:

| Name     | Type                                          | Description                                                                  |
| :------- | :-------------------------------------------- | :--------------------------------------------------------------------------- |
| `params` | struct INonfungiblePositionManager.MintParams | The params necessary to mint a position, encoded as `MintParams` in calldata |

#### Return Values:

| Name        | Type    | Description                                             |
| :---------- | :------ | :------------------------------------------------------ |
| `tokenId`   | uint256 | The ID of the token that represents the minted position |
| `liquidity` | uint128 | The amount of liquidity for this position               |
| `amount0`   | uint256 | The amount of token0                                    |
| `amount1`   | uint256 | The amount of token1                                    |

### tokenURI

```solidity
  function tokenURI(
    uint256 tokenId
  ) public view returns (string)
```

Returns a URI describing a particular token ID

#### Parameters:

| Name      | Type    | Description                                              |
| :-------- | :------ | :------------------------------------------------------- |
| `tokenId` | uint256 | The ID of the token that represents the minted position  |

#### Return Values:

A base64 string with the URI data.

### baseURI

```solidity
  function baseURI(
  ) public returns (string)
```

### increaseLiquidity

```solidity
  function increaseLiquidity(
    struct INonfungiblePositionManager.IncreaseLiquidityParams params
  ) external returns (uint128 liquidity, uint256 amount0, uint256 amount1)
```

Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`

#### Parameters:

| Name     | Type                                                       | Description                                                         |
| :------- | :--------------------------------------------------------- | :------------------------------------------------------------------ |
| `params` | struct INonfungiblePositionManager.IncreaseLiquidityParams | tokenId The ID of the token for which liquidity is being increased, |

#### Return Values:

| Name        | Type    | Description                                          |
| :---------- | :------ | :--------------------------------------------------- |
| `liquidity` | uint128 | The new liquidity amount as a result of the increase |
| `amount0`   | uint256 | The amount of token0 to achieve resulting liquidity  |
| `amount1`   | uint256 | The amount of token1 to achieve resulting liquidity  |

### decreaseLiquidity

```solidity
  function decreaseLiquidity(
    struct INonfungiblePositionManager.DecreaseLiquidityParams params
  ) external returns (uint256 amount0, uint256 amount1)
```

Decreases the amount of liquidity in a position and accounts it to the position

#### Parameters:

| Name     | Type                                                       | Description                                                         |
| :------- | :--------------------------------------------------------- | :------------------------------------------------------------------ |
| `params` | struct INonfungiblePositionManager.DecreaseLiquidityParams | tokenId The ID of the token for which liquidity is being decreased, |

#### Return Values:

| Name      | Type    | Description                                                  |
| :-------- | :------ | :----------------------------------------------------------- |
| `amount0` | uint256 | The amount of token0 accounted to the position's tokens owed |
| `amount1` | uint256 | The amount of token1 accounted to the position's tokens owed |

### collect

```solidity
  function collect(
    struct INonfungiblePositionManager.CollectParams params
  ) external returns (uint256 amount0, uint256 amount1)
```

Collects up to a maximum amount of fees owed to a specific position to the recipient

#### Parameters:

| Name     | Type                                             | Description                                                     |
| :------- | :----------------------------------------------- | :-------------------------------------------------------------- |
| `params` | struct INonfungiblePositionManager.CollectParams | tokenId The ID of the NFT for which tokens are being collected, |

recipient The account that should receive the tokens,
amount0Max The maximum amount of token0 to collect,
amount1Max The maximum amount of token1 to collect

#### Return Values:

| Name      | Type    | Description                            |
| :-------- | :------ | :------------------------------------- |
| `amount0` | uint256 | The amount of fees collected in token0 |
| `amount1` | uint256 | The amount of fees collected in token1 |

### burn

```solidity
  function burn(
    uint256 tokenId
  ) external
```

Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
must be collected first.

#### Parameters:

| Name      | Type    | Description                              |
| :-------- | :------ | :--------------------------------------- |
| `tokenId` | uint256 | The ID of the token that is being burned |

### \_getAndIncrementNonce

```solidity
  function _getAndIncrementNonce(
  ) internal returns (uint256)
```

### getApproved

```solidity
  function getApproved(
  ) public view returns (address)
```

Returns the account approved for `tokenId` token.
Requirements:

- `tokenId` must exist.

### \_approve

```solidity
  function _approve(
  ) internal
```

Overrides \_approve to use the operator in the position, which is packed with the position permit nonce
</file>

<file path="docs/contracts/v3/reference/periphery/NonfungibleTokenPositionDescriptor.md">
Produces a string containing the data URI for a JSON metadata string

## Functions

### constructor

```solidity
  function constructor(
  ) public
```

### tokenURI

```solidity
  function tokenURI(
    contract INonfungiblePositionManager positionManager,
    uint256 tokenId
  ) external returns (string)
```

Produces the URI describing a particular token ID for a position manager

Note this URI may be a data: URI with the JSON contents directly inlined

#### Parameters:

| Name              | Type                                 | Description                                                                    |
| :---------------- | :----------------------------------- | :----------------------------------------------------------------------------- |
| `positionManager` | contract INonfungiblePositionManager | The position manager for which to describe the token                           |
| `tokenId`         | uint256                              | The ID of the token for which to produce a description, which may not be valid |

#### Return Values:

| Name  | Type                                 | Description                          |
| :---- | :----------------------------------- | :----------------------------------- |
| `The` | contract INonfungiblePositionManager | URI of the ERC721-compliant metadata |

### flipRatio

```solidity
  function flipRatio(
  ) public returns (bool)
```

### tokenRatioPriority

```solidity
  function tokenRatioPriority(
  ) public returns (int256)
```
</file>

<file path="docs/contracts/v3/reference/periphery/SwapRouter.md">
Router for stateless execution of swaps against Uniswap V3

> Input parameters are viewable on the [**Swap Router Interface**](./interfaces/ISwapRouter)

## Functions

### constructor

```solidity
  function constructor(
  ) public
```

### uniswapV3SwapCallback

```solidity
  function uniswapV3SwapCallback(
    int256 amount0Delta,
    int256 amount1Delta,
    bytes data
  ) external
```

Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.

In the implementation you must pay the pool tokens owed for the swap.
The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
amount0Delta and amount1Delta can both be 0 if no tokens were swapped.

#### Parameters:

| Name           | Type   | Description                                                                                                                                                                             |
| :------------- | :----- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `amount0Delta` | int256 | The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool. |
| `amount1Delta` | int256 | The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool. |
| `data`         | bytes  | Any data passed through by the caller via the IUniswapV3PoolActions#swap call                                                                                                           |

### exactInputSingle

```solidity
  function exactInputSingle(
    struct ISwapRouter.ExactInputSingleParams params
  ) external returns (uint256 amountOut)
```

Swaps `amountIn` of one token for as much as possible of another token

#### Parameters:

| Name     | Type                                      | Description                                                                            |
| :------- | :---------------------------------------- | :------------------------------------------------------------------------------------- |
| `params` | struct ISwapRouter.ExactInputSingleParams | The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata |

#### Return Values:

| Name        | Type    | Description                      |
| :---------- | :------ | :------------------------------- |
| `amountOut` | uint256 | The amount of the received token |

### exactInput

```solidity
  function exactInput(
    struct ISwapRouter.ExactInputParams params
  ) external returns (uint256 amountOut)
```

Swaps `amountIn` of one token for as much as possible of another along the specified path

#### Parameters:

| Name     | Type                                | Description                                                                                |
| :------- | :---------------------------------- | :----------------------------------------------------------------------------------------- |
| `params` | struct ISwapRouter.ExactInputParams | The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata |

#### Return Values:

| Name        | Type    | Description                      |
| :---------- | :------ | :------------------------------- |
| `amountOut` | uint256 | The amount of the received token |

### exactOutputSingle

```solidity
  function exactOutputSingle(
    struct ISwapRouter.ExactOutputSingleParams params
  ) external returns (uint256 amountIn)
```

Swaps as little as possible of one token for `amountOut` of another token

#### Parameters:

| Name     | Type                                       | Description                                                                             |
| :------- | :----------------------------------------- | :-------------------------------------------------------------------------------------- |
| `params` | struct ISwapRouter.ExactOutputSingleParams | The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata |

#### Return Values:

| Name       | Type    | Description                   |
| :--------- | :------ | :---------------------------- |
| `amountIn` | uint256 | The amount of the input token |

### exactOutput

```solidity
  function exactOutput(
    struct ISwapRouter.ExactOutputParams params
  ) external returns (uint256 amountIn)
```

Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)

#### Parameters:

| Name     | Type                                 | Description                                                                                 |
| :------- | :----------------------------------- | :------------------------------------------------------------------------------------------ |
| `params` | struct ISwapRouter.ExactOutputParams | The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata |

#### Return Values:

| Name       | Type    | Description                   |
| :--------- | :------ | :---------------------------- |
| `amountIn` | uint256 | The amount of the input token |
</file>

<file path="docs/contracts/v3/reference/periphery/V3Migrator.md">
## Functions

### constructor

```solidity
  function constructor(
  ) public
```

### receive

```solidity
  function receive(
  ) external
```

### migrate

```solidity
  function migrate(
  ) external
```
</file>

<file path="docs/contracts/v3/reference/_category_.json">
{
  "label": "Technical Reference",
  "position": 5,
  "collapsed": true
}
</file>

<file path="docs/contracts/v3/reference/error-codes.md">
---
id: error-codes
title: Error Codes
---

LiquidityMath.sol

- `LS`: Liquidity Sub
- `LA`: Liquidity Add

Oracle.sol

- `OLD`: The target must be chronologically after the oldest observation

- `I`: The pool has not been initialized

Position.sol

- `NP`: Burn cannot be called for a position with 0 liquidity

Tick.sol

- `LO`: LiquidityGrossAfter must be less than MaxLiquidity

TickMath.sol

- `T`: The given tick must be less than, or equal to, the maximum tick
- `R`: second inequality must be < because the price can never reach the price at the max tick

TransferHelper.sol

- `TF`: Transfer Failed : errors with TF if transfer fails

UniswapV3Pool.sol

- `LOK`: The reentrancy guard. A transaction cannot re-enter the pool mid-swap

- `TLU`: The lower tick must be below the upper tick
- `TLM`: The lower tick must be greater, or equal to, the minimum tick
- `TUM`: The upper tick must be lesser than, or equal to, the maximum tick
- `AI`: The pool is already initialized
- `M0`: Mint 0, The balance of token0 in the given pool before minting must be less than, or equal to, the balance after minting
- `M1`: Mint 1, The balance of token1 in the given pool before minting must be less than, or equal to, the balance after minting
- `AS`: `amountSpecified` cannot be zero
- `SPL`: Square root price limit
- `IIA`: Insufficient input amount, an insufficient amount of input token was sent during the callback
- `L`: Liquidity in the pool must be greater than zero for a flash to be executed
- `F0`: The balance of token0 in the given pool before the flash transaction must be less than, or equal to, the balance of token0 after the flash plus the fee
- `F1`: The balance of token1 in the given pool before the flash transaction must be less than, or equal to, the balance of token1 after the flash plus the fee
</file>

<file path="docs/contracts/v3/reference/overview.md">
---
id: overview
title: Overview
sidebar_position: 1
---

Uniswap v3 is a binary smart contract system comprised of many libraries, which together make the Core and Periphery.

Core contracts provide fundamental safety guarantees for all parties interacting with Uniswap. They define the logic of pool generation, the pools themselves, and the interactions involving the respective assets therein.

Periphery contracts interact with one or more Core contracts but are not part of the core. They are designed to provide methods of interacting with the core that increase clarity and user safety.

External calls will primarily call the periphery interfaces. Externally available functions are all viewable in the reference documentation. Internal functions are viewable on the Uniswap v3 GitHub repo.

## Core

> [**Core Source Code**](https://github.com/Uniswap/uniswap-v3-core)

The core consists of a single factory, a pool deployer, and the many pools the factory will create.

A significant amount of care and attention has been given to gas optimization in the core contracts. The result is a substantial reduction in gas costs for all protocol interactions compared to V2, at the cost of a reduction in code clarity.

### Factory

> [**Factory Reference**](./core/UniswapV3Factory)

The factory defines the logic for generating pools. A pool is defined by two tokens, which make up the asset pair, and a fee. There can be multiple pools of the same asset pair, distinguished only by their swap fee.

### Pools

> [**Pool Reference**](./core/UniswapV3Pool).

Pools primarily serve as automated market makers for the paired assets. Additionally, they expose price oracle data and may be used as an asset source for flash transactions.

## Periphery

The periphery is a constellation of smart contracts designed to support domain-specific interactions with the core. As the Uniswap protocol is a permissionless system, the contracts described below have no special privileges and are only a small subset of possible periphery-like contracts.

### SwapRouter

> [**Swap Router Reference**](./periphery/SwapRouter)

> [**Swap Router Interface**](./periphery/interfaces/ISwapRouter)

The swap router supports all the basic requirements of a front-end offering trading. It natively supports single trades (x to y) and multihop trades (e.g. x to y to z).

### Nonfungible Position Manager

> [**Nonfungible Position Manager Reference**](./periphery/NonfungiblePositionManager)

> [**Nonfungible Position Manager Interface**](./periphery/interfaces/INonfungiblePositionManager)

The position manager handles the logic transactions involving the creation, adjustment, or exiting of positions.

### Oracle

> [**Oracle Reference**](./core/libraries/Oracle)

The oracle provides price and liquidity data useful for a wide variety of system designs, and is available in every deployed pool.

### Periphery Libraries

> [**Periphery Libraries**](./periphery/libraries/Base64)

The libraries provide a variety of helper functions developers may need, like calculating pool addresses, safe transfer functions, and more.
</file>

<file path="docs/contracts/v3/_category_.json">
{
  "label": "v3 Protocol",
  "position": 2,
  "collapsed": true
}
</file>

<file path="docs/contracts/v3/overview.md">
---
id: overview
title: Overview
sidebar_position: 1
---

Welcome to the Uniswap v3 smart contracts documentation.

The pages here contain guides and technical documentation for the Uniswap v3 Smart Contracts.
You can use these docs to learn about the v3 Protocol Smart Contracts and develop on-chain integrations.

## Guides

If you are new to the Uniswap Protocol, we recommend you start with the [basic concepts](../../concepts/uniswap-protocol) first.

You can then setup your [local environment](./guides/local-environment) and execute your [first swap](./guides/swaps/single-swaps).

## Reference

For a deeper dive, read through the [technical reference](./reference/overview) docs.

## Resources

- [**v3 Core**](https://github.com/Uniswap/v3-core)
- [**v3 Periphery**](https://github.com/Uniswap/v3-periphery)
</file>

<file path="docs/contracts/v4/concepts/_category_.json">
{
  "label": "Concepts",
  "position": 3,
  "collapsed": true
}
</file>

<file path="docs/contracts/v4/concepts/dynamic-fees.mdx">
---
title: Dynamic Fees
sidebar_position: 7
---

Uniswap v4 introduces dynamic fees, allowing for flexible and responsive fee structures managed through hooks. This feature enables pools to adapt fees to changing market conditions, potentially improving liquidity provider profitability and overall market efficiency.

## What are Dynamic Fees?

Dynamic fees in Uniswap v4 are a specific type of swap fee paid by swappers that directly accrue to liquidity providers. These fees are distinct from protocol fees and hook fees (Optional fees that can be implemented by custom hooks), and represent a significant advancement over the fee structures in previous Uniswap versions.

Unlike the static fee tiers in Uniswap v3 (0.05%, 0.30%, 1.0%) or the single fee in v2, dynamic fees in v4 offer much more flexibility. Dynamic fees can:

- Adjust in real-time based on various market conditions
- Change on a per-swap basis
- Allow for any fee percentage (e.g., 4.9 bips, 10 bips)
- Be updated at various intervals (yearly, per block, or per transaction)

This dynamic nature allows for more efficient fee pricing, potentially benefiting both liquidity providers and traders by adapting to current market conditions. By allowing fees to fluctuate based on market dynamics, Uniswap v4 aims to optimize liquidity provision and trading across a wide range of market scenarios.

## Motivation and Benefits of Dynamic Fees

1. **Improved Pricing of Volatility:** Adapt fees to market volatility, similar to traditional exchanges adjusting bid-ask spreads.
2. **Order Flow Discrimination:** Price different types of trades (e.g., arbitrage vs. uninformed) more accurately.
3. **Improved Market Efficiency and Stability:** Fees can adjust to reflect real-time market conditions, optimizing for both liquidity providers and traders. Dynamic fees could help dampen extreme market movements by adjusting incentives in real-time.
4. **Enhanced Capital Efficiency and Liquidity Provider Returns:** By optimizing fees, pools can attract more liquidity and facilitate more efficient trading. More accurate fee pricing could lead to better returns for liquidity providers, potentially attracting more capital to pools.
5. **Better Risk Management:** During high volatility, fees can increase to protect liquidity providers from impermanent loss.
6. **Customizable Strategies:** Enable complex fee strategies for specific token pairs or market segments.

## Dynamic Fees Use Cases

1. **Volatility-Based Fees:** Adjust fees based on the historical or realized volatility of the asset pair.
2. **Volume-Based Fees:** Lower fees during high-volume periods to attract more trades, and increase fees during low-volume periods to compensate liquidity providers.
3. **Time-Based Fees:** Implement different fee structures for different times of day or days of the week, based on historical trading patterns.
4. **Market Depth-Based Fees:** Adjust fees based on the current liquidity depth in the pool.
5. **Cross-Pool Arbitrage Mitigation:** Dynamically adjust fees to discourage harmful arbitrage between different pools or exchanges.
6. **Gas Price-Responsive Fees:** Adjust fees based on network congestion and gas prices to ensure profitability for liquidity providers.
7. **Event-Driven Fees:** Implement special fee structures during significant market events or token-specific occurrences.
8. **Lookback approach:** Set the fee to match the most profitable fee tier of external pools with the same asset pair over a recent period.
9. **Price oracle approach:** Use an external price oracle to determine the correct asset price and adjust fees based on how trades move the pool price relative to this external price.
10. **Price momentum approach:** Analyze recent price history and asymmetrically adjust fees based on trade direction.
11. **Asset composition approach:** Lower fees for trades that balance the pool and higher fees for trades that imbalance it.
12. **Transaction-source based approach:** Provide lower fees for transactions routed through certain aggregators or sources less likely to be arbitrage trades.

## Dynamic Fees Mechanism

In Uniswap v4, the dynamic fee capability of a pool is determined at pool creation and is immutable. This means that whether a pool uses dynamic fees or not is set when the pool is initially created and cannot be changed afterwards. For pools that do use dynamic fees, Uniswap v4 supports two primary methods for updating the fee:

1. **Periodic Updates via PoolManager:** Fees can be updated by calling the `updateDynamicLPFee` function on the PoolManager contract at specified intervals.
2. **Per-Swap Updates via beforeSwap Hook:** Fees can be dynamically set for each swap by returning the fee from the `beforeSwap` hook. This allows hooks to override the LP fee for each swap in dynamic fee pools.

These methods offer flexibility in implementing various fee strategies.

Below is an example of how to set dynamic fees using the `beforeSwap` hook:

![](./images/Uniswap_V4_Dynamic_Fees_Step_1.jpg)

Before a swap occurs, the `beforeSwap` hook is invoked to determine the fee based on the defined logic. This hook calls the `updateDynamicLPFee` function on the PoolManager contract to update the fee.

![](./images/Uniswap_V4_Dynamic_Fees_Step_2.jpg)

The `updateDynamicLPFee` function in the PoolManager contract updates the pool's fee accordingly.

For more detailed information on implementing these methods, please refer to our [Dynamic Fees Implementation Guide](https://uniswap-docs-staging.vercel.app/documentation/featured-guides/hooks/v4/guides-for-solidity-contracts/dynamic-fee-pools).

## Considerations and Best Practices

- The optimal fee depends on at least two factors: **asset volatility** and **volume of uninformed flow.**
- For volatile pairs in systems like Uniswap v3, which don't discriminate between flows, low fee-tier pools are only sensible when uninformed flow is large and asset volatility is relatively low.
- Performance implications of frequent fee updates should be carefully considered.
- Security measures should be implemented to prevent manipulation of fee-setting mechanisms.
- Balance responsiveness with gas costs to optimize for both performance and cost-effectiveness.

For more detailed implementation guidance and best practices, refer to our [Dynamic Fees Implementation Guide](https://uniswap-docs-staging.vercel.app/documentation/featured-guides/hooks/v4/guides-for-solidity-contracts/dynamic-fee-pools).
</file>

<file path="docs/contracts/v4/concepts/erc6909.mdx">
---
title: ERC-6909
sidebar_position: 3
---

Uniswap v4 uses [ERC-6909](https://eips.ethereum.org/EIPS/eip-6909) to further improve gas-efficiency on token claims and redemptions.

ERC-6909 is a minimal and gas-efficient standard for managing multiple ERC-20 tokens from a single contract. It provides a simplified alternative to the more complex ERC-1155 multi-token standard. 

### ERC-6909 vs ERC-1155

ERC-6909 offers several advantages over ERC-1155:
1. Simplified interface: ERC-6909 removes unnecessary safe transfer callbacks and batching constraints presented in ERC-1155.
2. Improved transfer delegation: ERC-6909 provides a more efficient system for transfer delegation.
3. Gas efficiency: ERC-6909 reduces gas costs for deployment, transfers, and burning operations.
4. Reduced code size: Implementing ERC-6909 results in smaller contract sizes compared to ERC-1155.

However, it's worth noting that ERC-6909 does introduce a `totalSupply` variable, which leads to an additional disk write on mint and burn operations.

## How it works

Instead of choosing to move tokens in/out of the `PoolManager`, developers can opt-in and leave the ERC-20 tokens within the `PoolManager`. In exchange, the `PoolManager` can **mint them an ERC-6909 token representing their claim**. In subsequent interactions requiring _paying_ tokens, users will not need to transfer ERC-20 tokens into the `PoolManager` - users can simply _burn_ some (or all) of their claim tokens they have


Doing _real_ ERC-20 token transfers requires calls to external smart contracts - incurring gas overhead compared to internal accounting. Secondly, these external smart contracts have their own custom logic within their `transfer` functions - for example USDC's blocked-address list - which is a further gas overhead. Thus, minting and burning ERC-6909 tokens are more gas-efficient because they don't require external function calls and have a constant-size gas overhead regardless of the underlying ERC-20 token.

This mechanism therefore helps further reduce gas costs. All these gas cost reductions overall make pools much more competitive based on the fees they charge.

## Examples

### High-frequency traders / MEV bots

These users are often conducting a lot of swaps in relatively short durations of time, while staying within the Uniswap Protocol. These power-users can trade using ERC-6909 tokens for improved gas-efficiency.

### Liquidity management

ERC-6909 does not only benefit swappers. For power-users that may be opening and closing liquidity positions frequently, liquidity managers can opt-in and receive their capital as ERC-6909.
</file>

<file path="docs/contracts/v4/concepts/fee-structure.mdx">
---
id: fee structure
title: v4 Fee Structure Guide
sidebar_position: 9
---

## Overview of Fee Types

In Uniswap v4, there are three main types of fees to understand:

- **LP Fee**: Fees earned by liquidity providers
- **Protocol Fee**: Fees collected by the protocol
- **Swap Fee**: Total fee paid by swappers (calculated by applying protocol fee and LP fee sequentially)

---

## LP Fees

LP fees are set by the pool initializer at pool creation and may be static or dynamic.

**Fee Range:**

- Maximum LP Fee: 100%
- Minimum LP Fee: 0%
- **Granularity**: Fees are set at pip-level precision

### Static LP Fees

- **Immutable** once set during pool initialization
- **Unlimited fee options** in v4 (major improvement from v3)
- In **v3**, LP fee options were limited to: 0.01%, 0.05%, 0.30%, and 1.00%

### Dynamic LP Fees

Dynamic fees offer more flexibility and real-time adjustability:

- A dynamic fee pool signals this capability by setting its LP fee to `0x800000` (where the first bit = 1)
- **Only the pool's hook** can update the dynamic fee—no additional permissions required
- A hook **cannot** update fees if the pool's fee is not set to `0x800000`

---

## Protocol Fees

Protocol fees are configured **per pool** with the following characteristics:

- Controlled by the **protocol fee controller** (set by the pool manager owner)
- **Maximum protocol fee**: 0.1% (1,000 pips)
- **Granularity**: Fees are set at pip-level precision (not basis points)
- **Unit conversion**: 1 basis point = 100 pips
- **Directional fees**: Separate fees can be set for:
    - token0 → token1 swaps
    - token1 → token0 swaps

---

## Swap Fees

### Key Change from v3 to v4

**v3 behavior**: Swap fee = LP fee (protocol fee was a percentage taken from LP fees)

**v4 behavior**: Swap fee = effective total fee after applying both protocol and LP fees sequentially

### Application Order

1. **Protocol fee** applied first to the input amount
2. **LP fee** applied second to the remaining input (after protocol fee deduction)

**Impact on LP Earnings:**

Note that this sequential application means introducing or increasing protocol fees will reduce LP earnings even if swap volume remains constant, since LPs now earn fees on a smaller base amount.

### Fee Cap

- **Total swap fee capped at 100%** of input amount
- **Important**: If swap fee = 100%, exact output swaps become impossible (entire input consumed by fees)

### Fee Calculation Formula

```solidity

// Method 1: Sequential application
uint256 swapFee = protocolFee + (lpFee * (1_000_000 - protocolFee)) / 1_000_000; (rounded up)

// Method 2: Mathematically equivalent
uint256 swapFee = protocolFee + lpFee - (protocolFee * lpFee) / 1_000_000;

```

### Mathematical Derivation

Starting with input amount:

```
amountIn
```

**Step 1**: Protocol fee takes:

```
amountIn × (protocolFee / 1_000_000)
```

**Step 2**: Remaining after protocol fee:

```

amountIn × (1 - protocolFee / 1_000_000)
```

**Step 3**: LP fee applies to remaining:

```
lpFee × (remaining amount)
```

**Final formula**:

```
swapFee = protocolFee + (lpFee × (1 - protocolFee / 1_000_000))
```

Which simplifies to:

```
swapFee = protocolFee + lpFee - (protocolFee × lpFee) / 1_000_000
```

## Example Calculation

**Given:**

- `protocolFee = 50` pips → 0.005%
- `lpFee = 3000` pips → 0.30%

**Calculation:**

```solidity
swapFee = 50 + 3000 - (50 × 3000) / 1_000_000
        = 50 + 3000 - 150 / 1_000_000
        = 50 + 3000 - 0.15
        = 3049.85 pips
```

**Result:** 3049.85 pips = **0.304985%** total swap fee

---

## Key Takeaways

- **Sequential application**: Protocol fees are deducted first, then LP fees apply to the remainder
- **Dynamic flexibility**: v4 introduces unlimited static fee tiers and dynamic fee capabilities
- **Directional control**: Protocol fees can differ by swap direction
- **Fee interaction**: The combined effect is slightly less than simple addition due to sequential application
</file>

<file path="docs/contracts/v4/concepts/flash-accounting.mdx">
---
title: Flash Accounting
sidebar_position: 2
---

## Flash Accounting

In previous versions of Uniswap, every time a swap was made - including multi-hop swap - tokens were transferred between Pool contracts for intermediate steps.

This design incurred inefficiencies because transferring tokens with external calls to their smart contracts - especially in a multi-hop swap - is quite expensive. This design was required since each pool was its own contract and token transfers were required to maintain accounting and solvency.

With the singleton architecture, a better design was possible and is referred to as _Flash Accounting_. The design became practical with gas efficiencies of [Transient Storage](https://eips.ethereum.org/EIPS/eip-1153). _Flash Accounting_ further reduces the gas cost of trades that cross multiple pools and supports more complex integrations with Uniswap v4.

With _flash accounting_, each balance-changing operation (e.g. swap and liquidity modification) updates an internal net balance known as `delta`. Only the final balance-changes require token transfers.

![Flash Accounting Step 1](./images/Uniswap_V4_Flash_Accounting_Step_1.png)
![Flash Accounting Step 2](./images/Uniswap_V4_Flash_Accounting_Step_2.png)

For example from the above diagrams - let's say you have 20 `USDC` and 20 `USDT` but you want to add liquidity with 15 `USDC` and 25 `USDT`. Previously this would require multiple external calls as tokens were transferred between Pool contracts when swapping from `USDC` to `USDT`. But now with v4's Flash Accounting we only need to keep track of `delta` - thus we can `swap` and `modifyLiquidity` in a single call and only the final balance-changes involve actual token transfers.

In the above example, we are swapping 5 USDC to 5 USDT to create liquidity with 15 USDC and 25 USDT. In between the operations (*swap, modifyLiquidity*), no token transfers are made

## Mechanism

### Locking

To ensure correctness and atomicity in complex operations like a multi-hop swap - v4 uses a locking mechanism. Anytime key actions need to take place within the `PoolManager` - e.g. swaps and liquidity modification - a periphery contract must `unlock` the `PoolManager` first. Then integrators implement the `unlockCallback` and proceed with any of the following actions on the pools:

- swap
- modifyLiquidity
- donate
- take
- settle
- mint
- burn
- sync

*Note that pool initialization can happen outside the context of unlocking the `PoolManager`, as there are no balance-changing operations associated with pool creation.*

The following diagrams visualize how the above steps will be implemented:

1. `unlock` the `PoolManager`
![Flash Accounting Locking Mechanism Step 1](./images/Uniswap_V4_Locking_Mechanism_Step_1.png)

2. Implement `unlockCallback` and proceed with any desired pool actions
![Flash Accounting Locking Mechanism Step 2](./images/Uniswap_V4_Locking_Mechanism_Step_2.png)

3. The actual token transfer happens at the end and the *delta* should be resolved
![Flash Accounting Locking Mechanism Step 3](./images/Uniswap_V4_Locking_Mechanism_Step_3.png)


### Balance Delta

Inside `unlockCallback`, a periphery contract performs balance-changing operations i.e. conduct swaps, modify positions, etc. After returning execution context back to `PoolManager`, the core contract checks that balances are resolved - nothing is owed to or from the `PoolManager`.

The balances resolved above is what we refer as the `delta`, a field held in the _transient_ state. The value(s) represent the _debts_ and _credits_ of assets owed to or from the `PoolManager`.

## Swapping

![Multi-hop swaps on V3 vs V4](./images/Uniswap_V4_Multihop_Swaps.png)

As shown in the above diagram, for example - let's say you want to swap `ETH` for `DAI`. Assuming this requires a multi-hop swap going from `ETH` to `USDC` and then from `USDC` to `DAI`.

### Previously on v3

1. `ETH` is transferred to `ETH <> USDC` pool contract

2. `USDC` is withdrawn from `ETH <> USDC` contract and transferred to `USDC <> DAI` contract

3. `DAI` is withdrawn from `USDC <> DAI` contract and transferred to the user

### Now on v4

1. Call `swap()` on `ETH <> USDC`

2. Call `swap()` on `USDC <> DAI`, with the credit of USDC from above being used as the input amount

3. User _resolves deltas_ by paying ETH and receiving DAI

Therefore we can skip the step of actually calling `transfer()` on the USDC contract.

The optimization scales infinitely, any number of arbitrary hops only requires two token transfers - input and output tokens.

## Liquidity Management

The optimization becomes more evident for complex liquidity operations

For example, a user wanted to add liquidity to `ETH <> DAI` but does not have DAI. The user can swap some `ETH` to `DAI` in order to add liquidity with both tokens. In addition, the user can multi-hop swap going from `ETH` to `USDC` to `DAI`. If properly integrated, the user would only need to transfer ETH _once_.

## Developer Resources

To see how unlock callback and delta work in a smart contract read [Unlock Callback & Deltas](/contracts/v4/guides/unlock-callback).
</file>

<file path="docs/contracts/v4/concepts/hooks.mdx">
---
title: Hooks
sidebar_position: 4
---

Uniswap v4 introduces Hooks, a system that allows developers to customize and extend the behavior of liquidity pools.

Hooks are external smart contracts that can be attached to individual pools. Every pool can have one hook but a hook can serve an infinite amount of pools to intercept and modify the execution flow at specific points during pool-related actions.

## Key Concepts

### Pool-Specific Hooks

- Each liquidity pool in Uniswap v4 can have its own hook contract attached to it. Hooks are optional for Uniswap v4 pools.
- The hook contract is specified when creating a new pool in the `PoolManager.initialize` function.
- Having pool-specific hooks allows for fine-grained control and customization of individual pools.

## Core Hook Functions

Uniswap v4 provides a set of core hook functions that can be implemented by developers. Developers do not have to implement every hook, you can mix&match them to whatever your liking is. You can use one or all of them!

- Hook contracts specify the permissions that determine which hook functions they implement, which is encoded in the address of the contract.
- The `PoolManager` uses these permissions to determine which hook functions to call for a given pool based on its Key.

### Initialize Hooks

- `beforeInitialize`: Called before a new pool is initialized.
- `afterInitialize`: Called after a new pool is initialized.
- These hooks allow developers to perform custom actions or validations during pool initialization, but these hooks can only be invoked once.

### Liquidity Modification Hooks

The liquidity modification hooks are extremely granular for security purposes.

- `beforeAddLiquidity`: Called before liquidity is added to a pool.
- `afterAddLiquidity`: Called after liquidity is added to a pool.
- `beforeRemoveLiquidity`: Called before liquidity is removed from a pool.
- `afterRemoveLiquidity`: Called after liquidity is removed from a pool.

### Swap Hooks

- `beforeSwap`: Called before a swap is executed in a pool.
- `afterSwap`: Called after a swap is executed in a pool.

### Donate Hooks

- `beforeDonate`: Called before a donation is made to a pool.
- `afterDonate`: Called after a donation is made to a pool.
- Donate hooks provide a way to customize the behavior of token donations to liquidity providers.

## Innovation and Potential

The introduction of hooks in Uniswap v4 opens up a world of possibilities for developers to innovate and build new DeFi protocols. Some potential use cases include:

- Customized AMMs with different pricing curves than xy = k.
- Yield farming and liquidity mining protocols that incentivize liquidity provision.
- Derivative and synthetic asset platforms built on top of Uniswap v4 liquidity.
- Lending hooks integrated with Uniswap v4 pools.

As a hook developer you can easily bootstrap the codebase of an entirely new DeFi protocol through hook designs, which subsequently drives down your audit costs and allows you to develop faster. However, it's important to note that just because you made a hook, that does not mean you will get liquidity routed to your hook from the Uniswap frontend.
</file>

<file path="docs/contracts/v4/concepts/integrated-routing-uniswap-x.mdx">
---
title: Integrated Routing with UniswapX
sidebar_position: 8
---

The [Uniswap Interface](https://app.uniswap.org) will be ramping up support for hooks in its standard routing system progressively over time. Hook builders looking to get immediate access to flow from the interface can do so by running a UniswapX filler for their hooked pools. 

At a high level, hook builders' filler implementations will need to do the following: 

1. (On Mainnet) Subscribe to the UniswapX RFQ system and submit fillable bids from orders they receive 
2. Listen to the public feed for orders they won or that are open to be filled publicly
3. Execute those orders against pools that use their hooks

Developers should check [UniswapX Documentation](/contracts/uniswapx/overview) to get started.
</file>

<file path="docs/contracts/v4/concepts/PoolManager.mdx">
---
title: PoolManager
sidebar_position: 6
---

In Uniswap v3, each liquidity pool was represented by a separate smart contract deployed through the Uniswapv3Factory contract. While this approach provided flexibility, it also led to increased gas costs for pool creation and multi-hop swaps.

Uniswap v4 addresses this issue by introducing the Singleton design pattern. The PoolManager contract now serves as a single entry point for all liquidity pools. Instead of deploying separate contracts for each pool, the pool state and logic are encapsulated within the PoolManager itself.

## Purpose

The primary purpose of the `PoolManager` is to:

- Efficiently manage liquidity pools
- Facilitate token swaps
- Reduce gas costs compared to the factory-based approach in Uniswap v3
- Enable extensibility through hooks

## Architecture

### Singleton Design

- Uniswap v4 uses a Singleton design pattern for the `PoolManager`
- All pool state and logic are encapsulated within the `PoolManager` contract

### Locking Mechanism

- The `PoolManager` uses a locking mechanism to allow for _flash accounting_ (also known as deferred balance accounting)
- When unlocked, the calling contract can perform various operations and zero-out outstanding balances before returning control to the `PoolManager` for final solvency checks

### Pool State

- The `Pool.State` struct contains information such as:
    - Current price
    - Liquidity
    - Tick bitmap
    - Fee growth
    - Position information

### Libraries

- The pool logic is implemented using Solidity libraries to keep the `PoolManager` contract modular and gas-efficient
- These libraries are:
    - `Pool`: Contains core pool functionality, such as swaps and liquidity management
    - `Hooks`: Handles the execution of hook functions
    - `Position`: Manages liquidity positions within a pool

## Core Functionality

### Pool Creation

- New pools are created by calling the `initialize` function on the `PoolManager`
- The pool creator specifies the token pair, fee tier, tick spacing, and optional hook contract address
- The `PoolManager` initializes the pool state and associates it with a unique `PoolId`

### Swaps

- Swaps are initiated through the `swap` function on the `PoolManager`, typically via a swap router contract
- The `PoolManager` executes the following steps:
    1. Checks if the pool is valid and initialized
    2. Executes the `beforeSwap` hook, if applicable
    3. Performs the actual swap, updating the pool state and charging fees
    4. Executes the `afterSwap` hook, if applicable
    5. Calculates the net token amounts owed to the user and the pool, represented by the `BalanceDelta` struct
- Swaps utilize flash accounting, where tokens are moved into the `PoolManager`, and only the final output tokens are withdrawn

### Liquidity Management

- Liquidity providers can add or remove liquidity using the `modifyLiquidity` function on the `PoolManager`. However, you wouldn't call this directly from your application, you would call this from a periphery contract to handle the locking & unlocking a particular pool. 
- The `PoolManager` executes the following steps:
    1. Checks if the pool is valid and initialized
    2. Determines if the modification is an addition or removal of liquidity
    3. Executes the appropriate `beforeAddLiquidity` or `beforeRemoveLiquidity` hook, if applicable
    4. Performs the actual liquidity modification and updates the pool state
    5. Emits the `ModifyLiquidity` event
    6. Executes the appropriate `afterAddLiquidity` or `afterRemoveLiquidity` hook, if applicable
    7. Calculates the balance delta and returns it to the caller

### Flash Accounting

- The `PoolManager` employs flash accounting to reduce gas costs and simplify multi-hop swaps
- Tokens are moved into the `PoolManager` contract, and all subsequent actions are performed within the contract's context
- Only the final output tokens are withdrawn from the `PoolManager` at the end of the transaction

### Transient Storage

- The `PoolManager` utilizes transient storage (EIP-1153) to store temporary data during complex operations
- Transient storage reduces gas costs by avoiding regular storage operations for data only needed within a single transaction
</file>

<file path="docs/contracts/v4/concepts/security.mdx">
---
id: security
title: Security
sidebar_position: 10
---

When building on Uniswap v4, security should be a primary consideration. This section covers emergency response resources and security best practices specific to v4 implementations.

## Emergency Response

### SEAL 911 Emergency Hotline

If you encounter a security incident (exploit, vulnerability, or other urgent security matter) while working with Uniswap v4, the SEAL 911 Emergency Hotline provides immediate access to security experts.

**Emergency Contact**: https://t.me/seal_911_bot

SEAL 911 is a community-operated Telegram bot that connects you directly with vetted security responders who can provide immediate assistance during security incidents.

#### How It Works
- Send a message through the bot during a security emergency
- Automatic alert routing to a vetted group of white hat security professionals
- Immediate response from trusted security experts in the space

#### Additional Resources
- [SEAL 911 GitHub Repository](https://github.com/security-alliance/seal-911)
- [Security Alliance Website](https://www.securityalliance.org/seal-911)

:::note
SEAL 911 is a third-party service operated by the Security Alliance. Exercise appropriate judgment when sharing sensitive information during emergency situations.
:::

## v4-Specific Security Considerations

### Hook Security
When developing custom hooks for v4, ensure proper validation and access controls. Malicious or poorly implemented hooks can compromise pool security.

### Flash Accounting
v4's flash accounting system requires careful implementation to prevent exploitation. Always ensure proper settlement of deltas.

### Pool Manager Interactions
Direct interactions with the PoolManager require thorough understanding of the locking mechanism and callback patterns.

## Audits

Uniswap's V4 core contracts have undergone a handful of extensive security reviews by multiple providers, with some reviews still ongoing. Below is a list of completed and draft reports. The full list can be found in the respective repositories' [audits directory](https://github.com/Uniswap/v4-core/blob/main/docs/security/audits):

> [Open Zeppelin report](https://github.com/Uniswap/v4-core/blob/main/docs/security/audits/OpenZeppelin_audit_core.pdf) from July 17th 2024.

> [Certora draft report](https://github.com/Uniswap/v4-core/blob/main/docs/security/audits/DRAFT_Certora_audit_core.pdf) from July 2024.

> [Trail of Bits report](https://github.com/Uniswap/v4-core/blob/main/docs/security/audits/TrailOfBits_audit_core.pdf) from September 5th 2024.

> [Spearbit draft report](https://github.com/Uniswap/v4-core/blob/main/docs/security/audits/DRAFT_Spearbit_audit_core.pdf) from September 5th 2024.

> [ABDK draft report](https://github.com/Uniswap/v4-core/blob/main/docs/security/audits/DRAFT_ABDK_audit_core.pdf) from September 5th 2024.


Similarly, the V4 periphery contracts have been reviewed by various audit providers, and the full list is inside the periphery repository's [audits directory](https://github.com/Uniswap/v4-periphery/tree/main/audits): 

> [Open Zeppelin report](https://github.com/Uniswap/v4-periphery/blob/main/audits/OpenZeppelin_audit_periphery_universal_router.pdf) from September 5th 2024.

> [Spearbit draft report](https://github.com/Uniswap/v4-periphery/blob/main/audits/DRAFT_Spearbit_audit_periphery.pdf) from September 5th 2024.

> [ABDK draft report](https://github.com/Uniswap/v4-periphery/blob/main/audits/DRAFT_ABDK_audit_periphery_universal_router.pdf) from September 5th 2024.

## Bug Bounty Program

In November 2024 Uniswap announced a [$15.5 million dollar bug bounty](https://blog.uniswap.org/v4-bug-bounty) for their V4 contracts. You can view the full [bounty page](https://cantina.xyz/bounties/f9df94db-c7b1-434b-bb06-d1360abdd1be) on Cantina.

## Additional Security Resources

- Review the [v4 Core contracts](../reference/core/) for implementation details
- Follow security best practices outlined in the [Hooks documentation](./04-hooks.mdx)
- Test thoroughly using the provided [test contracts](../reference/core/test/)
</file>

<file path="docs/contracts/v4/concepts/subscribers.mdx">
---
title: Subscribers
sidebar_position: 5
---

Subscribers, new in Uniswap v4, allow for liquidity-position owners to opt-in to a contract that receives _notifications_.
The new design is intended to support _liquidity mining_, additional rewards given to in-range liquidity providers. Through notification logic, position owners do not need
to risk their liquidity position and its underlying assets. In Uniswap v3, _liquidity mining_ was supported by fully transferring the 
liquidity position to an external contract; this old design would give the external contract full ownership and control of the liquidity position.

When a position owner _subscribes_ to a contract, the contract will receive notifcations when:

* The position is initially subscribed

* The position increases or decreases its liquidity

* The position is transferred

* The position is unsubscribed
</file>

<file path="docs/contracts/v4/concepts/v4-vs-v3.mdx">
---
title: v4 vs v3
sidebar_position: 1
---

While Uniswap v4's underlying concentrated liquidity is the same as Uniswap v3,
there are some key differences in the architecture and accounting.

## Singleton Design

### Pool Creation

**v4**: The singleton contract facilitates the creation of a pool and 
also stores its state. This pattern reduces costs when creating a pool
and doing multi-hop swaps. Because pools are _contract state_ and not entirely new _contracts_ themselves, pool creation is significantly cheaper.

**v3**: A factory contract is responsible for pool creation. The pool is
a separate contract instance that manages its own state. Pool initialization
is costly because contract creation is gas-intensive

### Flash Accounting

**v4**: The singleton uses _flash accounting_, meaning a caller that unlocks the PoolManager
is allowed to cause balance-changing operations (multiple swaps, multiple liquidity modifications, etc)
and only needs to perform token transfers at the very end of the sequence.

**v3**: Because flash accounting is missing from v3, it is the responsibility
of the integrating contract to perform token transfers, after each individual call, to each individual pool contract

## Liquidity Fee Accounting 

**v4**: Accrued fees act like a credit when modifying liquidity.
Increasing liquidity will convert the fee revenue to liquidity
inside the position while decreasing liquidity will automatically
require the withdrawal of unclaimed fee revenue.

An additional parameter _salt_ can be provided when creating liquidity. The
_salt_ is used to distinguish positions of the same range on the same pool.
This separation may be preferred to simplify fee accounting. If two users share the same
range and state in `PoolManager`, integrating contracts must be careful in managing
fees

**v3**: Liquidity positions of the same range and pool will share the same state. While believed to 
be more gas efficient at the time, integrating contracts will need to handle fee management since
the state is shared on the core pool contract

## Native ETH

**v4**: Pool pairs support native tokens, in doing so ETH swappers and
liquidity providers benefit from gas cost reductions from cheaper
transfers and removal of additional wrapping costs.

**v3**: ETH needs to be wrapped first before being paired with other tokens.
This results in higher gas costs because of wrapping and transferring
a wrapped native token.

## Subscribers

Only v4: Owners can now set a subscriber for their positions.
A subscriber contract will get notified every time the position's liquidity
or owner changes. Subscribers enable staking / liquidity-mining, but users do not need
to transfer their ERC-721 token.

**v3**: Staking in v3 requires users to transfer their ERC-721 token to a contract, putting the underlying assets at risk for malicious behavior.
</file>

<file path="docs/contracts/v4/guides/hooks/_category_.json">
{
  "label": "Hooks",
  "position": 1,
  "collapsed": true
}
</file>

<file path="docs/contracts/v4/guides/hooks/hook-deployment.mdx">
---
title: Hook Deployment
sidebar_position: 2
---

## Hook Flags

As mentioned in [Concept of Hooks](../../concepts/hooks.mdx), hook contracts indicate their implemented functions by __encoding its behavior in the address of the contract__. The `PoolManager` uses these permissions to determine which hook functions to call for a given pool. See `PoolManager` deployment addresses [here](/contracts/v4/deployments).

Each hook function e.g. `beforeSwap` - corresponds to a certain _flag_. For example, the `beforeSwap` function is correlated to the [`BEFORE_SWAP_FLAG`](https://github.com/Uniswap/v4-core/blob/main/src/libraries/Hooks.sol#L37) which has a value of `1 << 7`.

These flags represent specific bits in the address of the hook smart contract - and the value of the bit (a one or a zero) represents whether that flag is true or false. An example:

Addresses on Ethereum are 20 bytes long (160 bits). So for example the address:

```
0x00000000000000000000000000000000000000C0
```

represented in binary is:

```solidity
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 
0000 0000 0000 0000 0000 0000 1100 0000
```

In binary it goes from right-to-left - so the trailing 8 bits of this address are `1100 0000` where:

1st Bit to 6th Bit = `0`

7th Bit and 8th Bit = `1`

The `AFTER_SWAP` flag is represented by the 7th bit - which is set to `1` for the example contract address. In the `PoolManager` swap execution flow, it will observe the flag and make a call to the hook's `afterSwap` function.

Similarly, the 8th bit which is also a `1`, actually corresponds to the `BEFORE_SWAP` i.e. the `beforeSwap` hook function - which will also be called by the `PoolManager` during a `swap` workflow.

A full list of all flags can be found [here](https://github.com/Uniswap/v4-core/blob/main/src/libraries/Hooks.sol).

## Hook Miner

Because of encoded addresses, hook developers must _mine_ an address to a their particular pattern.

For local testing, `deployCodeTo` cheatcode in Foundry can be used to deploy hook contract to any address. 

But when deploying hooks to an actual network, address mining is required to find the proper deployment address
There is a helper library [`HookMiner.sol`](https://github.com/Uniswap/v4-periphery/blob/main/src/utils/HookMiner.sol) that can be used to mine for correct addresses.

Let's see it in action for a Foundry script. We will make use of the example - Points Hook from [Building Your First Hook](./01-your-first-hook.md).

First we set up the contract for Foundry script and import the relevant dependencies:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Script.sol";
import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {HookMiner} from "v4-periphery/src/utils/HookMiner.sol";

import {Constants} from "./base/Constants.sol";
import {PointsHook} from "../src/PointsHook.sol";

/// @notice Mines the address and deploys the PointsHook.sol Hook contract
contract PointsHookScript is Script, Constants {
    function setUp() public {}

    function run() public {
```

Specify the flags needed to be encoded in the address:

```solidity
uint160 flags = uint160(
    Hooks.AFTER_ADD_LIQUIDITY_FLAG | Hooks.AFTER_SWAP_FLAG
);
```

Mine the address by finding a `salt` that produces a hook address with the desired `flags`, use the Foundry deterministic deployer when deploying via Foundry script. For most chains, CREATE2_DEPLOYER contract address is [0x4e59b44847b379578588920ca78fbf26c0b4956c](https://book.getfoundry.sh/guides/deterministic-deployments-using-create2#getting-started).

```solidity
bytes memory constructorArgs = abi.encode(POOLMANAGER);
(address hookAddress, bytes32 salt) =
    HookMiner.find(CREATE2_DEPLOYER, flags, type(PointsHook).creationCode, constructorArgs);
```

:::note **CREATE2_DEPLOYER**
- `CREATE2_DEPLOYER` is the address that will deploy the hook. In `forge test`, this will be the test contract `address(this)` or the pranking address.
- In `forge script`, this should be `0x4e59b44847b379578588920cA78FbF26c0B4956C` (CREATE2 Deployer Proxy)
:::

Refer to this for more details on deploying contracts with CREATE2: [Deploying Contracts with CREATE2](https://docs.openzeppelin.com/cli/2.8/deploying-with-create2)

Deploy the hook using CREATE2 with the `salt`, and compare the deployed address with the address mined:

```solidity
vm.broadcast();
PointsHook pointsHook = new PointsHook{salt: salt}(IPoolManager(POOLMANAGER));
require(address(pointsHook) == hookAddress, "PointsHookScript: hook address mismatch");
```

## A Complete Foundry Script Contract

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Script.sol";
import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {HookMiner} from "v4-periphery/src/utils/HookMiner.sol";

import {Constants} from "./base/Constants.sol";
import {PointsHook} from "../src/PointsHook.sol";

/// @notice Mines the address and deploys the PointsHook.sol Hook contract
contract PointsHookScript is Script, Constants {
    function setUp() public {}

    function run() public {
        // hook contracts must have specific flags encoded in the address
        uint160 flags = uint160(
            Hooks.BEFORE_SWAP_FLAG | Hooks.AFTER_SWAP_FLAG | Hooks.BEFORE_ADD_LIQUIDITY_FLAG
                | Hooks.BEFORE_REMOVE_LIQUIDITY_FLAG
        );

        // Mine a salt that will produce a hook address with the correct flags
        bytes memory constructorArgs = abi.encode(POOLMANAGER);
        (address hookAddress, bytes32 salt) =
            HookMiner.find(CREATE2_DEPLOYER, flags, type(PointsHook).creationCode, constructorArgs);

        // Deploy the hook using CREATE2
        vm.broadcast();
        PointsHook pointsHook = new PointsHook{salt: salt}(IPoolManager(POOLMANAGER));
        require(address(pointsHook) == hookAddress, "PointsHookScript: hook address mismatch");
    }
}
```
</file>

<file path="docs/contracts/v4/guides/hooks/your-first-hook.md">
---
title: Building Your First Hook
sidebar_position: 1
---

## Introduction

Uniswap introduced the v4 of their protocol introducing several new concepts such as hooks, flash accounting, singleton architecture and more. The most interesting of these for developers is hooks, and that’s what we’ll be learning about today.

In this guide, we’ll be conceptualizing, understanding and building a basic points hook, which will give you some idea of how to build your own hook.

## What are we building?

Let’s start by conceptualizing what we’re building today and why. Let’s say you have a token named `TOKEN` that you want to incentivize people to buy. One way of doing so is awarding people points when they buy your token. Prior to v4, you’d have to do this off-chain or via your own helper contract outside of the swap logic, but in v4 you can enable universal access using hooks.

Let’s start by defining when users will be rewarded with these points:

1. When the user swaps `ETH` into `TOKEN` they will get awarded points equal to how much `ETH` they swapped the token with.
2. When the user adds liquidity, we award them with points equal to the amount of `ETH` they added.

In order to keep track of these points, we’ll mint the `POINTS` token to the user, this has an added benefit for the user to be able to track it in their wallet.

## Hook Design

Let’s figure out how our hook will work.

From the Uniswap v4 Documentation, there are several hooks available for developers to integrate with. In our use case, we specifically need the ability to read swaps and figure out what amounts they are swapping for and who they are.

For our hook, we’ll be using `afterSwap` and `afterAddLiquidity` hooks. Why these instead of the `before...` hooks? We’ll dig deeper into this later in this guide.

_Note: To initiate the swap in the first place, this is where [`UniversalRouter`](../../../../contracts/universal-router/01-overview.md) comes into play where we will pass in the [`V4_SWAP`](https://github.com/Uniswap/universal-router/blob/main/contracts/libraries/Commands.sol#L35) command to `UniversalRouter.execute`._

## Let’s create our hook!

We’ll call this hook `PointsHook` and create it in such a way that any pool paired with `TOKEN` can use it.

### Setting things up

The Uniswap [v4-template repo](https://github.com/uniswapfoundation/v4-template) provides a basic foundry environment with required imports already pre-loaded. Click on [`Use this template`](https://github.com/new?template_name=v4-template&template_owner=uniswapfoundation) to create a new repository with it.

Or simply clone it and install the dependencies:

```bash
git clone https://github.com/uniswapfoundation/v4-template.git
cd v4-template
# requires foundry
forge install
forge test
```

After that let's create a new contract `PointsHook.sol` in `src` folder with the following codes:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";

import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";

contract PointsHook is BaseHook {
    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions()
        public
        pure
        override
        returns (Hooks.Permissions memory)
    {
        return
            Hooks.Permissions({
                beforeInitialize: false,
                afterInitialize: false,
                beforeAddLiquidity: false,
                afterAddLiquidity: true,
                beforeRemoveLiquidity: false,
                afterRemoveLiquidity: false,
                beforeSwap: false,
                afterSwap: true,
                beforeDonate: false,
                afterDonate: false,
                beforeSwapReturnDelta: false,
                afterSwapReturnDelta: false,
                afterAddLiquidityReturnDelta: false,
                afterRemoveLiquidityReturnDelta: false
            });
    }
}
```

The above code does the following:

- import the relevant dependencies
- initialize the constructor by passing in the instance of PoolManager
- override `getHookPermissions` from `BaseHook.sol` to return a struct of permissions to signal which hook functions are to be implemented.
  It will also be used at deployment to validate the address correctly represents the expected permissions.

Awesome! Now it's all set to start building the hook!

### Basic Structure

So far, we’ve created the file named `PointsHook.sol` which only contains the outline of a hook contract. Let’s add our `afterSwap` and `afterAddLiquidity` hooks to it.

```solidity
contract PointsHook is BaseHook {
    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions()
        public
        pure
        override
        returns (Hooks.Permissions memory)
    {
        return
            Hooks.Permissions({
                beforeInitialize: false,
                afterInitialize: false,
                beforeAddLiquidity: false,
                afterAddLiquidity: true,
                beforeRemoveLiquidity: false,
                afterRemoveLiquidity: false,
                beforeSwap: false,
                afterSwap: true,
                beforeDonate: false,
                afterDonate: false,
                beforeSwapReturnDelta: false,
                afterSwapReturnDelta: false,
                afterAddLiquidityReturnDelta: false,
                afterRemoveLiquidityReturnDelta: false
            });
    }

    function _afterSwap(
        address,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata,
        BalanceDelta delta,
        bytes calldata
    ) internal override returns (bytes4, int128) {
        return (BaseHook.afterSwap.selector, 0);
    }

    function _afterAddLiquidity(
        address sender,
        PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata params,
        BalanceDelta delta,
        BalanceDelta feesAccrued,
        bytes calldata hookData
    ) internal override returns (bytes4, BalanceDelta) {
        return (BaseHook.afterAddLiquidity.selector, delta);
    }
}
```

You’ll notice that both hooks return their own selector in the functions, this is a pattern used by the protocol to signal “successful” invocation. We’ll talk about rest of the return parameters when we start adding the functionality.

Most of the code at this point should be self-explanatory. It’s not doing anything yet, but it’s a great place to start adding the functionality we need.

### Points Logic

First, let’s setup the `POINTS` token that we’ll reward users with via creating another contract `PointsToken.sol` and import relevant dependencies like `ERC20` and `Owned`.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Script.sol";
import {ERC20} from "solmate/src/tokens/ERC20.sol";
import {Owned} from "solmate/src/auth/Owned.sol";

contract PointsToken is ERC20, Owned {
    constructor() ERC20("Points Token", "POINTS", 18) Owned(msg.sender) {}

    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }
}
```

Let’s make it so that our hook can mint some!

```solidity
contract PointsHook is BaseHook {
    PointsToken public pointsToken;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {
        pointsToken = new PointsToken();
    }

    [...]
}
```

Next, we need to calculate how many points to assign based on the `ETH` value of the swap or liquidity action. We’ll be awarding `POINTS` in 1:1 ratio for the `ETH`, so if the user swapped 1 `ETH`, we’ll give them 1 `POINTS`. Let’s also create a function to award these to the user.

```solidity
    function getPointsForAmount(
        uint256 amount
    ) internal pure returns (uint256) {
        return amount; // 1:1 with ETH
    }

    function awardPoints(address to, uint256 amount) internal {
        pointsToken.mint(to, getPointsForAmount(amount));
    }
```

### Hook Logic

Now we need to actually get the value that the user is swapping or adding liquidity with. We’ll be using the two hooks to achieve that functionality.

#### Getting the user address

Before we go into the logic for the hook, we have a side quest! How do we actually get the address of the user? The `PositionManager` doesn’t pass the user address directly to the hook, mainly because of the complexity of getting that data in the first place.

You’d have noticed, both of our hooks have a `hookData` field at the end. This allows any arbitrary data to be passed to the hook at the time of invocation, and we’ll use this field to encode the user address.

Let’s create some helper functions to encode and decode this data:

```solidity
    function getHookData(address user) public pure returns (bytes memory) {
        return abi.encode(user);
    }

    function parseHookData(
        bytes calldata data
    ) public pure returns (address user) {
        return abi.decode(data, (address));
    }
```

#### Hook Logic: `afterSwap`

In order for us to award these points to the user, we need a few things and we also need to create a few conditions.

Let’s start with the most basic ones. We want the user to be swapping in the `ETH/TOKEN` pool and be buying the `TOKEN` in order to get awarded these `POINTS` token. Next, we need to figure out who the user is and how much ETH they are spending, and finally award the points accordingly.

```solidity
    function _afterSwap(
        address,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata swapParams,
        BalanceDelta delta,
        bytes calldata hookData
    ) internal override onlyPoolManager returns (bytes4, int128) {
        // We only award points in the ETH/TOKEN pools.
        if (!key.currency0.isAddressZero()) {
            return (BaseHook.afterSwap.selector, 0);
        }

        // We only award points if the user is buying the TOKEN
        if (!swapParams.zeroForOne) {
            return (BaseHook.afterSwap.selector, 0);
        }

        // Let's figure out who's the user
        address user = parseHookData(hookData);

        // How much ETH are they spending?
        uint256 ethSpendAmount = uint256(int256(-delta.amount0()));

        // And award the points!
        awardPoints(user, ethSpendAmount);

        return (BaseHook.afterSwap.selector, 0);
    }
```

That middle section about figuring out how much `ETH` the user spent seems a little fishy, what’s going on there? Let’s break it down.

When `amountSpecified` is less than 0, it means this is an `exact input for output` swap, essentially where the user is coming in with an exact amount of ETH. In the other case, it’s an `exact output for input` swap, where the user is expecting a specific amount out. In our case, we get this from the precalculated `delta` that Uniswap V4 gives us as a part of the `afterSwap` hook.

#### Hook Logic: `afterAddLiquidity`

Similar to what we did for the `afterSwap` hook, now we need to award users for adding liquidity. We’ll do the exact same thing here, except we’ll award the points based on the added liquidity.

```solidity
    function _afterAddLiquidity(
        address sender,
        PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata params,
        BalanceDelta delta,
        BalanceDelta feesAccrued,
        bytes calldata hookData
    ) internal override onlyPoolManager returns (bytes4, BalanceDelta) {
        // We only award points in the ETH/TOKEN pools.
        if (!key.currency0.isAddressZero()) {
            return (BaseHook.afterAddLiquidity.selector, delta);
        }

        // Let's figure out who's the user
        address user = parseHookData(hookData);

        // How much ETH are they spending?
        uint256 ethSpendAmount = uint256(int256(-delta.amount0()));

        // And award the points!
        awardPoints(user, ethSpendAmount);

        return (BaseHook.afterAddLiquidity.selector, delta);
    }
```

:::note
It is important to note that the delta should be passed to awardPoints function as it avoids amount errors in case of partial fills.
:::

## Testing

We’re using Foundry for building our hook, and we’ll continue using it to write our tests. One of the great things about Foundry is that you can write tests in Solidity itself instead of context switching between another language.

### Test Suite

The v4-template repo you cloned already has an existing base test file, let’s start by copying it into `PointsHook.t.sol`.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import {Fixtures} from "./utils/Fixtures.sol";
import {EasyPosm} from "./utils/EasyPosm.sol";

import {StateLibrary} from "v4-core/src/libraries/StateLibrary.sol";
import {Hooks, IHooks} from "v4-core/src/libraries/Hooks.sol";
import {PointsHook} from "../src/PointsHook.sol";
import {PointsToken} from "../src/PointsToken.sol";

import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId} from "v4-core/src/types/PoolId.sol";
import {Currency} from "v4-core/src/types/Currency.sol";
import {TickMath} from "v4-core/src/libraries/TickMath.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {LiquidityAmounts} from "v4-core/test/utils/LiquidityAmounts.sol";

contract PointsHookTest is Test, Fixtures {
    using EasyPosm for IPositionManager;
    using StateLibrary for IPoolManager;

    PointsHook hook;
    PointsToken pointsToken;
    PoolId poolId;

    uint256 tokenId;
    int24 tickLower;
    int24 tickUpper;

    function setUp() public {
        // creates the pool manager, utility routers, and test tokens
        deployFreshManagerAndRouters();
        deployMintAndApprove2Currencies();

        deployAndApprovePosm(manager);

        // Deploy the hook to an address with the correct flags
        address flags = address(
            uint160(Hooks.AFTER_SWAP_FLAG | Hooks.AFTER_ADD_LIQUIDITY_FLAG) ^
                (0x4444 << 144) // Namespace the hook to avoid collisions
        );
        bytes memory constructorArgs = abi.encode(manager); //Add all the necessary constructor arguments from the hook
        deployCodeTo("PointsHook.sol:PointsHook", constructorArgs, flags);
        hook = PointsHook(flags);
        pointsToken = hook.pointsToken();

        // Create the pool
        key = PoolKey(
            Currency.wrap(address(0)),
            currency1,
            3000,
            60,
            IHooks(hook)
        );
        poolId = key.toId();
        manager.initialize(key, SQRT_PRICE_1_1);

        // Provide full-range liquidity to the pool
        tickLower = TickMath.minUsableTick(key.tickSpacing);
        tickUpper = TickMath.maxUsableTick(key.tickSpacing);

        deal(address(this), 200 ether);

        (uint256 amount0, uint256 amount1) = LiquidityAmounts
            .getAmountsForLiquidity(
                SQRT_PRICE_1_1,
                TickMath.getSqrtPriceAtTick(tickLower),
                TickMath.getSqrtPriceAtTick(tickUpper),
                uint128(100e18)
            );

        (tokenId, ) = posm.mint(
            key,
            tickLower,
            tickUpper,
            100e18,
            amount0 + 1,
            amount1 + 1,
            address(this),
            block.timestamp,
            hook.getHookData(address(this))
        );
    }

    function test_PointsHook_Swap() public {
        // [code here]
    }
}
```

So far this test setup is fairly simple, we create a bunch of tokens and deploy v4 along with the position manager inside our test. Then, we create a pool with our hook and add some liquidity using the position manager.

Now, let’s write our test. We’ll start by testing the points awarded during the swap.

```solidity
    function test_PointsHook_Swap() public {
        // We already have some points because we added some liquidity during setup.
        // So, we'll subtract those from the total points to get the points awarded for this swap.
        uint256 startingPoints = pointsToken.balanceOf(address(this));

        // Let's swap some ETH for the token.
        bool zeroForOne = true;
        int256 amountSpecified = -1e18; // negative number indicates exact input swap!
        BalanceDelta swapDelta = swap(
            key,
            zeroForOne,
            amountSpecified,
            hook.getHookData(address(this))
        );

        uint256 endingPoints = pointsToken.balanceOf(address(this));

        // Let's make sure we got the right amount of points!
        assertEq(
            endingPoints - startingPoints,
            uint256(-amountSpecified),
            "Points awarded for swap should be 1:1 with ETH"
        );
    }
```

This test case is fairly straightforward and simply swaps 1 ETH for the target token and compares if we got the right amount of points awarded for it.

Next, we should test our liquidity addition.

```solidity
function test_PointsHook_Liquidity() public {
        // We already have some points because we added some liquidity during setup.
        // So, we'll subtract those from the total points to get the points awarded for this swap.
        uint256 startingPoints = pointsToken.balanceOf(address(this));

        uint128 liqToAdd = 100e18;

        (uint256 amount0, uint256 amount1) = LiquidityAmounts
            .getAmountsForLiquidity(
                SQRT_PRICE_1_1,
                TickMath.getSqrtPriceAtTick(tickLower),
                TickMath.getSqrtPriceAtTick(tickUpper),
                liqToAdd
            );

        posm.mint(
            key,
            tickLower,
            tickUpper,
            liqToAdd,
            amount0 + 1,
            amount1 + 1,
            address(this),
            block.timestamp,
            hook.getHookData(address(this))
        );

        uint256 endingPoints = pointsToken.balanceOf(address(this));

        // Let's make sure we got the right amount of points!
        assertApproxEqAbs(endingPoints - startingPoints, uint256(liqToAdd), 10);
    }
```

This test case looks very similar to the `afterSwap` one, except we’re testing based on the liquidity added. You’ll notice at the end we’re testing for approximate equality within 10 points. This is to account for minor differences in actual liquidity added due to ticks and pricing.

## Next Steps

Congratulations on building your very first hook! You could explore further by going to [Hook Deployment](./05-hook-deployment.mdx) to learn about how hook flags work and see how we will deploy a hook in action.
</file>

<file path="docs/contracts/v4/guides/_category_.json">
{
  "label": "Guides",
  "position": 5,
  "collapsed": true
}
</file>

<file path="docs/contracts/v4/guides/15-calculate-lp-fees.mdx">
---
title: Calculate LP fees
---

## Introduction

With hook introduced in v4, [Dynamic Fees](../concepts/07-dynamic-fees.mdx) is now possible and allow v4 pools to have a flexible and responsive fee structure comparing to v3 pools with static fee tiers(0.05%, 0.3%, 1%). 

While in v3 we can get the amount for the fees claimed on each liquidity operation in the `Collect` event, in v4 with dynamic fees, swap fees are directly accrued to liquidity positions and can be further handled by hooks at *`afterModifyLiquidity`* - thus we should not emit `feesAccrued` in the event `ModifiyLiquidity`. This not only saves gas on event emission but more importantly avoid causing confusion since the amount of `feesAccrued` could be changed as a result of hook execution.

```solidity
// Modify liquidity in v4
function modifyLiquidity(PoolKey memory key, IPoolManager.ModifyLiquidityParams memory params, bytes calldata hookData) 
    // ... 
    returns (BalanceDelta callerDelta, BalanceDelta feesAccrued) 
{
    PoolId id = key.toId();
    {
        // ... (other code)
        BalanceDelta principalDelta;
        (principalDelta, feesAccrued) = pool.modifyLiquidity(
            // ... (the ModifyLiquidityParams)
        );
        callerDelta = principalDelta + feesAccrued;
    }

    // event is emitted before the afterModifyLiquidity call to ensure events are always emitted in order
    emit ModifyLiquidity(id, msg.sender, params.tickLower, params.tickUpper, params.liquidityDelta, params.salt);

    BalanceDelta hookDelta;
    (callerDelta, hookDelta) = key.hooks.afterModifyLiquidity(key, params, callerDelta, feesAccrued, hookData);
    // ... (other code)
}
```

In this guide we will go through how you can calculate fees earned for a LP position in v4 specifically the **uncollected fees** and **total lifetime fees**.

## Contract Setup

Import the necessary dependencies and prepare the function signature for `getUncollectedFees` and `getLifetimeFees`.

```solidity
pragma solidity ^0.8.24;

import {FullMath} from "@uniswap/v4-core/src/libraries/FullMath.sol";
import {FixedPoint128} from "@uniswap/v4-core/src/libraries/FixedPoint128.sol";
import {Position} from "@uniswap/v4-core/src/libraries/Position.sol";
import {SafeCast} from "@uniswap/v4-core/src/libraries/SafeCast.sol";
import {IPoolManager} from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import {StateLibrary} from "@uniswap/v4-core/src/libraries/StateLibrary.sol";
import {BalanceDelta, toBalanceDelta} from "@uniswap/v4-core/src/types/BalanceDelta.sol";
import {PoolId} from "@uniswap/v4-core/src/types/PoolId.sol";
import {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";

import {IPositionManager} from "src/interfaces/IPositionManager.sol";
import {PositionConfig} from "src/types/PositionConfig.sol";

contract CalculateFeeExample {
    using SafeCast for uint256;
    using StateLibrary for IPoolManager;

    IPositionManager posm = IPositionManager(<POSM_ADDRESS>);
    IPoolManager manager = IPoolManager(<POOL_MANAGER_ADDRESS>);

    function getUncollectedFees(PositionConfig memory config, uint256 tokenId)
        external
        view
        returns (BalanceDelta uncollectedFees) {}

    function getLifetimeFees(PositionConfig memory config, uint256 tokenId)
        external
        view
        returns (BalanceDelta lifetimeFees) {}
}
```

### Calculate uncollected fees for a LP position

In `getUncollectedFees(PositionConfig config, uint256 tokenId)`:

1. Get the last recorded fee growth in `currency0` and `currency1` per unit of liquidity from `tickLower` to `tickUpper`
```solidity
PoolId poolId = config.poolKey.toId();

// getPositionInfo(poolId, owner, tL, tU, salt)
// owner is the position manager, salt is the tokenId
(uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128) =
    manager.getPositionInfo(poolId, address(posm), config.tickLower, config.tickUpper, bytes32(tokenId));
```

2. Get the all-time fee growth in `currency0` and `currency1` per unit of liquidity from `tickLower` to `tickUpper`
```solidity
(uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = 
    manager.getFeeGrowthInside(poolId, config.tickLower, config.tickUpper);
```

3. Compare the _all-time feeGrowthInside_ from step 2 against the _last recorded feeGrowthInside_ from step 1, and convert it to token amount
```solidity
uint128 tokenAmount =
    (FullMath.mulDiv(feeGrowthInsideX128 - feeGrowthInsideLastX128, liquidity, FixedPoint128.Q128)).toUint128();
```

### Calculate lifetime fees earned for a LP range

Create a new function `getLifetimeFee(PositionConfig config, uint256 tokenId)`:

1. Get the all-time fee growth in `currency0` and `currency1` per unit of liquidity from `tickLower` to `tickUpper`

```solidity
(uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = 
    manager.getFeeGrowthInside(poolId, config.tickLower, config.tickUpper);
```

2. Convert it to token amount

```solidity
uint128 tokenAmount =
    (FullMath.mulDiv(feeGrowthInsideX128, liquidity, FixedPoint128.Q128)).toUint128();
```

## Full Contract

```solidity
pragma solidity ^0.8.24;

import {FullMath} from "@uniswap/v4-core/src/libraries/FullMath.sol";
import {FixedPoint128} from "@uniswap/v4-core/src/libraries/FixedPoint128.sol";
import {Position} from "@uniswap/v4-core/src/libraries/Position.sol";
import {SafeCast} from "@uniswap/v4-core/src/libraries/SafeCast.sol";
import {IPoolManager} from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import {StateLibrary} from "@uniswap/v4-core/src/libraries/StateLibrary.sol";
import {BalanceDelta, toBalanceDelta} from "@uniswap/v4-core/src/types/BalanceDelta.sol";
import {PoolId} from "@uniswap/v4-core/src/types/PoolId.sol";
import {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";

import {IPositionManager} from "src/interfaces/IPositionManager.sol";
import {PositionConfig} from "src/types/PositionConfig.sol";

contract CalculateFeeExample {
    using SafeCast for uint256;
    using StateLibrary for IPoolManager;

    IPositionManager posm = IPositionManager(<POSM_ADDRESS>);
    IPoolManager manager = IPoolManager(<POOL_MANAGER_ADDRESS>);

    function getUncollectedFees(PositionConfig memory config, uint256 tokenId)
        external
        view
        returns (BalanceDelta uncollectedFees) {

        PoolId poolId = config.poolKey.toId();

        (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128) =
            manager.getPositionInfo(poolId, address(posm), config.tickLower, config.tickUpper, bytes32(tokenId));
        (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =
            manager.getFeeGrowthInside(poolId, config.tickLower, config.tickUpper);

        uncollectedFees = _convertFeesToBalanceDelta(
            feeGrowthInside0X128 - feeGrowthInside0LastX128, feeGrowthInside1X128 - feeGrowthInside1LastX128, liquidity);
    }

    function getLifetimeFees(PositionConfig memory config, uint256 tokenId)
        external
        view
        returns (BalanceDelta lifetimeFees) {

        PoolId poolId = config.poolKey.toId();

        (uint128 liquidity,,) = manager.getPositionInfo(poolId, address(posm), config.tickLower, config.tickUpper, bytes32(tokenId));
        (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =
            manager.getFeeGrowthInside(poolId, config.tickLower, config.tickUpper);

        lifetimeFees = _convertFeesToBalanceDelta(feeGrowthInside0X128, feeGrowthInside1X128, liquidity);
    }

    function _convertFeesToBalanceDelta(uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128, uint256 liquidity) 
        internal
        view 
        returns (BalanceDelta feesInBalanceDelta) {
            
        uint128 token0Amount = (FullMath.mulDiv(feeGrowthInside0X128, liquidity, FixedPoint128.Q128)).toUint128();
        uint128 token1Amount = (FullMath.mulDiv(feeGrowthInside1X128, liquidity, FixedPoint128.Q128)).toUint128();
        feesInBalanceDelta = toBalanceDelta(uint256(token0Amount).toInt128(), uint256(token1Amount).toInt128());
    }
}
```
</file>

<file path="docs/contracts/v4/guides/16-subscriber.mdx">
---
title: Subscriber
---

## Introduction

Uniswap v4 introduces Subscribers, a new mechanism in v4 that allows external contracts (aka Subscribers) to be notified by the PositionManager whenever specific events occur (e.g., liquidity changes, burns). It’s especially useful for designing **liquidity incentive** systems or reward programs.

Before diving into implementation details, let's understand what makes Subscribers valuable. When a position holder subscribes their position to a Subscriber contract, that contract receives notifications about various events: liquidity changes, position burns, and subscription status changes. This flow enables protocols to accurately track and reward liquidity provision.

Subscribers become of aware of the liquidity position, without needing to own the position and its underlying capital.

## Interface Methods

Let's explore each method that a [ISubscriber](https://github.com/Uniswap/v4-periphery/blob/main/src/interfaces/ISubscriber.sol) contract needs to implement. Understanding when and why these methods are called is crucial for building effective Subscriber contracts.

### Position Subscription Handling

The first two methods handle the subscription lifecycle:

```solidity
function notifySubscribe(
    uint256 tokenId,
    bytes memory data
) external;
```

This method is called whenever a position subscribes to your contract. The `tokenId` parameter identifies the subscribing position, while `data` can contain additional configuration information. 

For example, you might use this data parameter to specify:

- Lock-up duration for rewards
- Campaign-specific settings
- Custom reward parameters

> ***Note**: The data parameter is entirely optional and its interpretation is up to your implementation.*
> 

```solidity
function notifyUnsubscribe(
    uint256 tokenId
) external;
```

When a position unsubscribes, this method is called. There's an important consideration here:

> ***Important**: The gas consumption of this function must be less than unsubscribeGasLimit (set when deploying the PositionManager). This ensures users can always unsubscribe from your contract.

Also note that the subscriber contract reverts, the position will still unsuccessfully subscribe*
> 

### Position Modification Notifications

The next method handles liquidity changes and fee collection:

```solidity
function notifyModifyLiquidity(
    uint256 tokenId,
    int256 liquidityChange,
    BalanceDelta feesAccrued
) external;
```

This method is your window into position activity. It gets called in two scenarios:

- When users modify their liquidity (increase or decrease)
- When they collect accumulated fees

Here's what each parameter tells you:

- `tokenId`: The position being modified
- `liquidityChange`: How much liquidity is being added or removed (positive for additions, negative for removals)
- `feesAccrued`: Fees collected during this operation

> ***Warning**: Be cautious with feesAccrued values. In pools with a single liquidity position, malicious users can artificially inflate these values through self-donations.*
> 

### Handling Position Burns

The final method deals with position termination:

```solidity
function notifyBurn(
    uint256 tokenId,
    address owner,
    PositionInfo info,
    uint256 liquidity,
    BalanceDelta feesAccrued
) external;

```

When a position is burned (fully removed), this method provides comprehensive information about its final state:

- Who owned it (`owner`)
- Its configuration (`info`)
- How much liquidity was removed (`liquidity`)
- Any final fees collected (`feesAccrued`)

> ***Important**: When a position is burned, you'll only receive notifyBurn - there's no separate notifyModifyLiquidity call.*
> 

## How to Use Subscribers

Let's walk through the process of implementing and using a Subscriber contract. We'll break this down into four main steps that developers typically follow.

### Step 1: Implement Subscriber

First, create your contract implementing the ISubscriber interface:

```solidity

contract MySubscriber is ISubscriber {
    // Track subscribed positions
    mapping(uint256 => bool) public isSubscribed;

    // Implementation of interface methods
    function notifySubscribe(uint256 tokenId, bytes memory data) external {
        // Store subscription status
        isSubscribed[tokenId] = true;
    }

    // Other required methods...
}
```

> ***Note**: This is a basic implementation. Your actual contract will need more sophisticated tracking depending on your reward mechanism.*
> 

### Step 2: Deploy Subscriber

Once implemented, deploy your contract:

```solidity
MySubscriber subscriber = new MySubscriber();
```

Make sure to store the deployed address - users will need it to subscribe their positions.

### Step 3: Mint Position

Users need positions before they can subscribe. They can either use existing positions or mint new ones:

```solidity
// Using the Position Manager
uint256 tokenId = positionManager.mint(
    poolKey,
    tickLower,
    tickUpper,
    liquidity,
    // other parameters...
);
```

### Step 4: Subscribe Position

Finally, users can subscribe their positions to your contract:

```solidity
// Optional configuration data
bytes memory subscriptionData = ""; // Configure based on your needs

// Subscribe the position
positionManager.subscribe(
    tokenId,
    subscriber,
    subscriptionData
);
```

> ***Important**: Make sure users understand any lock-up periods or conditions specified in your subscriptionData.*
> 

### Important Considerations

When implementing and deploying Subscriber contracts, there are several crucial aspects to keep in mind. Let's explore each of these to ensure your implementation is secure and efficient.

### Gas Limits and Unsubscribe Safety

The most critical consideration is the unsubscribe process:

> ***Critical**: Your notifyUnsubscribe function must consume less gas than the unsubscribeGasLimit defined in the PositionManager. This is not just a best practice - it's a fundamental safety requirement that ensures users can always exit your system.*
> 

For example:

```solidity
function notifyUnsubscribe(uint256 tokenId) external {
    // Keep this function lightweight
    delete positionData[tokenId]; // Simple state cleanup
    emit PositionUnsubscribed(tokenId);
}
```

## Implementation Patterns

When building your Subscriber, follow these established patterns:

### Liquidity Tracking

It's essential to properly track liquidity changes:

- Use `notifyModifyLiquidity` to update your internal accounting
- Remember that positive changes mean liquidity is being added
- Account for negative changes when liquidity is removed

> ***Note**: During a position burn, you'll only receive notifyBurn - there won't be a separate notifyModifyLiquidity call.*
> 

### Optional Data Handling

The `optionalData` parameter in subscriptions can be used for:

- Additional campaign configuration
- Lock-up duration specifications
- Other custom parameters

## Security Considerations

Since Subscriber contracts often handle value distribution, security is paramount:

### Value Distribution

- **Custody**: Implement secure mechanisms for handling reward tokens
- **Calculation**: Ensure reward calculations are accurate and cannot be manipulated

### Protection Against Exploitation

Be aware of potential attack vectors:

- Users can artificially inflate `feesAccrued` in single-position pools
- Malicious actors might attempt to claim rewards they haven't earned

> ***Warning**: Always validate inputs and implement thorough checks before distributing any value.*
> 

## Implementation Example

Let’s build a **minimal** Subscriber implementation that demonstrates how to handle position events. In practice, you’d likely extend these concepts to include reward calculations or more complex accounting.

> ***Note**: The code below focuses on the essential mechanics of receiving notifications. A production system will need additional logic for security, reward distribution, and user interaction.*
> 

### Basic Reward Tracking

First, we set up our contract with the necessary data structures and references:

```solidity
contract LiquidityRewardsSubscriber is ISubscriber {
    // 1) Store subscription timestamps and liquidity for each position
    struct PositionData {
        uint256 subscriptionTime;
        uint256 currentLiquidity;
        bool isSubscribed;
    }

    // 2) A mapping from tokenId (position NFT) to our custom tracking data
    mapping(uint256 => PositionData) public positions;

    // 3) Reference to the PositionManager so we can authenticate notifications
    IPositionManager public immutable positionManager;

    constructor(IPositionManager _positionManager) {
        positionManager = _positionManager;
    }
}

```

### Why This Matters

- **`PositionData`**: Tracks how long the position has been subscribed (`subscriptionTime`), how much liquidity it currently has (`currentLiquidity`), and whether it’s active (`isSubscribed`).
- **`positionManager`**: We only trust calls from this authorized contract, preventing anyone else from triggering notifications.

## Handling Subscription Events

Next, we implement `notifySubscribe` and `notifyUnsubscribe` to manage a position’s subscription status:

```solidity
		/// @notice Handle new position subscriptions
		function notifySubscribe(
		    uint256 tokenId,
		    bytes memory /* data */
		) external {
		    require(msg.sender == address(positionManager), "Unauthorized");
		
		    positions[tokenId] = PositionData({
		        subscriptionTime: block.timestamp,
		        currentLiquidity: 0,
		        isSubscribed: true
		    });
		}
		
		/// @notice Clean up on unsubscribe
		/// @dev Keep this minimal to respect unsubscribeGasLimit
		function notifyUnsubscribe(uint256 tokenId) external {
		    require(msg.sender == address(positionManager), "Unauthorized");
		
		    // Remove all stored data for unsubscribed positions
		    delete positions[tokenId];
		}
```

### Key Takeaways

- We store the current block timestamp on `notifySubscribe` to measure how long a position has been subscribed.
- The `notifyUnsubscribe` method is deliberately small to ensure it remains below the `unsubscribeGasLimit`.

## Listening for Liquidity Modifications

Positions can add or remove liquidity, and potentially collect fees during the same transaction:

```solidity
/// @notice Track liquidity changes or fee collections
function notifyModifyLiquidity(
    uint256 tokenId,
    int256 liquidityChange,
    BalanceDelta /* feesAccrued */
) external {
    require(msg.sender == address(positionManager), "Unauthorized");

    PositionData storage position = positions[tokenId];

    if (liquidityChange > 0) {
        // Positive value indicates added liquidity
        position.currentLiquidity += uint256(liquidityChange);
    } else if (liquidityChange < 0) {
        // Negative value indicates removed liquidity
        position.currentLiquidity -= uint256(-liquidityChange);
    }
}
```

### Why This Is Important

- **`liquidityChange`** can be positive (liquidity added) or negative (liquidity removed). We update our internal tracking accordingly.
- **`feesAccrued`** is provided if the user also collects fees during this action. In a more advanced version, you could track these fees for reward calculations.

## Processing Position Burns

When a position is completely removed (burned), Uniswap v4 calls `notifyBurn`:

```solidity
/// @notice Called when a position is fully removed
function notifyBurn(
    uint256 tokenId,
    address,
    PositionInfo,
    uint256,
    BalanceDelta
) external {
    require(msg.sender == address(positionManager), "Unauthorized");

    // The position no longer exists, so remove our records
    delete positions[tokenId];
}
```

### Important Distinction

- **No `notifyModifyLiquidity`** is triggered on a full burn—`notifyBurn` covers any final liquidity/fee changes.

## Using the Subscriber

To put this into practice:

```solidity
// 1. Deploy the subscriber
LiquidityRewardsSubscriber subscriber = new LiquidityRewardsSubscriber(positionManager);

// 2. Users then subscribe their positions
positionManager.subscribe(tokenId, subscriber, "");

```

- **Deployment**: The developer deploying the Subscriber contract must store its address and share it with users.
- **Subscription**: Users call `subscribe(...)` on the PositionManager, passing in the `tokenId` and the subscriber’s address (yours).

## Production Considerations

> This example is deliberately minimal. A real-world Subscriber would need:
> 
> - **Reward Distribution**: Logic that calculates and distributes incentives based on `subscriptionTime`, `currentLiquidity`, or `feesAccrued`.
> - **Security Checks**: Safeguards against malicious actors who might inflate fees, manipulate liquidity changes, or spam subscribe/unsubscribe cycles.
> - **Access Control**: Roles or permissions if only certain addresses are allowed to manage rewards or update parameters.
> - **Gas Optimization**: Especially if you expect many positions to subscribe/unsubscribe frequently.
</file>

<file path="docs/contracts/v4/guides/accessing-msg.sender-using-hook.mdx">
---
title: Access msg.sender Inside a Hook
sidebar_position: 9
---

In Uniswap v4, when a hook is triggered, `msg.sender` is always the PoolManager contract, not the EOA or smart-account that initiated the swap. This behavior occurs because the PoolManager acts as an intermediary, executing the swap logic on behalf of the user.

## Securely Retrieving the Original `msg.sender` address in a Hook
Since a smart contract executes the swap, the `sender` parameter passed to `beforeSwap()` represents the caller of `PoolManager.swap()`.

This is typically a router contract, such as a custom swap router or the Universal Router. The challenge is distinguishing between different routers and securely obtaining the original msg.sender. 

This guide explains how to securely retrieve the EOA or smart account in a hook.

## Hook Overview
To identify the true sender of a swap:

* Maintain a trusted list of swap routers in the hook.
* When a swap is initiated, check if the sender is a trusted router.
* If trusted, call `msgSender()` view function on the router to retrieve the original EOA.

# Implementing a Trusted Router Mechanism

## Implement the Hook
Lets start with a simple hook that wants to access `msg.sender` in `beforeSwap()`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// Import statements for a hook

contract AccessSenderHook is BaseHook {
    // constructor, state, interface, etc
    // ...

    function _beforeSwap(address sender, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)
        internal
        override
        returns (bytes4, BeforeSwapDelta, uint24)
    {
        // read msg.sender
        // ...

        return (BaseHook.beforeSwap.selector, BeforeSwapDelta.wrap(0), 0);
    }

    ...
}
```

> [Refer to Building your first hook](https://docs.uniswap.org/contracts/v4/guides/hooks/your-first-hook#setting-things-up)

## Define an Interface for Trusted Routers
Each trusted router should implement a standard function that exposes the original ```msg.sender```

```solidity
interface IMsgSender {
    function msgSender() external view returns (address);
}
```
This function allows hooks to query the router for the actual sender.

## Store a List of Trusted Routers
The hook should keep track of which router contracts can be trusted to return a valid ```msgSender()```

This can be done with the help of add and remove functions implemented in the hook.

```
mapping(address swapRouter => bool approved) public verifiedRouters;
```

:::note
Make sure you include an address mapping in your hook for the routers before adding the functions.
:::

```solidity
function addRouter(address _router) external {
    verifiedRouters[_router] = true;
    console.log("Router added:", _router);
}
```

This function allows hook to add the router to the list of trusted routers.

```solidity
function removeRouter(address _router) external {
    verifiedRouters[_router] = false;
    console.log("Router removed:", _router);
}
```

This function allows the hook to remove the router from the list of trusted routers if it's no longer needed.

## Implementing `beforeSwap`

Now that we have implemented a basic hook and have added necessary functions, let us implement the beforeSwap function:

```solidity
function _beforeSwap(address sender, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)
    internal
    override
    returns (bytes4, BeforeSwapDelta, uint24)
{
    try IMsgSender(sender).msgSender() returns (address swapper) {
        console.log("Swap initiated by account:", swapper);
    } catch {
        revert("Router does not implement msgSender()");
    }

    return (BaseHook.beforeSwap.selector, BeforeSwapDelta.wrap(0), 0);
}
```

:::note
While developing, make sure that you verify the contracts are valid before adding them to the list of trusted routers.
:::


> **Here are some examples of trusted routers:**
 * https://github.com/Uniswap/universal-router/tree/main
 * https://github.com/z0r0z/v4-router

**Here is the full working code sample:**

```solidity=
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";

import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";
import "forge-std/console.sol";

interface IMsgSender {
    function msgSender() external view returns (address);
}

contract AccessSenderHook is BaseHook {

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {
    }

    function _beforeSwap(
        address sender,
        PoolKey calldata,
        IPoolManager.SwapParams calldata,
        bytes calldata
    ) internal override returns (bytes4, BeforeSwapDelta, uint24) {

        try IMsgSender(sender).msgSender() returns (address swapper) {
            console.log("Swap initiated by account:", swapper);
        } catch {
            revert("Router does not implement msgSender()");
        }

        return (BaseHook.beforeSwap.selector, BeforeSwapDelta.wrap(0), 0);
    }

    function getHookPermissions()
        public
        pure
        override
        returns (Hooks.Permissions memory)
    {
        return
            Hooks.Permissions({
                beforeInitialize: false,
                afterInitialize: false,
                beforeAddLiquidity: false,
                afterAddLiquidity: false,
                beforeRemoveLiquidity: false,
                afterRemoveLiquidity: false,
                beforeSwap: true,
                afterSwap: false,
                beforeDonate: false,
                afterDonate: false,
                beforeSwapReturnDelta: false,
                afterSwapReturnDelta: false,
                afterAddLiquidityReturnDelta: false,
                afterRemoveLiquidityReturnDelta: false
            });
    }
    
}
```
</file>

<file path="docs/contracts/v4/guides/custom-accounting.mdx">
---
title: Custom Accounting
sidebar_position: 3
---

## Introduction
Uniswap v4 introduces a set of powerful, interconnected features that proposes a new way automated market makers (AMMs) can function. Custom accounting, hook fees, custom curves, and return deltas might seem like distinct concepts, but they form a cohesive system that enables unprecedented flexibility in decentralized exchange mechanisms.

These features are grouped together because they collectively represent the core of Uniswap v4’s customizability. They all relate to how pool state is managed and modified, working in tandem to allow developers to create highly tailored AMM experiences. From dynamic fee structures to unique bonding curves.

## Brief Overview of Concepts

Before we dive into the details of custom accounting, hook fees, custom curves, and return deltas, let’s explore how these features work in Uniswap v4.

### Delta Accounting in v4

As described in [Flash Accounting](/contracts/v4/concepts/flash-accounting) Uniswap v4 tracks net token transfers with transient storage. Unlike previous versions that tracked absolute token balances, v4 records changes to these balances (*deltas*). This approach is at the core of v4’s enhanced flexibility and efficiency.

In the v4 architecture, the [`PoolManager`](/contracts/v4/concepts/PoolManager) manages credits or debits per address. After a swap router contract interacts with the PoolManager, the core contract determines that the swap router owes input tokens and must claim output tokens. Token balances are tracked as accumulated deltas in transient storage; and only the final deltas incur token transfers

Delta accounting provides several key benefits:

1. More efficient state management, especially for complex operations involving multiple steps.
2. Easier integration with hooks, allowing for custom logic to be applied to state changes.
3. Improved gas efficiency for many operations, as it reduces the number of storage writes.

This system forms the foundation upon which other v4 features, such as hook fees and custom curves, are built. It allows for more complex pool behaviors while maintaining efficiency and flexibility.

### Hook Fees in v4

Hook fees are a feature in Uniswap v4 that allow hook developers to monetize their hooks or implement custom value distribution mechanisms. Unlike pool fees or dynamic fees, hook fees are entirely separate and are implemented through custom logic in the hook itself.

Key characteristics of hook fees in Uniswap v4:

**Separate from Pool Fees**

Hook fees are distinct from the standard pool fees. They can be implemented alongside pool fees without interfering with the core fee structure.

**Implemented in beforeSwap**

Hook fees are typically calculated and applied in the `beforeSwap` function, allowing them to modify the swap parameters before the core swap logic is executed.

**Use of BeforeSwapDelta**

Hook fees often utilize the [`BeforeSwapDelta`](/contracts/v4/reference/core/types/beforeswapdelta) mechanism to adjust swap amounts and transfer deltas from the hook to the swap router, enabling precise control over how the fee affects the swap.

**Flexible Implementation**

Developers have full control over how hook fees are calculated, collected, and distributed. This allows for complex fee structures tailored to specific use cases. In other words, developers can implement static fees, percentage-based fees, or even a fee that changes.

**Potential Use Cases**

- Monetization of hook development
- Implementation of withdrawal penalties (e.g., to penalize just-in-time liquidity provision)
- Custom value distribution for liquidity providers

Keep reading because at the bottom we are providing a step by step guide on how to implement hook fees.

### Custom Curves in v4

Custom Curves in Uniswap v4 represent a big change in AMM design flexibility. Unlike [Uniswap v2](/contracts/v2/concepts/protocol-overview/how-uniswap-works) where the x*y=k formula was hardcoded, v4 allows developers to implement a wide variety of pricing models.

This is made possible through the hook system, particularly hooks that can interact with the swap process. Custom curves allow developers to eject the native concentrated liquidity pricing mechanism. These hooks can intercept swap requests, apply custom pricing logic, and return modified swap parameters. This enables the creation of pools with unique characteristics, such as:

- Stable asset pairs with minimal price impact
- Curves for special token types like rebasing tokens, RWAs, vault tokens

For example, creating a custom curve for a stable swap pool would involve designing a pricing function that maintains tighter price ranges when assets are near parity. This could be achieved by implementing a curve that's flatter in the middle (where assets are at their expected 1:1 ratio) and steeper at the edges (to discourage large imbalances).

This type of custom curve could significantly improve capital efficiency for stable asset pairs, reducing slippage for traders and potentially attracting more liquidity to the pool. It showcases how Uniswap v4's flexible architecture allows for tailored solutions to specific trading scenarios, opening up new possibilities in decentralized exchange design.

### Return Deltas in v4

Return deltas are a fundamental mechanism in Uniswap v4's custom accounting system. They allow for precise, programmatic adjustments to the outcomes of operations within the protocol.

Key aspects of return deltas:

1. **Dual Adjustment**: Return deltas simultaneously modify the balance changes (deltas) for both the hook contract and the swap router. This dual nature ensures that custom logic is accurately reflected across the entire system.
2. **Credits and Debts Modification**: By adjusting these deltas, return deltas effectively alter the credits and debts owed by the hook and the swap router. This allows for complex economic models to be implemented directly within the protocol.
3. **Native Pricing Bypass**: Return deltas enable hooks to implement custom curves that can completely bypass Uniswap's native pricing mechanism. This opens up possibilities for entirely new types of automated market makers within the Uniswap ecosystem.
4. **Hook Fee Implementation**: Through return deltas, hooks can implement their own fee structures, separate from the core protocol fees.

In essence, return deltas allow for bespoke modification of an operation's result -- enabling features that were previously impossible in earlier versions of the protocol.

## Implementing Hook Fees: A Step-by-Step Guide

In this guide, we'll walk through the process of implementing a custom fee hook in Uniswap v4. We'll not only show you how to write the code but also explain what's happening under the hood at each step.

### Step 1: Setting Up the Hook

First, let's create our basic hook structure:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";
import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {Currency} from "v4-core/src/types/Currency.sol";
import {BeforeSwapDelta, toBeforeSwapDelta} from "v4-core/src/types/BeforeSwapDelta.sol";

contract HookFeeExample is BaseHook {
    uint256 public constant HOOK_FEE_PERCENTAGE = 10;// 0.01% fee
    uint256 public constant FEE_DENOMINATOR = 100000;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: false,
            beforeRemoveLiquidity: false,
            afterAddLiquidity: false,
            afterRemoveLiquidity: false,
            beforeSwap: true,
            afterSwap: false,
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: true,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }
}

```

Here, we're setting up our hook with a constant fee of 0.01% and enabling the `beforeSwap` and `beforeSwapReturnDelta` permissions.

### Step 2: Implementing the beforeSwap Function

Now, let's implement our `beforeSwap` function:

```solidity
function _beforeSwap(
    address,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    bytes calldata
) internal override returns (bytes4, BeforeSwapDelta, uint24) {
    // Implementation details will be explained in the following sub-steps
}

```

#### Step 2.1: Calculate the swap amount and fee

We determine the absolute swap amount and calculate our fee based on it.

```solidity
uint256 swapAmount = params.amountSpecified < 0
    ? uint256(-params.amountSpecified)
    : uint256(params.amountSpecified);
uint256 feeAmount = (swapAmount * HOOK_FEE_PERCENTAGE) / FEE_DENOMINATOR;

```

#### Step 2.2: Collect the fee

We use `poolManager.take` to collect the fee. This creates a debt for our hook in the specified currency.

```solidity
Currency feeCurrency;

feeCurrency = params.amountSpecified < 0 == params.zeroForOne ? key.currency0 : key.currency1;

poolManager.take(feeCurrency, address(this), feeAmount);

```

:::note
> Using `poolManager.take()` requires an ERC20 balance on the PoolManager, i.e. via other liquidity pools. If the `.take()` amount exceeds the ERC20 balance, the code will revert. As a workaround, use either:
>1. `poolManager.mint()` to obtain ERC6909, which are also more gas efficient
>2. A custom swap router, where input tokens are transferred to PoolManager before the router calls `poolManager.swap()`
:::

#### Step 2.3: Create the BeforeSwapDelta

This is where the magic happens. We create a `BeforeSwapDelta` that represents our fee. The `toBeforeSwapDelta` function takes two parameters:

- The specified delta: This is our fee amount. It's positive because we're adding it to the hook's balance.
- The unspecified delta: We set this to 0 as we're not affecting the other currency.

```solidity
BeforeSwapDelta returnDelta = toBeforeSwapDelta(
    int128(int256(feeAmount)), // Specified delta (fee amount)
    0 // Unspecified delta (no change)
);

```

#### Step 2.4: Return values

We return the function selector, our `returnDelta`, and 0 for the fee override.

```solidity
return (BaseHook.beforeSwap.selector, returnDelta, 0);
```

### Step 3: Understanding the BeforeSwapDelta Mechanism

Now, let's dive deeper into how the `BeforeSwapDelta` works and how it affects the overall swap process.

1. **Initial State**:
Let's say a user wants to swap 100 USDC for USDT
    - Hook's delta: (0, 0)
    - User's swap request: -100 USDC (negative because they're selling)
    
2. **After Hook Execution**:
Our hook has taken a 1 USDC fee (assuming 1% for simplicity):
    - Hook's delta: (-1 USDC, 0) // The hook now owes 1 USDC to the pool
    - BeforeSwapDelta returned: (1 USDC, 0) // This will be added to the hook's delta and subtracted from the swap delta
    
3. **PoolManager Processing**:
The PoolManager applies our `BeforeSwapDelta`
The pool then swaps 99 USDC for, let's say, 98 USDT.
    
```solidity
amountToSwap = params.amountSpecified + hookDelta.getSpecifiedDelta();
-99 USDC = -100 USDC + 1 USDC
```
    
4. **Delta Resolution**:
The PoolManager then resolves the deltas:
    
```solidity
// Hook's new delta
newHookDelta = oldHookDelta + returnDelta
(0, 0) = (-1 USDC, 0) + (1 USDC, 0)

// Swap delta for router
swapDelta = (-99 USDC, 98 USDT) - (1 USDC, 0)
            = (-100 USDC, 98 USDT)
```
    
5. **Final Outcome**:
    - The hook's debt is cleared: It took 1 USDC as a fee, but "returned" it to the swap process.
    - The router (on behalf of the user) must pay 100 USDC (original amount including fee) and receives 98 USDT.

This process demonstrates how `BeforeSwapDelta` effectively "transfers" the hook's outstanding delta to the swap router, ensuring that the user pays the fee while the hook collects it, all within a single atomic transaction.

## Alternative: Charging Hook Fees in afterSwap

Charging hook fees in `afterSwap` is different from charging them in `beforeSwap` because `afterSwap` allows the hook to compute a fee on the actual output and collect it.
This is best used in case of partial swaps, as `afterSwap` charges a fee on the **actual output** observed from `BalanceDelta` without overcharging the user.

### When to prefer afterSwap?
- You want fees to reflect **what actually transferred** (not the requested amount).
- Your swaps frequently **hit price limits** or **liquidity ceilings**.

### Step 1: Setting the permission flags

Enable `afterSwap` and `afterSwapReturnDelta` permissions in the hook:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";
import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {Currency} from "v4-core/src/types/Currency.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {SwapParams} from "v4-core/src/types/PoolOperation.sol";

contract HookFeeAfterSwap is BaseHook {
    uint256 public constant HOOK_FEE_PERCENTAGE = 10;
    uint256 public constant FEE_DENOMINATOR     = 100_000;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
    return Hooks.Permissions({
        beforeInitialize: false,
        afterInitialize: false,
        beforeAddLiquidity: false,
        beforeRemoveLiquidity: false,
        afterAddLiquidity: false,
        afterRemoveLiquidity: false,
        beforeSwap: false,
        afterSwap: true,
        beforeDonate: false,
        afterDonate: false,
        beforeSwapReturnDelta: false,
        afterSwapReturnDelta: true,
        afterAddLiquidityReturnDelta: false,
        afterRemoveLiquidityReturnDelta: false
    });
}
}
```

### Step 2: Implementing `afterSwap` function:

In afterSwap, you do not build a BeforeSwapDelta. Instead, we read actual output from **BalanceDelta** and compute fee on that amount.

:::tip Unspecified currency (afterSwap)
The `int128` you return is for the **unspecified currency**. Map it like this:

- **exactIn** → unspecified = **output** token → take the fee in **output**; user receives less output.
- **exactOut** → unspecified = **input** token  → take the fee in **input**; user must pay more input.
:::

```solidity
function _afterSwap(
        address,
        PoolKey calldata key,
        SwapParams calldata params,
        BalanceDelta delta,
        bytes calldata
    ) internal override returns (bytes4, int128) {
        bool outputIsToken0 = params.zeroForOne ? false : true;

        int256 outputAmount = outputIsToken0 ? delta.amount0() : delta.amount1();
        if (outputAmount <= 0) {
            return (BaseHook.afterSwap.selector, 0);
        }

        uint256 feeAmount = (uint256(outputAmount) * HOOK_FEE_PERCENTAGE) / FEE_DENOMINATOR;

        require(feeAmount <= ((uint256(1) << 127) - 1), "fee too large");

        bool isExactIn = (params.amountSpecified < 0);

        Currency feeCurrency;
        if (isExactIn) {
            feeCurrency = outputIsToken0 ? key.currency0 : key.currency1;
        } else {
            bool inputIsToken0 = params.zeroForOne ? true : false;
            feeCurrency = inputIsToken0 ? key.currency0 : key.currency1;
        }

        poolManager.take(feeCurrency, address(this), feeAmount);

        return (BaseHook.afterSwap.selector, int128(int256(feeAmount)));
```

### Complete afterSwap contract:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";
import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {Currency} from "v4-core/src/types/Currency.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {SwapParams} from "v4-core/src/types/PoolOperation.sol";

contract HookFeeAfterSwap is BaseHook {
    uint256 public constant HOOK_FEE_PERCENTAGE = 10;
    uint256 public constant FEE_DENOMINATOR     = 100_000;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: false,
            beforeRemoveLiquidity: false,
            afterAddLiquidity: false,
            afterRemoveLiquidity: false,
            beforeSwap: false,
            afterSwap: true,
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: false,
            afterSwapReturnDelta: true,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    function _afterSwap(
        address ,
        PoolKey calldata key,
        SwapParams calldata params,
        BalanceDelta delta,
        bytes calldata
    ) internal override returns (bytes4, int128) {
        bool outputIsToken0 = params.zeroForOne ? false : true;

        int256 outputAmount = outputIsToken0 ? delta.amount0() : delta.amount1();
        if (outputAmount <= 0) {
            return (BaseHook.afterSwap.selector, 0);
        }

        uint256 feeAmount = (uint256(outputAmount) * HOOK_FEE_PERCENTAGE) / FEE_DENOMINATOR;

        require(feeAmount <= ((uint256(1) << 127) - 1), "fee too large");

        bool isExactIn = (params.amountSpecified < 0);

        Currency feeCurrency;
        if (isExactIn) {
            feeCurrency = outputIsToken0 ? key.currency0 : key.currency1;
        } else {
            bool inputIsToken0 = params.zeroForOne ? true : false;
            feeCurrency = inputIsToken0 ? key.currency0 : key.currency1;
        }

        poolManager.take(feeCurrency, address(this), feeAmount);

        return (BaseHook.afterSwap.selector, int128(int256(feeAmount)));
    }
}
```

## Conclusion

By implementing hook fees this way, we've leveraged Uniswap v4's delta accounting system to create a seamless fee collection mechanism. This approach allows for complex fee structures and behaviors without disrupting the core swap process or requiring separate fee transfers.
</file>

<file path="docs/contracts/v4/guides/ERC-6909.mdx">
---
title: ERC-6909
sidebar_position: 5
---

## Introduction

Uniswap v4 uses [ERC-6909](/contracts/v4/concepts/erc6909), a token standard that works alongside the protocol’s flash accounting system. This guide explains how ERC-6909 functions within v4, when to use mint versus burn operations, and how developers can implement them effectively.

## What is ERC-6909?

ERC-6909 is a token standard that enables efficient token management within a single contract through multiple token balances per user. Where ERC-20 requires separate approve and transfer calls for token interactions, ERC-6909 provides native support for multi-token operations through mint/burn mechanics that integrate with v4’s flash accounting system.

Here’s how the approaches differ:

```solidity
// Traditional ERC-20 approach
IERC20(tokenA).transferFrom(owner, poolManager, amount);

// ERC-6909 approach in v4
poolManager.burn(owner, currency.toId(), amount);
```

### Integration with Flash Accounting

While flash accounting tracks balance changes as deltas throughout a transaction, ERC-6909 provides an additional primitive to resolve  deltas. 

This enables:

1. Simplified transaction flows through direct mint/burn operations
2. Efficient handling of multi-step operations
3. Streamlined token management when using the PoolManager

### Gas Efficiency

ERC-6909 provides gas savings compared to ERC-20 tokens, making it particularly valuable for use cases requiring frequent token transfers like:

- Day trading operations
- MEV bot transactions
- Active liquidity management

This efficiency is especially beneficial when performing multiple token operations in rapid succession.

### Simplified Token Management

The traditional ERC-20 workflow requires careful management of allowances and transfers, often leading to complex transaction sequences and potential security concerns.

ERC-6909 takes a different approach by providing direct balance modifications through mint and burn operations.

By working through the PoolManager, all token operations are consolidated into a single interface. This means you don’t need to worry about managing multiple token approvals or keeping track of allowances across different contracts. Instead, you can focus on the core logic of your application while the PoolManager handles the token management aspects.

## Understanding ERC-6909 in v4

Let's explore how ERC-6909 is used across different v4 operations and understand when to use each of its operations.

### Operations and Token Movement

Different pool operations create different types of deltas that need to be resolved:

- **Swaps**: Create negative deltas for input tokens and positive deltas for output tokens
- **Adding Liquidity**: Creates negative deltas (tokens you need to provide)
- **Removing Liquidity**: Creates positive deltas (tokens you receive)
- **Donations**: Creates negative deltas (tokens you're donating)

### Using Mint and Burn

The choice between mint and burn operations depends on your token movement needs:

```solidity
// When you have positive deltas (withdrawing value from PoolManager):
poolManager.mint(currency, address(this), amount);

// When you have negative deltas (transferring value to PoolManager):
poolManager.burn(currency, address(this), amount);
```

This pattern is used throughout v4's operations:

- Use mint when withdrawing value from the pool (like receiving tokens from swaps)
- Use burn when transferring value to the pool (like providing tokens)

### Hook Integration

When building hooks, ERC-6909 operations help manage token movements within your hook's logic:

```solidity
function _beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params)
    internal
    returns (bytes4, BeforeSwapDelta, uint24)
{
    poolManager.mint(key.currency0, address(this), amount);
    
    return (
      BaseHook.beforeSwap.selector,
      BeforeSwapDeltaLibrary.ZERO_DELTA,
      0
    );
}
```

Other common cases would be to use `mint` for fee collection or `burn` for token distribution.

## Implementation

Let's build a contract that handles donations in v4 using ERC-6909. We'll create a donation router that follows this flow:

1. Users call our donation function with their desired amounts
2. Our contract packages this data and uses the PoolManager's unlock pattern
3. In the callback, we unpack the data and execute the donation, handling token movements using ERC-6909

First, let's set up our contract with the necessary imports and create a struct to help us pass data between functions:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import { IPoolManager } from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import { PoolKey } from "@uniswap/v4-core/src/types/PoolKey.sol";
import { BalanceDelta } from "@uniswap/v4-core/src/types/BalanceDelta.sol";
import { Currency } from "@uniswap/v4-core/src/types/Currency.sol";

contract DonationRouter {
    IPoolManager public immutable poolManager;

    // This struct helps us pack donation parameters to pass through
    // the unlock/callback pattern
    struct CallbackData {
        PoolKey key;
        uint256 amount0;
        uint256 amount1;
        bytes hookData;
    }

    constructor(IPoolManager _poolManager) {
        poolManager = _poolManager;
    }
}
```

Now let's implement the external donation function. Here we'll pack our parameters into the CallbackData struct and start the unlock process:

```solidity
/// @notice Donates tokens to a pool
/// @param key The pool to donate to
/// @param amount0 Amount of token0 to donate
/// @param amount1 Amount of token1 to donate
/// @param hookData Optional data to pass to hooks
function donate(
    PoolKey memory key,
    uint256 amount0,
    uint256 amount1,
    bytes memory hookData
) external returns (BalanceDelta delta) {
    // 1. Create a CallbackData struct with all our parameters
    CallbackData memory data = CallbackData({
        key: key,
        amount0: amount0,
        amount1: amount1,
        hookData: hookData
    });

    // 2. Encode our struct into bytes to pass through unlock
    bytes memory encodedData = abi.encode(data);
    
    // 3. Call unlock with our encoded data
    // 4. unlock will call our callback, which returns encoded delta
    // 5. Decode the returned bytes back into a BalanceDelta
    delta = abi.decode(
        poolManager.unlock(encodedData),
        (BalanceDelta)
    );
}
```

When the PoolManager calls our callback, we need to decode our data:

```solidity
function unlockCallback(
    bytes calldata rawData
) external returns (bytes memory) {
    // Only the PoolManager can trigger our callback
    require(msg.sender == address(poolManager));

    // Decode the bytes back into our CallbackData struct
    // (CallbackData) tells abi.decode what type to expect
    CallbackData memory data = abi.decode(rawData, (CallbackData));
```

Now `data` contains the same values we packed in donate():
    - `data.key`: The pool to donate to
    - `data.amount0`: Amount of first token
    - `data.amount1`: Amount of second token
    - `data.hookData`: Any hook data

And we can execute the donation:

```solidity
    // Execute the donation through PoolManager
    // This creates negative deltas for the tokens we're donating
    BalanceDelta delta = poolManager.donate(
        data.key,
        data.amount0,
        data.amount1,
        data.hookData
    );
```

After executing the donation through the PoolManager, we need to handle the token transfers. The donation creates negative deltas, which represent tokens that we owe to the PoolManager. This is where ERC-6909's burn operation comes into play.

Instead of using traditional token transfers, we can use ERC-6909's burn operation to settle this debt. We check each token's delta and, if negative, burn the corresponding amount of ERC-6909 tokens. And finally return the encoded delta. Let’s see how:

```solidity
 // Handle any negative deltas by burning ERC-6909 tokens
    if (delta.amount0() < 0) {
        poolManager.burn(
            data.key.currency0,
            address(this),
            uint256(-delta.amount0())
        );
    }
    if (delta.amount1() < 0) {
        poolManager.burn(
            data.key.currency1,
            address(this),
            uint256(-delta.amount1())
        );
    }

    // Encode and return the delta so donate() can decode it
    return abi.encode(delta);
}
```
</file>

<file path="docs/contracts/v4/guides/flash-accounting.mdx">
---
title: Flash Accounting
sidebar_position: 8
---

## Introduction

Flash accounting is v4’s mechanism for tracking token movements throughout a transaction. Unlike traditional token accounting which updates balances immediately after each operation, flash accounting accumulates changes (deltas) and settles them at the end of the transaction.

## How Flash Accounting Works

When interacting with v4's PoolManager, all token movements follow a consistent pattern: negative values represent tokens moving from users to the PoolManager, while positive values represent tokens moving from the PoolManager to users. This pattern appears in operations like swaps and liquidity management, where:

- Negative values indicate tokens going to the PoolManager
- Positive values indicate tokens coming from the PoolManager

These movements are tracked through deltas that represent token obligations:

- Negative deltas indicate tokens owed to the PoolManager
- Positive deltas indicate tokens the PoolManager owes to an address

## The PoolManager Lock Pattern

All operations that access pool liquidity must occur while the PoolManager is unlocked. This pattern ensures atomic execution and proper delta tracking:

1. Unlock the PoolManager
2. Execute operations (creating deltas)
3. Resolve all deltas
4. Context returns to the PoolManager which verifies no outstanding deltas

If any deltas remain unresolved when the PoolManager locks, the entire transaction reverts. This guarantees that all token movements balance out by the end of the transaction. 

## Understanding the Basics

Before diving into implementation patterns, let’s look at the key concepts you’ll need to work with flash accounting. Each example includes common scenarios you’ll encounter when building on v4.

### Working with Deltas

Every operation in v4 that involves tokens creates deltas. These deltas track what the executor owes to the PoolManager and vice versa:

```solidity
// Example: Executing a swap
// Note: This assumes the PoolManager has been unlocked
function executeSwap(PoolKey calldata key) external {
    // A swap returns a BalanceDelta
    BalanceDelta delta = poolManager.swap(
        key,
        IPoolManager.SwapParams({
            zeroForOne: true,
            amountSpecified: -1e18,  // Negative means spending/providing 1 ETH
            sqrtPriceLimitX96: MAX_SQRT_RATIO - 1  // Max price willing to accept
        }),
        ""
    );

    // Delta shows:
    // delta.amount0() = -1e18    (executor owes 1 ETH)
    // delta.amount1() = +2000e6  (executor receives 2000 USDC)
}
```

When a swap is executed, the PoolManager returns a `BalanceDelta` that shows your token obligations. In this example, the negative delta (-1e18) means the executor owes 1 ETH to the PoolManager, while the positive delta (+2000e6) means the executor is entitled to receive 2000 USDC. These deltas must be resolved before the transaction completes.

_Note how negative values in v4 consistently represent tokens going to the PoolManager - both in `amountSpecified` for the input amount and in the returned delta for tokens owed._

### Reading Delta States

A common pattern is checking current deltas before executing operations. The `TransientStateLibrary` helps you track these balances:

```solidity
import {TransientStateLibrary} from "@uniswap/v4-core/src/libraries/TransientStateLibrary.sol";

contract DeltaReader {
    using TransientStateLibrary for IPoolManager;

    function checkDeltaBeforeOperation(
        Currency currency,
        address user
    ) external view returns (int256) {
        // Important: This shows the current delta for this token/user pair
        return poolManager.currencyDelta(user, currency);
        // Negative: User owes tokens
        // Positive: User can claim tokens
        // Zero: No outstanding obligations
    }
}
```

The `TransientStateLibrary` provides utilities to check the current state of deltas at any point in your transaction. The `currencyDelta` function returns an int256 where negative values indicate the user owes tokens to the PoolManager, positive values mean the user can claim tokens from the PoolManager, and zero means there are no outstanding obligations for this token/user pair.

### Resolving Deltas

You must resolve all deltas before your transaction completes. There are two main approaches:

**1. Using ERC-20 Functions**

When using ERC-20 tokens, settling requires a specific sequence of operations:

```solidity
function resolveWithERC20(
    Currency currency,
    uint256 amount
) external {
    // For negative deltas (you owe tokens):
    if (!currency.isAddressZero()) {  // If not ETH
        poolManager.sync(currency);    // Sync currency balance first
        IERC20Minimal(Currency.unwrap(currency)).transfer(
            address(poolManager), 
            amount
        );
        poolManager.settle();          // Complete the settlement
    }

    // For positive deltas (receiving tokens):
    poolManager.take(currency, address(this), amount);
}
```

When resolving negative deltas with ERC-20 tokens, you need to:

1. Sync the currency balance with `sync()`
2. Transfer the tokens to the PoolManager
3. Complete the settlement with `settle()`

For positive deltas, simply use `take` to receive tokens from the PoolManager.

**2. Using ERC-6909 Functions**

```solidity
function resolveWithERC6909(
    Currency currency,
    uint256 amount
) external {
    // For negative deltas (you owe tokens):
    poolManager.burn(currency, address(this), amount);

    // For positive deltas (receiving tokens):
    poolManager.mint(currency, address(this), amount);
}
```

ERC-6909 operations map to their ERC-20 equivalents in v4:

- Use `burn` when you would use `settle` (for negative deltas)
- Use `mint` when you would use `take` (for positive deltas)

Notice how this pattern requires no additional sync operations or separate token transfers.

> **Important**: *Every delta must be resolved before the transaction ends, or the entire transaction will revert. Use* `TransientStateLibrary` *to verify your balances are properly settled.*
> 

> _Delta is a net balance resulting from token movements thus not bound to a certain token type i.e. can be resolved via mix-and-match with ERC-20 functions and ERC-6909 functions._

## Working with Flash Accounting

To interact with the PoolManager, we first need to create the functions our users will call. Then we'll implement the unlock callback pattern required to execute these operations.

### Using the Lock/Unlock Pattern

Let's start by creating our external function. First, we need to implement the callback that the `PoolManager` will use:

```solidity
function unlockCallback(bytes calldata data) external returns (bytes memory) {
    // To be implemented later
}
```

Now let's implement our external function that users will call:

```solidity
function executeSwap(
    PoolKey calldata key,
    uint256 amount
) external returns (int256, int256) {
    // Encode operation parameters
    bytes memory data = abi.encode(key, amount);

    // Call unlock with encoded data
    bytes memory result = poolManager.unlock(data);

    // Optional: Decode any relevant return data
    return (0, 0); // Replace with actual return values if needed
}
```

When you call this function the flow followed is the following:

1. `unlock` is called on the PoolManager
2. PoolManager calls back to your `unlockCallback`
3. Your callback executes the operations
4. All deltas must be resolved before returning
5. Execution of the logic returns to the PoolManager which verifies there are no outstanding deltas, and will relock itself

> **Warning***: Always implement proper access control in your unlock callback. Only the PoolManager should be able to call it.*
> 

### Implementing the Unlock Callback

First, let’s set up a contract with the proper unlock callback implementation:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IPoolManager} from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";
import {BalanceDelta} from "@uniswap/v4-core/src/types/BalanceDelta.sol";
import {Currency} from "@uniswap/v4-core/src/types/Currency.sol";

contract FlashAccountingExample {
    IPoolManager public immutable poolManager;

    constructor(IPoolManager _poolManager) {
        poolManager = _poolManager;
    }
    
    function executeSwap(
        PoolKey calldata key,
        uint256 amount
    ) external returns (int256, int256) {
        ...
    }

    function unlockCallback(bytes calldata data) external returns (bytes memory) {
        // Important: Must check caller is PoolManager
        require(msg.sender == address(poolManager), "Not pool manager");

        // Decode and call our executeOperations function which 
        // we'll implement next
        (bytes memory result) = executeOperations(data);

        // Important: Must return bytes, even if empty
        return result;
    }
}
```

This base contract sets up the foundation for working with v4’s flash accounting. The `unlockCallback` function is required for any operations that access pool liquidity - when your contract calls `poolManager.unlock()`, the PoolManager calls back to this function to execute your operations.

The callback must verify it's being called by the PoolManager and return a bytes value (even if empty) to prevent transaction failures. Any actual pool operations (like swaps or liquidity changes) will be handled through the `executeOperations` function.

> **Critical Note***: The most common mistake developers make is not returning a bytes value from unlockCallback. This will cause your transaction to revert. Always return a bytes value, even if it’s empty.*
> 

Let’s add functionality to execute operations:

```solidity
function executeOperations(
    bytes calldata data
) internal returns (bytes memory) {
    // Decode operation parameters
    (PoolKey memory key, uint256 amount) = abi.decode(
        data,
        (PoolKey, uint256)
    );

    // Execute operation (e.g. swap)
    BalanceDelta delta = poolManager.swap(
        key,
        IPoolManager.SwapParams({
            zeroForOne: true,
            amountSpecified: -int256(amount),
            sqrtPriceLimitX96: 0
        }),
        ""
    );

    // Resolve deltas
    if (delta.amount0() < 0) {
        poolManager.sync(key.currency0);
        IERC20Minimal(Currency.unwrap(key.currency0)).transfer(
            address(poolManager),
            uint256(-delta.amount0())
        );
        poolManager.settle();
    }
    if (delta.amount1() > 0) {
        poolManager.take(
            key.currency1,
            address(this),
            uint256(delta.amount1())
        );
    }

    return ""; // Return empty bytes if no specific result needed
}
```

The `executeOperations` function handles the actual pool operations. It first decodes the data passed from the unlock call to get the operation parameters. 

In this example, it executes a swap which creates deltas (token obligations) that must be resolved. For negative deltas (tokens we owe), we follow a specific sequence: first sync the currency state, then transfer the tokens to the PoolManager, and finally call settle. For positive deltas (tokens we receive), we use take to claim them. All deltas must be resolved before the function returns or the transaction will revert.

## Managing Liquidity with Flash Accounting

When adding or removing liquidity in v4, you’ll use `modifyLiquidity` which creates deltas that need to be handled through flash accounting. Let's understand how this works.

### Adding Liquidity

```solidity
// Example: Adding liquidity creates negative deltas (you need to provide tokens)
BalanceDelta delta = poolManager.modifyLiquidity(
    key,
    IPoolManager.ModifyLiquidityParams({
        tickLower: tickLower,       // Lower price bound for position
        tickUpper: tickUpper,       // Upper price bound for position
        liquidityDelta: liquidityAmount  // Positive for adding liquidity
    }),
    ""  // No hook data needed
);

// Negative deltas for both tokens
// delta.amount0() = -100  (need to provide token0)
// delta.amount1() = -200  (need to provide token1)
```

When adding liquidity to a pool, you’ll need to provide both tokens in the pair. The `modifyLiquidity` function returns a [`BalanceDelta`](/contracts/v4/reference/core/types/balancedelta) that indicates how many tokens you need to provide. In this case:

- The negative values in the delta (-100, -200) indicate you need to provide these amounts of each token
- The values are proportional to the current pool price and your specified price range (tickLower to tickUpper)
- These deltas must be resolved by providing the tokens before the transaction completes

### Removing Liquidity

```solidity
// Example: Removing liquidity creates positive deltas (you receive tokens)
BalanceDelta delta = poolManager.modifyLiquidity(
    key,
    IPoolManager.ModifyLiquidityParams({
        tickLower: tickLower,       // Same position bounds as when added
        tickUpper: tickUpper,
        liquidityDelta: -liquidityAmount  // Negative for removing liquidity
    }),
    ""  // No hook data needed
);

// Positive deltas for both tokens
// delta.amount0() = +100  (receive token0)
// delta.amount1() = +200  (receive token1)
```

When removing liquidity, the process is reversed. The negative `liquidityDelta` indicates you're removing liquidity, and the function returns positive deltas representing the tokens you'll receive:

- The positive values (+100, +200) indicate the amounts you’ll receive of each token
- The amounts depend on the pool’s current state and how much liquidity you’re removing
- These positive deltas represent tokens you can claim from the pool

> **Important***: Unlike single token operations, liquidity management typically involves handling deltas for both tokens in the pool.*
>
</file>

<file path="docs/contracts/v4/guides/position-manager.mdx">
---
title: Position Manager
sidebar_position: 6
---

## Introduction

The Position Manager in v4 provides a streamlined way to manage liquidity positions through a command-based interface. Unlike previous versions where each operation required separate function calls, v4’s Position Manager uses a batched command pattern that allows multiple operations to be executed in a single transaction.

## Command-Based Design

At its core, the Position Manager works by executing a sequence of commands:

```solidity
// Example: Minting a new position requires two commands
bytes memory actions = abi.encodePacked(
    Actions.MINT_POSITION,  // Create the position
    Actions.SETTLE_PAIR     // Provide the tokens
);
```

Each command (or action) represents a specific operation, and these actions can be:

- Liquidity Operations: Creating, modifying, or removing positions
- Delta-Resolving Operations: Handling token transfers and settlements

## How Commands Work Together

When executing operations through the Position Manager, you’ll always:

1. Define what actions to perform
2. Provide the parameters for each action
3. Execute them through a single function call

```solidity
// 1. Define actions
bytes memory actions = abi.encodePacked(action1, action2);

// 2. Encode parameters for each action
bytes[] memory params = new bytes[](2);
params[0] = abi.encode(/* parameters for action1 */);
params[1] = abi.encode(/* parameters for action2 */);

// 3. Execute through modifyLiquidities
positionManager.modifyLiquidities(
    abi.encode(actions, params),
    deadline
);
```

This design enables efficient operations by:

- Minimizing transaction costs through batching
- Allowing complex position management in single transactions
- Providing flexibility in how operations are combined

In the following sections, we’ll explore how to work with these commands and implement common liquidity management operations.

## Core Concepts

Before diving into specific operations, let’s understand the key concepts that make up the Position Manager’s architecture.

### Action Types

The Position Manager operates through a system of actions that work in pairs: when you perform a liquidity operation that changes position balances, you must also include actions to handle the resulting token movements.

### Understanding the Flow

When you execute a liquidity operation:

1. The operation creates deltas (token obligations)
2. These deltas represent tokens that need to be paid or received
3. Delta-resolving operations are then used to handle these token movements

### Liquidity Operations

[Actions](/contracts/v4/reference/periphery/libraries/Actions) that modify positions in the pool:

```solidity
// Common liquidity operations
uint256 constant MINT_POSITION = 0x02;       // Creates negative deltas (tokens needed for position)
uint256 constant INCREASE_LIQUIDITY = 0x00;  // Creates negative deltas (tokens to add)
uint256 constant DECREASE_LIQUIDITY = 0x01;  // Creates positive deltas (tokens to receive)
uint256 constant BURN_6909 = 0x18;           // Creates positive deltas (tokens to receive)
```

Each operation creates specific deltas that must be resolved:

- Negative deltas when you need to provide tokens (mint, increase)
- Positive deltas when you’re receiving tokens (decrease, burn)

### Delta-Resolving Operations

Actions that handle the token transfers needed to resolve deltas:

```solidity
// Common delta-resolving operations
uint256 constant SETTLE_PAIR = 0x0d;    // For negative deltas: Pay two tokens to the pool
uint256 constant TAKE_PAIR = 0x11;      // For positive deltas: Receive two tokens from the pool
uint256 constant CLOSE_CURRENCY = 0x12; // Handles either direction based on final delta
uint256 constant CLEAR_OR_TAKE = 0x13;  // For small amounts: Take if worth it, else ignore
```

### Operation Order

Understanding how operations create and resolve deltas helps in ordering them efficiently:

```solidity
// Efficient: Group operations that create deltas, then resolve them together
bytes memory actions = abi.encodePacked(
    Actions.MINT_POSITION,      // First delta: -100 tokens
    Actions.INCREASE_LIQUIDITY, // Second delta: -50 tokens
    Actions.SETTLE_PAIR        // Resolve total: -150 tokens at once
);

// Less efficient: Resolving deltas multiple times
bytes memory actions = abi.encodePacked(
    Actions.MINT_POSITION,      // Delta: -100 tokens
    Actions.SETTLE_PAIR,        // Resolve: -100 tokens
    Actions.INCREASE_LIQUIDITY, // New delta: -50 tokens
    Actions.SETTLE_PAIR        // Resolve again: -50 tokens
);
```

Best practices for ordering:

1. Group liquidity operations that create similar deltas (e.g., all negative or all positive)
2. Resolve all deltas together at the end when possible
3. Use `CLOSE_CURRENCY` when you can't predict the final delta

## Working with Liquidity Positions

When building on v4, you’ll need to manage liquidity positions through the Position Manager. Let’s walk through each operation, starting with creating new positions.

### Minting New Positions

To create a new liquidity position in v4, you’ll need to:

1. Define your position parameters (pool, price range, amount)
2. Mint the position NFT
3. Provide the initial tokens

### **Understanding Position Parameters**

Before minting, you need to determine:

- Which pool you’re providing liquidity to
- Your price range (defined by tick bounds)
- How much liquidity to provide
- Maximum amounts of tokens you’re willing to spend

```solidity
// Example position parameters
PoolKey poolKey = // Your pool key
int24 tickLower = -887272;   // Price range lower bound
int24 tickUpper = 887272;    // Price range upper bound
uint128 liquidity = 1000000; // Liquidity amount
uint256 amount0Max = 1e18;   // Max 1 token0
uint256 amount1Max = 1e18;   // Max 1 token1
```

### **Implementation**

Let’s implement a function to mint new liquidity positions step by step:

```solidity
/// @notice Mints a new liquidity position
/// @param poolKey The pool to provide liquidity to
/// @param tickLower Lower bound of the price range
/// @param tickUpper Upper bound of the price range
/// @param liquidity Amount of liquidity to provide
/// @param amount0Max Maximum amount of token0 to spend
/// @param amount1Max Maximum amount of token1 to spend
/// @param recipient Address that will own the position
function mintNewPosition(
    PoolKey calldata poolKey,
    int24 tickLower,
    int24 tickUpper,
    uint256 liquidity,
    uint128 amount0Max,
    uint128 amount1Max,
    address recipient
) external returns (uint256 tokenId) {
```

Define the sequence of operations needed for minting:

```solidity
// Define the sequence of operations:
// 1. MINT_POSITION - Creates the position and calculates token requirements
// 2. SETTLE_PAIR - Provides the tokens needed
bytes memory actions = abi.encodePacked(
    Actions.MINT_POSITION,
    Actions.SETTLE_PAIR
);
```

Set up parameters for each action:

```solidity
bytes[] memory params = new bytes[](2);

// Parameters for MINT_POSITION
params[0] = abi.encode(
    poolKey,     // Which pool to mint in
    tickLower,   // Position's lower price bound
    tickUpper,   // Position's upper price bound
    liquidity,   // Amount of liquidity to mint
    amount0Max,  // Maximum amount of token0 to use
    amount1Max,  // Maximum amount of token1 to use
    recipient,   // Who receives the NFT
    ""           // No hook data needed
);

// Parameters for SETTLE_PAIR - specify tokens to provide
params[1] = abi.encode(
    poolKey.currency0,  // First token to settle
    poolKey.currency1   // Second token to settle
);
```

Finally, execute the mint operation:

```solidity
// Execute the mint operation
positionManager.modifyLiquidities(
    abi.encode(actions, params),
    block.timestamp + 60  // 60 second deadline
);
```

## Increasing Liquidity

After a position is created, you might want to add more liquidity to it. This operation requires understanding how fee accumulation works since fees are credited to your position during an increase.

### **Understanding the Operation**

When increasing liquidity:

1. The operation calculates the tokens needed based on current prices
2. Any accumulated fees are **automatically credited** to your position
3. In some cases, fee revenue might partially or fully cover the tokens needed

### **Choosing the Right Delta Resolution**

Unlike minting where we always use SETTLE_PAIR, increasing liquidity has different delta-resolving options depending on your scenario:

1. **Standard Case**: When you’re providing new tokens

```solidity
bytes memory actions = abi.encodePacked(
    Actions.INCREASE_LIQUIDITY,
    Actions.SETTLE_PAIR
);
```

**2. Fee Conversion**: When converting accumulated fees to liquidity

```solidity
bytes memory actions = abi.encodePacked(
    Actions.INCREASE_LIQUIDITY,
    Actions.CLOSE_CURRENCY,  // For token0
    Actions.CLOSE_CURRENCY   // For token1
);
```

### **Implementation**

Here’s how to implement a flexible increase liquidity function:

```solidity
/// @notice Increases liquidity in an existing position
/// @param tokenId The ID of the position
/// @param liquidityIncrease Amount of liquidity to add
/// @param amount0Max Maximum amount of token0 to spend
/// @param amount1Max Maximum amount of token1 to spend
/// @param useFeesAsLiquidity Whether to use accumulated fees
function increaseLiquidity(
    uint256 tokenId,
    uint128 liquidityIncrease,
    uint256 amount0Max,
    uint256 amount1Max,
    bool useFeesAsLiquidity
) external {
```

Choose the appropriate delta resolution based on whether we’re using fees:

```solidity
// Define the sequence of operations:
// If using fees: Handle potential fee conversion
// If not: Standard liquidity addition
bytes memory actions;
if (useFeesAsLiquidity) {
    actions = abi.encodePacked(
        Actions.INCREASE_LIQUIDITY,  // Add liquidity
        Actions.CLOSE_CURRENCY,      // Handle token0 (might need to pay or receive)
        Actions.CLOSE_CURRENCY       // Handle token1 (might need to pay or receive)
    );
} else {
    actions = abi.encodePacked(
        Actions.INCREASE_LIQUIDITY,  // Add liquidity
        Actions.SETTLE_PAIR          // Provide tokens
    );
}
```

Prepare parameters based on our chosen strategy:

```solidity
// Number of parameters depends on our strategy
bytes[] memory params = new bytes[](
    useFeesAsLiquidity ? 3 : 2
);

// Parameters for INCREASE_LIQUIDITY
params[0] = abi.encode(
    tokenId,           // Position to increase
    liquidityIncrease, // Amount to add
    amount0Max,        // Maximum token0 to spend
    amount1Max,        // Maximum token1 to spend
    ""                // No hook data needed
);
```

Set up delta resolution parameters:

```solidity
if (useFeesAsLiquidity) {
    // Using CLOSE_CURRENCY for automatic handling of each token
    params[1] = abi.encode(currency0);  // Handle token0
    params[2] = abi.encode(currency1);  // Handle token1
} else {
    // Standard SETTLE_PAIR for providing tokens
    params[1] = abi.encode(currency0, currency1);
}
```

Execute the operation:

```solidity
// Execute the increase
positionManager.modifyLiquidities(
    abi.encode(actions, params),
    block.timestamp + 60  // 60 second deadline
);
}
```

## Decreasing Liquidity

When you want to remove liquidity from a position, you’ll need to handle both the liquidity reduction and any accumulated fees. Let’s understand how to implement this effectively.

### **Understanding the Operation**

Decreasing liquidity involves:

1. Specifying how much liquidity to remove
2. Setting minimum amounts to receive (slippage protection)
3. Collecting both the removed liquidity and any accumulated fees

### **Delta Resolution Options**

When decreasing liquidity, you’ll receive tokens, so it's most common to receive a pair of tokens:


```solidity
bytes memory actions = abi.encodePacked(
    Actions.DECREASE_LIQUIDITY,
    Actions.TAKE_PAIR
);
```

### **Implementation**

When removing liquidity from a position, you’ll be able to receive tokens and any accumulated fees. Let’s break down the implementation step by step.

```solidity
/// @notice Removes liquidity from a position
/// @param tokenId The ID of the position
/// @param liquidityDecrease Amount of liquidity to remove
/// @param amount0Min Minimum amount of token0 to receive
/// @param amount1Min Minimum amount of token1 to receive
/// @param recipient Address to receive the tokens
function decreaseLiquidity(
    uint256 tokenId,
    uint128 liquidityDecrease,
    uint256 amount0Min,
    uint256 amount1Min,
    address recipient
) external {
```

Prepare the parameters array:

```solidity
// Number of parameters depends on our strategy
bytes[] memory params = new bytes[](2);

// Parameters for DECREASE_LIQUIDITY
params[0] = abi.encode(
    tokenId,           // Position to decrease
    liquidityDecrease, // Amount to remove
    amount0Min,        // Minimum token0 to receive
    amount1Min,        // Minimum token1 to receive
    ""                // No hook data needed
);
```

Set up delta resolution parameters:

```solidity
// Parameters for TAKE_PAIR
params[1] = abi.encode(
    currency0,
    currency1,
    recipient
);
```

Execute the operation:

```solidity
// Execute the decrease
positionManager.modifyLiquidities(
    abi.encode(actions, params),
    block.timestamp + 60  // 60 second deadline
);
```

## Collecting Fees

In v4’s Position Manager, there isn’t a dedicated COLLECT command. Instead, **fees are collected by using DECREASE_LIQUIDITY with zero liquidity**. This pattern leverages the fact that fees are automatically credited during liquidity operations.

### **Understanding Fee Collection**

When collecting fees, you need to:

1. Perform a DECREASE_LIQUIDITY operation with zero liquidity
2. Handle the positive deltas (the fees you’re collecting)
3. Specify where the fees should go

### **Implementation**

```solidity
/// @notice Collects accumulated fees from a position
/// @param tokenId The ID of the position to collect fees from
/// @param recipient Address that will receive the fees
function collectFees(
    uint256 tokenId,
    address recipient
) external {
    // Define the sequence of operations
    bytes memory actions = abi.encodePacked(
        Actions.DECREASE_LIQUIDITY, // Remove liquidity
        Actions.TAKE_PAIR           // Receive both tokens
    );

    // Prepare parameters array
    bytes[] memory params = new bytes[](2);

    // Parameters for DECREASE_LIQUIDITY
    // All zeros since we're only collecting fees
    params[0] = abi.encode(
        tokenId,    // Position to collect from
        0,          // No liquidity change
        0,          // No minimum for token0 (fees can't be manipulated)
        0,          // No minimum for token1
        ""          // No hook data needed
    );
```

When collecting fees, we use a zero-liquidity decrease operation - this means we're not actually removing any liquidity from the position, we're just collecting accumulated fees.

And note that we set minimums to 0 for fee collection because fees cannot be manipulated in a front-run attack. This is different from other liquidity operations where setting appropriate minimum amounts is crucial for slippage protection.

Set up the fee collection parameters:

```solidity
    // Standard TAKE_PAIR for receiving all fees
    params[1] = abi.encode(
        currency0,
        currency1,
        recipient
    );
}
```

Execute the fee collection:

```solidity
// Execute fee collection
positionManager.modifyLiquidities(
    abi.encode(actions, params),
    block.timestamp + 60  // 60 second deadline
);
```

## Burning Positions

When you want to completely exit a position, burning is more efficient than removing liquidity and collecting fees separately. The BURN_POSITION command handles everything in a single operation.

### **Understanding Position Burning**

A burn operation:

- Removes all remaining liquidity from the pool
- Collects any accumulated fees
- Burns the position NFT
- Settles all tokens to a specified recipient

### **Implementation**

Let’s implement a position burning function step by step:

```solidity
/// @notice Burns a position and receives all tokens
/// @param tokenId The ID of the position to burn
/// @param recipient Address that will receive the tokens
/// @param amount0Min Minimum amount of token0 to receive
/// @param amount1Min Minimum amount of token1 to receive
function burnPosition(
    uint256 tokenId,
    address recipient,
    uint256 amount0Min,
    uint256 amount1Min
) external {
    // Define the sequence of operations:
    // 1. BURN_POSITION - Removes the position and creates positive deltas
    // 2. TAKE_PAIR - Sends all tokens to the recipient
    bytes memory actions = abi.encodePacked(
        Actions.BURN_POSITION,
        Actions.TAKE_PAIR
    );
```

The burn operation requires two sets of parameters:

```solidity
bytes[] memory params = new bytes[](2);

// Parameters for BURN_POSITION
params[0] = abi.encode(
    tokenId,      // Position to burn
    amount0Min,   // Minimum token0 to receive
    amount1Min,   // Minimum token1 to receive
    ""            // No hook data needed
);

// Parameters for TAKE_PAIR - where tokens will go
params[1] = abi.encode(
    currency0,   // First token
    currency1,   // Second token
    recipient    // Who receives the tokens
);
```

Finally, execute the operation:

```solidity
positionManager.modifyLiquidities(
    abi.encode(actions, params),
    block.timestamp + 60
);
```

## Batch-Operating Liquidity

The Position Manager’s command-based design enables you to perform multiple liquidity operations in a single transaction. This is particularly valuable when managing multiple positions or performing complex liquidity management strategies, such as taking tokens from one position to increase liquidity of another position.

### Benefits of Batch Operations

When managing liquidity across multiple positions, batching operations provides significant advantages:

- Reduced gas costs by combining token settlements
- Atomic execution of related operations
- Simplified token handling through combined delta resolution

### Implementation Guide

Let’s implement a common scenario: rebalancing liquidity by creating a new position while closing an old one and collecting its fees. We’ll go through it step by step.

First, let’s define our parameters:

```solidity
/// @notice Rebalances liquidity by creating a new position and closing an old one
/// @param newPositionParams Parameters for the new position
/// @param oldPositionId Position to close and collect fees from
/// @param recipient Address to receive tokens from closed position
struct NewPositionParams {
    PoolKey poolKey;
    int24 tickLower;
    int24 tickUpper;
    uint128 liquidity;
    uint256 amount0Max;
    uint256 amount1Max;
}
```

In this example, we will rebalance liquidity by closing the old position and opening a new position. For the sake of example, let's assume the user will have to transfer additional tokens. Note that capital from the first position is automatically used towards the second position through flash accounting.

```solidity
function rebalanceLiquidity(
    NewPositionParams calldata newPositionParams,
    uint256 oldPositionId,
    address recipient
) external {
    // Group liquidity operations first, then delta resolutions
    bytes memory actions = abi.encodePacked(
        Actions.BURN_POSITION,    // Remove old position
        Actions.MINT_POSITION,    // Create new position
        Actions.SETTLE_PAIR       // Provide tokens for new position
    );
```

Notice how we order our operations: liquidity operations first (MINT and BURN), followed by delta resolutions (SETTLE and TAKE). This ordering is crucial for gas efficiency.

Next, let’s prepare our parameters array:

```solidity
// We need one parameter set for each action
bytes[] memory params = new bytes[](3);
```

Now, let’s encode parameters for the old position:

```solidity
// Parameters for BURN_POSITION
params[0] = abi.encode(
    oldPositionId,
    0,  // No minimum for token0 (consider adding slippage protection)
    0,  // No minimum for token1
    ""  // No hook data
);
```

Then for minting the new position:

```solidity
// Parameters for MINT_POSITION
params[1] = abi.encode(
    newPositionParams.poolKey,
    newPositionParams.tickLower,
    newPositionParams.tickUpper,
    newPositionParams.liquidity,
    newPositionParams.amount0Max,
    newPositionParams.amount1Max,
    address(this),  // New position owner
    ""              // No hook data
);
```

Next, we handle token settlements. First for the new position:

```solidity
// Parameters for SETTLE_PAIR (providing tokens for new position)
params[2] = abi.encode(
  newPositionParams.poolKey.currency0,
  newPositionParams.poolKey.currency1
);
```

With everything prepared, we can execute our batch operation:

```solidity
// Execute all operations atomically
positionManager.modifyLiquidities(
    abi.encode(actions, params),
    block.timestamp + 60
);
    positionManager.modifyLiquidities(
        abi.encode(actions, params),
        block.timestamp + 60
    );
}
```

## Delta-Resolving Operations

While we’ve seen basic delta resolution using SETTLE_PAIR and TAKE_PAIR in previous sections, v4’s Position Manager provides additional operations for handling more complex scenarios. Let’s understand when and how to use each one.

### **CLOSE_CURRENCY: Handling Unknown Deltas**

When you can’t predict whether you’ll need to pay or receive tokens, CLOSE_CURRENCY automatically handles either case.

```solidity
// Example scenario: Converting fees to liquidity
bytes memory actions = abi.encodePacked(
    Actions.INCREASE_LIQUIDITY,
    Actions.CLOSE_CURRENCY  // Will automatically settle or take based on final delta
);

bytes[] memory params = new bytes[](2);

// Parameters for INCREASE_LIQUIDITY
params[0] = abi.encode(
    tokenId,
    liquidityIncrease,
    amount0Max,
    amount1Max,
    ""
);

// CLOSE_CURRENCY only needs the currency
params[1] = abi.encode(currency0);
```

This is particularly useful when:

- Converting fees to liquidity (fees might fully cover the increase)
- Complex operations where final deltas are uncertain
- Reducing code complexity by letting the protocol handle the direction

### **CLEAR_OR_TAKE: Optimizing for Dust**

Sometimes receiving small token amounts costs more in gas than they’re worth. CLEAR_OR_TAKE lets you specify a threshold:

```solidity
// Parameters for CLEAR_OR_TAKE
params[0] = abi.encode(
    currency,     // The token to handle
    threshold     // Minimum amount worth taking
);
```

If the amount to receive is:

- Above threshold: Tokens are taken (like TAKE_PAIR)
- Below threshold: Amount is forfeited, saving gas

This is valuable for:

- Operations where dust amounts can be ignored
- Gas optimization in production systems

### **SWEEP: Handling Excess Payments**

SWEEP helps recover any excess tokens sent to the PoolManager:

```solidity
bytes memory actions = abi.encodePacked(
    Actions.YOUR_MAIN_OPERATION,
    Actions.SWEEP  // Add at the end to collect any excess
);

// Parameters for SWEEP
params[1] = abi.encode(
    currency,   // Token to sweep
    recipient   // Where to send excess tokens
);
```

Use SWEEP when:

- **Dealing with native ETH operations**
- Conservative token approvals might result in excess
- Need to ensure all tokens are properly accounted for

### **Understanding modifyLiquiditiesWithoutUnlock**

This function follows the same encoding and command patterns as `modifyLiquidity`, but serves a specific purpose: it's used when the PoolManager is already unlocked. This is particularly useful in certain scenarios:

- When called from hooks that are already executing within the PoolManager's lock/unlock cycle
- For operations like automatic fee compounding, where a hook might want to reinvest fees for users

For example, a hook that automatically compounds fees for users would use `modifyLiquiditiesWithoutUnlock` because the hook is already executing within the PoolManager's unlock context, and cannot re-unlock the PoolManager
</file>

<file path="docs/contracts/v4/guides/read-pool-state.mdx">
---
title: Reading Pool State
sidebar_position: 2
---

## Introduction

Unlike previous versions, v4 uses a different approach for storing and accessing pool data, which requires understanding the use of [`StateLibrary`](/contracts/v4/reference/core/libraries/StateLibrary) and [`extsload`](/contracts/v4/reference/core/Extsload).

## Understanding the PoolManager Architecture

### The Singleton Design

In Uniswap v4, all pools are managed by a single `PoolManager` contract, unlike v3 where each pool was a separate contract. This design offers simplified management since all pools are now accessible through a single contract.

This approach significantly reduces deployment costs, simplifies protocol upgrades, and enables more efficient cross-pool interactions. It also allows for easier implementation of new features across all pools simultaneously. 

### Pools as Library Calls

In v4, pools are stored as complex structs, with Solidity libraries handling state changes. The `PoolManager` contract uses these libraries to perform operations on the pool state:

```solidity
contract PoolManager {
    using Pool for Pool.State;
    mapping(PoolId => Pool.State) internal pools;

    function swap(PoolId id, ...) external {
        pools[id].swap(...); // Library call
    }
}
```

This design allows all AMM logic to be encapsulated within the `PoolManager` contract.

## Reading Pool State in v4

In Uniswap v4, reading pool state involves a few key concepts and mechanisms that differ from previous versions. At the core of this new structure is a complex mapping within the PoolManager contract:

```solidity
mapping(PoolId id => Pool.State) internal _pools;
```

This mapping represents a fundamental shift in pool data storage:

1. Each pool is identified by a unique `PoolId`.
2. The `Pool.State` is a struct that contains all the state variables for a single pool.
3. This struct itself contains several nested mappings and complex data structures.

For example, the `Pool.State` struct might look something like this (simplified for illustration):

```solidity
struct State {
    uint160 sqrtPriceX96;
    int24 tick;
    uint128 liquidity;
    uint256 feeGrowthGlobal0X128;
    uint256 feeGrowthGlobal1X128;
    mapping(int24 => TickInfo) ticks;
    mapping(bytes32 => Position.Info) positions;
    // ... other fields
}
```

This complex structure allows for efficient storage of multiple pools and their associated data within a single contract. However, it also means that traditional getter functions would be inefficient or impractical for accessing this data, especially for nested mappings like `ticks` and `positions`.

To address this, Uniswap V4 introduces the StateLibrary and the concept of using `extsload` for reading pool state. These mechanisms provide efficient ways to access the data stored in this complex structure.

### The StateLibrary and `extsload`

```solidity
abstract contract Extsload is IExtsload {
    /// @inheritdoc IExtsload
    function extsload(bytes32 slot) external view returns (bytes32) {
        assembly ("memory-safe") {
            mstore(0, sload(slot))
            return(0, 0x20)
        }
    }

    // [...]
}
```

The `StateLibrary` is a crucial component in Uniswap v4 for reading pool state. It utilizes the `extsload` function, which is an external wrapper for the `SLOAD` opcode. This allows for efficient reading of arbitrary storage slots.

**How `extsload` works:**

- It takes a storage slot as input.
- It reads the value stored in that slot directly, using `SLOAD`, from the contract's storage.
- It returns the value as a `bytes32`.

This method is more gas-efficient than traditional getter functions, especially when reading multiple storage slots.

Moreover, using `extsload` instead of hand-written Solidity view functions lowers the contract bytecode size. This optimization is particularly important for Uniswap v4, as the core contracts are nearly at Ethereum's contract size limit.

### TransientStateLibrary and `exttload`

```solidity
abstract contract Exttload is IExttload {
    /// @inheritdoc IExttload
    function exttload(bytes32 slot) external view returns (bytes32) {
        assembly ("memory-safe") {
            mstore(0, tload(slot))
            return(0, 0x20)
        }
    }

    // [...]
}
```

While `StateLibrary` deals with persistent storage, [`TransientStateLibrary`](/contracts/v4/reference/core/libraries/transient-state-library) is used for handling transient storage. Transient storage, introduced in EIP-1153, is a way to store data that is only needed for the duration of a transaction, making it ideal for temporary data.

It uses the [`exttload`](/contracts/v4/reference/core/Exttload) function, which is similar to `extsload`, but for transient storage; it is an external wrapper for the `TLOAD` opcode.

## Implementing a `PoolStateReader` Contract

Let's create a `PoolStateReader` contract that showcases different methods for reading pool state. For each function, we'll explain its purpose, how it works, and provide an example use case.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/types/PoolId.sol";

contract PoolStateReader {
    using PoolIdLibrary for PoolKey;

    IPoolManager public immutable poolManager;

    constructor(IPoolManager _poolManager) {
        poolManager = _poolManager;
    }

    // Functions will be implemented here
}
```

Before we start, we need to import `StateLibrary` from the libraries available in v4-core.

```solidity
import {StateLibrary} from "v4-core/libraries/StateLibrary.sol";
```

Let's focus on this important line that we should add:

```solidity
using StateLibrary for IPoolManager;
```

This line is crucial for our PoolStateReader contract because it allows us to call StateLibrary functions as if they were methods of the IPoolManager interface, like for instance now we will be able to do `poolManager.getSlot0()`.

Now we’re up for breaking down each wrapper function that we're going to be adding to our helper contract, explain the purpose of the pool manager function to read the state, and provide use cases to make sure we understand its utility:

### `getSlot0()`

```solidity
function getPoolState(PoolKey calldata key) external view returns (
    uint160 sqrtPriceX96,
    int24 tick,
    uint24 protocolFee,
    uint24 lpFee
) {
    return poolManager.getSlot0(key.toId());
}
```

**Explanation:**

This function retrieves the current state of the pool, including its price, tick, and fee settings. It uses the `getSlot0()` function from `StateLibrary`, which efficiently reads these values from a single storage slot.

- `sqrtPriceX96`: The current price, encoded as a square root and scaled by 2^96. This encoding allows for efficient price calculations in the Uniswap algorithm.
- `tick`: The current tick, representing the quantized price. Ticks are used to efficiently track and update liquidity positions.
- `protocolFee`: The current protocol fee, represented in hundredths of a bip (i.e., units of 0.0001%).
- `lpFee`: The current liquidity provider fee, also represented in hundredths of a bip.

**Use Case:**

This function is essential for any application that needs to know the current state of a Uniswap v4 pool. For example:

- A price oracle could use this to get the current price of the pool.
- A trading bot could use this to determine if a trade is profitable given the current price and fees.
- A liquidity management system could use the `tick` to decide where to place new liquidity.

### `getLiquidity()`

```solidity
function getPoolLiquidity(PoolKey calldata key) external view returns (uint128 liquidity) {
    return poolManager.getLiquidity(key.toId());
}
```

**Explanation:**

This function retrieves the current total liquidity in the pool. Liquidity in Uniswap v4 represents the amount of assets available for trading within the current price range.

**Use Case:**

Understanding the total liquidity is crucial for several scenarios:

- Assessing the depth of the market and potential slippage for large trades.
- Monitoring the depth and growth of a pool over time.

### `getPositionInfo`

```solidity
function getPositionInfo(
    PoolKey calldata key,
    address owner,
    int24 tickLower,
    int24 tickUpper,
    bytes32 salt
) external view returns (
    uint128 liquidity,
    uint256 feeGrowthInside0LastX128,
    uint256 feeGrowthInside1LastX128
) {
    return poolManager.getPositionInfo(key.toId(), owner, tickLower, tickUpper, bytes32(salt));
}
```

**Explanation:**

This function retrieves information about a specific liquidity position. It returns:

- `liquidity`: The amount of liquidity in the position.
- `feeGrowthInside0LastX128` and `feeGrowthInside1LastX128`: The last recorded cumulative fees earned per unit of liquidity for each token.

**Use Case:**

This function is crucial for applications that need to manage or analyze individual liquidity positions:

- A liquidity management dashboard could use this to display a user's current positions and earned fees.
- An automated liquidity provision system could use this to decide when to rebalance or compound rewards.
- An analytics tool could use this to calculate the performance of different liquidity provision strategies.

### `getFeeGrowthGlobal`

```solidity
function getFeeGrowthGlobal(PoolKey calldata key) external view returns (
    uint256 feeGrowthGlobal0X128,
    uint256 feeGrowthGlobal1X128
) {
    return poolManager.getFeeGrowthGlobal(key.toId());
}
```

**Explanation:**

This function retrieves the global fee growth for both tokens in the pool. These values represent the cumulative fees per unit of liquidity since the pool's inception.

**Use Case:**

Global fee growth is essential for several advanced operations:

- Calculating the fees earned by a position that has been held for a long time.
- Analyzing the overall fee generation of a pool over its lifetime.
- Comparing the performance of different pools or fee tiers.

---

For additional reference, see [`StateLibrary`](/contracts/v4/reference/core/libraries/StateLibrary) and [`Extsload`](/contracts/v4/reference/core/Extsload)
</file>

<file path="docs/contracts/v4/guides/state-view.mdx">
---
title: StateView
sidebar_position: 7
---

## Introduction

When building on **Uniswap v4**, you will often need to read pool state for both onchain and offchain use cases. Onchain contracts can directly invoke the [**StateLibrary**](https://github.com/Uniswap/v4-core/blob/main/src/libraries/StateLibrary.sol) to execute these reads during transactions, but offchain systems—such as frontends or analytics services—require a deployed contract with view functions. This is where [**StateView**](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) comes in.

> *In short: Use StateLibrary within onchain contracts and use StateView with an RPC for frontends and analytics.*
> 

By providing a dedicated interface for offchain reads, **StateView** helps:

- Retrieve pool state without paying gas
- Simplify integration for frontends, dashboards, and analytics
- Ensure a clean separation between onchain logic and offchain queries

## Comparing onchain and offchain Access

If you’re familiar with [Reading Pool State](/contracts/v4/guides/read-pool-state), you already know that Uniswap v4 uses **extsload** for efficient data access. For onchain usage, we rely on **StateLibrary** within contracts. However, offchain clients cannot rely on an onchain library for state reads. 

Instead, **StateView** provides these same calls in a single contract designed explicitly for offchain consumption.

> *Because StateLibrary operates via onchain function calls, it’s not directly accessible to offchain clients. Hence, StateView provides a simple, gas-free interface designed for frontends and analytics.*
> 

For instance, an onchain contract might use the `StateLibrary` as follows:

```solidity
// Onchain contract using StateLibrary
contract MyProtocol {
    using StateLibrary for IPoolManager;

    function checkPoolPrice(PoolId poolId) external returns (uint160) {
        (uint160 sqrtPriceX96, , , ) = poolManager.getSlot0(poolId);
        // ... use the price in contract logic ...
        return sqrtPriceX96;
    }
}
```

By contrast, an offchain frontend or analytics service should interact with `StateView`:

```tsx
// Frontend or analytics client using StateView
const stateView = getContract({
  address: STATE_VIEW_ADDRESS,
  abi: stateViewABI
});

const { sqrtPriceX96 } = await stateView.read.getSlot0([poolId]);
// ... use the price in your application ...
```

This separation ensures that each context (onchain vs. offchain) uses the most efficient data reading pattern.

## Usage With Frontend Clients

Frontend applications frequently display real-time information about pools, positions, and other market data—without incurring transaction costs. **StateView** addresses these requirements by exposing read-only functions tailored for offchain integrations.

### Setting Up With Viem

We’ll use [**viem**](https://viem.sh/), a TypeScript library for Ethereum, to demonstrate how to connect to **StateView**.

```tsx
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';

// Initialize the client
const client = createPublicClient({
  chain: mainnet,
  transport: http()
});

// Set up StateView contract instance
const stateView = getContract({
  address: STATE_VIEW_ADDRESS,
  abi: stateViewABI,
  client
})
```

> **Note:** _The stateView object comes from our getContract call above. Make sure you’ve imported stateViewABI correctly before attempting to read from the contract._
> 

With this setup, you can now:

- **Connect to an Ethereum network**
- **Call StateView’s read functions**
- **Retrieve pool information offchain at no gas cost**

### Handling Errors and Invalid Pool IDs

When calling `stateView.read.<function>([poolId])`, be mindful that:

- If you pass an invalid `poolId` (typically a [`bytes32`](https://github.com/Uniswap/v4-core/blob/main/src/types/PoolId.sol#L6) in Uniswap v4), the call may revert or return unexpected data.
- Consider adding try-catch (or equivalent error handling in your framework) to gracefully handle failures if the pool does not exist or if the call fails onchain.

## Reading Pool Data

Here are common examples of how to retrieve pool data using **StateView**.

### Getting Pool State

A pool’s core state, such as its current price or fees, is often necessary for frontends. Use `getSlot0`:

```tsx
// Example: Reading pool price and fees
const getPoolState = async (poolId: string) => {
  // getSlot0 returns:
  // - Current price (sqrtPriceX96) in Q64.96 fixed-point format
  // - Active tick
  // - Protocol and LP fee settings
  const [
    sqrtPriceX96,
    tick,
    protocolFee,
    lpFee
   ] = await stateView.read.getSlot0([poolId]);

  return {
    price: calculatePrice(sqrtPriceX96), // implement your math logic for Q64.96
    tick,
    protocolFee,
    lpFee
  };
};
```

**What it Returns:**

- **`sqrtPriceX96`**: The current pool price in Q64.96 fixed-point format.
- **`tick`**: The current tick in which the pool is operating.
- **`protocolFee`** and **`lpFee`**: Fee parameters for protocol and LP fee tiers.

### Getting Pool Liquidity

To understand how much liquidity a pool holds:

```tsx
// Example: Reading the total active liquidity of a pool
const getPoolLiquidity = async (poolId: string) => {
  // getLiquidity returns the total liquidity currently active in the pool
  const liquidity = await stateView.read.getLiquidity([poolId]);
  return liquidity;
};
```

**Why It Matters:**

- Helps gauge the depth of the pool
- Influences price impact calculations in trading
- Provides context for the pool’s capacity to absorb trades

## Core Functions and Return Types

While **StateView** exposes many functions, here are several essential calls for most offchain applications. Each function typically takes a `poolId` (of type `bytes32`) as the key input, identifying which pool to query.

1. **[`getSlot0(poolId)`](/contracts/v4/reference/periphery/lens/StateView#getslot0)**
    - Returns `(uint160 sqrtPriceX96, int24 tick, uint8 protocolFee, uint8 lpFee)`.
    - Essential for displaying real-time price data and fees.
2. **[`getLiquidity(poolId)`](/contracts/v4/reference/periphery/lens/StateView#getliquidity)**
    - Returns `uint128 liquidity` (the total active pool liquidity).
    - Used to assess trading depth and volatility.
3. **[`getPositionInfo(poolId, positionId)`](/contracts/v4/reference/periphery/lens/StateView#getpositioninfo)**
    - Returns `(uint128 liquidity, uint256 feeGrowthInside0Last, uint256 feeGrowthInside1Last)`.
    - Critical for tracking user positions, especially to calculate earned fees over time.
4. **[`getFeeGrowthGlobals(poolId)`](/contracts/v4/reference/periphery/lens/StateView#getfeegrowthglobals)**
    - Returns `(uint256 feeGrowthGlobal0, uint256 feeGrowthGlobal1)`.
    - Useful for analytics around total fee accumulation in the pool.

### Note on `poolId` and `positionId`

- In **Uniswap v4**, a `poolId` is typically a `bytes32` that is derived by calling 
`keccak256(abi.encode(poolKey))` where poolKey contains:
  - currency0: The lower currency address of the pool
  - currency1: The higher currency address of the pool
  - fee: The pool LP fee (uint24)
  - tickSpacing: The tick spacing value (int24)
  - hooks: The hooks contract address
- A `positionId` may also be a `bytes32` or other unique identifier that references a specific position.

## Security and Gas Considerations

- **Offchain Reads**: Calls to `StateView` are purely read-only, so they cost no gas. This makes them ideal for frequently refreshing UI/analytics data.
- **Onchain vs. Offchain**: Remember that if you need to integrate pool data into a live transaction, you must use `StateLibrary` within your smart contract.
- **Edge Cases**: Always verify the returned data before using it in your application. Network or contract errors could lead to unexpected values.

## Conclusion

**StateView** is a powerful and efficient way to read Uniswap v4 pool data offchain. By separating onchain logic (using `StateLibrary`) and offchain reads (using `StateView`), Uniswap ensures the best developer experience for both contexts.

To recap:

1. **Setup**: Use libraries like `viem` to connect to the Ethereum network.
2. **Read**: Call `getSlot0`, `getLiquidity`, `getPositionInfo`, and other methods for crucial state data.
3. **Handle Errors**: Implement basic checks for invalid `poolId` or connection failures.
</file>

<file path="docs/contracts/v4/guides/swap-routing.mdx">
---
title: Swap routing
sidebar_position: 4
---

## Introduction to Universal Router for Uniswap v4 Swaps

Uniswap v4 introduces a new architecture where all pools are managed by a single PoolManager contract. While the underlying architecture uses a callback system for swaps, developers can still use the Universal Router to execute swaps on v4 pools, just as you would for v2 or v3.

## What is the Universal Router?

The Universal Router is a flexible, gas-efficient contract designed to execute complex swap operations across various protocols, including Uniswap v4. It serves as an intermediary between users and the Uniswap v4 `PoolManager`, handling the intricacies of swap execution.

While it’s technically possible to interact directly with the PoolManager contract for swaps, this approach is generally not recommended due to its complexity and potential inefficiencies. The Universal Router is designed to abstract away these complexities, providing a more straightforward and efficient method for executing swaps on v4 pools.

## UniversalRouter command encoding

The [Universal Router](/contracts/universal-router/overview) uses a unique encoding system for its commands and inputs, which is crucial to understand when configuring it for v4 swaps.

When calling `UniversalRouter.execute()`, you provide two main parameters:

1. `bytes commands`: A string of bytes where each byte represents a single command to be executed.
2. `bytes[] inputs`: An array of byte strings, each containing the encoded parameters for its corresponding command.

The `commands[i]` byte corresponds to the `inputs[i]` parameters, allowing for a series of operations to be defined and executed in sequence.

Each command is encoded as a single byte (`bytes1`) with a specific structure:

```
0 1 2 3 4 5 6 7
┌─┬─┬───────────┐
│f│r|  command  │
└─┴─┴───────────┘
```

- The first bit (`f`) is a flag that determines whether the command is allowed to revert without causing the entire transaction to fail. This enables partial execution of complex transactions.
- The second bit (`r`) is reserved for future use, providing flexibility for potential upgrades.
- The remaining 6 bits represent the specific command to be executed.

## Configuring Universal Router for Uniswap v4 Swaps

### Use Cases

Developers might need to configure the Universal Router for swapping on Uniswap v4 pools in several scenarios:

1. **Building a DEX aggregator**: If you’re creating a platform that finds the best rates across multiple DEXes, you’ll want to include Uniswap v4 pools in your options.
2. **Developing a trading bot**: Automated trading strategies often require the ability to execute swaps programmatically across various pools and versions.
3. **Creating a Dapp**: Many DeFi applications (lending platforms, yield aggregators, etc.) need to perform token swaps as part of their core functionality.

This guide focuses on how to interact with Universal Router from an on-chain contract.

### Step 1: Set Up the Project

First, we need to set up our project and install the necessary dependencies.
```bash
forge install uniswap/v4-core
forge install uniswap/v4-periphery
forge install uniswap/permit2
forge install uniswap/universal-router
forge install OpenZeppelin/openzeppelin-contracts
```
In the `remappings.txt`, add the following:
```
@uniswap/v4-core/=lib/v4-core/
@uniswap/v4-periphery/=lib/v4-periphery/
@uniswap/permit2/=lib/permit2/
@uniswap/universal-router/=lib/universal-router/
@openzeppelin/contracts/=lib/openzeppelin-contracts/
[...]
```

We’ll create a new Solidity contract for our example.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import { IUniversalRouter } from "@uniswap/universal-router/contracts/interfaces/IUniversalRouter.sol";
import { Commands } from "@uniswap/universal-router/contracts/libraries/Commands.sol";
import { IPoolManager } from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import { IV4Router } from "@uniswap/v4-periphery/src/interfaces/IV4Router.sol";
import { Actions } from "@uniswap/v4-periphery/src/libraries/Actions.sol";
import { IPermit2 } from "@uniswap/permit2/src/interfaces/IPermit2.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { StateLibrary } from "@uniswap/v4-core/src/libraries/StateLibrary.sol";
import { PoolKey } from "@uniswap/v4-core/src/types/PoolKey.sol";
import { Currency } from "@uniswap/v4-core/src/types/Currency.sol";

contract Example {
    using StateLibrary for IPoolManager;

    IUniversalRouter public immutable router;
    IPoolManager public immutable poolManager;
    IPermit2 public immutable permit2;

    constructor(address _router, address _poolManager, address _permit2) {
        router = IUniversalRouter(_router);
        poolManager = IPoolManager(_poolManager);
        permit2 = IPermit2(_permit2);
    }

    // We'll add more functions here
}
```

In this step, we’re importing the necessary contracts and interfaces:

- `UniversalRouter`: This will be our main interface for executing swaps. It provides a flexible way to interact with various Uniswap versions and other protocols.
- `Commands`: This library contains the command definitions used by the UniversalRouter.
- `IPoolManager`: This interface is needed for interacting with Uniswap v4 pools. While we don't directly use it in our simple example, it's often necessary for more complex interactions with v4 pools.
- `IPermit2`: This interface allows us to interact with the Permit2 contract, which provides enhanced token approval functionality.
- `StateLibrary`: This provides optimized functions for interacting with the PoolManager’s state. By using `StateLibrary`, we can more efficiently read and manipulate pool states, which is crucial for many operations in Uniswap v4.

### Step 2: Implement Token Approval with Permit2

`UniversalRouter` integrates with [Permit2](https://github.com/Uniswap/permit2), to enable users to have more safety, flexibility, and control over their ERC20 token approvals.

Before we can execute swaps, we need to ensure our contract can transfer tokens. We’ll implement a function to approve the Universal Router to spend tokens on behalf of our contract.

Here, for testing purposes, we set up our contract to use Permit2 with the UniversalRouter:

```solidity
function approveTokenWithPermit2(
	address token,
	uint160 amount,
	uint48 expiration
) external {
    IERC20(token).approve(address(permit2), type(uint256).max);
    permit2.approve(token, address(router), amount, expiration);
}
```

This function first approves Permit2 to spend the token, then uses Permit2 to approve the UniversalRouter with a specific amount and expiration time.

### Step 3: Implementing a Swap Function

#### 3.1: Function Signature

First, let’s define our function signature:

```solidity
function swapExactInputSingle(
    PoolKey calldata key, // PoolKey struct that identifies the v4 pool
    uint128 amountIn, // Exact amount of tokens to swap
    uint128 minAmountOut, // Minimum amount of output tokens expected
    uint256 deadline // Timestamp after which the transaction will revert
) external returns (uint256 amountOut) {
    // Implementation will follow
}
```
**Important note:**

1. The deadline parameter allows users to specify when their transaction should expire. This protects against unfavorable execution due to network delays or MEV attacks.
2. When swapping tokens involving native ETH, we use `Currency.wrap(address(0))` to represent ETH in the `PoolKey` struct.

```solidity
struct PoolKey {
    /// @notice The lower currency of the pool, sorted numerically.
    ///         For native ETH, Currency currency0 = Currency.wrap(address(0));
    Currency currency0;
    /// @notice The higher currency of the pool, sorted numerically
    Currency currency1;
    /// @notice The pool LP fee, capped at 1_000_000. If the highest bit is 1, the pool has a dynamic fee and must be exactly equal to 0x800000
    uint24 fee;
    /// @notice Ticks that involve positions must be a multiple of tick spacing
    int24 tickSpacing;
    /// @notice The hooks of the pool
    IHooks hooks;
}
```

#### 3.2: Encoding the Swap Command

When encoding a swap command for the Universal Router, we need to choose between two types of swaps:

1. Exact Input Swaps:

Use this swap-type when you know the exact amount of tokens you want to swap in, and you're willing to accept any amount of output tokens above your minimum. This is common when you want to sell a specific amount of tokens.

2. Exact Output Swaps:

Use this swap-type when you need a specific amount of output tokens, and you're willing to spend up to a maximum amount of input tokens. This is useful when you need to acquire a precise amount of tokens, for example, to repay a loan or meet a specific requirement.

Next, we encode the swap command:

```solidity
bytes memory commands = abi.encodePacked(uint8(Commands.V4_SWAP));
```

Here, we're using `V4_SWAP`, which tells the Universal Router that we want to perform a swap on a Uniswap v4 pool. The specific type of swap (exact input or exact output) will be determined by the V4Router actions we encode later. As we saw earlier, we encode this as a single byte, which is how the Universal Router expects to receive commands.

Check the complete list of [commands](https://docs.uniswap.org/contracts/universal-router/technical-reference#command).

#### 3.3: Action Encoding

Now, let’s encode the actions for the swap:

```solidity
// Encode V4Router actions
bytes memory actions = abi.encodePacked(
    uint8(Actions.SWAP_EXACT_IN_SINGLE),
    uint8(Actions.SETTLE_ALL),
    uint8(Actions.TAKE_ALL)
);
```

These actions define the sequence of operations that will be performed in our v4 swap:

1. `SWAP_EXACT_IN_SINGLE`: This action specifies that we want to perform an exact input swap using a single pool.
2. `SETTLE_ALL`: This action ensures all input tokens involved in the swap are properly paid. This is part of v4's settlement pattern for handling token transfers.
3. `TAKE_ALL`: This final action collects all output tokens after the swap is complete.

The sequence of these actions is important as they define the complete flow of our swap operation from start to finish.

#### 3.4: Preparing the Swap Inputs

For our v4 swap, we need to prepare three parameters that correspond to our encoded actions:

```solidity
bytes[] memory params = new bytes[](3);

// First parameter: swap configuration
params[0] = abi.encode(
    IV4Router.ExactInputSingleParams({
        poolKey: key,
        zeroForOne: true,            // true if we're swapping token0 for token1
        amountIn: amountIn,          // amount of tokens we're swapping
        amountOutMinimum: minAmountOut, // minimum amount we expect to receive
        hookData: bytes("")             // no hook data needed
    })
);

// Second parameter: specify input tokens for the swap
// encode SETTLE_ALL parameters
params[1] = abi.encode(key.currency0, amountIn);

// Third parameter: specify output tokens from the swap
params[2] = abi.encode(key.currency1, minAmountOut);
```

Each encoded parameter serves a specific purpose:

1. The first parameter configures how the swap should be executed, defining the pool, amounts, and other swap-specific details
2. The second parameter defines what tokens we're putting into the swap
3. The third parameter defines what tokens we expect to receive from the swap

These parameters work in conjunction with the actions we encoded earlier (`SWAP_EXACT_IN_SINGLE`, `SETTLE_ALL`, and `TAKE_ALL`) to execute our swap operation.

#### 3.5: Executing the Swap

Now we can execute the swap using the Universal Router. It's crucial to allow users to specify their own deadline for transaction execution:

```solidity
// Combine actions and params into inputs
inputs[0] = abi.encode(actions, params);

// Execute the swap with deadline protection
router.execute(commands, inputs, deadline);
```

This prepares and executes the swap based on our encoded commands, actions, and parameters.

> **Note**:  Never use block.timestamp or type(uint256).max as the deadline parameter.
>

#### 3.6: (Optional) Verifying the Swap Output

After the swap, we need to verify that we received at least the minimum amount of tokens we specified:

```solidity
amountOut = IERC20(Currency.unwrap(key.currency1)).balanceOf(address(this));
require(amountOut >= minAmountOut, "Insufficient output amount");
```

#### 3.7: Returning the Result

Finally, we return the amount of tokens we received:

```solidity
return amountOut;
```

This allows the caller of the function to know exactly how many tokens were received in the swap.

Here's the complete swap function that combines all the steps we've covered:

```solidity
function swapExactInputSingle(
    PoolKey calldata key,
    uint128 amountIn,
    uint128 minAmountOut,
    uint256 deadline 
) external returns (uint256 amountOut) {
// Encode the Universal Router command
    bytes memory commands = abi.encodePacked(uint8(Commands.V4_SWAP));
    bytes[] memory inputs = new bytes[](1);

// Encode V4Router actions
    bytes memory actions = abi.encodePacked(
        uint8(Actions.SWAP_EXACT_IN_SINGLE),
        uint8(Actions.SETTLE_ALL),
        uint8(Actions.TAKE_ALL)
    );

// Prepare parameters for each action
    bytes[] memory params = new bytes[](3);
    params[0] = abi.encode(
        IV4Router.ExactInputSingleParams({
            poolKey: key,
            zeroForOne: true,
            amountIn: amountIn,
            amountOutMinimum: minAmountOut,
            hookData: bytes("")
        })
    );
    params[1] = abi.encode(key.currency0, amountIn);
    params[2] = abi.encode(key.currency1, minAmountOut);

// Combine actions and params into inputs
    inputs[0] = abi.encode(actions, params);

// Execute the swap
    router.execute(commands, inputs, deadline);

// Verify and return the output amount
    amountOut = IERC20(Currency.unwrap(key.currency1)).balanceOf(address(this));
    require(amountOut >= minAmountOut, "Insufficient output amount");
    return amountOut;
}
```
</file>

<file path="docs/contracts/v4/guides/unlock-callback.mdx">
---
title: Unlock Callback & Deltas
sidebar_position: 1
---

### Refresher

In order to have access to the liquidity inside the `PoolManager`,
it needs to be _unlocked_ to begin with. After being unlocked, any
number of operations can be executed, which at the end of must be _locked_
again. At this point, if there are any _non-zero deltas_, meaning the
PoolManager is owed or owes tokens back to some address, the whole
execution reverts. Otherwise, both parties have paid or received
the right amount of tokens and the operations have successfully
carried out.

## Unlocking the PoolManager

### Implementing the unlock callback

Prior to unlocking the PoolManager, the integrating contract must
implement the `unlockCallback` function. This function will be
called by the PoolManager after being unlocked. An easy way to
do this is to inherit the `SafeCallback` abstract contract.

```solidity
import {SafeCallback} from "v4-periphery/src/base/SafeCallback.sol";

contract IntegratingContract is SafeCallback {
    constructor(IPoolManager _poolManager) SafeCallback(_poolManager) {}
}
```

### Calling the unlock function

After implementing the callback, the integrating contract can now
invoke the `unlock()` function. It receives a _bytes_ parameter
that is further passed to your callback function as an argument.
This parameter is used to encode the sequence of operations to be
executed in the context of the `PoolManager`.


```solidity
bytes memory unlockData = abi.encode(encode_operations_here);
bytes memory unlockResultData = poolManager.unlock(unlockData);
```

Next, we must override the `_unlockCallback` function inherited from
the `SafeCallback` contract. In your implementation, you should
decode your operations and continue with the desired logic.

```solidity
function _unlockCallback(bytes calldata data) internal override returns (bytes memory) {
    (...) = abi.decode(data, (...));
}
```

## Operations

There are **9** operations that can be done in the `PoolManager`
which fall in two categories: _liquidity-accessing_ and _delta-resolving_.

### Deltas

Deltas are the `PoolManager`'s method to keep track of token amounts it
needs to receive, respectively to distribute. A negative delta signals that
the `PoolManager` is owed tokens, while a positive one expresses a
token balance that needs to be paid to its user.

### Liquidity-accessing

_Liquidity-accessing_ operations will create non-zero _deltas_ and
produce a state transition of the selected pool.
They are the following:

* _modify liquidity_ - used to increase or decrease liquidity; increasing
liquidity will result in a negative token delta, while decreasing yields a positive one
* _swap_ - used to trade one token for another; will result in a negative tokenA delta
and a positive tokenB delta
* _donate_ - used to provide direct token revenue to positions in range;
will result in a negative delta for the pool's tokens the user wishes
to provide

### Delta-resolving

_Delta-resolving_ operations are used to even out the deltas created
by the _liquidity-accessing_ operations. 
They are the following:

* _settle_ - used following token transfers to the manager
or burning of ERC6909 claims to resolve negative deltas
* _take_ - transfer tokens from the manager, used to resolve
positive deltas but also provide token loans, producing negative deltas
* _mint_ - used to create ERC6909 claims, creating a negative delta
that needs to be resolved by transferring the corresponding token and
_settling_ afterwards
* _burn_ - removes ERC6909 claims, creating a positive delta for tokens to
be transferred back to the owner or used in settling negative balances
* _clear_ - used to zero out positive token deltas, helpful to forfeit
insignificant token amounts in order to avoid paying further transfer costs

### Handling Deltas for Liquidity Modifications 

#### When it happens  
- **Building custom routers** that pre-calculate token amounts.  
- **Estimating values** for user interfaces or simulations.  

#### Why It Happens  
- **Pre-calculated amounts** (e.g., from `LiquidityAmounts.getAmountsForLiquidity()`) use static math.  
- **Actual deltas** (from `modifyLiquidity()`) reflect real-time pool state, including:  
  - Tick crossings during execution.  
  - Rounding in fixed-point arithmetic (`Q128.128`).

#### Why LiquidityAmounts ≠ Liquidity Delta

The discrepancy occurs because:

- **Price Movement:** The pool's price changes between pre-calculation and execution
- **Tick Crossings:** Transactions may cross ticks, changing liquidity math
- **Rounding:** Static calculations use idealized math while execution uses Q128.128 fixed-point

#### 📊 Price Movement Example

When ETH/USDC price changes during transaction execution:

```solidity
// Static math calculation
LiquidityAmounts.getAmountsForLiquidity(
    sqrtRatioX96: 3000, // Fixed price
    ...
);

// Interacts with the pool and uses actual execution (reflects real-time price)
poolManager.modifyLiquidity(
    sqrtRatioX96: 3001, // Updated price
    ...
);
```

getAmountsForLiquidity() assumes static 3000 price
modifyLiquidity() reflects actual 3001 price

#### Key Impact  
| Scenario | Risk |  
|----------|------|  
| **Underestimating deltas** | Transactions revert with `CurrencyNotSettled`. |  
| **Overestimating deltas** | Users overpay and lose funds to residual dust. |
| **No slippage check** | Significant financial losses. |

#### Best Practices for Custom Routers 

1. **Never settle without validating against slippage**

    Supposing slippage tolerance is 50 (basis point)

    ```solidity
        require(
            actualAmount0 >= expectedAmount0 * (10_000 - slippageTolerance) / 10_000,
            "Slippage too high (token0)"
        );
        require(
            actualAmount1 >= expectedAmount1 * (10_000 - slippageTolerance) / 10_000,
            "Slippage too high (token1)"
        );
    ```

2. **Use Deltas for Settlement**  
   Always derive final amounts from `modifyLiquidity()` deltas:  
   ```solidity
        CallbackData memory _data = abi.decode(data, (CallbackData));
        (BalanceDelta delta, ) = poolManager.modifyLiquidity(
            _data.key,
            _data.params,
            hex""
        );
        
        _data.key.currency0.settle(poolManager, _data.key.hookAddress, delta.amount0() < 0
            ? uint256(uint128(-delta.amount0()))
            : uint256(uint128(delta.amount0())), false);
         _data.key.currency1.settle(poolManager, _data.key.hookAddress, delta.amount1() < 0
            ? uint256(uint128(-delta.amount1()))
            : uint256(uint128(delta.amount1())), false);
   ```

> ⚠️ **Custom Router Pitfall**  
> When pre-calculating liquidity changes, always account for rounding differences.  
> **Never** assume `getAmountsForLiquidity() == modifyLiquidity()` deltas.
> Enforce slippage post-execution.
</file>

<file path="docs/contracts/v4/quickstart/hooks/_category_.json">
{
  "label": "Hooks",
  "collapsed": true,
  "position": 4
}
</file>

<file path="docs/contracts/v4/quickstart/hooks/async-swap.mdx">
---
title: AsyncSwap Hooks
sidebar_position: 3
---

One feature enabled by [custom accounting](/contracts/v4/guides/custom-accounting) is​​​​‌ AsyncSwap swap. This feature allows hook developers to replace the v4 (v3-style) swap logic.

This means developers can replace Uniswap's internal core logic for how to handle swaps. Two emergent use-cases are possible with custom accounting:

1. Asynchronous swaps and swap-ordering. Delay the v4 swap logic for fulfillment at a later time.
2. Custom Curves. Replace the v4 swap logic with different swap logic. The custom logic is flexible and developers can implement symmetric curves, asymmetric curves, or custom quoting.

> AsyncSwap is typically described as taking the full input to replace the internal swap logic, partially taking the input is better described as *custom accounting*

Note: The flexibility of AsyncSwap means hook developers can implement harmful behavior (such as taking all swap amounts for themselves, charging extra fees, etc.). Hooks with AsyncSwap behavior should be examined very closely by both developers and users.

## Configure a AsyncSwap Hook

To enable AsyncSwap, developers will need the hook permission `BEFORE_SWAP_RETURNS_DELTA_FLAG`

```solidity
import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";
// ...

contract AsyncSwapHook is BaseHook {
    // ...

    function getHookPermissions() public pure virtual override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: false,
            afterAddLiquidity: false,
            beforeRemoveLiquidity: false,
            afterRemoveLiquidity: false,
            beforeSwap: false,
            afterSwap: true,
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: true,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    // ...
}
```

## beforeSwap

AsyncSwap only works on exact-input swaps and the *beforeSwap* **must** take the input currency and return [`BeforeSwapDelta`](/contracts/v4/reference/core/types/beforeswapdelta). The hook should `IPoolManager.mint` itself the corresponding tokens equal to the amount of the input (`amountSpecified`). It should then return a `BeforeSwapDelta` where `deltaSpecified = -amountSpecified` (the positive amount).

The funds' movements are as follows:

1. User initiates a swap, specifying -100 tokenA as input
2. The hook's beforeSwap takes 100 tokenA for itself, and returns a value of 100 to PoolManager. 
3. The PoolManager accounts the 100 tokens against the swap input, leaving 0 tokens remaining
4. The PoolManager does not execute swap logic, as there are no tokens left to swap
5. The PoolManager transfers the delta from the hook to the swap router, in step 2 the hook created a debt (that must be paid)
6. The swap router pays off the debt using the user's tokens

```solidity
contract AsyncSwapHook is BaseHook {
     // ...

    function _beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata)
        internal
        override
        returns (bytes4, BeforeSwapDelta, uint24)
    {
        // AsyncSwap only works on exact-input swaps
        if (params.amountSpecified < 0) {
            // take the input token so that v3-swap is skipped...
            Currency input = params.zeroForOne ? key.currency0 : key.currency1;
            uint256 amountTaken = uint256(-params.amountSpecified);
            poolManager.mint(address(this), input.toId(), amountTaken);

            // to AsyncSwap the exact input, we return the amount that's taken by the hook
            return (BaseHook.beforeSwap.selector, toBeforeSwapDelta(amountTaken.toInt128(), 0), 0);
        }
        else {
            return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO, 0);
        }

    }
}
```

## Testing

To verify the AsyncSwap behaved properly, developers should test the swap and that token balances match expected behavior.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import {Deployers} from "v4-core/test/utils/Deployers.sol";
// ...

contract AsyncSwapTest is Test, Deployers {
    // ...

    function setUp() public {
        // ... 
    }

    function test_asyncSwap() public {
        assertEq(hook.beforeSwapCount(poolId), 0);

        uint256 balance0Before = currency0.balanceOfSelf();
        uint256 balance1Before = currency1.balanceOfSelf();

        // Perform a test swap //
        int256 amount = -1e18;
        bool zeroForOne = true;
        BalanceDelta swapDelta = swap(poolKey, zeroForOne, amount, ZERO_BYTES);
        // ------------------- //

        uint256 balance0After = currency0.balanceOfSelf();
        uint256 balance1After = currency1.balanceOfSelf();

        // user paid token0
        assertEq(balance0Before - balance0After, 1e18);

        // user did not recieve token1 (AsyncSwap)
        assertEq(balance1Before, balance1After);
    }
}
```
</file>

<file path="docs/contracts/v4/quickstart/hooks/liquidity.mdx">
---
title: Liquidity Hooks
sidebar_position: 2
---

This guide will walk through on an example of adding and removing liquidity. There are four hook functions available to customize and extend these behavior:

- `beforeAddLiquidity`
- `afterAddLiquidity`
- `beforeRemoveLiquidity`
- `afterRemoveLiquidity`

As the names suggest `beforeAddLiquidity`/`afterAddLiquidity` are functions called before or after liquidity is added to a pool.
Similarly `beforeRemoveLiquidity`/`afterRemoveLiquidity` are functions called before or after liquidity is removed from a pool.

This guide will go through the parameters and examples specifically for `beforeAddLiquidity` and `beforeRemoveLiquidity`.

Note: The liquidity examples are not production ready code, and are implemented in a simplistic manner for the purpose of learning.

## Set Up the Contract

Declare the solidity version used to compile the contract, since transient storage is used the solidity version will be `>=0.8.24`.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
```

Import the relevant dependencies from `v4-core` and `v4-periphery`:

```solidity
import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";

import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";
```

Create a contract called LiquidityHook, use `PoolIdLibrary` to attach functions of computing ID of a pool to `PoolKey`. Declare two mappings to act as counters when calling `beforeAddLiquidity` and `beforeRemoveLiquidity`.

```solidity
contract LiquidityHook is BaseHook {
    using PoolIdLibrary for PoolKey;

    // NOTE: ---------------------------------------------------------
    // state variables should typically be unique to a pool
    // a single hook contract should be able to service multiple pools
    // ---------------------------------------------------------------

    mapping(PoolId => uint256 count) public beforeAddLiquidityCount;
    mapping(PoolId => uint256 count) public beforeRemoveLiquidityCount;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}
```

Override `getHookPermissions` from `BaseHook.sol` to return a struct of permissions to signal which hook functions are to be implemented.
It will also be used at deployment to validate the address correctly represents the expected permissions.

```solidity
function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
    return Hooks.Permissions({
        beforeInitialize: false,
        afterInitialize: false,
        beforeAddLiquidity: true,
        afterAddLiquidity: false,
        beforeRemoveLiquidity: true,
        afterRemoveLiquidity: false,
        beforeSwap: false,
        afterSwap: false,
        beforeDonate: false,
        afterDonate: false,
        beforeAddLiquidityReturnDelta: false,
        afterSwapReturnDelta: false,
        afterAddLiquidityReturnDelta: false,
        afterRemoveLiquidityReturnDelta: false
    });
}
```

## beforeAddLiquidity

Here the example shows that every time __before__ liquidity is added to a pool, `beforeAddLiquidityCount` for that pool will be incremented by one.

```solidity
function _beforeAddLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata,
    bytes calldata
) internal override returns (bytes4) {
    beforeAddLiquidityCount[key.toId()]++;
    return BaseHook.beforeAddLiquidity.selector;
}
```

### `beforeAddLiquidity` Parameters

When triggering the `beforeAddLiquidity` hook function, there are some parameters we can make use of to customize or extend the behavior of `modifyLiquidity`. These parameters are described in `beforeAddLiquidity` from [`IHooks.sol`](https://github.com/Uniswap/v4-core/blob/main/src/interfaces/IHooks.sol#L47).

A brief overview of the parameters:
- `sender` The initial `msg.sender` for the add liquidity call
- `key` The key for the pool
- `params` The parameters for adding liquidity i.e. `ModifyLiquidityParams` from [`IPoolManager.sol`](https://github.com/Uniswap/v4-core/blob/main/src/interfaces/IPoolManager.sol#L125C12-L125C33)
- `hookData` Arbitrary data handed into the `PoolManager` by the liquidity provider to be be passed on to the hook

## beforeRemoveLiquidity

Similiar as above, every time __before__ liquidity is removed from a pool, `beforeRemoveLiquidityCount` for that pool will be incremented by one.

```solidity
function _beforeRemoveLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata,
    bytes calldata
) internal override returns (bytes4) {
    beforeRemoveLiquidityCount[key.toId()]++;
    return BaseHook.beforeRemoveLiquidity.selector;
}
```

### `beforeRemoveLiquidity` Parameters

When triggering the `beforeRemoveLiquidity` hook function, there are some parameters we can make use of to customize or extend the behavior of `modifyLiquidity`. These parameters are described in `beforeRemoveLiquidity` from [`IHooks.sol`](https://github.com/Uniswap/v4-core/blob/main/src/interfaces/IHooks.sol#L78).

A brief overview of the parameters:
- `sender` The initial msg.sender for the remove liquidity call
- `key` The key for the pool
- `params` The parameters for removing liquidity i.e. `ModifyLiquidityParams` from [`IPoolManager.sol`](https://github.com/Uniswap/v4-core/blob/main/src/interfaces/IPoolManager.sol#L125C12-L125C33)
- `hookData` Arbitrary data handed into the `PoolManager` by the liquidity provider to be be passed on to the hook
   
## A Complete Liquidity Hook Contract

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";

import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";

contract LiquidityHook is BaseHook {
    using PoolIdLibrary for PoolKey;

    // NOTE: ---------------------------------------------------------
    // state variables should typically be unique to a pool
    // a single hook contract should be able to service multiple pools
    // ---------------------------------------------------------------

    mapping(PoolId => uint256 count) public beforeAddLiquidityCount;
    mapping(PoolId => uint256 count) public beforeRemoveLiquidityCount;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: true,
            afterAddLiquidity: false,
            beforeRemoveLiquidity: true,
            afterRemoveLiquidity: false,
            beforeSwap: false,
            afterSwap: false,
            beforeDonate: false,
            afterDonate: false,
            beforeAddLiquidityReturnDelta: false,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    // -----------------------------------------------
    // NOTE: see IHooks.sol for function documentation
    // -----------------------------------------------

    function _beforeAddLiquidity(
        address,
        PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata,
        bytes calldata
    ) internal override returns (bytes4) {
        beforeAddLiquidityCount[key.toId()]++;
        return BaseHook.beforeAddLiquidity.selector;
    }

    function _beforeRemoveLiquidity(
        address,
        PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata,
        bytes calldata
    ) internal override returns (bytes4) {
        beforeRemoveLiquidityCount[key.toId()]++;
        return BaseHook.beforeRemoveLiquidity.selector;
    }
}
```
</file>

<file path="docs/contracts/v4/quickstart/hooks/setup.mdx">
---
title:  Set Up Local Environment
sidebar_position: 0
---

Before writing the hook let's first have a local environment properly configured e.g. deploying pool manager, utility routers and test tokens. 

At the end of this guide a development environment will be set up to be used to build the rest of the examples in the Guides section of the docs.

To get started as quickly as possible for building Uniswap v4 hooks, there is a `Quick Start` section below to clone a boilerplate and get building. To start from scratch and learn the underlying concepts, jump to the `Start from Scratch` section.

## Quick Start

The Uniswap [v4-template repo](https://github.com/uniswapfoundation/v4-template) provides a basic foundry environment with required imports already pre-loaded. Click on [`Use this template`](https://github.com/new?template_name=v4-template&template_owner=uniswapfoundation) to create a new repository with it.

Or simply clone it and install the dependencies:

```bash
git clone https://github.com/uniswapfoundation/v4-template.git
cd v4-template
# requires foundry
forge install
forge test
```

Then hop to the [Local Node via Anvil](#local-node-via-anvil) to complete the set up and start developing.

---

## Start from Scratch

In the following sections, let's walk through the steps to create the same environment set up as the boilerplate from scratch and learn the underlying concepts.

### Setting up Foundry

First thing is to set up a new Foundry project. 

If there is no Foundry installed - follow the [Foundry Book](https://book.getfoundry.sh/getting-started/installation) for installation.

Once Foundry is setup, initialize a new project:

```bash
forge init counter-hook
cd counter-hook
```

Then install the Uniswap `v4-core` and `v4-periphery` contracts as dependencies:

```bash
forge install Uniswap/v4-core && forge install Uniswap/v4-periphery
```

Next, set up the remappings so that the shorthand syntax for importing contracts from the dependencies work nicely:

```bash
forge remappings > remappings.txt
```

> If there is something wrong with the inferred remappings, please replace with the following in `remappings.txt`:

```
@uniswap/v4-core/=lib/v4-core/
forge-gas-snapshot/=lib/v4-core/lib/forge-gas-snapshot/src/
forge-std/=lib/v4-core/lib/forge-std/src/
permit2/=lib/v4-periphery/lib/permit2/
solmate/=lib/v4-core/lib/solmate/
v4-core/=lib/v4-core/
v4-periphery/=lib/v4-periphery/
```

After that, remove the default Counter contract and its associated test and script file that Foundry initially set up. To do that, either manually delete those files, or just run the following:

```bash
rm ./**/Counter*.sol
```

Finally, since v4 uses transient storage which is only available after Ethereum's cancun hard fork and on Solidity versions >= 0.8.24 - some config must be set in `foundry.toml` config file. 

To do that, add the following lines to `foundry.toml`:

```toml
# foundry.toml

solc_version = "0.8.26"
evm_version = "cancun"
ffi = true
```

Awesome! Now it's all set to start building the hook! Let’s run a quick test to confirm everything is set up properly.

### Compile a Basic Hook Contract

To confirm that the environment is configured correctly let's write a basic Counter Hook contract. Create a new file, `./src/CounterHook.sol` and paste the following code into it:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";

import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";

contract CounterHook is BaseHook {
    using PoolIdLibrary for PoolKey;

    // NOTE: ---------------------------------------------------------
    // state variables should typically be unique to a pool
    // a single hook contract should be able to service multiple pools
    // ---------------------------------------------------------------

    mapping(PoolId => uint256 count) public beforeSwapCount;
    mapping(PoolId => uint256 count) public afterSwapCount;

    mapping(PoolId => uint256 count) public beforeAddLiquidityCount;
    mapping(PoolId => uint256 count) public beforeRemoveLiquidityCount;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: true,
            afterAddLiquidity: false,
            beforeRemoveLiquidity: true,
            afterRemoveLiquidity: false,
            beforeSwap: true,
            afterSwap: true,
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: false,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    // -----------------------------------------------
    // NOTE: see IHooks.sol for function documentation
    // -----------------------------------------------

    function _beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, bytes calldata)
        internal
        override
        returns (bytes4, BeforeSwapDelta, uint24)
    {
        beforeSwapCount[key.toId()]++;
        return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);
    }

    function _afterSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)
        internal
        override
        returns (bytes4, int128)
    {
        afterSwapCount[key.toId()]++;
        return (BaseHook.afterSwap.selector, 0);
    }

    function _beforeAddLiquidity(
        address,
        PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata,
        bytes calldata
    ) internal override returns (bytes4) {
        beforeAddLiquidityCount[key.toId()]++;
        return BaseHook.beforeAddLiquidity.selector;
    }

    function _beforeRemoveLiquidity(
        address,
        PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata,
        bytes calldata
    ) internal override returns (bytes4) {
        beforeRemoveLiquidityCount[key.toId()]++;
        return BaseHook.beforeRemoveLiquidity.selector;
    }
}
```

To compile the Counter Hook contracts in the `./src` folder, use the foundry build command:

```bash
forge build
```

If the environment is compiled correctly it will display a message:

```
Compiler run successful!
```

### Local Node via Anvil

Other than writing unit tests, [Anvil](https://book.getfoundry.sh/anvil/) can be used to deploy and test hooks.

With the local node up and running, use the `--rpc-url 127.0.0.1:8545` flag in tests to point the Foundry testing suite to that local node:

```bash
# start anvil, a local EVM chain
anvil

# in a new terminal
# foundry script for deploying v4 & hooks to anvil
forge script script/Anvil.s.sol \
    --rpc-url http://localhost:8545 \
    --private-key <test_wallet_private_key> \
    --broadcast

# test on the anvil local node
forge test --rpc-url 127.0.0.1:8545
```

## Next Steps
With the environment set up ready to be built on. Jump over to the guides section to learn about the Uniswap functions that can be integrated with Hook. Remember to add all contracts (.sol files) to the `./src` folder and their subsequent tests to the `./test` folder. Then test them against the local anvil node by running:

```bash
forge test --rpc-url 127.0.0.1:8545
```

## Appendix: OpenZeppelin Hooks Library

> [OpenZeppelin Hooks Library](https://docs.openzeppelin.com/uniswap-hooks/1.x/), included in [v4-template](https://github.com/uniswapfoundation/v4-template), provides secure and modular reference implementations for Uniswap v4 Hooks!

If you're starting from scratch, you can install the OpenZeppelin Hooks library:

```bash
$ forge install OpenZeppelin/uniswap-hooks
```

The library includes:
- **BaseHook**: Core scaffolding with security checks and permission management
- **BaseCustomAccounting**: For implementing hook-owned liquidity and custom token accounting
- **BaseCustomCurve**: For replacing default concentrated liquidity math with custom swap logic
- **BaseAsyncSwap**: For implementing non-atomic and asynchronous swaps
- **BaseDynamicFee**: For implementing dynamic fee pools
- **BaseOverrideFee**: For implementing dynamic fees on every swap
- **BaseDynamicAfterFee**: For implementing post-swap fee adjustments based on actual swap output
</file>

<file path="docs/contracts/v4/quickstart/hooks/swap.mdx">
---
title: Swap Hooks
sidebar_position: 1
---

Swaps are the most common interaction with the Uniswap protocol. When it comes to swap there are two hook functions available to customize and extend its behavior:

- `beforeSwap`
- `afterSwap`

As the names suggest `beforeSwap`/`afterSwap` are functions called before or after a swap is executed on a pool.

This guide will go through the parameters for `beforeSwap` and `afterSwap`, and a simple example of a swap hook.

Note: The swap hook is not production ready code, and is implemented in a simplistic manner for the purpose of learning.

## Set Up the Contract

Declare the solidity version used to compile the contract, here we will use `>=0.8.24` for the solidity version as transient storage is used.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
```

Import the relevant dependencies from `v4-core` and `v4-periphery`:

```solidity
import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";

import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";
```

Create a contract called `SwapHook`, use `PoolIdLibrary` to attach functions of computing `poolId` for `PoolKey`. Declare two mappings as counters for `beforeSwap` and `afterSwap`.

```solidity
contract SwapHook is BaseHook {
    using PoolIdLibrary for PoolKey;

    // NOTE: ---------------------------------------------------------
    // state variables should typically be unique to a pool
    // a single hook contract should be able to service multiple pools
    // ---------------------------------------------------------------

    mapping(PoolId => uint256 count) public beforeSwapCount;
    mapping(PoolId => uint256 count) public afterSwapCount;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}
```

Override `getHookPermissions()` from `BaseHook` to return a struct of permissions to signal which hook functions are to be implemented.
It will also be used at deployment to validate the hook address correctly represents the expected permissions.

```solidity
function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
    return Hooks.Permissions({
        beforeInitialize: false,
        afterInitialize: false,
        beforeAddLiquidity: false,
        afterAddLiquidity: false,
        beforeRemoveLiquidity: false,
        afterRemoveLiquidity: false,
        beforeSwap: true,
        afterSwap: true,
        beforeDonate: false,
        afterDonate: false,
        beforeSwapReturnDelta: false,
        afterSwapReturnDelta: false,
        afterAddLiquidityReturnDelta: false,
        afterRemoveLiquidityReturnDelta: false
    });
}
```

## beforeSwap

Here the example shows that every time __before__ a swap is executed in a pool, `beforeSwapCount` for that pool will be incremented by one.

```solidity
function _beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, bytes calldata)
    internal
    override
    returns (bytes4, BeforeSwapDelta, uint24)
{
    beforeSwapCount[key.toId()]++;
    return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);
}
```

### `beforeSwap` Parameters

When triggering the `beforeSwap` hook function, there are some parameters we can make use of to customize or extend the behavior of `swap`. These parameters are described in [`beforeSwap`](/contracts/v4/reference/core/interfaces/IHooks#beforeswap) from `IHooks`.

A brief overview of the parameters:
- `sender` The initial `msg.sender` for the `PoolManager.swap` call - typically a swap router
- `key` The key for the pool
- `params` The parameters for the swap i.e. [`SwapParams`](/contracts/v4/reference/core/interfaces/IPoolManager#swapparams) from `IPoolManager`
- `hookData` Arbitrary data handed into the `PoolManager` by the swapper to be passed on to the hook

## afterSwap

Similiar as above, every time __after__ a swap is executed in a pool, `afterSwapCount` for that pool will be incremented by one.

```solidity
function _afterSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)
    internal
    override
    returns (bytes4, int128)
{
    afterSwapCount[key.toId()]++;
    return (BaseHook.afterSwap.selector, 0);
}
```

### `afterSwap` Parameters

When triggering the `afterSwap` hook function, there are some parameters we can make use of to customize or extend the behavior of `swap`. These parameters are described in [`afterSwap`](/contracts/v4/reference/core/interfaces/IPoolManager#swapparams) from `IHooks`.

A brief overview of the parameters:
- `sender` The initial `msg.sender` for the `PoolManager.swap` call - typically a swap router
- `key` The key for the pool
- `params` The parameters for the swap i.e. [`SwapParams`](/contracts/v4/reference/core/interfaces/IPoolManager#swapparams) from `IPoolManager`
- `delta` The amount owed to the caller (positive) or owed to the pool (negative)
- `hookData` Arbitrary data handed into the `PoolManager` by the swapper to be passed on to the hook
   


## A Complete Swap Hook Contract

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";

import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";

contract SwapHook is BaseHook {
    using PoolIdLibrary for PoolKey;

    // NOTE: ---------------------------------------------------------
    // state variables should typically be unique to a pool
    // a single hook contract should be able to service multiple pools
    // ---------------------------------------------------------------

    mapping(PoolId => uint256 count) public beforeSwapCount;
    mapping(PoolId => uint256 count) public afterSwapCount;

    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: true,
            afterAddLiquidity: false,
            beforeRemoveLiquidity: true,
            afterRemoveLiquidity: false,
            beforeSwap: true,
            afterSwap: true,
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: false,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    // -----------------------------------------------
    // NOTE: see IHooks.sol for function documentation
    // -----------------------------------------------

    function _beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, bytes calldata)
        internal
        override
        returns (bytes4, BeforeSwapDelta, uint24)
    {
        beforeSwapCount[key.toId()]++;
        return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);
    }

    function _afterSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)
        internal
        override
        returns (bytes4, int128)
    {
        afterSwapCount[key.toId()]++;
        return (BaseHook.afterSwap.selector, 0);
    }
}
```
</file>

<file path="docs/contracts/v4/quickstart/manage-liquidity/_category_.json">
{
  "label": "Manage Liquidity",
  "collapsed": true,
  "position": 2
}
</file>

<file path="docs/contracts/v4/quickstart/manage-liquidity/batch-liquidity.mdx">
---
title: Batch Modify
sidebar_position: 6
---

### Context

As seen in previous guides, `PositionManager` is a command-based contract. This design is conducive to 
batching complex liquidity operations. For example, developers can encode efficient logic to move
liquidity between two positions on entirely different Pools. 

### Setup

See the [setup guide](./00-setup-liquidity.mdx)

## Guide

Below is a general reference guide for batch-operating on multiple liquidity positions, in *solidity*.
This guide does _not_ focus on a specific batch sequence, and is intended to be a general guide for `PositionManager`'s command-based interface.

### 1. Encoded Actions

Actions are divided into two types: _liquidity-operations_ and _delta-resolving_.

* _liquidity-operations_ - actions which that incur a *balance-change*, a change in the pool's liquidity
* _delta-resolving_ - actions which facilitate token transfers, such as _settling_ and _taking_

The _ordering_ of `actions` determines the sequence of operations. The minimum number of actions is roughly two actions; and the maximum is limited by block gas limit.
Additionally, _liquidity-operations_ do not have to happen prior to _delta-resolving_ actions. Developers can mix / alternate between
the two types of actions.

> **However** is good practice to perform _liquidity-operations_ before _delta-resolving_ actions. Minimizing token transfers
and leveraging [_flash accounting_](../../concepts/02-flash-accounting.mdx) is more gas efficient

Example: `Action.Y` happens after `Action.X` but before `Action.Z`
```solidity
import {Actions} from "v4-periphery/src/libraries/Actions.sol";

bytes memory actions = abi.encodePacked(uint8(Actions.X), uint8(Actions.Y), uint8(Actions.Z), ...);
```

**A Note on Special Actions**:

`PositionManager` supports a few _delta-resolving_ actions beyond the standard `SETTLE` and `TAKE` actions

* `CLOSE_CURRENCY` - automatically determines if a currency should be settled (paid) or taken. Used for cases where callers may not know the final delta
* `CLEAR_OR_TAKE`- forfeit tokens if the amount is below a specified threshold, otherwise take the tokens. Used for cases where callers may expect to produce dust
* `SWEEP` - return any excess token balances to a recipient. Used for cases where callers may conversatively overpay tokens

### 2. Encoded Parameters

Each action has its own parameters to encode. Generally:

* _liquidity-operations_ - encode tokenIds, liquidity amounts, and slippage

* _delta-resolving_ - encode currencies, amounts, and recipients

Because actions are ordered, the parameters "zip" with their corresponding actions. The second parameter corresponds to the second action.
Every action has its own encoded parameters

```solidity
bytes[] memory params = new bytes[](3);

params[0] = abi.encode(...); // parameters for the first action
params[1] = abi.encode(...); // parameters for the second action
params[2] = abi.encode(...); // parameters for the third action
```

### 3. Submit Call

The entrypoint for all liquidity operations is `modifyLiquidities()`

```solidity
uint256 deadline = block.timestamp + 60;

posm.modifyLiquidities(
    abi.encode(actions, params),
    deadline
);
```
</file>

<file path="docs/contracts/v4/quickstart/manage-liquidity/burn-liquidity.mdx">
---
title: Burn Position
sidebar_position: 5
---

### Context

To liquidate a position, the _burn_ functionality can be invoked.
The funds in the position will be withdrawn and
all the information of the underlying token will be cleared.
Burning the position is a cost effective way to
exit as a liquidity provider.

### Setup

See the [setup guide](./00-setup-liquidity.mdx)

## Guide

Below is a step-by-step guide to burn a position.

### 1. Import and define `IPositionManager`

```solidity
import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";

// inside a contract, test, or foundry script:
IPositionManager posm = IPositionManager(<address>);
```

### 2. Encode Actions

To burn a position, two actions are required:

* burn operation - clears position entirely, withdrawing funds
* take pair - sends withdrawn funds to the recipient

```solidity
import {Actions} from "v4-periphery/src/libraries/Actions.sol";

bytes memory actions = abi.encodePacked(uint8(Actions.BURN_POSITION), uint8(Actions.TAKE_PAIR));
```

### 3. Encode Parameters

```solidity
bytes[] memory params = new bytes[](2);
```

The `BURN_POSITION` action requires the following parameters:

| Parameter    | Type      | Description                                                                   |
|--------------|-----------|-------------------------------------------------------------------------------|
| `tokenId`    | _uint256_ | position identifier                                                           |
| `amount0Min` | _uint128_ | the minimum amount of currency0 liquidity msg.sender is expecting to get back |
| `amount1Min` | _uint128_ | the minimum amount of currency1 liquidity msg.sender is expecting to get back |
| `hookData`   | _bytes_   | arbitrary data that will be forwarded to hook functions                       |

```solidity
params[0] = abi.encode(tokenId, amount0Min, amount1Min, hookData);
```

The `TAKE_PAIR` action requires the following parameters:

| Parameter    | Type      | Description                           |
|--------------|-----------|---------------------------------------|
| `currency0`  | _Currency_| first token currency                  |
| `currency1`  | _Currency_| second token currency                 |
| `recipient`  | _address_ | address that will receive the tokens  |

```solidity
params[1] = abi.encode(currency0, currency1, recipient);
```

### 4. Submit Call

The entrypoint for all liquidity operations is `modifyLiquidities()`

```solidity
uint256 deadline = block.timestamp + 60;

posm.modifyLiquidities(
    abi.encode(actions, params),
    deadline
);
```
</file>

<file path="docs/contracts/v4/quickstart/manage-liquidity/collect.mdx">
---
title: Collect Fees
sidebar_position: 4
---

### Setup

See the [setup guide](./setup-liquidity.mdx)

## Guide

In order to collect fees, the integrator must execute encoded actions
using the `PositionManager` contract. **Note** that there is no
`COLLECT` command, instead developers must decrease liquidity with a zero
liquidity change.

### 1. Import and define `IPositionManager`

```solidity
import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";
// inside a contract, test, or foundry script:
IPositionManager posm = IPositionManager(<address>);
```

### 2. Encode actions

To collect fees, the following operations are required:
* decrease liquidity - collect fees from the core contract
* take pair - transfer the fee revenue, as both tokens, to a recipient

```solidity
import {Actions} from "v4-periphery/src/libraries/Actions.sol";
bytes memory actions = abi.encodePacked(uint8(Actions.DECREASE_LIQUIDITY), uint8(Actions.TAKE_PAIR));
```

### 3. Encode Parameters

```solidity
bytes[] memory params = new bytes[](2);
```

The `DECREASE_LIQUIDITY` action requires the following parameters:

| Parameter    | Type      | Description                                                                   |
|--------------|-----------|-------------------------------------------------------------------------------|
| `tokenId`    | _uint256_ | position identifier                                                           |
| `liquidity`  | _uint256_ | the amount of liquidity to withdraw                                           |
| `amount0Min` | _uint128_ | the minimum amount of currency0 liquidity msg.sender is expecting to get back |
| `amount1Min` | _uint128_ | the minimum amount of currency1 liquidity msg.sender is expecting to get back |
| `hookData`   | _bytes_   | arbitrary data that will be forwarded to hook functions                       |

**Note** that in order to collect fees we will default `liquidity`, `amount0Min` and `amount1Min` to 0.
Because fee collection can not be manipulated in a front-run attack, it is safe to set the slippage
values `amount0Min, amount1Min` to `0`.

```solidity
/// @dev collecting fees is achieved with liquidity=0, the second parameter
params[0] = abi.encode(tokenId, 0, 0, 0, hookData);
```

The `TAKE_PAIR` action requires the following parameters:

* `currency0` - _Currency_, one of the tokens to be paid by msg.sender
* `currency1` - _Currency_, the other token to be paid by msg.sender
* `recipient` - _address_, destination of the fee revenue for both tokens

```solidity
Currency currency0 = Currency.wrap(<tokenAddress1>); // tokenAddress1 = 0 for native ETH
Currency currency1 = Currency.wrap(<tokenAddress2>);
params[1] = abi.encode(currency0, currency1, recipient);
```

### 4. Submit Call

The entrypoint for all liquidity operations is `modifyLiquidities()`.

```solidity
uint256 deadline = block.timestamp + 60;

uint256 valueToPass = currency0.isAddressZero() ? amount0Max : 0;

posm.modifyLiquidities{value: valueToPass}(
    abi.encode(actions, params),
    deadline
);
```

## Additional notes:

* To obtain the amount of fees received, callers should read
token balances before and after the `.modifyLiquidities()` call.
</file>

<file path="docs/contracts/v4/quickstart/manage-liquidity/decrease-liquidity.mdx">
---
title: Decrease Liquidity
sidebar_position: 3
---

### Context

Please note that `PositionManager` is a command-based contract, where integrators will be encoding commands and their corresponding
parameters.

Decreasing liquidity assumes the position already exists and the user wants to remove tokens from the position.

### Setup

See the [setup guide](./00-setup-liquidity.mdx)

## Guide

Below is a step-by-step guide for decreasing a position's liquidity, in *solidity*.

### 1. Import and define `IPositionManager`

```solidity
import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";

// inside a contract, test, or foundry script:
IPositionManager posm = IPositionManager(<address>);
```

### 2. Encode Actions

To decrease a position's liquidity, the first action must be:

* _decrease_ operation - the subtraction of liquidity to an existing position.

For _delta resolving_ operations, developers may need to choose between `TAKE_PAIR`, `CLOSE_CURRENCY`, or `CLEAR_OR_TAKE` actions.

> In Uniswap v4, fee revenue is automatically debited to a position on decreasing liquidity

If decreasing the liquidity requires the transfer of both tokens:

* _take pair_ - receives a pair of tokens, to decrease liquidity

Otherwise:

* _clear or take_ - if the token amount to-be-collected is below a threshold, opt to forfeit the dust. Otherwise, claim the tokens

```solidity
import {Actions} from "v4-periphery/src/libraries/Actions.sol";
```

If both tokens need to be sent:
```solidity
bytes memory actions = abi.encodePacked(uint8(Actions.DECREASE_LIQUIDITY), uint8(Actions.TAKE_PAIR));
```

If converting fees to liquidity, forfeiting dust:
```solidity
bytes memory actions = abi.encodePacked(uint8(Actions.DECREASE_LIQUIDITY), uint8(Actions.CLEAR_OR_TAKE), uint8(Actions.CLEAR_OR_TAKE));
```

### 3. Encoded Parameters

When taking pair:

```solidity
bytes[] memory params = new bytes[](2);
```

Otherwise:

```solidity
bytes[] memory params = new bytes[](3);
```

The `DECREASE_LIQUIDITY` action requires the following parameters:

| Parameter    | Type      | Description                                                                   |
|--------------|-----------|-------------------------------------------------------------------------------|
| `tokenId`    | _uint256_ | position identifier                                                           |
| `liquidity`  | _uint256_ | the amount of liquidity to remove                                             |
| `amount0Min` | _uint128_ | the minimum amount of currency0 liquidity msg.sender is willing to receive    |
| `amount1Min` | _uint128_ | the minimum amount of currency1 liquidity msg.sender is willing to receive    |
| `hookData`   | _bytes_   | arbitrary data that will be forwarded to hook functions                       |

```solidity
params[0] = abi.encode(tokenId, liquidity, amount0Min, amount1Min, hookData);
```

The `TAKE_PAIR` action requires the following parameters:

* `currency0` - _Currency_, one of the tokens to be received
* `currency1` - _Currency_, the other token to be received
* `recipient` - _Recipient_, the recipient to receive the tokens

In the above case, the parameter encoding is:

```solidity
Currency currency0 = Currency.wrap(<tokenAddress1>); // tokenAddress1 = 0 for native ETH
Currency currency1 = Currency.wrap(<tokenAddress2>);
params[1] = abi.encode(currency0, currency1, recipient);
``` 

The `CLEAR_OR_TAKE` action requires one `currency` and:

* `amountMax` - _uint256_, the maximum threshold to concede dust,
otherwise taking the dust. 

In this case, the parameter encoding is:

```solidity
params[1] = abi.encode(currency0, amount0Max);
params[2] = abi.encode(currency1, amount1Max);
```

### 4. Submit Call

The entrypoint for all liquidity operations is `modifyLiquidities()`.

```solidity
uint256 deadline = block.timestamp + 60;

uint256 valueToPass = currency0.isAddressZero() ? amount0Max : 0;

posm.modifyLiquidities{value: valueToPass}(
    abi.encode(actions, params),
    deadline
);
```
</file>

<file path="docs/contracts/v4/quickstart/manage-liquidity/increase-liquidity.mdx">
---
title: Increase Liquidity
sidebar_position: 2
---

### Context

Please note that `PositionManager` is a command-based contract, where integrators will be encoding commands and their corresponding
parameters.

Increasing liquidity assumes the position already exists and the user wants to add more tokens to the position.

### Setup

See the [setup guide](./00-setup-liquidity.mdx)

## Guide

Below is a step-by-step guide for increasing a position's liquidity, in *solidity*.

### 1. Import and define `IPositionManager`

```solidity
import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";

// inside a contract, test, or foundry script:
IPositionManager posm = IPositionManager(<address>);
```

### 2. Encode Actions

To increase a position's liquidity, the first action must be:

* _increase_ operation - the addition of liquidity to an existing position.

For _delta resolving_ operations, developers may need to choose between `SETTLE_PAIR`, `CLOSE_CURRENCY`, or `CLEAR_OR_TAKE` actions.

> In Uniswap v4, fee revenue is automatically credited to a position on increasing liquidity

> There are some cases, where the fee revenue can entirely "pay" for a liquidity increase, and remainder tokens need to be collected

If increasing the liquidity requires the transfer of both tokens:

* _settle pair_ - pays a pair of tokens, to increase liquidity

**If increasing the liquidity for ETH positions, a third action is required:**

* _sweep_ - to recover excess eth sent to the position manager

Otherwise:

* _close currency_ - automatically determines if a currency should be settled or taken.
* OR _clear or take_ - if the token amount to-be-collected is below a threshold, opt to forfeit the dust. Otherwise, claim the tokens

```solidity
import {Actions} from "v4-periphery/src/libraries/Actions.sol";
```

If both tokens need to be sent:
```solidity
bytes memory actions = abi.encodePacked(uint8(Actions.INCREASE_LIQUIDITY), uint8(Actions.SETTLE_PAIR));
```

If increasing liquidity for ETH positions:
```solidity
bytes memory actions = abi.encodePacked(uint8(Actions.INCREASE_LIQUIDITY), uint8(Actions.SETTLE_PAIR), uint8(Actions.SWEEP));
```

If converting fees to liquidity, and expect excess fees to be collected
```solidity
bytes memory actions = abi.encodePacked(uint8(Actions.INCREASE_LIQUIDITY), uint8(Actions.CLOSE_CURRENCY), uint8(Actions.CLOSE_CURRENCY));
```

If converting fees to liquidity, forfeiting dust:
```solidity
bytes memory actions = abi.encodePacked(uint8(Actions.INCREASE_LIQUIDITY), uint8(Actions.CLEAR_OR_TAKE), uint8(Actions.CLEAR_OR_TAKE));
```

### 3. Encoded Parameters

When settling pair (for non-ETH positions):

```solidity
bytes[] memory params = new bytes[](2);
```

Otherwise:

```solidity
bytes[] memory params = new bytes[](3);
```

The `INCREASE_LIQUIDITY` action requires the following parameters:

| Parameter    | Type      | Description                                                                   |
|--------------|-----------|-------------------------------------------------------------------------------|
| `tokenId`    | _uint256_ | position identifier                                                           |
| `liquidity`  | _uint256_ | the amount of liquidity to add                                                |
| `amount0Max` | _uint128_ | the maximum amount of currency0 liquidity msg.sender is willing to pay        |
| `amount1Max` | _uint128_ | the maximum amount of currency1 liquidity msg.sender is willing to pay        |
| `hookData`   | _bytes_   | arbitrary data that will be forwarded to hook functions                       |

```solidity
params[0] = abi.encode(tokenId, liquidity, amount0Max, amount1Max, hookData);
```

The `SETTLE_PAIR` action requires the following parameters:

* `currency0` - _Currency_, one of the tokens to be paid by msg.sender
* `currency1` - _Currency_, the other token to be paid by msg.sender

In the above case, the parameter encoding is:

```solidity
Currency currency0 = Currency.wrap(<tokenAddress1>); // tokenAddress1 = 0 for native ETH
Currency currency1 = Currency.wrap(<tokenAddress2>);
params[1] = abi.encode(currency0, currency1);
```

The `SWEEP` action requires the following parameters:

* `currency` - _Currency_, token to sweep - most commonly native Ether: `CurrencyLibrary.ADDRESS_ZERO`
* `recipient` - _address_, where to send excess tokens

In this case, the parameter encoding is:

```solidity
params[2] = abi.encode(currency, recipient);
```

The `CLOSE_CURRENCY` action requires only one `currency` parameter
and the encoding is:

```solidity
params[1] = abi.encode(currency0)
params[2] = abi.encode(currency1)
```

The `CLEAR_OR_TAKE` action requires one `currency` and:

* `amountMax` - _uint256_, the maximum threshold to concede dust,
otherwise taking the dust. 

In this case, the parameter encoding is:

```solidity
params[1] = abi.encode(currency0, amount0Max);
params[2] = abi.encode(currency1, amount1Max);
```

### 4. Submit Call

The entrypoint for all liquidity operations is `modifyLiquidities()`.

```solidity
uint256 deadline = block.timestamp + 60;

uint256 valueToPass = currency0.isAddressZero() ? amount0Max : 0;

posm.modifyLiquidities{value: valueToPass}(
    abi.encode(actions, params),
    deadline
);
```
</file>

<file path="docs/contracts/v4/quickstart/manage-liquidity/mint-position.mdx">
---
title: Mint Position
sidebar_position: 1
---

Similar to Uniswap v3, liquidity positions are minted as ERC-721 tokens and depend on a *periphery* contract.
v4's `PositionManager` contract will facilitate liquidity management

## Context

Please note that `PositionManager` is a command-based contract, where integrators will be encoding commands and their corresponding
parameters.

## Setup

See the [setup guide](./00-setup-liquidity.mdx)

## Guide

Below is a step-by-step guide for minting a v4 liquidity position, in *solidity*

### 1. Import and define `IPositionManager`

```solidity
import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";

// inside a contract, test, or foundry script:
IPositionManager posm = IPositionManager(<address>);
```

### 2. Encode Actions

To mint a position, two actions are required:

* mint operation - the creation of the liquidity position
* settle pair - the two tokens to be paid by msg.sender

**If providing ETH liquidity, a third action is required:**
* sweep - to recover excess eth sent to the position manager

```solidity
import {Actions} from "v4-periphery/src/libraries/Actions.sol";

bytes memory actions = abi.encodePacked(uint8(Actions.MINT_POSITION), uint8(Actions.SETTLE_PAIR));

// For ETH liquidity positions
bytes memory actions = abi.encodePacked(uint8(Actions.MINT_POSITION), uint8(Actions.SETTLE_PAIR), uint8(Actions.SWEEP));
```

### 3. Encode Parameters

```solidity
bytes[] memory params = new bytes[](2); // new bytes[](3) for ETH liquidity positions
```

The `MINT_POSITION` action requires the following parameters:

| Parameter    | Type      | Description                                                    |
|--------------|-----------|----------------------------------------------------------------|
| `poolKey`    | _PoolKey_ | where the liquidity will be added to                           |
| `tickLower`  | _int24_   | the lower tick boundary of the position                        |
| `tickUpper`  | _int24_   | the upper tick boundary of the position                        |
| `liquidity`  | _uint256_ | the amount of liquidity units to mint                          |
| `amount0Max` | _uint128_ | the maximum amount of currency0 msg.sender is willing to pay   |
| `amount1Max` | _uint128_ | the maximum amount of currency1 msg.sender is willing to pay   |
| `recipient`  | _address_ | the address that will receive the liquidity position (ERC-721) |
| `hookData`   | _bytes_   | arbitrary data that will be forwarded to hook functions        |

```solidity
Currency currency0 = Currency.wrap(<tokenAddress1>); // tokenAddress1 = 0 for native ETH
Currency currency1 = Currency.wrap(<tokenAddress2>);
PoolKey poolKey = PoolKey(currency0, currency1, 3000, 60, IHooks(hook));

params[0] = abi.encode(poolKey, tickLower, tickUpper, liquidity, amount0Max, amount1Max, recipient, hookData);
```

The `SETTLE_PAIR` action requires the following parameters:

* `currency0` - _Currency_, one of the tokens to be paid by msg.sender
* `currency1` - _Currency_, the other token to be paid by msg.sender

```solidity
params[1] = abi.encode(currency0, currency1);
```

The `SWEEP` action requires the following parameters:

* `currency` - _Currency_, token to sweep - most commonly native Ether: `CurrencyLibrary.ADDRESS_ZERO`
* `recipient` - _address_, where to send excess tokens

```solidity
params[2] = abi.encode(currency, recipient);
```

### 4. Submit Call

The entrypoint for all liquidity operations is `modifyLiquidities()`

```solidity
uint256 deadline = block.timestamp + 60;

uint256 valueToPass = currency0.isAddressZero() ? amount0Max : 0;

posm.modifyLiquidities{value: valueToPass}(
    abi.encode(actions, params),
    deadline
);
```

## Additional notes:

* To obtain balance changes, callers should read token balances before and after the `.modifyLiquidities()` call
</file>

<file path="docs/contracts/v4/quickstart/manage-liquidity/setup-liquidity.mdx">
---
title: Setup
sidebar_position: 0
---

For users looking to interact with the canonical Uniswap v4 `PositionManager`, _v4-periphery_ is a required dependency

Currently, developing with Uniswap v4 _requires [foundry](https://book.getfoundry.sh)_

## Quickstart

_Use [v4-template](https://github.com/new?template_name=v4-template&template_owner=uniswapfoundation)_, which has pre-configured dependencies and tests for Uniswap v4

Clone the repository made from _v4-template_
```bash
git clone https://github.com/<your_username>/<your_repo>
```

Install dependencies
```bash
forge install
```

---

## Manual Setup

After cloning the repository, and installing foundry, developers can manually set up their Uniswap v4 environment:

1. Initialize a foundry project
    ```bash
    forge init . --force
    ```

2. Install dependencies
    ```bash
    forge install uniswap/v4-core
    forge install uniswap/v4-periphery
    ```

3. Set the `remappings.txt` to:
    ```
    @uniswap/v4-core/=lib/v4-core/
    forge-gas-snapshot/=lib/v4-core/lib/forge-gas-snapshot/src/
    forge-std/=lib/v4-core/lib/forge-std/src/
    permit2/=lib/v4-periphery/lib/permit2/
    solmate/=lib/v4-core/lib/solmate/
    v4-periphery/=lib/v4-periphery/
    ```
</file>

<file path="docs/contracts/v4/quickstart/_category_.json">
{
  "label": "Quickstart",
  "position": 4,
  "collapsed": false
}
</file>

<file path="docs/contracts/v4/quickstart/create-pool.mdx">
---
title: Create Pool
sidebar_position: 1
---

## Context

Creating a pool on Uniswap v4 is permissionless and enables the trading of an asset. Uniswap v4 is a popular destination for creating markets due to its:

* Proven track record and battle-tested codebase
* Concentrated liquidity, unlocking capital efficiency
* Flexibile pool design through dynamic fees and hooks
* Gas-efficient architecture
* Integrations with alternative trading venues

For more information, developers should see [Uniswap v4 Overview](/contracts/v4/overview)

The guide covers two approaches to creating a pool:
1. Create a pool only
2. Create a pool and add initial liquidity, with one transaction

### Setup

Developing with Uniswap v4 _requires [foundry](https://book.getfoundry.sh)_

Install the dependencies:
```bash
forge install uniswap/v4-core
forge install uniswap/v4-periphery
```

## Guide: Create a Pool Only

To initialize a Uniswap v4 Pool _without initial liquidity_, developers should call [`PoolManager.initialize()`](/contracts/v4/reference/core/interfaces/IPoolManager#initialize)

Creating a pool without liquidity may be useful for "reserving" a pool for future use, when initial liquidity is not available, or when external market makers would provide the starting liquidity

### 1. Configure the Pool

```solidity
import {PoolKey} from "v4-core/src/types/PoolKey.sol";

PoolKey memory pool = PoolKey({
    currency0: currency0,
    currency1: currency1,
    fee: lpFee,
    tickSpacing: tickSpacing,
    hooks: hookContract
});
```
> For native token pairs (Ether), use `CurrencyLibrary.ADDRESS_ZERO` as `currency0`

[PoolKey](/contracts/v4/reference/core/types/PoolKey) uniquely identifies a pool

* _Currencies_ should be sorted, `uint160(currency0) < uint160(currency1)`
* _lpFee_ is the fee expressed in pips, i.e. 3000 = 0.30%
* _tickSpacing_ is the granularity of the pool. Lower values are more precise but may be more expensive to trade on
* _hookContract_ is the address of the hook contract

A note on `tickSpacing`:

Lower tick spacing provides improved price precision; however, smaller tick spaces will cause swaps to cross ticks more often, incurring higher gas costs

As a reference, Uniswap v3 pools are configured with:

| Fee   | Fee Value | Tick Spacing |
|-------|-----------|--------------|
| 0.01% | 100       | 1            |
| 0.05% | 500       | 10           |
| 0.30% | 3000      | 60           |
| 1.00% | 10_000    | 200          |

### 2. Call `initialize`
Pools are initialized with a starting price
```solidity
IPoolManager(manager).initialize(pool, startingPrice);
```   
* the _startingPrice_ is expressed as sqrtPriceX96: `floor(sqrt(token1 / token0) * 2^96)`
    - i.e. `79228162514264337593543950336` is the starting price for a 1:1 pool

## Guide: Create a Pool & Add Liquidity
Uniswap v4's [PositionManager](/contracts/v4/reference/periphery/PositionManager) supports atomic creation of a pool and initial liquidity using [_multicall_](/contracts/v4/reference/periphery/base/Multicall_v4). Developers can create a trading pool, with liquidity, in a single transaction:

### 1. Initialize the parameters provided to `multicall()`
```solidity
bytes[] memory params = new bytes[](2);
```
* The first call, `params[0]`, will encode `initializePool` parameters
* The second call, `params[1]`, will encode a _mint_ operation for `modifyLiquidities`

### 2. Configure the pool
```solidity
PoolKey memory pool = PoolKey({
    currency0: currency0,
    currency1: currency1,
    fee: lpFee,
    tickSpacing: tickSpacing,
    hooks: hookContract
});
```
> For native token pairs (Ether), use `CurrencyLibrary.ADDRESS_ZERO` as `currency0`

[PoolKey](/contracts/v4/reference/core/types/PoolKey) uniquely identifies a pool
* _Currencies_ should be sorted, `uint160(currency0) < uint160(currency1)`
* _lpFee_ is the fee expressed in pips, i.e. 3000 = 0.30%
* _tickSpacing_ is the granularity of the pool. Lower values are more precise but more expensive to trade
* _hookContract_ is the address of the hook contract

### 3. Encode the [`initializePool`](/contracts/v4/reference/periphery/base/PoolInitializer) parameters
Pools are initialized with a starting price
```solidity
import {IPoolInitializer_v4} from "v4-periphery/src/interfaces/IPoolInitializer_v4.sol";

params[0] = abi.encodeWithSelector(
    IPoolInitializer_v4.initializePool.selector,
    pool,
    startingPrice
);
```
* the _startingPrice_ is expressed as _sqrtPriceX96_: `floor(sqrt(token1 / token0) * 2^96)`
    - `79228162514264337593543950336` is the starting price for a 1:1 pool

### 4. Initialize the _mint-liquidity_ parameters    
PositionManager's `modifyLiquidities` uses an encoded command system
```solidity
bytes memory actions = abi.encodePacked(uint8(Actions.MINT_POSITION), uint8(Actions.SETTLE_PAIR));
```
* The first command `MINT_POSITION` creates a new liquidity position
* The second command `SETTLE_PAIR` indicates that tokens are to be paid by the caller, to create the position

### 5. Encode the `MINT_POSITION` parameters
```solidity
bytes[] memory mintParams = new bytes[](2);
mintParams[0] = abi.encode(pool, tickLower, tickUpper, liquidity, amount0Max, amount1Max, recipient, hookData);
```
* _pool_ the same `PoolKey` defined above, in pool-creation
* _tickLower_ and _tickUpper_ are the range of the position, must be a multiple of `pool.tickSpacing`
* _liquidity_ is the amount of liquidity units to add, see `LiquidityAmounts` for converting token amounts to liquidity units
* _amount0Max_ and _amount1Max_ are the maximum amounts of token0 and token1 the caller is willing to transfer
* _recipient_ is the address that will receive the liquidity position (ERC-721)
* _hookData_ is the optional hook data

### 6. Encode the `SETTLE_PAIR` parameters
    Creating a position on a pool requires the caller to transfer `currency0` and `currency1` tokens
```solidity
mintParams[1] = abi.encode(pool.currency0, pool.currency1);
```

### 7. Encode the [`modifyLiquidites`](/contracts/v4/reference/periphery/PositionManager#modifyliquidities) call
```solidity
// Note: In production, deadlines should be calculated off-chain using real time
// For example: uint256 deadline = block.timestamp + 3600; // 1 hour from now
uint256 deadline = block.timestamp + 3600; // 1 hour deadline
params[1] = abi.encodeWithSelector(
    posm.modifyLiquidities.selector, abi.encode(actions, mintParams), deadline
);
```

### 8. Approve the tokens
`PositionManager` uses `Permit2` for token transfers
* Repeat for both tokens
```solidity
// approve permit2 as a spender
IERC20(token).approve(address(permit2), type(uint256).max);

// approve `PositionManager` as a spender
IAllowanceTransfer(address(permit2)).approve(token, address(positionManager), type(uint160).max, type(uint48).max);
```

### 9. Execute the multicall
The `multicall` is used to execute multiple calls in a single transaction
```solidity
PositionManager(posm).multicall(params);
```
For pools paired with native tokens (Ether), provide `value` in the contract call
```solidity
PositionManager(posm).multicall{value: ethToSend}(params);
```
> Excess Ether is **NOT** refunded unless developers encoded `SWEEP` in the `actions` parameter

For a full end-to-end script, developers should see [v4-template's scripts](https://github.com/uniswapfoundation/v4-template/tree/main/script)
</file>

<file path="docs/contracts/v4/quickstart/subscriber.mdx">
---
title: Subscriber
sidebar_position: 5
---

### Context

For developers looking to support custom _liquidity mining_, Subscriber contracts can be used to receive notifications about position modifications or transfers.

## Guide

### 1. Implement the [`ISubscriber`](https://github.com/Uniswap/v4-periphery/blob/main/src/interfaces/ISubscriber.sol) interface

Can also refer to [MockSubscriber](https://github.com/Uniswap/v4-periphery/blob/main/test/mocks/MockSubscriber.sol) for an actual implementation example.

```solidity
import {ISubscriber} from "v4-periphery/src/interfaces/ISubscriber.sol";

contract MySubscriber is ISubscriber {
    uint256 public notifySubscribeCount;
    uint256 public notifyUnsubscribeCount;
    uint256 public notifyModifyLiquidityCount;
    uint256 public notifyBurnCount;
    // other implementations...

    function notifySubscribe(uint256, bytes memory) external onlyByPosm {
        notifySubscribeCount++;
    }

    function notifyUnsubscribe(uint256) external onlyByPosm {
        notifyUnsubscribeCount++;
    }

    function notifyModifyLiquidity(uint256, int256, BalanceDelta) external onlyByPosm {
        notifyModifyLiquidityCount++;
    }

    function notifyBurn(uint256, address, PositionInfo, uint256, BalanceDelta)
        external
        onlyByPosm
    {
        notifyBurnCount++;
    }
}
```

### 2. A caveat on `unsubscribe()`

To prevent gas griefing during unsubscription, Uniswap v4 sets a fixed variable [`unsubscribeGasLimit`](/contracts/v4/reference/periphery/interfaces/INotifier#unsubscribegaslimit) when calling a subscriber’s `notifyUnsubscribe()` function.

Without this limit, malicious subscribers could prevent liquidity providers from unsubscribing. If `notifyUnsubscribe()` were to consume too much gas, it would cause the unsubscription transaction to revert, thus leading to a denial-of-service

With the gas limit in place, if the subscriber’s notification fails, the unsubscription will still succeed and only the notification to the subscriber is skipped.

From [`_unsubscribe()`](https://github.com/Uniswap/v4-periphery/blob/main/src/base/Notifier.sol#L80) on `Notifier`:
```solidity
if (address(_subscriber).code.length > 0) {
    // require that the remaining gas is sufficient to notify the subscriber
    // otherwise, users can select a gas limit where .notifyUnsubscribe hits OutOfGas yet the
    // transaction/unsubscription can still succee
    if (gasleft() < unsubscribeGasLimit) GasLimitTooLow.selector.revertWith();
    try _subscriber.notifyUnsubscribe{gas: unsubscribeGasLimit}(tokenId) {} catch {}
}
```

### 3. Opt-in to a subscriber contract

To opt-in to a subscriber contract, call [`subscribe()`](/contracts/v4/reference/periphery/interfaces/INotifier#subscribe) on `PositionManager`.

```solidity
import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";

IPositionManager posm = IPositionManager(<address>);
ISubscriber mySubscriber = ISubscriber(<address>);

bytes memory optionalData = ...;
posm.subscribe(tokenId, mySubscriber, optionalData);
```
</file>

<file path="docs/contracts/v4/quickstart/swap.mdx">
---
title: Swap
sidebar_position: 3
---

## Swapping on Uniswap v4
The `Universal Router` is a flexible, gas-efficient contract designed to execute complex swap operations across various protocols, including Uniswap v4. It serves as an intermediary between users and the Uniswap v4 `PoolManager`, handling the intricacies of swap execution.

Although it's technically possible to interact directly with the PoolManager contract for swaps, this approach is not recommended due to its complexity and potential inefficiencies. Instead, the Universal Router is the preferred method, as it abstracts away these complexities. By using the Universal Router, developers and users can ensure a more straightforward, efficient, and standardized approach to executing swaps on v4 pools, aligning with best practices for Uniswap interactions.

## Configuring Universal Router for Uniswap v4 Swaps

Set up a foundry project and install the necessary dependencies:
```bash
forge install uniswap/v4-core
forge install uniswap/v4-periphery
forge install uniswap/permit2
forge install uniswap/universal-router
forge install uniswap/v3-core
forge install uniswap/v2-core
forge install OpenZeppelin/openzeppelin-contracts
```
In the `remappings.txt`, add the following:
```
@uniswap/v4-core/=lib/v4-core/
@uniswap/v4-periphery/=lib/v4-periphery/
@uniswap/permit2/=lib/permit2/
@uniswap/universal-router/=lib/universal-router/
@uniswap/v3-core/=lib/v3-core/
@uniswap/v2-core/=lib/v2-core/
@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/
[...]
```

### Step 1: Set Up the Project

First, we need to set up our project and import the necessary dependencies. We'll create a new Solidity contract for our example.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import { UniversalRouter } from "@uniswap/universal-router/contracts/UniversalRouter.sol";
import { Commands } from "@uniswap/universal-router/contracts/libraries/Commands.sol";
import { IPoolManager } from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import { IV4Router } from "@uniswap/v4-periphery/src/interfaces/IV4Router.sol";
import { Actions } from "@uniswap/v4-periphery/src/libraries/Actions.sol";
import { IPermit2 } from "@uniswap/permit2/src/interfaces/IPermit2.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { StateLibrary } from "@uniswap/v4-core/src/libraries/StateLibrary.sol";

contract Example {
    using StateLibrary for IPoolManager;

    UniversalRouter public immutable router;
    IPoolManager public immutable poolManager;
    IPermit2 public immutable permit2;

    constructor(address _router, address _poolManager, address _permit2) {
        router = UniversalRouter(payable(_router));
        poolManager = IPoolManager(_poolManager);
        permit2 = IPermit2(_permit2);
    }

    // We'll add more functions here
}
```

In this step, we're importing the necessary contracts and interfaces:

- `UniversalRouter`: This will be our main interface for executing swaps. It provides a flexible way to interact with various Uniswap versions and other protocols.
- `Commands`: This library contains the command definitions used by the UniversalRouter.
- `IPoolManager`: This interface is needed for interacting with Uniswap v4 pools. While we don't directly use it in our simple example, it's often necessary for more complex interactions with v4 pools.
- `IPermit2`: This interface allows us to interact with the Permit2 contract, which provides enhanced token approval functionality.
- `StateLibrary`: This provides optimized functions for interacting with the PoolManager's state. By using `StateLibrary`, we can more efficiently read and manipulate pool states, which is crucial for many operations in Uniswap v4.

### Step 2: Implement Token Approval with Permit2

`UniversalRouter` integrates with [Permit2](https://github.com/Uniswap/permit2), to enable users to have more safety, flexibility, and control over their ERC20 token approvals.

Before we can execute swaps, we need to ensure our contract can transfer tokens. We’ll implement a function to approve the Universal Router to spend tokens on behalf of our contract.

Here, for testing purposes, we set up our contract to use Permit2 with the UniversalRouter:

```solidity
function approveTokenWithPermit2(
	address token,
	uint160 amount,
	uint48 expiration
) external {
    IERC20(token).approve(address(permit2), type(uint256).max);
    permit2.approve(token, address(router), amount, expiration);
}
```

This function first approves Permit2 to spend the token, then uses Permit2 to approve the UniversalRouter with a specific amount and expiration time.

### Step 3: Implementing a Swap Function

#### 3.1: Function Signature

First, let’s define our function signature:

```solidity
function swapExactInputSingle(
    PoolKey calldata key, // PoolKey struct that identifies the v4 pool
    uint128 amountIn, // Exact amount of tokens to swap
    uint128 minAmountOut, // Minimum amount of output tokens expected
    uint256 deadline // Timestamp after which the transaction will revert
) external returns (uint256 amountOut) {
    // Implementation will follow
}
```
**Important note:**

1. The deadline parameter allows users to specify when their transaction should expire. This protects against unfavorable execution due to network delays or MEV attacks.
2. When swapping tokens involving native ETH, we use `Currency.wrap(address(0))` to represent ETH in the `PoolKey` struct.

```solidity
struct PoolKey {
    /// @notice The lower currency of the pool, sorted numerically.
    ///         For native ETH, Currency currency0 = Currency.wrap(address(0));
    Currency currency0;
    /// @notice The higher currency of the pool, sorted numerically
    Currency currency1;
    /// @notice The pool LP fee, capped at 1_000_000. If the highest bit is 1, the pool has a dynamic fee and must be exactly equal to 0x800000
    uint24 fee;
    /// @notice Ticks that involve positions must be a multiple of tick spacing
    int24 tickSpacing;
    /// @notice The hooks of the pool
    IHooks hooks;
}
```

#### 3.2: Encoding the Swap Command

When encoding a swap command for the Universal Router, we need to choose between two types of swaps:

1. Exact Input Swaps:

Use this swap-type when you know the exact amount of tokens you want to swap in, and you're willing to accept any amount of output tokens above your minimum. This is common when you want to sell a specific amount of tokens.

2. Exact Output Swaps:

Use this swap-type when you need a specific amount of output tokens, and you're willing to spend up to a maximum amount of input tokens. This is useful when you need to acquire a precise amount of tokens, for example, to repay a loan or meet a specific requirement.

Next, we encode the swap command:

```solidity
bytes memory commands = abi.encodePacked(uint8(Commands.V4_SWAP));
```

Here, we're using `V4_SWAP`, which tells the Universal Router that we want to perform a swap on a Uniswap v4 pool. The specific type of swap (exact input or exact output) will be determined by the V4Router actions we encode later. As we saw earlier, we encode this as a single byte, which is how the Universal Router expects to receive commands.

Check the complete list of [commands](https://docs.uniswap.org/contracts/universal-router/technical-reference#command).

#### 3.3: Action Encoding

Now, let’s encode the actions for the swap:

```solidity
// Encode V4Router actions
bytes memory actions = abi.encodePacked(
    uint8(Actions.SWAP_EXACT_IN_SINGLE),
    uint8(Actions.SETTLE_ALL),
    uint8(Actions.TAKE_ALL)
);
```

These actions define the sequence of operations that will be performed in our v4 swap:

1. `SWAP_EXACT_IN_SINGLE`: This action specifies that we want to perform an exact input swap using a single pool.
2. `SETTLE_ALL`: This action ensures all input tokens involved in the swap are properly paid. This is part of v4's settlement pattern for handling token transfers.
3. `TAKE_ALL`: This final action collects all output tokens after the swap is complete.

The sequence of these actions is important as they define the complete flow of our swap operation from start to finish.

#### 3.4: Preparing the Swap Inputs

For our v4 swap, we need to prepare three parameters that correspond to our encoded actions:

```solidity
bytes[] memory params = new bytes[](3);

// First parameter: swap configuration
params[0] = abi.encode(
    IV4Router.ExactInputSingleParams({
        poolKey: key,
        zeroForOne: true,            // true if we're swapping token0 for token1
        amountIn: amountIn,          // amount of tokens we're swapping
        amountOutMinimum: minAmountOut, // minimum amount we expect to receive
        hookData: bytes("")             // no hook data needed
    })
);

// Second parameter: specify input tokens for the swap
// encode SETTLE_ALL parameters
params[1] = abi.encode(key.currency0, amountIn);

// Third parameter: specify output tokens from the swap
params[2] = abi.encode(key.currency1, minAmountOut);
```

Each encoded parameter corresponds to a specific action in our swap:

1. The first parameter configures how the swap should be executed, defining the pool, amounts, and other swap-specific details
2. The second parameter defines what tokens we're putting into the swap
3. The third parameter defines what tokens we expect to receive from the swap

The sequence of these parameters must match the sequence of actions we defined earlier (`SWAP_EXACT_IN_SINGLE`, `SETTLE_ALL`, and `TAKE_ALL`).

#### 3.5: Executing the Swap

Now we can execute the swap using the Universal Router:

```solidity
bytes[] memory inputs = new bytes[](1);

// Combine actions and params into inputs
inputs[0] = abi.encode(actions, params);

// Execute the swap
uint256 deadline = block.timestamp + 20;
router.execute(commands, inputs, deadline);
```

This prepares and executes the swap based on our encoded commands, actions, and parameters.

> **Note**:  Never use block.timestamp or type(uint256).max as the deadline parameter.
>

#### 3.6: (Optional) Verifying the Swap Output

After the swap, we need to verify that we received at least the minimum amount of tokens we specified:

```solidity
amountOut = key.currency1.balanceOf(address(this));
require(amountOut >= minAmountOut, "Insufficient output amount");
```

#### 3.7: Returning the Result

Finally, we return the amount of tokens we received:

```solidity
return amountOut;
```

This allows the caller of the function to know exactly how many tokens were received in the swap.

Here's the complete swap function that combines all the steps we've covered:

```solidity
function swapExactInputSingle(
    PoolKey calldata key,
    uint128 amountIn,
    uint128 minAmountOut
) external returns (uint256 amountOut) {
    // Encode the Universal Router command
    bytes memory commands = abi.encodePacked(uint8(Commands.V4_SWAP));
    bytes[] memory inputs = new bytes[](1);

    // Encode V4Router actions
    bytes memory actions = abi.encodePacked(
        uint8(Actions.SWAP_EXACT_IN_SINGLE),
        uint8(Actions.SETTLE_ALL),
        uint8(Actions.TAKE_ALL)
    );

    // Prepare parameters for each action
    bytes[] memory params = new bytes[](3);
    params[0] = abi.encode(
        IV4Router.ExactInputSingleParams({
            poolKey: key,
            zeroForOne: true,
            amountIn: amountIn,
            amountOutMinimum: minAmountOut,
            hookData: bytes("")
        })
    );
    params[1] = abi.encode(key.currency0, amountIn);
    params[2] = abi.encode(key.currency1, minAmountOut);

    // Combine actions and params into inputs
    inputs[0] = abi.encode(actions, params);

    // Execute the swap
    uint256 deadline = block.timestamp + 20;
    router.execute(commands, inputs, deadline);

    // Verify and return the output amount
    amountOut = key.currency1.balanceOf(address(this));
    require(amountOut >= minAmountOut, "Insufficient output amount");
    return amountOut;
}
```
</file>

<file path="docs/contracts/v4/reference/core/interfaces/IERC20Minimal.md">
# IERC20Minimal
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/external/IERC20Minimal.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Contains a subset of the full ERC20 interface that is used in Uniswap V3


## Functions
### balanceOf

Returns an account's balance in the token


```solidity
function balanceOf(address account) external view returns (uint256);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`account`|`address`|The account for which to look up the number of tokens it has, i.e. its balance|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint256`|The number of tokens held by the account|


### transfer

Transfers the amount of token from the `msg.sender` to the recipient


```solidity
function transfer(address recipient, uint256 amount) external returns (bool);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`recipient`|`address`|The account that will receive the amount transferred|
|`amount`|`uint256`|The number of tokens to send from the sender to the recipient|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bool`|Returns true for a successful transfer, false for an unsuccessful transfer|


### allowance

Returns the current allowance given to a spender by an owner


```solidity
function allowance(address owner, address spender) external view returns (uint256);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`owner`|`address`|The account of the token owner|
|`spender`|`address`|The account of the token spender|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint256`|The current allowance granted by `owner` to `spender`|


### approve

Sets the allowance of a spender from the `msg.sender` to the value `amount`


```solidity
function approve(address spender, uint256 amount) external returns (bool);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`spender`|`address`|The account which will be allowed to spend a given amount of the owners tokens|
|`amount`|`uint256`|The amount of tokens allowed to be used by `spender`|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bool`|Returns true for a successful approval, false for unsuccessful|


### transferFrom

Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`


```solidity
function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The account from which the transfer will be initiated|
|`recipient`|`address`|The recipient of the transfer|
|`amount`|`uint256`|The amount of the transfer|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bool`|Returns true for a successful transfer, false for unsuccessful|


## Events
### Transfer
Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.


```solidity
event Transfer(address indexed from, address indexed to, uint256 value);
```

**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`from`|`address`|The account from which the tokens were sent, i.e. the balance decreased|
|`to`|`address`|The account to which the tokens were sent, i.e. the balance increased|
|`value`|`uint256`|The amount of tokens that were transferred|

### Approval
Event emitted when the approval amount for the spender of a given owner's tokens changes.


```solidity
event Approval(address indexed owner, address indexed spender, uint256 value);
```

**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`owner`|`address`|The account that approved spending of its tokens|
|`spender`|`address`|The account for which the spending allowance was modified|
|`value`|`uint256`|The new allowance from the owner to the spender|
</file>

<file path="docs/contracts/v4/reference/core/interfaces/IERC6909Claims.md">
# IERC6909Claims
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/external/IERC6909Claims.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for claims over a contract balance, wrapped as a ERC6909


## Functions
### balanceOf

Owner balance of an id.


```solidity
function balanceOf(address owner, uint256 id) external view returns (uint256 amount);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`owner`|`address`|The address of the owner.|
|`id`|`uint256`|The id of the token.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amount`|`uint256`|The balance of the token.|


### allowance

Spender allowance of an id.


```solidity
function allowance(address owner, address spender, uint256 id) external view returns (uint256 amount);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`owner`|`address`|The address of the owner.|
|`spender`|`address`|The address of the spender.|
|`id`|`uint256`|The id of the token.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amount`|`uint256`|The allowance of the token.|


### isOperator

Checks if a spender is approved by an owner as an operator


```solidity
function isOperator(address owner, address spender) external view returns (bool approved);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`owner`|`address`|The address of the owner.|
|`spender`|`address`|The address of the spender.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`approved`|`bool`|The approval status.|


### transfer

Transfers an amount of an id from the caller to a receiver.


```solidity
function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`receiver`|`address`|The address of the receiver.|
|`id`|`uint256`|The id of the token.|
|`amount`|`uint256`|The amount of the token.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bool`|bool True, always, unless the function reverts|


### transferFrom

Transfers an amount of an id from a sender to a receiver.


```solidity
function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The address of the sender.|
|`receiver`|`address`|The address of the receiver.|
|`id`|`uint256`|The id of the token.|
|`amount`|`uint256`|The amount of the token.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bool`|bool True, always, unless the function reverts|


### approve

Approves an amount of an id to a spender.


```solidity
function approve(address spender, uint256 id, uint256 amount) external returns (bool);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`spender`|`address`|The address of the spender.|
|`id`|`uint256`|The id of the token.|
|`amount`|`uint256`|The amount of the token.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bool`|bool True, always|


### setOperator

Sets or removes an operator for the caller.


```solidity
function setOperator(address operator, bool approved) external returns (bool);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`operator`|`address`|The address of the operator.|
|`approved`|`bool`|The approval status.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bool`|bool True, always|


## Events
### OperatorSet

```solidity
event OperatorSet(address indexed owner, address indexed operator, bool approved);
```

### Approval

```solidity
event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);
```

### Transfer

```solidity
event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);
```
</file>

<file path="docs/contracts/v4/reference/core/interfaces/IExtsload.md">
# IExtsload
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IExtsload.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for functions to access any storage slot in a contract


## Functions
### extsload

Called by external contracts to access granular pool state


```solidity
function extsload(bytes32 slot) external view returns (bytes32 value);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`slot`|`bytes32`|Key of slot to sload|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`value`|`bytes32`|The value of the slot as bytes32|


### extsload

Called by external contracts to access granular pool state


```solidity
function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes32[] memory values);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`startSlot`|`bytes32`|Key of slot to start sloading from|
|`nSlots`|`uint256`|Number of slots to load into return value|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`values`|`bytes32[]`|List of loaded values.|


### extsload

Called by external contracts to access sparse pool state


```solidity
function extsload(bytes32[] calldata slots) external view returns (bytes32[] memory values);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`slots`|`bytes32[]`|List of slots to SLOAD from.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`values`|`bytes32[]`|List of loaded values.|
</file>

<file path="docs/contracts/v4/reference/core/interfaces/IExttload.md">
# IExttload
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IExttload.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for functions to access any transient storage slot in a contract


## Functions
### exttload

Called by external contracts to access transient storage of the contract


```solidity
function exttload(bytes32 slot) external view returns (bytes32 value);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`slot`|`bytes32`|Key of slot to tload|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`value`|`bytes32`|The value of the slot as bytes32|


### exttload

Called by external contracts to access sparse transient pool state


```solidity
function exttload(bytes32[] calldata slots) external view returns (bytes32[] memory values);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`slots`|`bytes32[]`|List of slots to tload|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`values`|`bytes32[]`|List of loaded values|
</file>

<file path="docs/contracts/v4/reference/core/interfaces/IHooks.md">
# IHooks
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IHooks.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

V4 decides whether to invoke specific hooks by inspecting the least significant bits
of the address that the hooks contract is deployed to.
For example, a hooks contract deployed to address: 0x0000000000000000000000000000000000002400
has the lowest bits '10 0100 0000 0000' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.
See the Hooks library for the full spec.

*Should only be callable by the v4 PoolManager.*


## Functions
### beforeInitialize

The hook called before the state of a pool is initialized


```solidity
function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96) external returns (bytes4);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the initialize call|
|`key`|`PoolKey`|The key for the pool being initialized|
|`sqrtPriceX96`|`uint160`|The sqrt(price) of the pool as a Q64.96|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|


### afterInitialize

The hook called after the state of a pool is initialized


```solidity
function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)
    external
    returns (bytes4);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the initialize call|
|`key`|`PoolKey`|The key for the pool being initialized|
|`sqrtPriceX96`|`uint160`|The sqrt(price) of the pool as a Q64.96|
|`tick`|`int24`|The current tick after the state of a pool is initialized|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|


### beforeAddLiquidity

The hook called before liquidity is added


```solidity
function beforeAddLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata hookData
) external returns (bytes4);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the add liquidity call|
|`key`|`PoolKey`|The key for the pool|
|`params`|`IPoolManager.ModifyLiquidityParams`|The parameters for adding liquidity|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|


### afterAddLiquidity

The hook called after liquidity is added


```solidity
function afterAddLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    BalanceDelta delta,
    BalanceDelta feesAccrued,
    bytes calldata hookData
) external returns (bytes4, BalanceDelta);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the add liquidity call|
|`key`|`PoolKey`|The key for the pool|
|`params`|`IPoolManager.ModifyLiquidityParams`|The parameters for adding liquidity|
|`delta`|`BalanceDelta`|The caller's balance delta after adding liquidity; the sum of principal delta, fees accrued, and hook delta|
|`feesAccrued`|`BalanceDelta`|The fees accrued since the last time fees were collected from this position|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|
|`<none>`|`BalanceDelta`|BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency|


### beforeRemoveLiquidity

The hook called before liquidity is removed


```solidity
function beforeRemoveLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata hookData
) external returns (bytes4);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the remove liquidity call|
|`key`|`PoolKey`|The key for the pool|
|`params`|`IPoolManager.ModifyLiquidityParams`|The parameters for removing liquidity|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|


### afterRemoveLiquidity

The hook called after liquidity is removed


```solidity
function afterRemoveLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    BalanceDelta delta,
    BalanceDelta feesAccrued,
    bytes calldata hookData
) external returns (bytes4, BalanceDelta);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the remove liquidity call|
|`key`|`PoolKey`|The key for the pool|
|`params`|`IPoolManager.ModifyLiquidityParams`|The parameters for removing liquidity|
|`delta`|`BalanceDelta`|The caller's balance delta after removing liquidity; the sum of principal delta, fees accrued, and hook delta|
|`feesAccrued`|`BalanceDelta`|The fees accrued since the last time fees were collected from this position|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|
|`<none>`|`BalanceDelta`|BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency|


### beforeSwap

The hook called before a swap


```solidity
function beforeSwap(
    address sender,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    bytes calldata hookData
) external returns (bytes4, BeforeSwapDelta, uint24);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the swap call|
|`key`|`PoolKey`|The key for the pool|
|`params`|`IPoolManager.SwapParams`|The parameters for the swap|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|
|`<none>`|`BeforeSwapDelta`|BeforeSwapDelta The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency|
|`<none>`|`uint24`|uint24 Optionally override the lp fee, only used if three conditions are met: 1. the Pool has a dynamic fee, 2. the value's 2nd highest bit is set (23rd bit, 0x400000), and 3. the value is less than or equal to the maximum fee (1 million)|


### afterSwap

The hook called after a swap


```solidity
function afterSwap(
    address sender,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    BalanceDelta delta,
    bytes calldata hookData
) external returns (bytes4, int128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the swap call|
|`key`|`PoolKey`|The key for the pool|
|`params`|`IPoolManager.SwapParams`|The parameters for the swap|
|`delta`|`BalanceDelta`|The amount owed to the caller (positive) or owed to the pool (negative)|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|
|`<none>`|`int128`|int128 The hook's delta in unspecified currency. Positive: the hook is owed/took currency, negative: the hook owes/sent currency|


### beforeDonate

The hook called before donate


```solidity
function beforeDonate(address sender, PoolKey calldata key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    returns (bytes4);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the donate call|
|`key`|`PoolKey`|The key for the pool|
|`amount0`|`uint256`|The amount of token0 being donated|
|`amount1`|`uint256`|The amount of token1 being donated|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|


### afterDonate

The hook called after donate


```solidity
function afterDonate(address sender, PoolKey calldata key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    returns (bytes4);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the donate call|
|`key`|`PoolKey`|The key for the pool|
|`amount0`|`uint256`|The amount of token0 being donated|
|`amount1`|`uint256`|The amount of token1 being donated|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|
</file>

<file path="docs/contracts/v4/reference/core/interfaces/IPoolManager.md">
# IPoolManager
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IPoolManager.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IProtocolFees](contracts/v4/reference/core/interfaces/IProtocolFees.md), [IERC6909Claims](contracts/v4/reference/core/interfaces/IERC6909Claims.md), [IExtsload](contracts/v4/reference/core/interfaces/IExtsload.md), [IExttload](contracts/v4/reference/core/interfaces/IExttload.md)

Interface for the PoolManager


## Functions
### unlock

All interactions on the contract that account deltas require unlocking. A caller that calls `unlock` must implement
`IUnlockCallback(msg.sender).unlockCallback(data)`, where they interact with the remaining functions on this contract.

*The only functions callable without an unlocking are `initialize` and `updateDynamicLPFee`*


```solidity
function unlock(bytes calldata data) external returns (bytes memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`data`|`bytes`|Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)`|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes`|The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)`|


### initialize

Initialize the state for a given pool ID

*A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee*


```solidity
function initialize(PoolKey memory key, uint160 sqrtPriceX96) external returns (int24 tick);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The pool key for the pool to initialize|
|`sqrtPriceX96`|`uint160`|The initial square root price|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`tick`|`int24`|The initial tick of the pool|


### modifyLiquidity

Modify the liquidity for the given pool

*Poke by calling with a zero liquidityDelta*

*Note that feesAccrued can be artificially inflated by a malicious actor and integrators should be careful using the value
For pools with a single liquidity position, actors can donate to themselves to inflate feeGrowthGlobal (and consequently feesAccrued)
atomically donating and collecting fees in the same unlockCallback may make the inflated value more extreme*


```solidity
function modifyLiquidity(PoolKey memory key, ModifyLiquidityParams memory params, bytes calldata hookData)
    external
    returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The pool to modify liquidity in|
|`params`|`ModifyLiquidityParams`|The parameters for modifying the liquidity|
|`hookData`|`bytes`|The data to pass through to the add/removeLiquidity hooks|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`callerDelta`|`BalanceDelta`|The balance delta of the caller of modifyLiquidity. This is the total of both principal, fee deltas, and hook deltas if applicable|
|`feesAccrued`|`BalanceDelta`|The balance delta of the fees generated in the liquidity range. Returned for informational purposes|


### swap

Swap against the given pool

*Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified.
Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG
the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.*


```solidity
function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)
    external
    returns (BalanceDelta swapDelta);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The pool to swap in|
|`params`|`SwapParams`|The parameters for swapping|
|`hookData`|`bytes`|The data to pass through to the swap hooks|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`swapDelta`|`BalanceDelta`|The balance delta of the address swapping|


### donate

Donate the given currency amounts to the in-range liquidity providers of a pool

*Calls to donate can be frontrun adding just-in-time liquidity, with the aim of receiving a portion donated funds.
Donors should keep this in mind when designing donation mechanisms.*

*This function donates to in-range LPs at slot0.tick. In certain edge-cases of the swap algorithm, the `sqrtPrice` of
a pool can be at the lower boundary of tick `n`, but the `slot0.tick` of the pool is already `n - 1`. In this case a call to
`donate` would donate to tick `n - 1` (slot0.tick) not tick `n` (getTickAtSqrtPrice(slot0.sqrtPriceX96)).
Read the comments in `Pool.swap()` for more information about this.*


```solidity
function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    returns (BalanceDelta);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The key of the pool to donate to|
|`amount0`|`uint256`|The amount of currency0 to donate|
|`amount1`|`uint256`|The amount of currency1 to donate|
|`hookData`|`bytes`|The data to pass through to the donate hooks|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`BalanceDelta`|BalanceDelta The delta of the caller after the donate|


### sync

Writes the current ERC20 balance of the specified currency to transient storage
This is used to checkpoint balances for the manager and derive deltas for the caller.

*This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped
for native tokens because the amount to settle is determined by the sent value.
However, if an ERC20 token has been synced and not settled, and the caller instead wants to settle
native funds, this function can be called with the native currency to then be able to settle the native currency*


```solidity
function sync(Currency currency) external;
```

### take

Called by the user to net out some value owed to the user

*Will revert if the requested amount is not available, consider using `mint` instead*

*Can also be used as a mechanism for free flash loans*


```solidity
function take(Currency currency, address to, uint256 amount) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency`|`Currency`|The currency to withdraw from the pool manager|
|`to`|`address`|The address to withdraw to|
|`amount`|`uint256`|The amount of currency to withdraw|


### settle

Called by the user to pay what is owed


```solidity
function settle() external payable returns (uint256 paid);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`paid`|`uint256`|The amount of currency settled|


### settleFor

Called by the user to pay on behalf of another address


```solidity
function settleFor(address recipient) external payable returns (uint256 paid);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`recipient`|`address`|The address to credit for the payment|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`paid`|`uint256`|The amount of currency settled|


### clear

WARNING - Any currency that is cleared, will be non-retrievable, and locked in the contract permanently.
A call to clear will zero out a positive balance WITHOUT a corresponding transfer.

*This could be used to clear a balance that is considered dust.
Additionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.*


```solidity
function clear(Currency currency, uint256 amount) external;
```

### mint

Called by the user to move value into ERC6909 balance

*The id is converted to a uint160 to correspond to a currency address
If the upper 12 bytes are not 0, they will be 0-ed out*


```solidity
function mint(address to, uint256 id, uint256 amount) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`to`|`address`|The address to mint the tokens to|
|`id`|`uint256`|The currency address to mint to ERC6909s, as a uint256|
|`amount`|`uint256`|The amount of currency to mint|


### burn

Called by the user to move value from ERC6909 balance

*The id is converted to a uint160 to correspond to a currency address
If the upper 12 bytes are not 0, they will be 0-ed out*


```solidity
function burn(address from, uint256 id, uint256 amount) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`from`|`address`|The address to burn the tokens from|
|`id`|`uint256`|The currency address to burn from ERC6909s, as a uint256|
|`amount`|`uint256`|The amount of currency to burn|


### updateDynamicLPFee

Updates the pools lp fees for the a pool that has enabled dynamic lp fees.

*A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee*


```solidity
function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The key of the pool to update dynamic LP fees for|
|`newDynamicLPFee`|`uint24`|The new dynamic pool LP fee|


## Events
### Initialize
Emitted when a new pool is initialized


```solidity
event Initialize(
    PoolId indexed id,
    Currency indexed currency0,
    Currency indexed currency1,
    uint24 fee,
    int24 tickSpacing,
    IHooks hooks,
    uint160 sqrtPriceX96,
    int24 tick
);
```

**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`id`|`PoolId`|The abi encoded hash of the pool key struct for the new pool|
|`currency0`|`Currency`|The first currency of the pool by address sort order|
|`currency1`|`Currency`|The second currency of the pool by address sort order|
|`fee`|`uint24`|The fee collected upon every swap in the pool, denominated in hundredths of a bip|
|`tickSpacing`|`int24`|The minimum number of ticks between initialized ticks|
|`hooks`|`IHooks`|The hooks contract address for the pool, or address(0) if none|
|`sqrtPriceX96`|`uint160`|The price of the pool on initialization|
|`tick`|`int24`|The initial tick of the pool corresponding to the initialized price|

### ModifyLiquidity
Emitted when a liquidity position is modified


```solidity
event ModifyLiquidity(
    PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta, bytes32 salt
);
```

**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`id`|`PoolId`|The abi encoded hash of the pool key struct for the pool that was modified|
|`sender`|`address`|The address that modified the pool|
|`tickLower`|`int24`|The lower tick of the position|
|`tickUpper`|`int24`|The upper tick of the position|
|`liquidityDelta`|`int256`|The amount of liquidity that was added or removed|
|`salt`|`bytes32`|The extra data to make positions unique|

### Swap
Emitted for swaps between currency0 and currency1


```solidity
event Swap(
    PoolId indexed id,
    address indexed sender,
    int128 amount0,
    int128 amount1,
    uint160 sqrtPriceX96,
    uint128 liquidity,
    int24 tick,
    uint24 fee
);
```

**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`id`|`PoolId`|The abi encoded hash of the pool key struct for the pool that was modified|
|`sender`|`address`|The address that initiated the swap call, and that received the callback|
|`amount0`|`int128`|The delta of the currency0 balance of the pool|
|`amount1`|`int128`|The delta of the currency1 balance of the pool|
|`sqrtPriceX96`|`uint160`|The sqrt(price) of the pool after the swap, as a Q64.96|
|`liquidity`|`uint128`|The liquidity of the pool after the swap|
|`tick`|`int24`|The log base 1.0001 of the price of the pool after the swap|
|`fee`|`uint24`|The swap fee in hundredths of a bip|

### Donate
Emitted for donations


```solidity
event Donate(PoolId indexed id, address indexed sender, uint256 amount0, uint256 amount1);
```

**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`id`|`PoolId`|The abi encoded hash of the pool key struct for the pool that was donated to|
|`sender`|`address`|The address that initiated the donate call|
|`amount0`|`uint256`|The amount donated in currency0|
|`amount1`|`uint256`|The amount donated in currency1|

## Errors
### CurrencyNotSettled
Thrown when a currency is not netted out after the contract is unlocked


```solidity
error CurrencyNotSettled();
```

### PoolNotInitialized
Thrown when trying to interact with a non-initialized pool


```solidity
error PoolNotInitialized();
```

### AlreadyUnlocked
Thrown when unlock is called, but the contract is already unlocked


```solidity
error AlreadyUnlocked();
```

### ManagerLocked
Thrown when a function is called that requires the contract to be unlocked, but it is not


```solidity
error ManagerLocked();
```

### TickSpacingTooLarge
Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow


```solidity
error TickSpacingTooLarge(int24 tickSpacing);
```

### TickSpacingTooSmall
Pools must have a positive non-zero tickSpacing passed to #initialize


```solidity
error TickSpacingTooSmall(int24 tickSpacing);
```

### CurrenciesOutOfOrderOrEqual
PoolKey must have currencies where address(currency0) < address(currency1)


```solidity
error CurrenciesOutOfOrderOrEqual(address currency0, address currency1);
```

### UnauthorizedDynamicLPFeeUpdate
Thrown when a call to updateDynamicLPFee is made by an address that is not the hook,
or on a pool that does not have a dynamic swap fee.


```solidity
error UnauthorizedDynamicLPFeeUpdate();
```

### SwapAmountCannotBeZero
Thrown when trying to swap amount of 0


```solidity
error SwapAmountCannotBeZero();
```

### NonzeroNativeValue
Thrown when native currency is passed to a non native settlement


```solidity
error NonzeroNativeValue();
```

### MustClearExactPositiveDelta
Thrown when `clear` is called with an amount that is not exactly equal to the open currency delta.


```solidity
error MustClearExactPositiveDelta();
```

## Structs
### ModifyLiquidityParams

```solidity
struct ModifyLiquidityParams {
    int24 tickLower;
    int24 tickUpper;
    int256 liquidityDelta;
    bytes32 salt;
}
```

### SwapParams

```solidity
struct SwapParams {
    bool zeroForOne;
    int256 amountSpecified;
    uint160 sqrtPriceLimitX96;
}
```
</file>

<file path="docs/contracts/v4/reference/core/interfaces/IProtocolFees.md">
# IProtocolFees
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IProtocolFees.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for all protocol-fee related functions in the pool manager


## Functions
### protocolFeesAccrued

Given a currency address, returns the protocol fees accrued in that currency


```solidity
function protocolFeesAccrued(Currency currency) external view returns (uint256 amount);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency`|`Currency`|The currency to check|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amount`|`uint256`|The amount of protocol fees accrued in the currency|


### setProtocolFee

Sets the protocol fee for the given pool


```solidity
function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The key of the pool to set a protocol fee for|
|`newProtocolFee`|`uint24`|The fee to set|


### setProtocolFeeController

Sets the protocol fee controller


```solidity
function setProtocolFeeController(address controller) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`controller`|`address`|The new protocol fee controller|


### collectProtocolFees

Collects the protocol fees for a given recipient and currency, returning the amount collected

*This will revert if the contract is unlocked*


```solidity
function collectProtocolFees(address recipient, Currency currency, uint256 amount)
    external
    returns (uint256 amountCollected);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`recipient`|`address`|The address to receive the protocol fees|
|`currency`|`Currency`|The currency to withdraw|
|`amount`|`uint256`|The amount of currency to withdraw|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amountCollected`|`uint256`|The amount of currency successfully withdrawn|


### protocolFeeController

Returns the current protocol fee controller address


```solidity
function protocolFeeController() external view returns (address);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`address`|address The current protocol fee controller address|


## Events
### ProtocolFeeControllerUpdated
Emitted when the protocol fee controller address is updated in setProtocolFeeController.


```solidity
event ProtocolFeeControllerUpdated(address indexed protocolFeeController);
```

### ProtocolFeeUpdated
Emitted when the protocol fee is updated for a pool.


```solidity
event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFee);
```

## Errors
### ProtocolFeeTooLarge
Thrown when protocol fee is set too high


```solidity
error ProtocolFeeTooLarge(uint24 fee);
```

### InvalidCaller
Thrown when collectProtocolFees or setProtocolFee is not called by the controller.


```solidity
error InvalidCaller();
```

### ProtocolFeeCurrencySynced
Thrown when collectProtocolFees is attempted on a token that is synced.


```solidity
error ProtocolFeeCurrencySynced();
```
</file>

<file path="docs/contracts/v4/reference/core/interfaces/IUnlockCallback.md">
# IUnlockCallback
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/callback/IUnlockCallback.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the callback executed when an address unlocks the pool manager


## Functions
### unlockCallback

Called by the pool manager on `msg.sender` when the manager is unlocked


```solidity
function unlockCallback(bytes calldata data) external returns (bytes memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`data`|`bytes`|The data that was passed to the call to unlock|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes`|Any data that you want to be returned from the unlock call|
</file>

<file path="docs/contracts/v4/reference/core/libraries/_category_.json">
{
  "label": "Libraries",
  "position": 0,
  "collapsed": true
}
</file>

<file path="docs/contracts/v4/reference/core/libraries/BitMath.md">
# BitMath
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/BitMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Author:**
Solady (https://github.com/Vectorized/solady/blob/8200a70e8dc2a77ecb074fc2e99a2a0d36547522/src/utils/LibBit.sol)

*This library provides functionality for computing bit properties of an unsigned integer*


## Functions
### mostSignificantBit

Returns the index of the most significant bit of the number,
where the least significant bit is at index 0 and the most significant bit is at index 255


```solidity
function mostSignificantBit(uint256 x) internal pure returns (uint8 r);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`x`|`uint256`|the value for which to compute the most significant bit, must be greater than 0|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`r`|`uint8`|the index of the most significant bit|


### leastSignificantBit

Returns the index of the least significant bit of the number,
where the least significant bit is at index 0 and the most significant bit is at index 255


```solidity
function leastSignificantBit(uint256 x) internal pure returns (uint8 r);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`x`|`uint256`|the value for which to compute the least significant bit, must be greater than 0|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`r`|`uint8`|the index of the least significant bit|
</file>

<file path="docs/contracts/v4/reference/core/libraries/CurrencyDelta.md">
# CurrencyDelta
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/CurrencyDelta.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

*this library implements the equivalent of a mapping, as transient storage can only be accessed in assembly*


## Functions
### _computeSlot

calculates which storage slot a delta should be stored in for a given account and currency


```solidity
function _computeSlot(address target, Currency currency) internal pure returns (bytes32 hashSlot);
```

### getDelta


```solidity
function getDelta(Currency currency, address target) internal view returns (int256 delta);
```

### applyDelta

applies a new currency delta for a given account and currency


```solidity
function applyDelta(Currency currency, address target, int128 delta) internal returns (int256 previous, int256 next);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`previous`|`int256`|The prior value|
|`next`|`int256`|The modified result|
</file>

<file path="docs/contracts/v4/reference/core/libraries/CurrencyReserves.md">
# CurrencyReserves
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/CurrencyReserves.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


## State Variables
### RESERVES_OF_SLOT
bytes32(uint256(keccak256("ReservesOf")) - 1)


```solidity
bytes32 constant RESERVES_OF_SLOT = 0x1e0745a7db1623981f0b2a5d4232364c00787266eb75ad546f190e6cebe9bd95;
```


### CURRENCY_SLOT
bytes32(uint256(keccak256("Currency")) - 1)


```solidity
bytes32 constant CURRENCY_SLOT = 0x27e098c505d44ec3574004bca052aabf76bd35004c182099d8c575fb238593b9;
```


## Functions
### getSyncedCurrency


```solidity
function getSyncedCurrency() internal view returns (Currency currency);
```

### resetCurrency


```solidity
function resetCurrency() internal;
```

### syncCurrencyAndReserves


```solidity
function syncCurrencyAndReserves(Currency currency, uint256 value) internal;
```

### getSyncedReserves


```solidity
function getSyncedReserves() internal view returns (uint256 value);
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/CustomRevert.md">
# CustomRevert
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/CustomRevert.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Contains functions for reverting with custom errors with different argument types efficiently

*To use this library, declare `using CustomRevert for bytes4;` and replace `revert CustomError()` with
`CustomError.selector.revertWith()`*

*The functions may tamper with the free memory pointer but it is fine since the call context is exited immediately*


## Functions
### revertWith

*Reverts with the selector of a custom error in the scratch space*


```solidity
function revertWith(bytes4 selector) internal pure;
```

### revertWith

*Reverts with a custom error with an address argument in the scratch space*


```solidity
function revertWith(bytes4 selector, address addr) internal pure;
```

### revertWith

*Reverts with a custom error with an int24 argument in the scratch space*


```solidity
function revertWith(bytes4 selector, int24 value) internal pure;
```

### revertWith

*Reverts with a custom error with a uint160 argument in the scratch space*


```solidity
function revertWith(bytes4 selector, uint160 value) internal pure;
```

### revertWith

*Reverts with a custom error with two int24 arguments*


```solidity
function revertWith(bytes4 selector, int24 value1, int24 value2) internal pure;
```

### revertWith

*Reverts with a custom error with two uint160 arguments*


```solidity
function revertWith(bytes4 selector, uint160 value1, uint160 value2) internal pure;
```

### revertWith

*Reverts with a custom error with two address arguments*


```solidity
function revertWith(bytes4 selector, address value1, address value2) internal pure;
```

### bubbleUpAndRevertWith

bubble up the revert message returned by a call and revert with a wrapped ERC-7751 error

*this method can be vulnerable to revert data bombs*


```solidity
function bubbleUpAndRevertWith(address revertingContract, bytes4 revertingFunctionSelector, bytes4 additionalContext)
    internal
    pure;
```

## Errors
### WrappedError
*ERC-7751 error for wrapping bubbled up reverts*


```solidity
error WrappedError(address target, bytes4 selector, bytes reason, bytes details);
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/FixedPoint128.md">
# FixedPoint128
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/FixedPoint128.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)


## State Variables
### Q128

```solidity
uint256 internal constant Q128 = 0x100000000000000000000000000000000;
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/FixedPoint96.md">
# FixedPoint96
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/FixedPoint96.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)

*Used in SqrtPriceMath.sol*


## State Variables
### RESOLUTION

```solidity
uint8 internal constant RESOLUTION = 96;
```


### Q96

```solidity
uint256 internal constant Q96 = 0x1000000000000000000000000;
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/FullMath.md">
# FullMath
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/FullMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision

*Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits*


## Functions
### mulDiv

Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0

*Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv*


```solidity
function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`a`|`uint256`|The multiplicand|
|`b`|`uint256`|The multiplier|
|`denominator`|`uint256`|The divisor|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`result`|`uint256`|The 256-bit result|


### mulDivRoundingUp

Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0


```solidity
function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`a`|`uint256`|The multiplicand|
|`b`|`uint256`|The multiplier|
|`denominator`|`uint256`|The divisor|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`result`|`uint256`|The 256-bit result|
</file>

<file path="docs/contracts/v4/reference/core/libraries/Hooks.md">
# Hooks
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/Hooks.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

V4 decides whether to invoke specific hooks by inspecting the least significant bits
of the address that the hooks contract is deployed to.
For example, a hooks contract deployed to address: 0x0000000000000000000000000000000000002400
has the lowest bits '10 0100 0000 0000' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.


## State Variables
### ALL_HOOK_MASK

```solidity
uint160 internal constant ALL_HOOK_MASK = uint160((1 << 14) - 1);
```


### BEFORE_INITIALIZE_FLAG

```solidity
uint160 internal constant BEFORE_INITIALIZE_FLAG = 1 << 13;
```


### AFTER_INITIALIZE_FLAG

```solidity
uint160 internal constant AFTER_INITIALIZE_FLAG = 1 << 12;
```


### BEFORE_ADD_LIQUIDITY_FLAG

```solidity
uint160 internal constant BEFORE_ADD_LIQUIDITY_FLAG = 1 << 11;
```


### AFTER_ADD_LIQUIDITY_FLAG

```solidity
uint160 internal constant AFTER_ADD_LIQUIDITY_FLAG = 1 << 10;
```


### BEFORE_REMOVE_LIQUIDITY_FLAG

```solidity
uint160 internal constant BEFORE_REMOVE_LIQUIDITY_FLAG = 1 << 9;
```


### AFTER_REMOVE_LIQUIDITY_FLAG

```solidity
uint160 internal constant AFTER_REMOVE_LIQUIDITY_FLAG = 1 << 8;
```


### BEFORE_SWAP_FLAG

```solidity
uint160 internal constant BEFORE_SWAP_FLAG = 1 << 7;
```


### AFTER_SWAP_FLAG

```solidity
uint160 internal constant AFTER_SWAP_FLAG = 1 << 6;
```


### BEFORE_DONATE_FLAG

```solidity
uint160 internal constant BEFORE_DONATE_FLAG = 1 << 5;
```


### AFTER_DONATE_FLAG

```solidity
uint160 internal constant AFTER_DONATE_FLAG = 1 << 4;
```


### BEFORE_SWAP_RETURNS_DELTA_FLAG

```solidity
uint160 internal constant BEFORE_SWAP_RETURNS_DELTA_FLAG = 1 << 3;
```


### AFTER_SWAP_RETURNS_DELTA_FLAG

```solidity
uint160 internal constant AFTER_SWAP_RETURNS_DELTA_FLAG = 1 << 2;
```


### AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG

```solidity
uint160 internal constant AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 1;
```


### AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG

```solidity
uint160 internal constant AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 0;
```


## Functions
### validateHookPermissions

Utility function intended to be used in hook constructors to ensure
the deployed hooks address causes the intended hooks to be called

*permissions param is memory as the function will be called from constructors*


```solidity
function validateHookPermissions(IHooks self, Permissions memory permissions) internal pure;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`IHooks`||
|`permissions`|`Permissions`|The hooks that are intended to be called|


### isValidHookAddress

Ensures that the hook address includes at least one hook flag or dynamic fees, or is the 0 address


```solidity
function isValidHookAddress(IHooks self, uint24 fee) internal pure returns (bool);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`IHooks`|The hook to verify|
|`fee`|`uint24`|The fee of the pool the hook is used with|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bool`|bool True if the hook address is valid|


### callHook

performs a hook call using the given calldata on the given hook that doesn't return a delta


```solidity
function callHook(IHooks self, bytes memory data) internal returns (bytes memory result);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`result`|`bytes`|The complete data returned by the hook|


### callHookWithReturnDelta

performs a hook call using the given calldata on the given hook


```solidity
function callHookWithReturnDelta(IHooks self, bytes memory data, bool parseReturn) internal returns (int256);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`int256`|int256 The delta returned by the hook|


### noSelfCall

modifier to prevent calling a hook if they initiated the action


```solidity
modifier noSelfCall(IHooks self);
```

### beforeInitialize

calls beforeInitialize hook if permissioned and validates return value


```solidity
function beforeInitialize(IHooks self, PoolKey memory key, uint160 sqrtPriceX96) internal noSelfCall(self);
```

### afterInitialize

calls afterInitialize hook if permissioned and validates return value


```solidity
function afterInitialize(IHooks self, PoolKey memory key, uint160 sqrtPriceX96, int24 tick) internal noSelfCall(self);
```

### beforeModifyLiquidity

calls beforeModifyLiquidity hook if permissioned and validates return value


```solidity
function beforeModifyLiquidity(
    IHooks self,
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    bytes calldata hookData
) internal noSelfCall(self);
```

### afterModifyLiquidity

calls afterModifyLiquidity hook if permissioned and validates return value


```solidity
function afterModifyLiquidity(
    IHooks self,
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    BalanceDelta delta,
    BalanceDelta feesAccrued,
    bytes calldata hookData
) internal returns (BalanceDelta callerDelta, BalanceDelta hookDelta);
```

### beforeSwap

calls beforeSwap hook if permissioned and validates return value


```solidity
function beforeSwap(IHooks self, PoolKey memory key, IPoolManager.SwapParams memory params, bytes calldata hookData)
    internal
    returns (int256 amountToSwap, BeforeSwapDelta hookReturn, uint24 lpFeeOverride);
```

### afterSwap

calls afterSwap hook if permissioned and validates return value


```solidity
function afterSwap(
    IHooks self,
    PoolKey memory key,
    IPoolManager.SwapParams memory params,
    BalanceDelta swapDelta,
    bytes calldata hookData,
    BeforeSwapDelta beforeSwapHookReturn
) internal returns (BalanceDelta, BalanceDelta);
```

### beforeDonate

calls beforeDonate hook if permissioned and validates return value


```solidity
function beforeDonate(IHooks self, PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    internal
    noSelfCall(self);
```

### afterDonate

calls afterDonate hook if permissioned and validates return value


```solidity
function afterDonate(IHooks self, PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    internal
    noSelfCall(self);
```

### hasPermission


```solidity
function hasPermission(IHooks self, uint160 flag) internal pure returns (bool);
```

## Errors
### HookAddressNotValid
Thrown if the address will not lead to the specified hook calls being called


```solidity
error HookAddressNotValid(address hooks);
```

**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`hooks`|`address`|The address of the hooks contract|

### InvalidHookResponse
Hook did not return its selector


```solidity
error InvalidHookResponse();
```

### HookCallFailed
Additional context for ERC-7751 wrapped error when a hook call fails


```solidity
error HookCallFailed();
```

### HookDeltaExceedsSwapAmount
The hook's delta changed the swap from exactIn to exactOut or vice versa


```solidity
error HookDeltaExceedsSwapAmount();
```

## Structs
### Permissions

```solidity
struct Permissions {
    bool beforeInitialize;
    bool afterInitialize;
    bool beforeAddLiquidity;
    bool afterAddLiquidity;
    bool beforeRemoveLiquidity;
    bool afterRemoveLiquidity;
    bool beforeSwap;
    bool afterSwap;
    bool beforeDonate;
    bool afterDonate;
    bool beforeSwapReturnDelta;
    bool afterSwapReturnDelta;
    bool afterAddLiquidityReturnDelta;
    bool afterRemoveLiquidityReturnDelta;
}
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/liquidity-amounts.mdx">
---
title: LiquidityAmounts
---

The `LiquidityAmounts` library provides functions for computing liquidity amounts from token amounts and prices in Uniswap V4.

## Key Concept: sqrtPriceX96

`sqrtPriceX96` represents the square root of the price ratio of token1 to token0, multiplied by 2^96. This representation allows for precise price calculations across a wide range of values while using fixed-point arithmetic. It's more efficient than using ticks for intermediate calculations, as it avoids frequent conversions between prices and ticks.

## Functions

### getLiquidityForAmount0

```solidity
function getLiquidityForAmount0(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount0)
internal
pure
returns (uint128 liquidity)
```

Computes the amount of liquidity received for a given amount of token0 and price range.

| Param Name     | Type    | Description                                   |
|----------------|---------|-----------------------------------------------|
| sqrtPriceAX96  | uint160 | Square root of price at first tick boundary   |
| sqrtPriceBX96  | uint160 | Square root of price at second tick boundary  |
| amount0        | uint256 | The amount of token0 being sent in            |

Returns the amount of liquidity received.

### getLiquidityForAmount1

```solidity
function getLiquidityForAmount1(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount1)
internal
pure
returns (uint128 liquidity)
```

Computes the amount of liquidity received for a given amount of token1 and price range.

| Param Name     | Type    | Description                                   |
|----------------|---------|-----------------------------------------------|
| sqrtPriceAX96  | uint160 | Square root of price at first tick boundary   |
| sqrtPriceBX96  | uint160 | Square root of price at second tick boundary  |
| amount1        | uint256 | The amount of token1 being sent in            |

Returns the amount of liquidity received.

### getLiquidityForAmounts

```solidity
function getLiquidityForAmounts(
uint160 sqrtPriceX96,
uint160 sqrtPriceAX96,
uint160 sqrtPriceBX96,
uint256 amount0,
uint256 amount1
) internal pure returns (uint128 liquidity)
```

Computes the maximum amount of liquidity received for given amounts of token0 and token1, the current pool prices, and the prices at the tick boundaries.

| Param Name     | Type    | Description                                   |
|----------------|---------|-----------------------------------------------|
| sqrtPriceX96   | uint160 | Current square root price of the pool         |
| sqrtPriceAX96  | uint160 | Square root of price at first tick boundary   |
| sqrtPriceBX96  | uint160 | Square root of price at second tick boundary  |
| amount0        | uint256 | The amount of token0 being sent in            |
| amount1        | uint256 | The amount of token1 being sent in            |

Returns the maximum amount of liquidity received.

### getAmount0ForLiquidity

```solidity
function getAmount0ForLiquidity(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity)
internal
pure
returns (uint256 amount0)
```

Computes the amount of token0 for a given amount of liquidity and a price range.

| Param Name     | Type    | Description                                   |
|----------------|---------|-----------------------------------------------|
| sqrtPriceAX96  | uint160 | Square root of price at first tick boundary   |
| sqrtPriceBX96  | uint160 | Square root of price at second tick boundary  |
| liquidity      | uint128 | The liquidity being valued                    |

Returns the amount of token0.

### getAmount1ForLiquidity

```solidity
function getAmount1ForLiquidity(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity)
internal
pure
returns (uint256 amount1)
```

Computes the amount of token1 for a given amount of liquidity and a price range.

| Param Name     | Type    | Description                                   |
|----------------|---------|-----------------------------------------------|
| sqrtPriceAX96  | uint160 | Square root of price at first tick boundary   |
| sqrtPriceBX96  | uint160 | Square root of price at second tick boundary  |
| liquidity      | uint128 | The liquidity being valued                    |

Returns the amount of token1.

### getAmountsForLiquidity

```solidity
function getAmountsForLiquidity(
uint160 sqrtPriceX96,
uint160 sqrtPriceAX96,
uint160 sqrtPriceBX96,
uint128 liquidity
) internal pure returns (uint256 amount0, uint256 amount1)
```

Computes the token0 and token1 value for a given amount of liquidity, the current pool prices, and the prices at the tick boundaries.

| Param Name     | Type    | Description                                   |
|----------------|---------|-----------------------------------------------|
| sqrtPriceX96   | uint160 | Current square root price of the pool         |
| sqrtPriceAX96  | uint160 | Square root of price at first tick boundary   |
| sqrtPriceBX96  | uint160 | Square root of price at second tick boundary  |
| liquidity      | uint128 | The liquidity being valued                    |

Returns the amount of token0 and token1.
</file>

<file path="docs/contracts/v4/reference/core/libraries/LiquidityMath.md">
# LiquidityMath
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/LiquidityMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


## Functions
### addDelta

Add a signed liquidity delta to liquidity and revert if it overflows or underflows


```solidity
function addDelta(uint128 x, int128 y) internal pure returns (uint128 z);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`x`|`uint128`|The liquidity before change|
|`y`|`int128`|The delta by which liquidity should be changed|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`z`|`uint128`|The liquidity delta|
</file>

<file path="docs/contracts/v4/reference/core/libraries/Lock.md">
# Lock
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/Lock.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

This is a temporary library that allows us to use transient storage (tstore/tload)
TODO: This library can be deleted when we have the transient keyword support in solidity.


## State Variables
### IS_UNLOCKED_SLOT

```solidity
bytes32 internal constant IS_UNLOCKED_SLOT = 0xc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab23;
```


## Functions
### unlock


```solidity
function unlock() internal;
```

### lock


```solidity
function lock() internal;
```

### isUnlocked


```solidity
function isUnlocked() internal view returns (bool unlocked);
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/LPFeeLibrary.md">
# LPFeeLibrary
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/LPFeeLibrary.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Library of helper functions for a pools LP fee


## State Variables
### DYNAMIC_FEE_FLAG
An lp fee of exactly 0b1000000... signals a dynamic fee pool. This isn't a valid static fee as it is > MAX_LP_FEE


```solidity
uint24 public constant DYNAMIC_FEE_FLAG = 0x800000;
```


### OVERRIDE_FEE_FLAG
the second bit of the fee returned by beforeSwap is used to signal if the stored LP fee should be overridden in this swap


```solidity
uint24 public constant OVERRIDE_FEE_FLAG = 0x400000;
```


### REMOVE_OVERRIDE_MASK
mask to remove the override fee flag from a fee returned by the beforeSwaphook


```solidity
uint24 public constant REMOVE_OVERRIDE_MASK = 0xBFFFFF;
```


### MAX_LP_FEE
the lp fee is represented in hundredths of a bip, so the max is 100%


```solidity
uint24 public constant MAX_LP_FEE = 1000000;
```


## Functions
### isDynamicFee

returns true if a pool's LP fee signals that the pool has a dynamic fee


```solidity
function isDynamicFee(uint24 self) internal pure returns (bool);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`uint24`|The fee to check|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bool`|bool True of the fee is dynamic|


### isValid

returns true if an LP fee is valid, aka not above the maximum permitted fee


```solidity
function isValid(uint24 self) internal pure returns (bool);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`uint24`|The fee to check|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bool`|bool True of the fee is valid|


### validate

validates whether an LP fee is larger than the maximum, and reverts if invalid


```solidity
function validate(uint24 self) internal pure;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`uint24`|The fee to validate|


### getInitialLPFee

gets and validates the initial LP fee for a pool. Dynamic fee pools have an initial fee of 0.

*if a dynamic fee pool wants a non-0 initial fee, it should call `updateDynamicLPFee` in the afterInitialize hook*


```solidity
function getInitialLPFee(uint24 self) internal pure returns (uint24);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`uint24`|The fee to get the initial LP from|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint24`|initialFee 0 if the fee is dynamic, otherwise the fee (if valid)|


### isOverride

returns true if the fee has the override flag set (2nd highest bit of the uint24)


```solidity
function isOverride(uint24 self) internal pure returns (bool);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`uint24`|The fee to check|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bool`|bool True of the fee has the override flag set|


### removeOverrideFlag

returns a fee with the override flag removed


```solidity
function removeOverrideFlag(uint24 self) internal pure returns (uint24);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`uint24`|The fee to remove the override flag from|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint24`|fee The fee without the override flag set|


### removeOverrideFlagAndValidate

Removes the override flag and validates the fee (reverts if the fee is too large)


```solidity
function removeOverrideFlagAndValidate(uint24 self) internal pure returns (uint24 fee);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`uint24`|The fee to remove the override flag from, and then validate|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`fee`|`uint24`|The fee without the override flag set (if valid)|


## Errors
### LPFeeTooLarge
Thrown when the static or dynamic fee on a pool exceeds 100%.


```solidity
error LPFeeTooLarge(uint24 fee);
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/NonzeroDeltaCount.md">
# NonzeroDeltaCount
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/NonzeroDeltaCount.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

This is a temporary library that allows us to use transient storage (tstore/tload)
for the nonzero delta count.
TODO: This library can be deleted when we have the transient keyword support in solidity.


## State Variables
### NONZERO_DELTA_COUNT_SLOT

```solidity
bytes32 internal constant NONZERO_DELTA_COUNT_SLOT = 0x7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b;
```


## Functions
### read


```solidity
function read() internal view returns (uint256 count);
```

### increment


```solidity
function increment() internal;
```

### decrement

Potential to underflow. Ensure checks are performed by integrating contracts to ensure this does not happen.
Current usage ensures this will not happen because we call decrement with known boundaries (only up to the number of times we call increment).


```solidity
function decrement() internal;
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/ParseBytes.md">
# ParseBytes
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/ParseBytes.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Parses bytes returned from hooks and the byte selector used to check return selectors from hooks.

*parseSelector also is used to parse the expected selector
For parsing hook returns, note that all hooks return either bytes4 or (bytes4, 32-byte-delta) or (bytes4, 32-byte-delta, uint24).*


## Functions
### parseSelector


```solidity
function parseSelector(bytes memory result) internal pure returns (bytes4 selector);
```

### parseFee


```solidity
function parseFee(bytes memory result) internal pure returns (uint24 lpFee);
```

### parseReturnDelta


```solidity
function parseReturnDelta(bytes memory result) internal pure returns (int256 hookReturn);
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/Pool.md">
# Pool
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/Pool.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

a library with all actions that can be performed on a pool


## Functions
### checkTicks

*Common checks for valid tick inputs.*


```solidity
function checkTicks(int24 tickLower, int24 tickUpper) private pure;
```

### initialize


```solidity
function initialize(State storage self, uint160 sqrtPriceX96, uint24 lpFee) internal returns (int24 tick);
```

### setProtocolFee


```solidity
function setProtocolFee(State storage self, uint24 protocolFee) internal;
```

### setLPFee

Only dynamic fee pools may update the lp fee.


```solidity
function setLPFee(State storage self, uint24 lpFee) internal;
```

### modifyLiquidity

Effect changes to a position in a pool

*PoolManager checks that the pool is initialized before calling*


```solidity
function modifyLiquidity(State storage self, ModifyLiquidityParams memory params)
    internal
    returns (BalanceDelta delta, BalanceDelta feeDelta);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`State`||
|`params`|`ModifyLiquidityParams`|the position details and the change to the position's liquidity to effect|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`delta`|`BalanceDelta`|the deltas of the token balances of the pool, from the liquidity change|
|`feeDelta`|`BalanceDelta`|the fees generated by the liquidity range|


### swap

Executes a swap against the state, and returns the amount deltas of the pool

*PoolManager checks that the pool is initialized before calling*


```solidity
function swap(State storage self, SwapParams memory params)
    internal
    returns (BalanceDelta swapDelta, uint256 amountToProtocol, uint24 swapFee, SwapResult memory result);
```

### donate

Donates the given amount of currency0 and currency1 to the pool


```solidity
function donate(State storage state, uint256 amount0, uint256 amount1) internal returns (BalanceDelta delta);
```

### getFeeGrowthInside

Retrieves fee growth data


```solidity
function getFeeGrowthInside(State storage self, int24 tickLower, int24 tickUpper)
    internal
    view
    returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`State`|The Pool state struct|
|`tickLower`|`int24`|The lower tick boundary of the position|
|`tickUpper`|`int24`|The upper tick boundary of the position|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`feeGrowthInside0X128`|`uint256`|The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries|
|`feeGrowthInside1X128`|`uint256`|The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries|


### updateTick

Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa


```solidity
function updateTick(State storage self, int24 tick, int128 liquidityDelta, bool upper)
    internal
    returns (bool flipped, uint128 liquidityGrossAfter);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`State`|The mapping containing all tick information for initialized ticks|
|`tick`|`int24`|The tick that will be updated|
|`liquidityDelta`|`int128`|A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)|
|`upper`|`bool`|true for updating a position's upper tick, or false for updating a position's lower tick|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`flipped`|`bool`|Whether the tick was flipped from initialized to uninitialized, or vice versa|
|`liquidityGrossAfter`|`uint128`|The total amount of liquidity for all positions that references the tick after the update|


### tickSpacingToMaxLiquidityPerTick

Derives max liquidity per tick from given tick spacing

*Executed when adding liquidity*


```solidity
function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128 result);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tickSpacing`|`int24`|The amount of required tick separation, realized in multiples of `tickSpacing` e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`result`|`uint128`|The max liquidity per tick|


### checkPoolInitialized

Reverts if the given pool has not been initialized


```solidity
function checkPoolInitialized(State storage self) internal view;
```

### clearTick

Clears tick data


```solidity
function clearTick(State storage self, int24 tick) internal;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`State`|The mapping containing all initialized tick information for initialized ticks|
|`tick`|`int24`|The tick that will be cleared|


### crossTick

Transitions to next tick as needed by price movement


```solidity
function crossTick(State storage self, int24 tick, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128)
    internal
    returns (int128 liquidityNet);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`State`|The Pool state struct|
|`tick`|`int24`|The destination tick of the transition|
|`feeGrowthGlobal0X128`|`uint256`|The all-time global fee growth, per unit of liquidity, in token0|
|`feeGrowthGlobal1X128`|`uint256`|The all-time global fee growth, per unit of liquidity, in token1|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidityNet`|`int128`|The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)|


## Errors
### TicksMisordered
Thrown when tickLower is not below tickUpper


```solidity
error TicksMisordered(int24 tickLower, int24 tickUpper);
```

**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tickLower`|`int24`|The invalid tickLower|
|`tickUpper`|`int24`|The invalid tickUpper|

### TickLowerOutOfBounds
Thrown when tickLower is less than min tick


```solidity
error TickLowerOutOfBounds(int24 tickLower);
```

**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tickLower`|`int24`|The invalid tickLower|

### TickUpperOutOfBounds
Thrown when tickUpper exceeds max tick


```solidity
error TickUpperOutOfBounds(int24 tickUpper);
```

**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tickUpper`|`int24`|The invalid tickUpper|

### TickLiquidityOverflow
For the tick spacing, the tick has too much liquidity


```solidity
error TickLiquidityOverflow(int24 tick);
```

### PoolAlreadyInitialized
Thrown when trying to initialize an already initialized pool


```solidity
error PoolAlreadyInitialized();
```

### PoolNotInitialized
Thrown when trying to interact with a non-initialized pool


```solidity
error PoolNotInitialized();
```

### PriceLimitAlreadyExceeded
Thrown when sqrtPriceLimitX96 on a swap has already exceeded its limit


```solidity
error PriceLimitAlreadyExceeded(uint160 sqrtPriceCurrentX96, uint160 sqrtPriceLimitX96);
```

**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceCurrentX96`|`uint160`|The invalid, already surpassed sqrtPriceLimitX96|
|`sqrtPriceLimitX96`|`uint160`|The surpassed price limit|

### PriceLimitOutOfBounds
Thrown when sqrtPriceLimitX96 lies outside of valid tick/price range


```solidity
error PriceLimitOutOfBounds(uint160 sqrtPriceLimitX96);
```

**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceLimitX96`|`uint160`|The invalid, out-of-bounds sqrtPriceLimitX96|

### NoLiquidityToReceiveFees
Thrown by donate if there is currently 0 liquidity, since the fees will not go to any liquidity providers


```solidity
error NoLiquidityToReceiveFees();
```

### InvalidFeeForExactOut
Thrown when trying to swap with max lp fee and specifying an output amount


```solidity
error InvalidFeeForExactOut();
```

## Structs
### TickInfo

```solidity
struct TickInfo {
    uint128 liquidityGross;
    int128 liquidityNet;
    uint256 feeGrowthOutside0X128;
    uint256 feeGrowthOutside1X128;
}
```

### State
The state of a pool

*Note that feeGrowthGlobal can be artificially inflated
For pools with a single liquidity position, actors can donate to themselves to freely inflate feeGrowthGlobal
atomically donating and collecting fees in the same unlockCallback may make the inflated value more extreme*


```solidity
struct State {
    Slot0 slot0;
    uint256 feeGrowthGlobal0X128;
    uint256 feeGrowthGlobal1X128;
    uint128 liquidity;
    mapping(int24 tick => TickInfo) ticks;
    mapping(int16 wordPos => uint256) tickBitmap;
    mapping(bytes32 positionKey => Position.State) positions;
}
```

### ModifyLiquidityParams

```solidity
struct ModifyLiquidityParams {
    address owner;
    int24 tickLower;
    int24 tickUpper;
    int128 liquidityDelta;
    int24 tickSpacing;
    bytes32 salt;
}
```

### ModifyLiquidityState

```solidity
struct ModifyLiquidityState {
    bool flippedLower;
    uint128 liquidityGrossAfterLower;
    bool flippedUpper;
    uint128 liquidityGrossAfterUpper;
}
```

### SwapResult

```solidity
struct SwapResult {
    uint160 sqrtPriceX96;
    int24 tick;
    uint128 liquidity;
}
```

### StepComputations

```solidity
struct StepComputations {
    uint160 sqrtPriceStartX96;
    int24 tickNext;
    bool initialized;
    uint160 sqrtPriceNextX96;
    uint256 amountIn;
    uint256 amountOut;
    uint256 feeAmount;
    uint256 feeGrowthGlobalX128;
}
```

### SwapParams

```solidity
struct SwapParams {
    int256 amountSpecified;
    int24 tickSpacing;
    bool zeroForOne;
    uint160 sqrtPriceLimitX96;
    uint24 lpFeeOverride;
}
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/Position.md">
# Position
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/Position.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Positions represent an owner address' liquidity between a lower and upper tick boundary

*Positions store additional state for tracking fees owed to the position*


## Functions
### get

Returns the State struct of a position, given an owner and position boundaries


```solidity
function get(mapping(bytes32 => State) storage self, address owner, int24 tickLower, int24 tickUpper, bytes32 salt)
    internal
    view
    returns (State storage position);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`mapping(bytes32 => State)`|The mapping containing all user positions|
|`owner`|`address`|The address of the position owner|
|`tickLower`|`int24`|The lower tick boundary of the position|
|`tickUpper`|`int24`|The upper tick boundary of the position|
|`salt`|`bytes32`|A unique value to differentiate between multiple positions in the same range|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`position`|`State`|The position info struct of the given owners' position|


### calculatePositionKey

A helper function to calculate the position key


```solidity
function calculatePositionKey(address owner, int24 tickLower, int24 tickUpper, bytes32 salt)
    internal
    pure
    returns (bytes32 positionKey);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`owner`|`address`|The address of the position owner|
|`tickLower`|`int24`|the lower tick boundary of the position|
|`tickUpper`|`int24`|the upper tick boundary of the position|
|`salt`|`bytes32`|A unique value to differentiate between multiple positions in the same range, by the same owner. Passed in by the caller.|


### update

Credits accumulated fees to a user's position


```solidity
function update(State storage self, int128 liquidityDelta, uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)
    internal
    returns (uint256 feesOwed0, uint256 feesOwed1);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`State`|The individual position to update|
|`liquidityDelta`|`int128`|The change in pool liquidity as a result of the position update|
|`feeGrowthInside0X128`|`uint256`|The all-time fee growth in currency0, per unit of liquidity, inside the position's tick boundaries|
|`feeGrowthInside1X128`|`uint256`|The all-time fee growth in currency1, per unit of liquidity, inside the position's tick boundaries|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`feesOwed0`|`uint256`|The amount of currency0 owed to the position owner|
|`feesOwed1`|`uint256`|The amount of currency1 owed to the position owner|


## Errors
### CannotUpdateEmptyPosition
Cannot update a position with no liquidity


```solidity
error CannotUpdateEmptyPosition();
```

## Structs
### State

```solidity
struct State {
    uint128 liquidity;
    uint256 feeGrowthInside0LastX128;
    uint256 feeGrowthInside1LastX128;
}
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/ProtocolFeeLibrary.md">
# ProtocolFeeLibrary
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/ProtocolFeeLibrary.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

library of functions related to protocol fees


## State Variables
### MAX_PROTOCOL_FEE
Max protocol fee is 0.1% (1000 pips)

*Increasing these values could lead to overflow in Pool.swap*


```solidity
uint16 public constant MAX_PROTOCOL_FEE = 1000;
```


### FEE_0_THRESHOLD
Thresholds used for optimized bounds checks on protocol fees


```solidity
uint24 internal constant FEE_0_THRESHOLD = 1001;
```


### FEE_1_THRESHOLD

```solidity
uint24 internal constant FEE_1_THRESHOLD = 1001 << 12;
```


### PIPS_DENOMINATOR
the protocol fee is represented in hundredths of a bip


```solidity
uint256 internal constant PIPS_DENOMINATOR = 1_000_000;
```


## Functions
### getZeroForOneFee


```solidity
function getZeroForOneFee(uint24 self) internal pure returns (uint16);
```

### getOneForZeroFee


```solidity
function getOneForZeroFee(uint24 self) internal pure returns (uint16);
```

### isValidProtocolFee


```solidity
function isValidProtocolFee(uint24 self) internal pure returns (bool valid);
```

### calculateSwapFee

*here `self` is just a single direction's protocol fee, not a packed type of 2 protocol fees*


```solidity
function calculateSwapFee(uint16 self, uint24 lpFee) internal pure returns (uint24 swapFee);
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/SafeCast.md">
# SafeCast
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/SafeCast.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Contains methods for safely casting between types


## Functions
### toUint160

Cast a uint256 to a uint160, revert on overflow


```solidity
function toUint160(uint256 x) internal pure returns (uint160 y);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`x`|`uint256`|The uint256 to be downcasted|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`y`|`uint160`|The downcasted integer, now type uint160|


### toUint128

Cast a uint256 to a uint128, revert on overflow


```solidity
function toUint128(uint256 x) internal pure returns (uint128 y);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`x`|`uint256`|The uint256 to be downcasted|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`y`|`uint128`|The downcasted integer, now type uint128|


### toUint128

Cast a int128 to a uint128, revert on overflow or underflow


```solidity
function toUint128(int128 x) internal pure returns (uint128 y);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`x`|`int128`|The int128 to be casted|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`y`|`uint128`|The casted integer, now type uint128|


### toInt128

Cast a int256 to a int128, revert on overflow or underflow


```solidity
function toInt128(int256 x) internal pure returns (int128 y);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`x`|`int256`|The int256 to be downcasted|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`y`|`int128`|The downcasted integer, now type int128|


### toInt256

Cast a uint256 to a int256, revert on overflow


```solidity
function toInt256(uint256 x) internal pure returns (int256 y);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`x`|`uint256`|The uint256 to be casted|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`y`|`int256`|The casted integer, now type int256|


### toInt128

Cast a uint256 to a int128, revert on overflow


```solidity
function toInt128(uint256 x) internal pure returns (int128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`x`|`uint256`|The uint256 to be downcasted|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`int128`|The downcasted integer, now type int128|


## Errors
### SafeCastOverflow

```solidity
error SafeCastOverflow();
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/SqrtPriceMath.md">
# SqrtPriceMath
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/SqrtPriceMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas


## Functions
### getNextSqrtPriceFromAmount0RoundingUp

Gets the next sqrt price given a delta of currency0

*Always rounds up, because in the exact output case (increasing price) we need to move the price at least
far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the
price less in order to not send too much output.
The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),
if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).*


```solidity
function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)
    internal
    pure
    returns (uint160);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPX96`|`uint160`|The starting price, i.e. before accounting for the currency0 delta|
|`liquidity`|`uint128`|The amount of usable liquidity|
|`amount`|`uint256`|How much of currency0 to add or remove from virtual reserves|
|`add`|`bool`|Whether to add or remove the amount of currency0|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint160`|The price after adding or removing amount, depending on add|


### getNextSqrtPriceFromAmount1RoundingDown

Gets the next sqrt price given a delta of currency1

*Always rounds down, because in the exact output case (decreasing price) we need to move the price at least
far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the
price less in order to not send too much output.
The formula we compute is within \<1 wei of the lossless version: sqrtPX96 +- amount / liquidity*


```solidity
function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)
    internal
    pure
    returns (uint160);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPX96`|`uint160`|The starting price, i.e., before accounting for the currency1 delta|
|`liquidity`|`uint128`|The amount of usable liquidity|
|`amount`|`uint256`|How much of currency1 to add, or remove, from virtual reserves|
|`add`|`bool`|Whether to add, or remove, the amount of currency1|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint160`|The price after adding or removing `amount`|


### getNextSqrtPriceFromInput

Gets the next sqrt price given an input amount of currency0 or currency1

*Throws if price or liquidity are 0, or if the next price is out of bounds*


```solidity
function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne)
    internal
    pure
    returns (uint160);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPX96`|`uint160`|The starting price, i.e., before accounting for the input amount|
|`liquidity`|`uint128`|The amount of usable liquidity|
|`amountIn`|`uint256`|How much of currency0, or currency1, is being swapped in|
|`zeroForOne`|`bool`|Whether the amount in is currency0 or currency1|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint160`|uint160 The price after adding the input amount to currency0 or currency1|


### getNextSqrtPriceFromOutput

Gets the next sqrt price given an output amount of currency0 or currency1

*Throws if price or liquidity are 0 or the next price is out of bounds*


```solidity
function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne)
    internal
    pure
    returns (uint160);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPX96`|`uint160`|The starting price before accounting for the output amount|
|`liquidity`|`uint128`|The amount of usable liquidity|
|`amountOut`|`uint256`|How much of currency0, or currency1, is being swapped out|
|`zeroForOne`|`bool`|Whether the amount out is currency1 or currency0|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint160`|uint160 The price after removing the output amount of currency0 or currency1|


### getAmount0Delta

Gets the amount0 delta between two prices

*Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),
i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))*


```solidity
function getAmount0Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity, bool roundUp)
    internal
    pure
    returns (uint256);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceAX96`|`uint160`|A sqrt price|
|`sqrtPriceBX96`|`uint160`|Another sqrt price|
|`liquidity`|`uint128`|The amount of usable liquidity|
|`roundUp`|`bool`|Whether to round the amount up or down|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint256`|uint256 Amount of currency0 required to cover a position of size liquidity between the two passed prices|


### absDiff

Equivalent to: `a >= b ? a - b : b - a`


```solidity
function absDiff(uint160 a, uint160 b) internal pure returns (uint256 res);
```

### getAmount1Delta

Gets the amount1 delta between two prices

*Calculates liquidity * (sqrt(upper) - sqrt(lower))*


```solidity
function getAmount1Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity, bool roundUp)
    internal
    pure
    returns (uint256 amount1);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceAX96`|`uint160`|A sqrt price|
|`sqrtPriceBX96`|`uint160`|Another sqrt price|
|`liquidity`|`uint128`|The amount of usable liquidity|
|`roundUp`|`bool`|Whether to round the amount up, or down|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amount1`|`uint256`|Amount of currency1 required to cover a position of size liquidity between the two passed prices|


### getAmount0Delta

Equivalent to:
amount1 = roundUp
? FullMath.mulDivRoundingUp(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96)
: FullMath.mulDiv(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96);
Cannot overflow because `type(uint128).max * type(uint160).max >> 96 < (1 << 192)`.

Helper that gets signed currency0 delta


```solidity
function getAmount0Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, int128 liquidity)
    internal
    pure
    returns (int256);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceAX96`|`uint160`|A sqrt price|
|`sqrtPriceBX96`|`uint160`|Another sqrt price|
|`liquidity`|`int128`|The change in liquidity for which to compute the amount0 delta|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`int256`|int256 Amount of currency0 corresponding to the passed liquidityDelta between the two prices|


### getAmount1Delta

Helper that gets signed currency1 delta


```solidity
function getAmount1Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, int128 liquidity)
    internal
    pure
    returns (int256);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceAX96`|`uint160`|A sqrt price|
|`sqrtPriceBX96`|`uint160`|Another sqrt price|
|`liquidity`|`int128`|The change in liquidity for which to compute the amount1 delta|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`int256`|int256 Amount of currency1 corresponding to the passed liquidityDelta between the two prices|


## Errors
### InvalidPriceOrLiquidity

```solidity
error InvalidPriceOrLiquidity();
```

### InvalidPrice

```solidity
error InvalidPrice();
```

### NotEnoughLiquidity

```solidity
error NotEnoughLiquidity();
```

### PriceOverflow

```solidity
error PriceOverflow();
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/StateLibrary.md">
# StateLibrary
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/StateLibrary.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

A helper library to provide state getters that use extsload


## State Variables
### POOLS_SLOT
index of pools mapping in the PoolManager


```solidity
bytes32 public constant POOLS_SLOT = bytes32(uint256(6));
```


### FEE_GROWTH_GLOBAL0_OFFSET
index of feeGrowthGlobal0X128 in Pool.State


```solidity
uint256 public constant FEE_GROWTH_GLOBAL0_OFFSET = 1;
```


### LIQUIDITY_OFFSET
index of liquidity in Pool.State


```solidity
uint256 public constant LIQUIDITY_OFFSET = 3;
```


### TICKS_OFFSET
index of TicksInfo mapping in Pool.State: mapping(int24 => TickInfo) ticks;


```solidity
uint256 public constant TICKS_OFFSET = 4;
```


### TICK_BITMAP_OFFSET
index of tickBitmap mapping in Pool.State


```solidity
uint256 public constant TICK_BITMAP_OFFSET = 5;
```


### POSITIONS_OFFSET
index of Position.State mapping in Pool.State: mapping(bytes32 => Position.State) positions;


```solidity
uint256 public constant POSITIONS_OFFSET = 6;
```


## Functions
### getSlot0

Get Slot0 of the pool: sqrtPriceX96, tick, protocolFee, lpFee

*Corresponds to pools[poolId].slot0*


```solidity
function getSlot0(IPoolManager manager, PoolId poolId)
    internal
    view
    returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 lpFee);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`manager`|`IPoolManager`|The pool manager contract.|
|`poolId`|`PoolId`|The ID of the pool.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceX96`|`uint160`|The square root of the price of the pool, in Q96 precision.|
|`tick`|`int24`|The current tick of the pool.|
|`protocolFee`|`uint24`|The protocol fee of the pool.|
|`lpFee`|`uint24`|The swap fee of the pool.|


### getTickInfo

Retrieves the tick information of a pool at a specific tick.

*Corresponds to pools[poolId].ticks[tick]*


```solidity
function getTickInfo(IPoolManager manager, PoolId poolId, int24 tick)
    internal
    view
    returns (uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`manager`|`IPoolManager`|The pool manager contract.|
|`poolId`|`PoolId`|The ID of the pool.|
|`tick`|`int24`|The tick to retrieve information for.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidityGross`|`uint128`|The total position liquidity that references this tick|
|`liquidityNet`|`int128`|The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left)|
|`feeGrowthOutside0X128`|`uint256`|fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)|
|`feeGrowthOutside1X128`|`uint256`|fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)|


### getTickLiquidity

Retrieves the liquidity information of a pool at a specific tick.

*Corresponds to pools[poolId].ticks[tick].liquidityGross and pools[poolId].ticks[tick].liquidityNet. A more gas efficient version of getTickInfo*


```solidity
function getTickLiquidity(IPoolManager manager, PoolId poolId, int24 tick)
    internal
    view
    returns (uint128 liquidityGross, int128 liquidityNet);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`manager`|`IPoolManager`|The pool manager contract.|
|`poolId`|`PoolId`|The ID of the pool.|
|`tick`|`int24`|The tick to retrieve liquidity for.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidityGross`|`uint128`|The total position liquidity that references this tick|
|`liquidityNet`|`int128`|The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left)|


### getTickFeeGrowthOutside

Retrieves the fee growth outside a tick range of a pool

*Corresponds to pools[poolId].ticks[tick].feeGrowthOutside0X128 and pools[poolId].ticks[tick].feeGrowthOutside1X128. A more gas efficient version of getTickInfo*


```solidity
function getTickFeeGrowthOutside(IPoolManager manager, PoolId poolId, int24 tick)
    internal
    view
    returns (uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`manager`|`IPoolManager`|The pool manager contract.|
|`poolId`|`PoolId`|The ID of the pool.|
|`tick`|`int24`|The tick to retrieve fee growth for.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`feeGrowthOutside0X128`|`uint256`|fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)|
|`feeGrowthOutside1X128`|`uint256`|fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)|


### getFeeGrowthGlobals

Retrieves the global fee growth of a pool.

*Corresponds to pools[poolId].feeGrowthGlobal0X128 and pools[poolId].feeGrowthGlobal1X128*

*Note that feeGrowthGlobal can be artificially inflated
For pools with a single liquidity position, actors can donate to themselves to freely inflate feeGrowthGlobal
atomically donating and collecting fees in the same unlockCallback may make the inflated value more extreme*


```solidity
function getFeeGrowthGlobals(IPoolManager manager, PoolId poolId)
    internal
    view
    returns (uint256 feeGrowthGlobal0, uint256 feeGrowthGlobal1);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`manager`|`IPoolManager`|The pool manager contract.|
|`poolId`|`PoolId`|The ID of the pool.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`feeGrowthGlobal0`|`uint256`|The global fee growth for token0.|
|`feeGrowthGlobal1`|`uint256`|The global fee growth for token1.|


### getLiquidity

Retrieves total the liquidity of a pool.

*Corresponds to pools[poolId].liquidity*


```solidity
function getLiquidity(IPoolManager manager, PoolId poolId) internal view returns (uint128 liquidity);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`manager`|`IPoolManager`|The pool manager contract.|
|`poolId`|`PoolId`|The ID of the pool.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The liquidity of the pool.|


### getTickBitmap

Retrieves the tick bitmap of a pool at a specific tick.

*Corresponds to pools[poolId].tickBitmap[tick]*


```solidity
function getTickBitmap(IPoolManager manager, PoolId poolId, int16 tick) internal view returns (uint256 tickBitmap);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`manager`|`IPoolManager`|The pool manager contract.|
|`poolId`|`PoolId`|The ID of the pool.|
|`tick`|`int16`|The tick to retrieve the bitmap for.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`tickBitmap`|`uint256`|The bitmap of the tick.|


### getPositionInfo

Retrieves the position information of a pool without needing to calculate the `positionId`.

*Corresponds to pools[poolId].positions[positionId]*


```solidity
function getPositionInfo(
    IPoolManager manager,
    PoolId poolId,
    address owner,
    int24 tickLower,
    int24 tickUpper,
    bytes32 salt
) internal view returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`manager`|`IPoolManager`||
|`poolId`|`PoolId`|The ID of the pool.|
|`owner`|`address`|The owner of the liquidity position.|
|`tickLower`|`int24`|The lower tick of the liquidity range.|
|`tickUpper`|`int24`|The upper tick of the liquidity range.|
|`salt`|`bytes32`|The bytes32 randomness to further distinguish position state.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The liquidity of the position.|
|`feeGrowthInside0LastX128`|`uint256`|The fee growth inside the position for token0.|
|`feeGrowthInside1LastX128`|`uint256`|The fee growth inside the position for token1.|


### getPositionInfo

Retrieves the position information of a pool at a specific position ID.

*Corresponds to pools[poolId].positions[positionId]*


```solidity
function getPositionInfo(IPoolManager manager, PoolId poolId, bytes32 positionId)
    internal
    view
    returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`manager`|`IPoolManager`|The pool manager contract.|
|`poolId`|`PoolId`|The ID of the pool.|
|`positionId`|`bytes32`|The ID of the position.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The liquidity of the position.|
|`feeGrowthInside0LastX128`|`uint256`|The fee growth inside the position for token0.|
|`feeGrowthInside1LastX128`|`uint256`|The fee growth inside the position for token1.|


### getPositionLiquidity

Retrieves the liquidity of a position.

*Corresponds to pools[poolId].positions[positionId].liquidity. More gas efficient for just retrieiving liquidity as compared to getPositionInfo*


```solidity
function getPositionLiquidity(IPoolManager manager, PoolId poolId, bytes32 positionId)
    internal
    view
    returns (uint128 liquidity);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`manager`|`IPoolManager`|The pool manager contract.|
|`poolId`|`PoolId`|The ID of the pool.|
|`positionId`|`bytes32`|The ID of the position.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The liquidity of the position.|


### getFeeGrowthInside

Calculate the fee growth inside a tick range of a pool

*pools[poolId].feeGrowthInside0LastX128 in Position.State is cached and can become stale. This function will calculate the up to date feeGrowthInside*


```solidity
function getFeeGrowthInside(IPoolManager manager, PoolId poolId, int24 tickLower, int24 tickUpper)
    internal
    view
    returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`manager`|`IPoolManager`|The pool manager contract.|
|`poolId`|`PoolId`|The ID of the pool.|
|`tickLower`|`int24`|The lower tick of the range.|
|`tickUpper`|`int24`|The upper tick of the range.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`feeGrowthInside0X128`|`uint256`|The fee growth inside the tick range for token0.|
|`feeGrowthInside1X128`|`uint256`|The fee growth inside the tick range for token1.|


### _getPoolStateSlot


```solidity
function _getPoolStateSlot(PoolId poolId) internal pure returns (bytes32);
```

### _getTickInfoSlot


```solidity
function _getTickInfoSlot(PoolId poolId, int24 tick) internal pure returns (bytes32);
```

### _getPositionInfoSlot


```solidity
function _getPositionInfoSlot(PoolId poolId, bytes32 positionId) internal pure returns (bytes32);
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/SwapMath.md">
# SwapMath
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/SwapMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.


## State Variables
### MAX_SWAP_FEE
the swap fee is represented in hundredths of a bip, so the max is 100%

*the swap fee is the total fee on a swap, including both LP and Protocol fee*


```solidity
uint256 internal constant MAX_SWAP_FEE = 1e6;
```


## Functions
### getSqrtPriceTarget

Computes the sqrt price target for the next swap step


```solidity
function getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160 sqrtPriceLimitX96)
    internal
    pure
    returns (uint160 sqrtPriceTargetX96);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`zeroForOne`|`bool`|The direction of the swap, true for currency0 to currency1, false for currency1 to currency0|
|`sqrtPriceNextX96`|`uint160`|The Q64.96 sqrt price for the next initialized tick|
|`sqrtPriceLimitX96`|`uint160`|The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceTargetX96`|`uint160`|The price target for the next swap step|


### computeSwapStep

Computes the result of swapping some amount in, or amount out, given the parameters of the swap

*If the swap's amountSpecified is negative, the combined fee and input amount will never exceed the absolute value of the remaining amount.*

*feePips must be no larger than MAX_SWAP_FEE for this function. We ensure that before setting a fee using LPFeeLibrary.isValid.*


```solidity
function computeSwapStep(
    uint160 sqrtPriceCurrentX96,
    uint160 sqrtPriceTargetX96,
    uint128 liquidity,
    int256 amountRemaining,
    uint24 feePips
) internal pure returns (uint160 sqrtPriceNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceCurrentX96`|`uint160`|The current sqrt price of the pool|
|`sqrtPriceTargetX96`|`uint160`|The price that cannot be exceeded, from which the direction of the swap is inferred|
|`liquidity`|`uint128`|The usable liquidity|
|`amountRemaining`|`int256`|How much input or output amount is remaining to be swapped in/out|
|`feePips`|`uint24`|The fee taken from the input amount, expressed in hundredths of a bip|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceNextX96`|`uint160`|The price after swapping the amount in/out, not to exceed the price target|
|`amountIn`|`uint256`|The amount to be swapped in, of either currency0 or currency1, based on the direction of the swap|
|`amountOut`|`uint256`|The amount to be received, of either currency0 or currency1, based on the direction of the swap|
|`feeAmount`|`uint256`|The amount of input that will be taken as a fee|
</file>

<file path="docs/contracts/v4/reference/core/libraries/TickBitmap.md">
# TickBitmap
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/TickBitmap.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Stores a packed mapping of tick index to its initialized state

*The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.*


## Functions
### compress

*round towards negative infinity*


```solidity
function compress(int24 tick, int24 tickSpacing) internal pure returns (int24 compressed);
```

### position

Computes the position in the mapping where the initialized bit for a tick lives


```solidity
function position(int24 tick) internal pure returns (int16 wordPos, uint8 bitPos);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tick`|`int24`|The tick for which to compute the position|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`wordPos`|`int16`|The key in the mapping containing the word in which the bit is stored|
|`bitPos`|`uint8`|The bit position in the word where the flag is stored|


### flipTick

Flips the initialized state for a given tick from false to true, or vice versa


```solidity
function flipTick(mapping(int16 => uint256) storage self, int24 tick, int24 tickSpacing) internal;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`mapping(int16 => uint256)`|The mapping in which to flip the tick|
|`tick`|`int24`|The tick to flip|
|`tickSpacing`|`int24`|The spacing between usable ticks|


### nextInitializedTickWithinOneWord

Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either
to the left (less than or equal to) or right (greater than) of the given tick


```solidity
function nextInitializedTickWithinOneWord(
    mapping(int16 => uint256) storage self,
    int24 tick,
    int24 tickSpacing,
    bool lte
) internal view returns (int24 next, bool initialized);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`self`|`mapping(int16 => uint256)`|The mapping in which to compute the next initialized tick|
|`tick`|`int24`|The starting tick|
|`tickSpacing`|`int24`|The spacing between usable ticks|
|`lte`|`bool`|Whether to search for the next initialized tick to the left (less than or equal to the starting tick)|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`next`|`int24`|The next initialized or uninitialized tick up to 256 ticks away from the current tick|
|`initialized`|`bool`|Whether the next tick is initialized, as the function only searches within up to 256 ticks|


## Errors
### TickMisaligned
Thrown when the tick is not enumerated by the tick spacing


```solidity
error TickMisaligned(int24 tick, int24 tickSpacing);
```

**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tick`|`int24`|the invalid tick|
|`tickSpacing`|`int24`|The tick spacing of the pool|
</file>

<file path="docs/contracts/v4/reference/core/libraries/TickMath.md">
# TickMath
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/TickMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
prices between 2**-128 and 2**128


## State Variables
### MIN_TICK
*The minimum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**-128*

*If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used*


```solidity
int24 internal constant MIN_TICK = -887272;
```


### MAX_TICK
*The maximum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**128*

*If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used*


```solidity
int24 internal constant MAX_TICK = 887272;
```


### MIN_TICK_SPACING
*The minimum tick spacing value drawn from the range of type int16 that is greater than 0, i.e. min from the range [1, 32767]*


```solidity
int24 internal constant MIN_TICK_SPACING = 1;
```


### MAX_TICK_SPACING
*The maximum tick spacing value drawn from the range of type int16, i.e. max from the range [1, 32767]*


```solidity
int24 internal constant MAX_TICK_SPACING = type(int16).max;
```


### MIN_SQRT_PRICE
*The minimum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MIN_TICK)*


```solidity
uint160 internal constant MIN_SQRT_PRICE = 4295128739;
```


### MAX_SQRT_PRICE
*The maximum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MAX_TICK)*


```solidity
uint160 internal constant MAX_SQRT_PRICE = 1461446703485210103287273052203988822378723970342;
```


### MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE
*A threshold used for optimized bounds check, equals `MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1`*


```solidity
uint160 internal constant MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE =
    1461446703485210103287273052203988822378723970342 - 4295128739 - 1;
```


## Functions
### maxUsableTick

Given a tickSpacing, compute the maximum usable tick


```solidity
function maxUsableTick(int24 tickSpacing) internal pure returns (int24);
```

### minUsableTick

Given a tickSpacing, compute the minimum usable tick


```solidity
function minUsableTick(int24 tickSpacing) internal pure returns (int24);
```

### getSqrtPriceAtTick

Calculates sqrt(1.0001^tick) * 2^96

*Throws if |tick| > max tick*


```solidity
function getSqrtPriceAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tick`|`int24`|The input tick for the above formula|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceX96`|`uint160`|A Fixed point Q64.96 number representing the sqrt of the price of the two assets (currency1/currency0) at the given tick|


### getTickAtSqrtPrice

Calculates the greatest tick value such that getSqrtPriceAtTick(tick) \<= sqrtPriceX96

*Throws in case sqrtPriceX96 < MIN_SQRT_PRICE, as MIN_SQRT_PRICE is the lowest value getSqrtPriceAtTick may
ever return.*


```solidity
function getTickAtSqrtPrice(uint160 sqrtPriceX96) internal pure returns (int24 tick);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceX96`|`uint160`|The sqrt price for which to compute the tick as a Q64.96|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`tick`|`int24`|The greatest tick for which the getSqrtPriceAtTick(tick) is less than or equal to the input sqrtPriceX96|


## Errors
### InvalidTick
Thrown when the tick passed to #getSqrtPriceAtTick is not between MIN_TICK and MAX_TICK


```solidity
error InvalidTick(int24 tick);
```

### InvalidSqrtPrice
Thrown when the price passed to #getTickAtSqrtPrice does not correspond to a price between MIN_TICK and MAX_TICK


```solidity
error InvalidSqrtPrice(uint160 sqrtPriceX96);
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/transient-state-library.mdx">
---
title: TransientStateLibrary
---

The `TransientStateLibrary` is a crucial component of Uniswap V4, providing utility functions for managing transient state in the PoolManager contract. This library handles operations related to reserves, delta counts, and locking state, which are essential for the efficient and secure operation of the Uniswap V4 protocol.

## Key Concepts

### Transient Storage

Uniswap V4 uses transient storage to optimize gas costs and improve efficiency. Transient storage, introduced in EIP-1153, is a way to store data that is only needed for the duration of a transaction, without persisting it to the blockchain's state trie. This is achieved using the `TLOAD` and `TSTORE` opcodes.

Key points about transient storage in Uniswap V4:

1. **PoolManager and** `exttload`: Instead of exposing custom getters for transient storage, the PoolManager implements an `exttload` (external tload) function. This function serves as an external wrapper for the `TLOAD` opcode, providing a standardized interface for accessing transient storage.
2. **TransientStateLibrary's Role:** The `TransientStateLibrary` acts as an intermediary, making calls to the PoolManager's `exttload` function to access transient storage. This abstraction simplifies the interaction with transient storage for other parts of the Uniswap V4 ecosystem.
3. **Standardization:** By channeling all transient storage access through the PoolManager's `exttload` function, Uniswap V4 ensures a consistent and controlled approach to managing transient data across the protocol.

Common operations that involve transient state include:

- Checking reserves (`getReserves`)
- Verifying currency deltas (`currencyDelta`)
- Syncing currency states (`sync`)
- Settling currency balances (`settle`)

This architecture allows Uniswap V4 to benefit from the gas efficiency of transient storage while maintaining a clean and standardized interface for interacting with this temporary data.

## Functions

### getReserves

```solidity
function getReserves(IPoolManager manager, Currency currency) internal view returns (uint256)
```

Retrieves the reserves of a specific currency from the PoolManager's transient storage.

| Param Name | Type         | Description                                      |
|------------|--------------|--------------------------------------------------|
| manager    | IPoolManager | The PoolManager contract instance                 |
| currency   | Currency     | The currency for which to fetch reserves          |

**Returns:**
- `uint256`: The amount of reserves for the specified currency

**Notes:**
- Returns `0` if the reserves are not synced
- Returns `type(uint256).max` if the reserves are synced but the value is `0`

### getNonzeroDeltaCount

```solidity
function getNonzeroDeltaCount(IPoolManager manager) internal view returns (uint256)
```

Retrieves the count of nonzero deltas that must be zeroed out before the contract can be locked.

| Param Name | Type         | Description                          |
|------------|--------------|--------------------------------------|
| manager    | IPoolManager | The PoolManager contract instance    |

**Returns:**

- `uint256`: The number of nonzero deltas

### currencyDelta

```solidity
function currencyDelta(IPoolManager manager, address caller_, Currency currency) internal view returns (int256)
```

Fetches the current delta for a specific caller and currency from the PoolManager's transient storage.

| Param Name | Type         | Description                                      |
|------------|--------------|--------------------------------------------------|
| manager    | IPoolManager | The PoolManager contract instance                 |
| caller_    | address      | The address of the caller                         |
| currency   | Currency     | The currency for which to lookup the delta        |

**Returns:**

- `int256`: The delta value for the specified caller and currency

**Notes:**

- A **negative** delta indicates an amount that must be **paid or settled** by the caller. In other words, a negative delta means the caller owes that amount and needs to pay or settle it.
- A **positive** delta indicates an amount that is owed to the caller. This delta amount must be **taken or claimed** by the caller.

### isUnlocked

```solidity
function isUnlocked(IPoolManager manager) internal view returns (bool)
```

Checks if the PoolManager contract is currently unlocked.

| Param Name | Type         | Description                          |
|------------|--------------|--------------------------------------|
| manager    | IPoolManager | The PoolManager contract instance    |

**Returns:**

- `bool`: `true` if the contract is unlocked, `false` otherwise

## Usage and Importance

The `TransientStateLibrary` plays a critical role in Uniswap V4's operation:

1. **Gas Optimization:** By using transient storage, the library helps reduce gas costs associated with state changes that are only relevant within a single transaction. This is particularly important for multi-hop transactions, where internal net balances (deltas) are updated instead of making token transfers for each hop.
2. **Security:** The library provides functions to check the lock state and manage deltas, which are crucial for maintaining the integrity of the protocol during operations. The use of transient storage also allows for more efficient implementation of security measures compared to V3's reentrancy guards.
3. **Flexibility:** The library allows for efficient management of currency-specific data, such as reserves and deltas, which is essential for Uniswap V4's multi-currency pools.
4. **Encapsulation:** By centralizing these utility functions in a library, the code promotes better organization and reusability across the Uniswap V4 codebase.

## Integration with PoolManager

The `TransientStateLibrary` is designed to work closely with the `PoolManager` contract. The `TransientStateLibrary` can be easily integrated with the `PoolManager` contract using the `using` keyword for syntactic sugar. This allows you to call the library functions as if they were methods of the `IPoolManager` instance. Here's an example:

```solidity
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {TransientStateLibrary} from "v4-core/src/libraries/TransientStateLibrary.sol";

contract Example {
    using TransientStateLibrary for IPoolManager;

    function example() external {
        int256 delta = manager.currencyDelta(address(this), currency);
        // Use the delta value...
    }
}
```

In this example, the `using TransientStateLibrary for IPoolManager;` statement allows you to call `currencyDelta` directly on the `manager` instance, making your code more readable and concise.
</file>

<file path="docs/contracts/v4/reference/core/libraries/TransientStateLibrary.md">
# TransientStateLibrary
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/TransientStateLibrary.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

A helper library to provide state getters that use exttload


## Functions
### getSyncedReserves

returns the reserves for the synced currency

*returns 0 if the reserves are not synced or value is 0.
Checks the synced currency to only return valid reserve values (after a sync and before a settle).*


```solidity
function getSyncedReserves(IPoolManager manager) internal view returns (uint256);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`manager`|`IPoolManager`|The pool manager contract.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint256`|uint256 The reserves of the currency.|


### getSyncedCurrency


```solidity
function getSyncedCurrency(IPoolManager manager) internal view returns (Currency);
```

### getNonzeroDeltaCount

Returns the number of nonzero deltas open on the PoolManager that must be zeroed out before the contract is locked


```solidity
function getNonzeroDeltaCount(IPoolManager manager) internal view returns (uint256);
```

### currencyDelta

Get the current delta for a caller in the given currency


```solidity
function currencyDelta(IPoolManager manager, address target, Currency currency) internal view returns (int256);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`manager`|`IPoolManager`||
|`target`|`address`|The credited account address|
|`currency`|`Currency`|The currency for which to lookup the delta|


### isUnlocked

Returns whether the contract is unlocked or not


```solidity
function isUnlocked(IPoolManager manager) internal view returns (bool);
```
</file>

<file path="docs/contracts/v4/reference/core/libraries/UnsafeMath.md">
# UnsafeMath
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/libraries/UnsafeMath.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Contains methods that perform common math functions but do not do any overflow or underflow checks


## Functions
### divRoundingUp

Returns ceil(x / y)

*division by 0 will return 0, and should be checked externally*


```solidity
function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`x`|`uint256`|The dividend|
|`y`|`uint256`|The divisor|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`z`|`uint256`|The quotient, ceil(x / y)|


### simpleMulDiv

Calculates floor(a×b÷denominator)

*division by 0 will return 0, and should be checked externally*


```solidity
function simpleMulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`a`|`uint256`|The multiplicand|
|`b`|`uint256`|The multiplier|
|`denominator`|`uint256`|The divisor|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`result`|`uint256`|The 256-bit result, floor(a×b÷denominator)|
</file>

<file path="docs/contracts/v4/reference/core/test/ActionsRouter.md">
# ActionsRouter
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/ActionsRouter.sol)

**Inherits:**
[IUnlockCallback](/src/interfaces/callback/IUnlockCallback.sol/interface.IUnlockCallback.md), Test

A router that handles an arbitrary input of actions.
TODO: Can continue to add functions per action.


## Actions
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/ActionsRouter.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


```solidity
enum Actions {
    SETTLE,
    SETTLE_NATIVE,
    SETTLE_FOR,
    TAKE,
    PRANK_TAKE_FROM,
    SYNC,
    MINT,
    CLEAR,
    ASSERT_BALANCE_EQUALS,
    ASSERT_RESERVES_EQUALS,
    ASSERT_DELTA_EQUALS,
    ASSERT_NONZERO_DELTA_COUNT_EQUALS,
    TRANSFER_FROM,
    COLLECT_PROTOCOL_FEES
}
```

## State Variables
### manager

```solidity
IPoolManager manager;
```


## Functions
### constructor


```solidity
constructor(IPoolManager _manager);
```

### unlockCallback


```solidity
function unlockCallback(bytes calldata data) external returns (bytes memory);
```

### executeActions


```solidity
function executeActions(Actions[] memory actions, bytes[] memory params) external payable;
```

### _settle


```solidity
function _settle() internal;
```

### _settleNative


```solidity
function _settleNative(bytes memory params) internal;
```

### _settleFor


```solidity
function _settleFor(bytes memory params) internal;
```

### _take


```solidity
function _take(bytes memory params) internal;
```

### _prankTakeFrom


```solidity
function _prankTakeFrom(bytes memory params) internal;
```

### _sync


```solidity
function _sync(bytes memory params) internal;
```

### _mint


```solidity
function _mint(bytes memory params) internal;
```

### _clear


```solidity
function _clear(bytes memory params) internal;
```

### _assertBalanceEquals


```solidity
function _assertBalanceEquals(bytes memory params) internal view;
```

### _assertReservesEquals


```solidity
function _assertReservesEquals(bytes memory params) internal view;
```

### _assertDeltaEquals


```solidity
function _assertDeltaEquals(bytes memory params) internal view;
```

### _assertNonzeroDeltaCountEquals


```solidity
function _assertNonzeroDeltaCountEquals(bytes memory params) internal view;
```

### _transferFrom


```solidity
function _transferFrom(bytes memory params) internal;
```

### _collectProtocolFees


```solidity
function _collectProtocolFees(bytes memory params) internal;
```

## Errors
### ActionNotSupported

```solidity
error ActionNotSupported();
```

### CheckParameters

```solidity
error CheckParameters();
```
</file>

<file path="docs/contracts/v4/reference/core/test/BaseTestHooks.md">
# BaseTestHooks
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/BaseTestHooks.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IHooks](contracts/v4/reference/core/interfaces/IHooks.md)


## Functions
### beforeInitialize


```solidity
function beforeInitialize(address, PoolKey calldata, uint160) external virtual returns (bytes4);
```

### afterInitialize


```solidity
function afterInitialize(address, PoolKey calldata, uint160, int24) external virtual returns (bytes4);
```

### beforeAddLiquidity


```solidity
function beforeAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)
    external
    virtual
    returns (bytes4);
```

### afterAddLiquidity


```solidity
function afterAddLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata
) external virtual returns (bytes4, BalanceDelta);
```

### beforeRemoveLiquidity


```solidity
function beforeRemoveLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)
    external
    virtual
    returns (bytes4);
```

### afterRemoveLiquidity


```solidity
function afterRemoveLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata
) external virtual returns (bytes4, BalanceDelta);
```

### beforeSwap


```solidity
function beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)
    external
    virtual
    returns (bytes4, BeforeSwapDelta, uint24);
```

### afterSwap


```solidity
function afterSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)
    external
    virtual
    returns (bytes4, int128);
```

### beforeDonate


```solidity
function beforeDonate(address, PoolKey calldata, uint256, uint256, bytes calldata) external virtual returns (bytes4);
```

### afterDonate


```solidity
function afterDonate(address, PoolKey calldata, uint256, uint256, bytes calldata) external virtual returns (bytes4);
```

## Errors
### HookNotImplemented

```solidity
error HookNotImplemented();
```
</file>

<file path="docs/contracts/v4/reference/core/test/CurrencyTest.md">
# CurrencyTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/CurrencyTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


## Functions
### transfer


```solidity
function transfer(Currency currency, address to, uint256 amount) external;
```

### balanceOfSelf


```solidity
function balanceOfSelf(Currency currency) external view returns (uint256);
```

### balanceOf


```solidity
function balanceOf(Currency currency, address owner) external view returns (uint256);
```

### isAddressZero


```solidity
function isAddressZero(Currency currency) external pure returns (bool);
```

### toId


```solidity
function toId(Currency currency) external pure returns (uint256);
```

### fromId


```solidity
function fromId(uint256 id) external pure returns (Currency);
```
</file>

<file path="docs/contracts/v4/reference/core/test/CustomCurveHook.md">
# CustomCurveHook
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/CustomCurveHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[BaseTestHooks](contracts/v4/reference/core/test/BaseTestHooks.md)


## State Variables
### manager

```solidity
IPoolManager immutable manager;
```


## Functions
### constructor


```solidity
constructor(IPoolManager _manager);
```

### onlyPoolManager


```solidity
modifier onlyPoolManager();
```

### beforeSwap


```solidity
function beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata)
    external
    override
    onlyPoolManager
    returns (bytes4, BeforeSwapDelta, uint24);
```

### afterAddLiquidity


```solidity
function afterAddLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata
) external view override onlyPoolManager returns (bytes4, BalanceDelta);
```

### _getInputOutputAndAmount


```solidity
function _getInputOutputAndAmount(PoolKey calldata key, IPoolManager.SwapParams calldata params)
    internal
    pure
    returns (Currency input, Currency output, uint256 amount);
```

## Errors
### AddLiquidityDirectToHook

```solidity
error AddLiquidityDirectToHook();
```
</file>

<file path="docs/contracts/v4/reference/core/test/DeltaReturningHook.md">
# DeltaReturningHook
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/DeltaReturningHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[BaseTestHooks](contracts/v4/reference/core/test/BaseTestHooks.md)


## State Variables
### manager

```solidity
IPoolManager immutable manager;
```


### deltaSpecified

```solidity
int128 deltaSpecified;
```


### deltaUnspecifiedBeforeSwap

```solidity
int128 deltaUnspecifiedBeforeSwap;
```


### deltaUnspecifiedAfterSwap

```solidity
int128 deltaUnspecifiedAfterSwap;
```


## Functions
### constructor


```solidity
constructor(IPoolManager _manager);
```

### onlyPoolManager


```solidity
modifier onlyPoolManager();
```

### setDeltaSpecified


```solidity
function setDeltaSpecified(int128 delta) external;
```

### setDeltaUnspecifiedBeforeSwap


```solidity
function setDeltaUnspecifiedBeforeSwap(int128 delta) external;
```

### setDeltaUnspecifiedAfterSwap


```solidity
function setDeltaUnspecifiedAfterSwap(int128 delta) external;
```

### beforeSwap


```solidity
function beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata)
    external
    override
    onlyPoolManager
    returns (bytes4, BeforeSwapDelta, uint24);
```

### afterSwap


```solidity
function afterSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, BalanceDelta, bytes calldata)
    external
    override
    onlyPoolManager
    returns (bytes4, int128);
```

### _sortCurrencies


```solidity
function _sortCurrencies(PoolKey calldata key, IPoolManager.SwapParams calldata params)
    internal
    pure
    returns (Currency specified, Currency unspecified);
```

### _settleOrTake


```solidity
function _settleOrTake(Currency currency, int128 delta) internal;
```
</file>

<file path="docs/contracts/v4/reference/core/test/DynamicFeesTestHook.md">
# DynamicFeesTestHook
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/DynamicFeesTestHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[BaseTestHooks](contracts/v4/reference/core/test/BaseTestHooks.md)


## State Variables
### fee

```solidity
uint24 internal fee;
```


### manager

```solidity
IPoolManager manager;
```


## Functions
### setManager


```solidity
function setManager(IPoolManager _manager) external;
```

### setFee


```solidity
function setFee(uint24 _fee) external;
```

### afterInitialize


```solidity
function afterInitialize(address, PoolKey calldata key, uint160, int24) external override returns (bytes4);
```

### beforeSwap


```solidity
function beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, bytes calldata)
    external
    override
    returns (bytes4, BeforeSwapDelta, uint24);
```

### forcePoolFeeUpdate


```solidity
function forcePoolFeeUpdate(PoolKey calldata _key, uint24 _fee) external;
```
</file>

<file path="docs/contracts/v4/reference/core/test/DynamicReturnFeeTestHook.md">
# DynamicReturnFeeTestHook
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/DynamicReturnFeeTestHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[BaseTestHooks](contracts/v4/reference/core/test/BaseTestHooks.md)


## State Variables
### fee

```solidity
uint24 internal fee;
```


### manager

```solidity
IPoolManager manager;
```


## Functions
### setManager


```solidity
function setManager(IPoolManager _manager) external;
```

### setFee


```solidity
function setFee(uint24 _fee) external;
```

### beforeSwap


```solidity
function beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)
    external
    view
    override
    returns (bytes4, BeforeSwapDelta, uint24);
```

### forcePoolFeeUpdate


```solidity
function forcePoolFeeUpdate(PoolKey calldata _key, uint24 _fee) external;
```
</file>

<file path="docs/contracts/v4/reference/core/test/EmptyRevertContract.md">
# EmptyRevertContract
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/EmptyRevertContract.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


## Functions
### fallback


```solidity
fallback() external;
```
</file>

<file path="docs/contracts/v4/reference/core/test/EmptyTestHooks.md">
# EmptyTestHooks
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/EmptyTestHooks.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IHooks](contracts/v4/reference/core/interfaces/IHooks.md)


## Functions
### constructor


```solidity
constructor();
```

### beforeInitialize


```solidity
function beforeInitialize(address, PoolKey calldata, uint160) external pure override returns (bytes4);
```

### afterInitialize


```solidity
function afterInitialize(address, PoolKey calldata, uint160, int24) external pure override returns (bytes4);
```

### beforeAddLiquidity


```solidity
function beforeAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)
    external
    pure
    override
    returns (bytes4);
```

### afterAddLiquidity


```solidity
function afterAddLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata
) external pure override returns (bytes4, BalanceDelta);
```

### beforeRemoveLiquidity


```solidity
function beforeRemoveLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)
    external
    pure
    override
    returns (bytes4);
```

### afterRemoveLiquidity


```solidity
function afterRemoveLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata
) external pure override returns (bytes4, BalanceDelta);
```

### beforeSwap


```solidity
function beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)
    external
    pure
    override
    returns (bytes4, BeforeSwapDelta, uint24);
```

### afterSwap


```solidity
function afterSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)
    external
    pure
    override
    returns (bytes4, int128);
```

### beforeDonate


```solidity
function beforeDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)
    external
    pure
    override
    returns (bytes4);
```

### afterDonate


```solidity
function afterDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)
    external
    pure
    override
    returns (bytes4);
```
</file>

<file path="docs/contracts/v4/reference/core/test/FeeTakingHook.md">
# FeeTakingHook
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/FeeTakingHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[BaseTestHooks](contracts/v4/reference/core/test/BaseTestHooks.md)


## State Variables
### manager

```solidity
IPoolManager immutable manager;
```


### LIQUIDITY_FEE

```solidity
uint128 public constant LIQUIDITY_FEE = 543;
```


### SWAP_FEE_BIPS

```solidity
uint128 public constant SWAP_FEE_BIPS = 123;
```


### TOTAL_BIPS

```solidity
uint128 public constant TOTAL_BIPS = 10000;
```


## Functions
### constructor


```solidity
constructor(IPoolManager _manager);
```

### onlyPoolManager


```solidity
modifier onlyPoolManager();
```

### afterSwap


```solidity
function afterSwap(
    address,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    BalanceDelta delta,
    bytes calldata
) external override onlyPoolManager returns (bytes4, int128);
```

### afterRemoveLiquidity


```solidity
function afterRemoveLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta delta,
    BalanceDelta,
    bytes calldata
) external override onlyPoolManager returns (bytes4, BalanceDelta);
```

### afterAddLiquidity


```solidity
function afterAddLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta delta,
    BalanceDelta,
    bytes calldata
) external override onlyPoolManager returns (bytes4, BalanceDelta);
```
</file>

<file path="docs/contracts/v4/reference/core/test/Fuzzers.md">
# Fuzzers
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/Fuzzers.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
StdUtils


## State Variables
### _vm

```solidity
Vm internal constant _vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
```


## Functions
### boundLiquidityDelta


```solidity
function boundLiquidityDelta(PoolKey memory key, int256 liquidityDeltaUnbounded, int256 liquidityMaxByAmount)
    internal
    pure
    returns (int256);
```

### boundLiquidityDeltaTightly


```solidity
function boundLiquidityDeltaTightly(
    PoolKey memory key,
    int256 liquidityDeltaUnbounded,
    int256 liquidityMaxByAmount,
    uint256 maxPositions
) internal pure returns (int256);
```

### getLiquidityDeltaFromAmounts


```solidity
function getLiquidityDeltaFromAmounts(int24 tickLower, int24 tickUpper, uint160 sqrtPriceX96)
    internal
    pure
    returns (int256);
```

### boundTicks


```solidity
function boundTicks(int24 tickLower, int24 tickUpper, int24 tickSpacing) internal pure returns (int24, int24);
```

### boundTicks


```solidity
function boundTicks(PoolKey memory key, int24 tickLower, int24 tickUpper) internal pure returns (int24, int24);
```

### createRandomSqrtPriceX96


```solidity
function createRandomSqrtPriceX96(int24 tickSpacing, int256 seed) internal pure returns (uint160);
```

### createFuzzyLiquidityParams

*Obtain fuzzed and bounded parameters for creating liquidity*


```solidity
function createFuzzyLiquidityParams(
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    uint160 sqrtPriceX96
) internal pure returns (IPoolManager.ModifyLiquidityParams memory result);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The pool key|
|`params`|`IPoolManager.ModifyLiquidityParams`|IPoolManager.ModifyLiquidityParams Note that these parameters are unbounded|
|`sqrtPriceX96`|`uint160`|The current sqrt price|


### createFuzzyLiquidityParamsWithTightBound


```solidity
function createFuzzyLiquidityParamsWithTightBound(
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    uint160 sqrtPriceX96,
    uint256 maxPositions
) internal pure returns (IPoolManager.ModifyLiquidityParams memory result);
```

### createFuzzyLiquidity


```solidity
function createFuzzyLiquidity(
    PoolModifyLiquidityTest modifyLiquidityRouter,
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    uint160 sqrtPriceX96,
    bytes memory hookData
) internal returns (IPoolManager.ModifyLiquidityParams memory result, BalanceDelta delta);
```

### createFuzzyLiquidityWithTightBound


```solidity
function createFuzzyLiquidityWithTightBound(
    PoolModifyLiquidityTest modifyLiquidityRouter,
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    uint160 sqrtPriceX96,
    bytes memory hookData,
    uint256 maxPositions
) internal returns (IPoolManager.ModifyLiquidityParams memory result, BalanceDelta delta);
```
</file>

<file path="docs/contracts/v4/reference/core/test/HooksTest.md">
# HooksTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/HooksTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


## Functions
### validateHookPermissions


```solidity
function validateHookPermissions(address hookAddress, Hooks.Permissions calldata params) external pure;
```

### isValidHookAddress


```solidity
function isValidHookAddress(address hookAddress, uint24 fee) external pure returns (bool);
```

### shouldCallBeforeInitialize


```solidity
function shouldCallBeforeInitialize(address hookAddress) external pure returns (bool);
```

### shouldCallAfterInitialize


```solidity
function shouldCallAfterInitialize(address hookAddress) external pure returns (bool);
```

### shouldCallBeforeSwap


```solidity
function shouldCallBeforeSwap(address hookAddress) external pure returns (bool);
```

### shouldCallAfterSwap


```solidity
function shouldCallAfterSwap(address hookAddress) external pure returns (bool);
```

### shouldCallBeforeAddLiquidity


```solidity
function shouldCallBeforeAddLiquidity(address hookAddress) external pure returns (bool);
```

### shouldCallAfterAddLiquidity


```solidity
function shouldCallAfterAddLiquidity(address hookAddress) external pure returns (bool);
```

### shouldCallBeforeRemoveLiquidity


```solidity
function shouldCallBeforeRemoveLiquidity(address hookAddress) external pure returns (bool);
```

### shouldCallAfterRemoveLiquidity


```solidity
function shouldCallAfterRemoveLiquidity(address hookAddress) external pure returns (bool);
```

### shouldCallBeforeDonate


```solidity
function shouldCallBeforeDonate(address hookAddress) external pure returns (bool);
```

### shouldCallAfterDonate


```solidity
function shouldCallAfterDonate(address hookAddress) external pure returns (bool);
```

### getGasCostOfShouldCall


```solidity
function getGasCostOfShouldCall(address hookAddress) external view returns (uint256);
```

### getGasCostOfValidateHookAddress


```solidity
function getGasCostOfValidateHookAddress(address hookAddress, Hooks.Permissions calldata params)
    external
    view
    returns (uint256);
```
</file>

<file path="docs/contracts/v4/reference/core/test/LiquidityMathTest.md">
# LiquidityMathTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/LiquidityMathTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


## Functions
### addDelta


```solidity
function addDelta(uint128 x, int128 y) external pure returns (uint128 z);
```
</file>

<file path="docs/contracts/v4/reference/core/test/LPFeeTakingHook.md">
# LPFeeTakingHook
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/LPFeeTakingHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[BaseTestHooks](contracts/v4/reference/core/test/BaseTestHooks.md)

a hook that takes all of the LP fee revenue

*an example test hook to validate the data is provided correctly*


## State Variables
### manager

```solidity
IPoolManager immutable manager;
```


## Functions
### constructor


```solidity
constructor(IPoolManager _manager);
```

### onlyPoolManager


```solidity
modifier onlyPoolManager();
```

### afterRemoveLiquidity


```solidity
function afterRemoveLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta feeDelta,
    bytes calldata
) external override onlyPoolManager returns (bytes4, BalanceDelta);
```

### afterAddLiquidity


```solidity
function afterAddLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta feeDelta,
    bytes calldata
) external override onlyPoolManager returns (bytes4, BalanceDelta);
```
</file>

<file path="docs/contracts/v4/reference/core/test/MockContract.md">
# MockContract
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/MockContract.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
Proxy

Mock contract that tracks the number of calls to various functions by selector

*allows for proxying to an implementation contract
if real logic or return values are needed*


## State Variables
### calls

```solidity
mapping(bytes32 => uint256) public calls;
```


### callParams

```solidity
mapping(bytes32 => mapping(bytes => uint256)) public callParams;
```


### impl
If set, delegatecall to implementation after tracking call


```solidity
address internal impl;
```


## Functions
### timesCalledSelector


```solidity
function timesCalledSelector(bytes32 selector) public view returns (uint256);
```

### timesCalled


```solidity
function timesCalled(string calldata fnSig) public view returns (uint256);
```

### calledWithSelector


```solidity
function calledWithSelector(bytes32 selector, bytes calldata params) public view returns (bool);
```

### calledWith


```solidity
function calledWith(string calldata fnSig, bytes calldata params) public view returns (bool);
```

### _implementation

exposes implementation contract address


```solidity
function _implementation() internal view override returns (address);
```

### setImplementation


```solidity
function setImplementation(address _impl) external;
```

### _beforeFallback

Captures calls by selector


```solidity
function _beforeFallback() internal;
```

### _fallback


```solidity
function _fallback() internal override;
```

### receive


```solidity
receive() external payable;
```
</file>

<file path="docs/contracts/v4/reference/core/test/MockERC6909Claims.md">
# MockERC6909Claims
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/MockERC6909Claims.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[ERC6909Claims](contracts/v4/reference/core/ERC6909Claims.md)

Mock contract for testing ERC6909Claims


## Functions
### mint

mocked mint logic


```solidity
function mint(address to, uint256 id, uint256 amount) public;
```

### burn

mocked burn logic


```solidity
function burn(uint256 id, uint256 amount) public;
```

### burnFrom

mocked burn logic without checking sender allowance


```solidity
function burnFrom(address from, uint256 id, uint256 amount) public;
```
</file>

<file path="docs/contracts/v4/reference/core/test/MockHooks.md">
# MockHooks
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/MockHooks.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IHooks](contracts/v4/reference/core/interfaces/IHooks.md)


## State Variables
### beforeInitializeData

```solidity
bytes public beforeInitializeData;
```


### afterInitializeData

```solidity
bytes public afterInitializeData;
```


### beforeAddLiquidityData

```solidity
bytes public beforeAddLiquidityData;
```


### afterAddLiquidityData

```solidity
bytes public afterAddLiquidityData;
```


### beforeRemoveLiquidityData

```solidity
bytes public beforeRemoveLiquidityData;
```


### afterRemoveLiquidityData

```solidity
bytes public afterRemoveLiquidityData;
```


### beforeSwapData

```solidity
bytes public beforeSwapData;
```


### afterSwapData

```solidity
bytes public afterSwapData;
```


### beforeDonateData

```solidity
bytes public beforeDonateData;
```


### afterDonateData

```solidity
bytes public afterDonateData;
```


### returnValues

```solidity
mapping(bytes4 => bytes4) public returnValues;
```


### lpFees

```solidity
mapping(PoolId => uint16) public lpFees;
```


## Functions
### beforeInitialize


```solidity
function beforeInitialize(address, PoolKey calldata, uint160) external override returns (bytes4);
```

### afterInitialize


```solidity
function afterInitialize(address, PoolKey calldata, uint160, int24) external override returns (bytes4);
```

### beforeAddLiquidity


```solidity
function beforeAddLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    bytes calldata hookData
) external override returns (bytes4);
```

### afterAddLiquidity


```solidity
function afterAddLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata hookData
) external override returns (bytes4, BalanceDelta);
```

### beforeRemoveLiquidity


```solidity
function beforeRemoveLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    bytes calldata hookData
) external override returns (bytes4);
```

### afterRemoveLiquidity


```solidity
function afterRemoveLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata hookData
) external override returns (bytes4, BalanceDelta);
```

### beforeSwap


```solidity
function beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata hookData)
    external
    override
    returns (bytes4, BeforeSwapDelta, uint24);
```

### afterSwap


```solidity
function afterSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata hookData)
    external
    override
    returns (bytes4, int128);
```

### beforeDonate


```solidity
function beforeDonate(address, PoolKey calldata, uint256, uint256, bytes calldata hookData)
    external
    override
    returns (bytes4);
```

### afterDonate


```solidity
function afterDonate(address, PoolKey calldata, uint256, uint256, bytes calldata hookData)
    external
    override
    returns (bytes4);
```

### setReturnValue


```solidity
function setReturnValue(bytes4 key, bytes4 value) external;
```

### setlpFee


```solidity
function setlpFee(PoolKey calldata key, uint16 value) external;
```
</file>

<file path="docs/contracts/v4/reference/core/test/NativeERC20.md">
# NativeERC20
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/NativeERC20.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
Test

*This token contract simulates the ERC20 representation of a native token where on `transfer` and `transferFrom` the native balances are modified using a precompile*


## State Variables
### name

```solidity
string public name = "NativeERC20";
```


### symbol

```solidity
string public symbol = "NERC20";
```


### decimals

```solidity
uint8 public decimals = 18;
```


### allowance

```solidity
mapping(address => mapping(address => uint256)) public allowance;
```


## Functions
### totalSupply


```solidity
function totalSupply() public view returns (uint256);
```

### approve


```solidity
function approve(address guy, uint256 wad) public returns (bool);
```

### transfer


```solidity
function transfer(address dst, uint256 wad) public returns (bool);
```

### transferFrom


```solidity
function transferFrom(address src, address dst, uint256 wad) public returns (bool);
```

### balanceOf


```solidity
function balanceOf(address account) external view returns (uint256);
```

## Events
### Approval

```solidity
event Approval(address indexed src, address indexed guy, uint256 wad);
```

### Transfer

```solidity
event Transfer(address indexed src, address indexed dst, uint256 wad);
```
</file>

<file path="docs/contracts/v4/reference/core/test/NoDelegateCallTest.md">
# NoDelegateCallTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/NoDelegateCallTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[NoDelegateCall](contracts/v4/reference/core/NoDelegateCall.md)


## Functions
### canBeDelegateCalled


```solidity
function canBeDelegateCalled() public view returns (uint256);
```

### cannotBeDelegateCalled


```solidity
function cannotBeDelegateCalled() public view noDelegateCall returns (uint256);
```

### getGasCostOfCanBeDelegateCalled


```solidity
function getGasCostOfCanBeDelegateCalled() external view returns (uint256);
```

### getGasCostOfCannotBeDelegateCalled


```solidity
function getGasCostOfCannotBeDelegateCalled() external view returns (uint256);
```

### callsIntoNoDelegateCallFunction


```solidity
function callsIntoNoDelegateCallFunction() external view;
```

### noDelegateCallPrivate


```solidity
function noDelegateCallPrivate() private view noDelegateCall;
```
</file>

<file path="docs/contracts/v4/reference/core/test/PoolClaimsTest.md">
# PoolClaimsTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolClaimsTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[PoolTestBase](contracts/v4/reference/core/test/PoolTestBase.md)


## Functions
### constructor


```solidity
constructor(IPoolManager _manager) PoolTestBase(_manager);
```

### deposit

Convert ERC20 into a claimable 6909


```solidity
function deposit(Currency currency, address user, uint256 amount) external payable;
```

### withdraw

Redeem claimable 6909 for ERC20


```solidity
function withdraw(Currency currency, address user, uint256 amount) external payable;
```

### unlockCallback


```solidity
function unlockCallback(bytes calldata rawData) external returns (bytes memory);
```

## Structs
### CallbackData

```solidity
struct CallbackData {
    address sender;
    address user;
    Currency currency;
    uint256 amount;
    bool deposit;
}
```
</file>

<file path="docs/contracts/v4/reference/core/test/PoolDonateTest.md">
# PoolDonateTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolDonateTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[PoolTestBase](contracts/v4/reference/core/test/PoolTestBase.md)


## Functions
### constructor


```solidity
constructor(IPoolManager _manager) PoolTestBase(_manager);
```

### donate


```solidity
function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes memory hookData)
    external
    payable
    returns (BalanceDelta delta);
```

### unlockCallback


```solidity
function unlockCallback(bytes calldata rawData) external returns (bytes memory);
```

## Structs
### CallbackData

```solidity
struct CallbackData {
    address sender;
    PoolKey key;
    uint256 amount0;
    uint256 amount1;
    bytes hookData;
}
```
</file>

<file path="docs/contracts/v4/reference/core/test/PoolEmptyUnlockTest.md">
# PoolEmptyUnlockTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolEmptyUnlockTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IUnlockCallback](/src/interfaces/callback/IUnlockCallback.sol/interface.IUnlockCallback.md)


## State Variables
### manager

```solidity
IPoolManager manager;
```


## Functions
### constructor


```solidity
constructor(IPoolManager _manager);
```

### unlock


```solidity
function unlock() external;
```

### unlockCallback

Called by the pool manager on `msg.sender` when the manager is unlocked


```solidity
function unlockCallback(bytes calldata) external override returns (bytes memory);
```

## Events
### UnlockCallback

```solidity
event UnlockCallback();
```
</file>

<file path="docs/contracts/v4/reference/core/test/PoolModifyLiquidityTest.md">
# PoolModifyLiquidityTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolModifyLiquidityTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[PoolTestBase](contracts/v4/reference/core/test/PoolTestBase.md)


## Functions
### constructor


```solidity
constructor(IPoolManager _manager) PoolTestBase(_manager);
```

### modifyLiquidity


```solidity
function modifyLiquidity(PoolKey memory key, IPoolManager.ModifyLiquidityParams memory params, bytes memory hookData)
    external
    payable
    returns (BalanceDelta delta);
```

### modifyLiquidity


```solidity
function modifyLiquidity(
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    bytes memory hookData,
    bool settleUsingBurn,
    bool takeClaims
) public payable returns (BalanceDelta delta);
```

### unlockCallback


```solidity
function unlockCallback(bytes calldata rawData) external returns (bytes memory);
```

## Structs
### CallbackData

```solidity
struct CallbackData {
    address sender;
    PoolKey key;
    IPoolManager.ModifyLiquidityParams params;
    bytes hookData;
    bool settleUsingBurn;
    bool takeClaims;
}
```
</file>

<file path="docs/contracts/v4/reference/core/test/PoolModifyLiquidityTestNoChecks.md">
# PoolModifyLiquidityTestNoChecks
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolModifyLiquidityTestNoChecks.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[PoolTestBase](contracts/v4/reference/core/test/PoolTestBase.md)


## Functions
### constructor


```solidity
constructor(IPoolManager _manager) PoolTestBase(_manager);
```

### modifyLiquidity


```solidity
function modifyLiquidity(PoolKey memory key, IPoolManager.ModifyLiquidityParams memory params, bytes memory hookData)
    external
    payable
    returns (BalanceDelta delta);
```

### modifyLiquidity


```solidity
function modifyLiquidity(
    PoolKey memory key,
    IPoolManager.ModifyLiquidityParams memory params,
    bytes memory hookData,
    bool settleUsingBurn,
    bool takeClaims
) public payable returns (BalanceDelta delta);
```

### unlockCallback


```solidity
function unlockCallback(bytes calldata rawData) external returns (bytes memory);
```

## Structs
### CallbackData

```solidity
struct CallbackData {
    address sender;
    PoolKey key;
    IPoolManager.ModifyLiquidityParams params;
    bytes hookData;
    bool settleUsingBurn;
    bool takeClaims;
}
```
</file>

<file path="docs/contracts/v4/reference/core/test/PoolNestedActionsTest.md">
# Action
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolNestedActionsTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


```solidity
enum Action {
    NESTED_SELF_UNLOCK,
    NESTED_EXECUTOR_UNLOCK,
    SWAP_AND_SETTLE,
    DONATE_AND_SETTLE,
    ADD_LIQUIDITY_AND_SETTLE,
    REMOVE_LIQUIDITY_AND_SETTLE,
    INITIALIZE
}
```

# PoolNestedActionsTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolNestedActionsTest.sol)

**Inherits:**
Test, [IUnlockCallback](/src/interfaces/callback/IUnlockCallback.sol/interface.IUnlockCallback.md)


## State Variables
### manager

```solidity
IPoolManager manager;
```


### executor

```solidity
NestedActionExecutor public executor;
```


### user

```solidity
address user;
```


## Functions
### constructor


```solidity
constructor(IPoolManager _manager);
```

### unlock


```solidity
function unlock(bytes calldata data) external;
```

### unlockCallback

Called by the pool manager on `msg.sender` when the manager is unlocked


```solidity
function unlockCallback(bytes calldata data) external override returns (bytes memory);
```

### _nestedUnlock


```solidity
function _nestedUnlock() internal;
```

# NestedActionExecutor
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolNestedActionsTest.sol)

**Inherits:**
Test, [PoolTestBase](contracts/v4/reference/core/test/PoolTestBase.md)


## State Variables
### key

```solidity
PoolKey internal key;
```


### user

```solidity
address user;
```


### ADD_LIQUIDITY_PARAMS

```solidity
IPoolManager.ModifyLiquidityParams internal ADD_LIQUIDITY_PARAMS =
    IPoolManager.ModifyLiquidityParams({tickLower: -120, tickUpper: 120, liquidityDelta: 1e18, salt: 0});
```


### REMOVE_LIQUIDITY_PARAMS

```solidity
IPoolManager.ModifyLiquidityParams internal REMOVE_LIQUIDITY_PARAMS =
    IPoolManager.ModifyLiquidityParams({tickLower: -120, tickUpper: 120, liquidityDelta: -1e18, salt: 0});
```


### SWAP_PARAMS

```solidity
IPoolManager.SwapParams internal SWAP_PARAMS =
    IPoolManager.SwapParams({zeroForOne: true, amountSpecified: -100, sqrtPriceLimitX96: Constants.SQRT_PRICE_1_2});
```


### DONATE_AMOUNT0

```solidity
uint256 internal DONATE_AMOUNT0 = 12345e6;
```


### DONATE_AMOUNT1

```solidity
uint256 internal DONATE_AMOUNT1 = 98765e4;
```


## Functions
### constructor


```solidity
constructor(IPoolManager _manager, address _user) PoolTestBase(_manager);
```

### setKey


```solidity
function setKey(PoolKey memory _key) external;
```

### execute


```solidity
function execute(Action[] memory actions) public;
```

### _nestedUnlock


```solidity
function _nestedUnlock() internal;
```

### _swap


```solidity
function _swap(address caller) internal;
```

### _addLiquidity


```solidity
function _addLiquidity(address caller) internal;
```

### _removeLiquidity


```solidity
function _removeLiquidity(address caller) internal;
```

### _donate


```solidity
function _donate(address caller) internal;
```

### _initialize


```solidity
function _initialize() internal;
```

### unlockCallback


```solidity
function unlockCallback(bytes calldata) external pure override returns (bytes memory);
```

## Errors
### KeyNotSet

```solidity
error KeyNotSet();
```
</file>

<file path="docs/contracts/v4/reference/core/test/PoolSwapTest.md">
# PoolSwapTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolSwapTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[PoolTestBase](contracts/v4/reference/core/test/PoolTestBase.md)


## Functions
### constructor


```solidity
constructor(IPoolManager _manager) PoolTestBase(_manager);
```

### swap


```solidity
function swap(
    PoolKey memory key,
    IPoolManager.SwapParams memory params,
    TestSettings memory testSettings,
    bytes memory hookData
) external payable returns (BalanceDelta delta);
```

### unlockCallback


```solidity
function unlockCallback(bytes calldata rawData) external returns (bytes memory);
```

## Errors
### NoSwapOccurred

```solidity
error NoSwapOccurred();
```

## Structs
### CallbackData

```solidity
struct CallbackData {
    address sender;
    TestSettings testSettings;
    PoolKey key;
    IPoolManager.SwapParams params;
    bytes hookData;
}
```

### TestSettings

```solidity
struct TestSettings {
    bool takeClaims;
    bool settleUsingBurn;
}
```
</file>

<file path="docs/contracts/v4/reference/core/test/PoolTakeTest.md">
# PoolTakeTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolTakeTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[PoolTestBase](contracts/v4/reference/core/test/PoolTestBase.md)


## Functions
### constructor


```solidity
constructor(IPoolManager _manager) PoolTestBase(_manager);
```

### take


```solidity
function take(PoolKey memory key, uint256 amount0, uint256 amount1) external payable;
```

### unlockCallback


```solidity
function unlockCallback(bytes calldata rawData) external returns (bytes memory);
```

### _testTake


```solidity
function _testTake(Currency currency, address sender, uint256 amount) internal;
```

## Structs
### CallbackData

```solidity
struct CallbackData {
    address sender;
    PoolKey key;
    uint256 amount0;
    uint256 amount1;
}
```
</file>

<file path="docs/contracts/v4/reference/core/test/PoolTestBase.md">
# PoolTestBase
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/PoolTestBase.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IUnlockCallback](/src/interfaces/callback/IUnlockCallback.sol/interface.IUnlockCallback.md)


## State Variables
### manager

```solidity
IPoolManager public immutable manager;
```


## Functions
### constructor


```solidity
constructor(IPoolManager _manager);
```

### _fetchBalances


```solidity
function _fetchBalances(Currency currency, address user, address deltaHolder)
    internal
    view
    returns (uint256 userBalance, uint256 poolBalance, int256 delta);
```
</file>

<file path="docs/contracts/v4/reference/core/test/ProtocolFeesImplementation.md">
# ProtocolFeesImplementation
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/ProtocolFeesImplementation.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[ProtocolFees](contracts/v4/reference/core/ProtocolFees.md)


## State Variables
### _pools

```solidity
mapping(PoolId id => Pool.State) internal _pools;
```


### isUnlocked

```solidity
bool internal isUnlocked;
```


## Functions
### constructor


```solidity
constructor() ProtocolFees(msg.sender);
```

### setPrice


```solidity
function setPrice(PoolKey memory key, uint160 sqrtPriceX96) public;
```

### _getPool


```solidity
function _getPool(PoolId id) internal view override returns (Pool.State storage);
```

### setIsUnlocked


```solidity
function setIsUnlocked(bool newValue) public;
```

### _isUnlocked


```solidity
function _isUnlocked() internal view override returns (bool);
```

### updateProtocolFees


```solidity
function updateProtocolFees(Currency currency, uint256 amount) public;
```
</file>

<file path="docs/contracts/v4/reference/core/test/ProxyPoolManager.md">
# ProxyPoolManager
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/ProxyPoolManager.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IPoolManager](contracts/v4/reference/core/interfaces/IPoolManager.md), [ProtocolFees](contracts/v4/reference/core/ProtocolFees.md), [NoDelegateCall](contracts/v4/reference/core/NoDelegateCall.md), [ERC6909Claims](contracts/v4/reference/core/ERC6909Claims.md), [Extsload](contracts/v4/reference/core/Extsload.md), [Exttload](contracts/v4/reference/core/Exttload.md)

A proxy pool manager that delegates calls to the real/delegate pool manager


## State Variables
### MAX_TICK_SPACING

```solidity
int24 private constant MAX_TICK_SPACING = TickMath.MAX_TICK_SPACING;
```


### MIN_TICK_SPACING

```solidity
int24 private constant MIN_TICK_SPACING = TickMath.MIN_TICK_SPACING;
```


### _pools

```solidity
mapping(PoolId id => Pool.State) internal _pools;
```


### _delegateManager

```solidity
address internal immutable _delegateManager;
```


## Functions
### constructor


```solidity
constructor(address delegateManager) ProtocolFees(msg.sender);
```

### onlyWhenUnlocked

This will revert if the contract is locked


```solidity
modifier onlyWhenUnlocked();
```

### unlock

All interactions on the contract that account deltas require unlocking. A caller that calls `unlock` must implement
`IUnlockCallback(msg.sender).unlockCallback(data)`, where they interact with the remaining functions on this contract.

*The only functions callable without an unlocking are `initialize` and `updateDynamicLPFee`*


```solidity
function unlock(bytes calldata data) external noDelegateCall returns (bytes memory result);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`data`|`bytes`|Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)`|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`result`|`bytes`|The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)`|


### initialize

Initialize the state for a given pool ID

*A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee*


```solidity
function initialize(PoolKey memory key, uint160 sqrtPriceX96) external noDelegateCall returns (int24 tick);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The pool key for the pool to initialize|
|`sqrtPriceX96`|`uint160`|The initial square root price|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`tick`|`int24`|The initial tick of the pool|


### modifyLiquidity

Modify the liquidity for the given pool

*Poke by calling with a zero liquidityDelta*


```solidity
function modifyLiquidity(PoolKey memory key, IPoolManager.ModifyLiquidityParams memory params, bytes calldata hookData)
    external
    onlyWhenUnlocked
    noDelegateCall
    returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The pool to modify liquidity in|
|`params`|`IPoolManager.ModifyLiquidityParams`|The parameters for modifying the liquidity|
|`hookData`|`bytes`|The data to pass through to the add/removeLiquidity hooks|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`callerDelta`|`BalanceDelta`|The balance delta of the caller of modifyLiquidity. This is the total of both principal, fee deltas, and hook deltas if applicable|
|`feesAccrued`|`BalanceDelta`|The balance delta of the fees generated in the liquidity range. Returned for informational purposes|


### swap

Swap against the given pool

*Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified.
Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG
the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.*


```solidity
function swap(PoolKey memory key, IPoolManager.SwapParams memory params, bytes calldata hookData)
    external
    onlyWhenUnlocked
    noDelegateCall
    returns (BalanceDelta swapDelta);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The pool to swap in|
|`params`|`IPoolManager.SwapParams`|The parameters for swapping|
|`hookData`|`bytes`|The data to pass through to the swap hooks|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`swapDelta`|`BalanceDelta`|The balance delta of the address swapping|


### donate

Donate the given currency amounts to the in-range liquidity providers of a pool

*Calls to donate can be frontrun adding just-in-time liquidity, with the aim of receiving a portion donated funds.
Donors should keep this in mind when designing donation mechanisms.*


```solidity
function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    onlyWhenUnlocked
    noDelegateCall
    returns (BalanceDelta delta);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The key of the pool to donate to|
|`amount0`|`uint256`|The amount of currency0 to donate|
|`amount1`|`uint256`|The amount of currency1 to donate|
|`hookData`|`bytes`|The data to pass through to the donate hooks|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`delta`|`BalanceDelta`|BalanceDelta The delta of the caller after the donate|


### sync

Writes the current ERC20 balance of the specified currency to transient storage
This is used to checkpoint balances for the manager and derive deltas for the caller.

*This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped
for native tokens because the amount to settle is determined by the sent value.
However, if an ERC20 token has been synced and not settled, and the caller instead wants to settle
native funds, this function can be called with the native currency to then be able to settle the native currency*


```solidity
function sync(Currency currency) public;
```

### take

Called by the user to net out some value owed to the user

*Will revert if the requested amount is not available, consider using `mint` instead*


```solidity
function take(Currency currency, address to, uint256 amount) external onlyWhenUnlocked noDelegateCall;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency`|`Currency`|The currency to withdraw from the pool manager|
|`to`|`address`|The address to withdraw to|
|`amount`|`uint256`|The amount of currency to withdraw|


### settle

Called by the user to pay what is owed


```solidity
function settle() external payable onlyWhenUnlocked noDelegateCall returns (uint256 paid);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`paid`|`uint256`|The amount of currency settled|


### settleFor

Called by the user to pay on behalf of another address


```solidity
function settleFor(address recipient) external payable onlyWhenUnlocked noDelegateCall returns (uint256 paid);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`recipient`|`address`|The address to credit for the payment|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`paid`|`uint256`|The amount of currency settled|


### clear

WARNING - Any currency that is cleared, will be non-retrievable, and locked in the contract permanently.
A call to clear will zero out a positive balance WITHOUT a corresponding transfer.

*This could be used to clear a balance that is considered dust.
Additionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.*


```solidity
function clear(Currency currency, uint256 amount) external onlyWhenUnlocked;
```

### mint

Called by the user to move value into ERC6909 balance

*The id is converted to a uint160 to correspond to a currency address
If the upper 12 bytes are not 0, they will be 0-ed out*


```solidity
function mint(address to, uint256 id, uint256 amount) external onlyWhenUnlocked noDelegateCall;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`to`|`address`|The address to mint the tokens to|
|`id`|`uint256`|The currency address to mint to ERC6909s, as a uint256|
|`amount`|`uint256`|The amount of currency to mint|


### burn

Called by the user to move value from ERC6909 balance

*The id is converted to a uint160 to correspond to a currency address
If the upper 12 bytes are not 0, they will be 0-ed out*


```solidity
function burn(address from, uint256 id, uint256 amount) external onlyWhenUnlocked noDelegateCall;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`from`|`address`|The address to burn the tokens from|
|`id`|`uint256`|The currency address to burn from ERC6909s, as a uint256|
|`amount`|`uint256`|The amount of currency to burn|


### updateDynamicLPFee

Updates the pools lp fees for the a pool that has enabled dynamic lp fees.

*A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee*


```solidity
function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The key of the pool to update dynamic LP fees for|
|`newDynamicLPFee`|`uint24`|The new dynamic pool LP fee|


### _delegateCall

Make a delegate call, bubble up any error or return the result


```solidity
function _delegateCall(address target, bytes memory data) internal returns (bytes memory result);
```

### _getPool

Implementation of the _getPool function defined in ProtocolFees


```solidity
function _getPool(PoolId id) internal view override returns (Pool.State storage);
```

### _isUnlocked

Implementation of the _isUnlocked function defined in ProtocolFees


```solidity
function _isUnlocked() internal view override returns (bool);
```
</file>

<file path="docs/contracts/v4/reference/core/test/SkipCallsTestHook.md">
# SkipCallsTestHook
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/SkipCallsTestHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[BaseTestHooks](contracts/v4/reference/core/test/BaseTestHooks.md), Test


## State Variables
### counter

```solidity
uint256 public counter;
```


### manager

```solidity
IPoolManager manager;
```


## Functions
### setManager


```solidity
function setManager(IPoolManager _manager) external;
```

### beforeInitialize


```solidity
function beforeInitialize(address, PoolKey calldata key, uint160 sqrtPriceX96) external override returns (bytes4);
```

### afterInitialize


```solidity
function afterInitialize(address, PoolKey calldata key, uint160 sqrtPriceX96, int24)
    external
    override
    returns (bytes4);
```

### beforeAddLiquidity


```solidity
function beforeAddLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata hookData
) external override returns (bytes4);
```

### afterAddLiquidity


```solidity
function afterAddLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    BalanceDelta,
    BalanceDelta,
    bytes calldata hookData
) external override returns (bytes4, BalanceDelta);
```

### beforeRemoveLiquidity


```solidity
function beforeRemoveLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata hookData
) external override returns (bytes4);
```

### afterRemoveLiquidity


```solidity
function afterRemoveLiquidity(
    address,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    BalanceDelta,
    BalanceDelta,
    bytes calldata hookData
) external override returns (bytes4, BalanceDelta);
```

### beforeSwap


```solidity
function beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata hookData)
    external
    override
    returns (bytes4, BeforeSwapDelta, uint24);
```

### afterSwap


```solidity
function afterSwap(
    address,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    BalanceDelta,
    bytes calldata hookData
) external override returns (bytes4, int128);
```

### beforeDonate


```solidity
function beforeDonate(address, PoolKey calldata key, uint256 amt0, uint256 amt1, bytes calldata hookData)
    external
    override
    returns (bytes4);
```

### afterDonate


```solidity
function afterDonate(address, PoolKey calldata key, uint256 amt0, uint256 amt1, bytes calldata hookData)
    external
    override
    returns (bytes4);
```

### _initialize


```solidity
function _initialize(PoolKey memory key, uint160 sqrtPriceX96) public;
```

### _swap


```solidity
function _swap(PoolKey calldata key, IPoolManager.SwapParams memory params, bytes calldata hookData) public;
```

### _addLiquidity


```solidity
function _addLiquidity(PoolKey calldata key, IPoolManager.ModifyLiquidityParams memory params, bytes calldata hookData)
    public;
```

### _removeLiquidity


```solidity
function _removeLiquidity(
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams memory params,
    bytes calldata hookData
) public;
```

### _donate


```solidity
function _donate(PoolKey calldata key, uint256 amt0, uint256 amt1, bytes calldata hookData) public;
```
</file>

<file path="docs/contracts/v4/reference/core/test/SqrtPriceMathEchidnaTest.md">
# SqrtPriceMathEchidnaTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/SqrtPriceMathEchidnaTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


## Functions
### mulDivRoundingUpInvariants


```solidity
function mulDivRoundingUpInvariants(uint256 x, uint256 y, uint256 z) external pure;
```

### getNextSqrtPriceFromInputInvariants


```solidity
function getNextSqrtPriceFromInputInvariants(uint160 sqrtP, uint128 liquidity, uint256 amountIn, bool zeroForOne)
    external
    pure;
```

### getNextSqrtPriceFromOutputInvariants


```solidity
function getNextSqrtPriceFromOutputInvariants(uint160 sqrtP, uint128 liquidity, uint256 amountOut, bool zeroForOne)
    external
    pure;
```

### getNextSqrtPriceFromAmount0RoundingUpInvariants


```solidity
function getNextSqrtPriceFromAmount0RoundingUpInvariants(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)
    external
    pure;
```

### getNextSqrtPriceFromAmount1RoundingDownInvariants


```solidity
function getNextSqrtPriceFromAmount1RoundingDownInvariants(
    uint160 sqrtPX96,
    uint128 liquidity,
    uint256 amount,
    bool add
) external pure;
```

### getAmount0DeltaInvariants


```solidity
function getAmount0DeltaInvariants(uint160 sqrtP, uint160 sqrtQ, uint128 liquidity) external pure;
```

### getAmount0DeltaEquivalency


```solidity
function getAmount0DeltaEquivalency(uint160 sqrtP, uint160 sqrtQ, uint128 liquidity, bool roundUp) external pure;
```

### getAmount1DeltaInvariants


```solidity
function getAmount1DeltaInvariants(uint160 sqrtP, uint160 sqrtQ, uint128 liquidity) external pure;
```

### getAmount0DeltaSignedInvariants


```solidity
function getAmount0DeltaSignedInvariants(uint160 sqrtP, uint160 sqrtQ, int128 liquidity) external pure;
```

### getAmount1DeltaSignedInvariants


```solidity
function getAmount1DeltaSignedInvariants(uint160 sqrtP, uint160 sqrtQ, int128 liquidity) external pure;
```

### getOutOfRangeMintInvariants


```solidity
function getOutOfRangeMintInvariants(uint160 sqrtA, uint160 sqrtB, int128 liquidity) external pure;
```

### getInRangeMintInvariants


```solidity
function getInRangeMintInvariants(uint160 sqrtLower, uint160 sqrtCurrent, uint160 sqrtUpper, int128 liquidity)
    external
    pure;
```
</file>

<file path="docs/contracts/v4/reference/core/test/SwapRouterNoChecks.md">
# SwapRouterNoChecks
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/SwapRouterNoChecks.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[PoolTestBase](contracts/v4/reference/core/test/PoolTestBase.md)


## Functions
### constructor


```solidity
constructor(IPoolManager _manager) PoolTestBase(_manager);
```

### swap


```solidity
function swap(PoolKey memory key, IPoolManager.SwapParams memory params) external payable;
```

### unlockCallback


```solidity
function unlockCallback(bytes calldata rawData) external returns (bytes memory);
```

## Errors
### NoSwapOccurred

```solidity
error NoSwapOccurred();
```

## Structs
### CallbackData

```solidity
struct CallbackData {
    address sender;
    PoolKey key;
    IPoolManager.SwapParams params;
}
```
</file>

<file path="docs/contracts/v4/reference/core/test/TestERC20.md">
# TestERC20
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/TestERC20.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IERC20Minimal](contracts/v4/reference/core/interfaces/IERC20Minimal.md)


## State Variables
### balanceOf

```solidity
mapping(address => uint256) public override balanceOf;
```


### allowance

```solidity
mapping(address => mapping(address => uint256)) public override allowance;
```


## Functions
### constructor


```solidity
constructor(uint256 amountToMint);
```

### mint


```solidity
function mint(address to, uint256 amount) public;
```

### transfer


```solidity
function transfer(address recipient, uint256 amount) external override returns (bool);
```

### approve


```solidity
function approve(address spender, uint256 amount) external override returns (bool);
```

### transferFrom


```solidity
function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool);
```
</file>

<file path="docs/contracts/v4/reference/core/test/TestInvalidERC20.md">
# TestInvalidERC20
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/TestInvalidERC20.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IERC20Minimal](contracts/v4/reference/core/interfaces/IERC20Minimal.md)


## State Variables
### balanceOf

```solidity
mapping(address => uint256) public override balanceOf;
```


### allowance

```solidity
mapping(address => mapping(address => uint256)) public override allowance;
```


## Functions
### constructor


```solidity
constructor(uint256 amountToMint);
```

### mint


```solidity
function mint(address to, uint256 amount) public;
```

### transfer


```solidity
function transfer(address recipient, uint256 amount) external override returns (bool);
```

### approve


```solidity
function approve(address spender, uint256 amount) external override returns (bool);
```

### transferFrom


```solidity
function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool);
```
</file>

<file path="docs/contracts/v4/reference/core/test/TickMathEchidnaTest.md">
# TickMathEchidnaTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/TickMathEchidnaTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


## Functions
### checkGetSqrtPriceAtTickInvariants


```solidity
function checkGetSqrtPriceAtTickInvariants(int24 tick) external pure;
```

### checkGetTickAtSqrtPriceInvariants


```solidity
function checkGetTickAtSqrtPriceInvariants(uint160 price) external pure;
```
</file>

<file path="docs/contracts/v4/reference/core/test/TickMathTest.md">
# TickMathTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/TickMathTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


## Functions
### getSqrtPriceAtTick


```solidity
function getSqrtPriceAtTick(int24 tick) external pure returns (uint160);
```

### getGasCostOfGetSqrtPriceAtTick


```solidity
function getGasCostOfGetSqrtPriceAtTick(int24 tick) external view returns (uint256);
```

### getTickAtSqrtPrice


```solidity
function getTickAtSqrtPrice(uint160 sqrtPriceX96) external pure returns (int24);
```

### getGasCostOfGetTickAtSqrtPrice


```solidity
function getGasCostOfGetTickAtSqrtPrice(uint160 sqrtPriceX96) external view returns (uint256);
```

### MIN_SQRT_PRICE


```solidity
function MIN_SQRT_PRICE() external pure returns (uint160);
```

### MAX_SQRT_PRICE


```solidity
function MAX_SQRT_PRICE() external pure returns (uint160);
```

### MIN_TICK


```solidity
function MIN_TICK() external pure returns (int24);
```

### MAX_TICK


```solidity
function MAX_TICK() external pure returns (int24);
```
</file>

<file path="docs/contracts/v4/reference/core/test/TickOverflowSafetyEchidnaTest.md">
# TickOverflowSafetyEchidnaTest
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/test/TickOverflowSafetyEchidnaTest.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


## State Variables
### MIN_TICK

```solidity
int24 private constant MIN_TICK = -16;
```


### MAX_TICK

```solidity
int24 private constant MAX_TICK = 16;
```


### pool

```solidity
Pool.State private pool;
```


### tick

```solidity
int24 private tick = 0;
```


### feeGrowthGlobal0X128

```solidity
uint256 feeGrowthGlobal0X128 = type(uint256).max / 2;
```


### feeGrowthGlobal1X128

```solidity
uint256 feeGrowthGlobal1X128 = type(uint256).max / 2;
```


### totalLiquidity

```solidity
int256 totalLiquidity = 0;
```


### totalGrowth0

```solidity
uint256 private totalGrowth0 = 0;
```


### totalGrowth1

```solidity
uint256 private totalGrowth1 = 0;
```


## Functions
### increaseFeeGrowthGlobal0X128


```solidity
function increaseFeeGrowthGlobal0X128(uint256 amount) external;
```

### increaseFeeGrowthGlobal1X128


```solidity
function increaseFeeGrowthGlobal1X128(uint256 amount) external;
```

### setPosition


```solidity
function setPosition(int24 tickLower, int24 tickUpper, int128 liquidityDelta) external;
```

### moveToTick


```solidity
function moveToTick(int24 target) external;
```
</file>

<file path="docs/contracts/v4/reference/core/types/_category_.json">
{
  "label": "Types",
  "position": 1,
  "collapsed": true
}
</file>

<file path="docs/contracts/v4/reference/core/types/balancedelta-guide.mdx">
---
title: BalanceDelta Guide
---

`BalanceDelta` is a type used in Uniswap V4 to represent the balance changes of two tokens (token0 and token1). It tightly packs the two values in a single 256 bits. It is designed to efficiently store and manipulate these balance deltas, with the upper 128 bits representing the change in token0 (`amount0`) and the lower 128 bits representing the change in token1 (`amount1`).

## Purpose

The main purpose of `BalanceDelta` is to keep track of the net balance changes in the two tokens of a pool after various operations such as swaps, liquidity modifications, and interactions with hooks. It provides a compact and efficient way to store and update these balance deltas throughout the execution flow of the pool.

In the context of hooks, `BalanceDelta` is used to ensure that the net balance change for each token is zero after the hook's functionality is executed. This is important for maintaining the integrity of the pool's balances and ensuring that the hooks do not introduce any unexpected or unauthorized balance changes.

## Type Definition

```solidity
type BalanceDelta is int256;
```

## Using Directives

```solidity
using {add as +, sub as -, eq as ==, neq as !=} for BalanceDelta global;
using BalanceDeltaLibrary for BalanceDelta global;
using SafeCast for int256;
```

These using directives enable arithmetic operations, equality comparisons, and library functions to be used directly on `BalanceDelta` values.

## Functions

### toBalanceDelta

```solidity
function toBalanceDelta(int128 amount0, int128 amount1) pure returns (BalanceDelta balanceDelta);
```

Creates a `BalanceDelta` value from two `int128` values representing `amount0` and `amount1`.

| Param Name | Type    | Description                          |
|------------|---------|--------------------------------------|
| amount0    | int128  | The amount for the first token       |
| amount1    | int128  | The amount for the second token      |

Returns the created `BalanceDelta` value.

### add

```solidity
function add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta);
```

Adds two `BalanceDelta` values.

| Param Name | Type         | Description                          |
|------------|--------------|--------------------------------------|
| a          | BalanceDelta | The first `BalanceDelta` value       |
| b          | BalanceDelta | The second `BalanceDelta` value      |

Returns the sum of the two `BalanceDelta` values.

### sub

```solidity
function sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta);
```

Subtracts one `BalanceDelta` value from another.

| Param Name | Type         | Description                          |
|------------|--------------|--------------------------------------|
| a          | BalanceDelta | The first `BalanceDelta` value       |
| b          | BalanceDelta | The second `BalanceDelta` value      |

Returns the difference of the two `BalanceDelta` values.

### eq

```solidity
function eq(BalanceDelta a, BalanceDelta b) pure returns (bool);
```

Checks if two `BalanceDelta` values are equal.

| Param Name | Type         | Description                          |
|------------|--------------|--------------------------------------|
| a          | BalanceDelta | The first `BalanceDelta` value       |
| b          | BalanceDelta | The second `BalanceDelta` value      |

Returns `true` if the values are equal, `false` otherwise.

### neq

```solidity
function neq(BalanceDelta a, BalanceDelta b) pure returns (bool);
```

Checks if two `BalanceDelta` values are not equal.

| Param Name | Type         | Description                          |
|------------|--------------|--------------------------------------|
| a          | BalanceDelta | The first `BalanceDelta` value       |
| b          | BalanceDelta | The second `BalanceDelta` value      |

Returns `true` if the values are not equal, `false` otherwise.

## Library Functions

### amount0

```solidity
function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0);
```

Extracts the `amount0` value from a `BalanceDelta`.

| Param Name   | Type         | Description                          |
|--------------|--------------|--------------------------------------|
| balanceDelta | BalanceDelta | The `BalanceDelta` value             |

Returns the extracted `amount0` value as an `int128`.

### amount1

```solidity
function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1);
```

Extracts the `amount1` value from a `BalanceDelta`.

| Param Name   | Type         | Description                          |
|--------------|--------------|--------------------------------------|
| balanceDelta | BalanceDelta | The `BalanceDelta` value             |

Returns the extracted `amount1` value as an `int128`.

## Usage in Hooks

When a hook is called during a swap or liquidity modification, it can perform custom logic and interact with the pool's balances. However, to maintain the correctness of the pool's state, the hook must ensure that any balance changes it introduces are properly accounted for and net to zero at the end of its execution.
The BalanceDelta is forwarded to the `afterSwap` & `afterAddliquidity`, `afterRemoveLiquidity` hooks.  

## Usage in the Pool Library

In the `Pool` library, `BalanceDelta` is used extensively to track balance changes during various operations such as swaps, liquidity modifications, and donations. The library functions `swap`, `modifyLiquidity`, and `donate` all return `BalanceDelta` values representing the net balance changes resulting from these operations.

The `Pool` library uses `BalanceDelta` to efficiently update and manage the pool's balances, ensuring that the net balance changes are accurately accounted for and that the pool remains in a consistent state.

By leveraging the compact representation and efficient arithmetic operations provided by `BalanceDelta`, the `Pool` library can perform complex balance calculations and updates in a gas-optimized manner, reducing the overall cost of executing pool-related operations.
</file>

<file path="docs/contracts/v4/reference/core/types/BalanceDelta.md">
# BalanceDelta
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BalanceDelta.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

*Two `int128` values packed into a single `int256` where the upper 128 bits represent the amount0
and the lower 128 bits represent the amount1.*


```solidity
type BalanceDelta is int256;
```

## BalanceDeltaLibrary
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BalanceDelta.sol)

Library for getting the amount0 and amount1 deltas from the BalanceDelta type


## State Variables
### ZERO_DELTA
A BalanceDelta of 0


```solidity
BalanceDelta public constant ZERO_DELTA = BalanceDelta.wrap(0);
```


## Functions
### amount0


```solidity
function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0);
```

### amount1


```solidity
function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1);
```

# sub
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BalanceDelta.sol)


```solidity
function sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta);
```

# toBalanceDelta
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BalanceDelta.sol)


```solidity
function toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta);
```

# eq
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BalanceDelta.sol)


```solidity
function eq(BalanceDelta a, BalanceDelta b) pure returns (bool);
```

# add
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BalanceDelta.sol)


```solidity
function add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta);
```

# neq
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BalanceDelta.sol)


```solidity
function neq(BalanceDelta a, BalanceDelta b) pure returns (bool);
```
</file>

<file path="docs/contracts/v4/reference/core/types/beforeswapdelta-guide.mdx">
---
title: BeforeSwapDelta Guide
---

`BeforeSwapDelta` is a custom type used in Uniswap V4 hook contracts to represent balance changes during swap operations. It is specifically designed to handle the return value of the `beforeSwap` hook and to be compatible with the `afterSwap` hook.

Before explaining `BeforeSwapDelta` in detail, it is worth noting that in the context of Uniswap V4 swaps:

- The **specified** token is the one for which the user specifies an exact input or output amount.
- The **unspecified** token is the counterpart in the swap, whose amount is determined by the pool's pricing mechanism.

## Purpose

The main purpose of `BeforeSwapDelta` is to efficiently encode and decode balance changes for both specified and unspecified tokens in a single 256-bit value. This compact representation allows for gas-efficient operations and seamless integration with Uniswap V4's hook system.

`BeforeSwapDelta` is essential for:

- Allowing hooks to modify swap parameters or override default swap behavior
- Allowing hooks to take fees from swaps
- Providing fine-grained control over balance adjustments resulting from swaps
- Optimizing gas usage by packing two `int128` values into a single `int256`

To summarise, `BeforeSwapDelta` is used to ensure that the net balance change for each token is zero after the hook's functionality is executed. This is important for maintaining the integrity of the pool's balances and ensuring that the hooks do not introduce any unexpected or unauthorized balance changes.

## Type Definition

```solidity
type BeforeSwapDelta is int256;
```

The `BeforeSwapDelta` type is an alias for int256, where:

- The upper 128 bits represent the delta in specified tokens
- The lower 128 bits represent the delta in unspecified tokens

## Using Directives

```solidity
using BeforeSwapDeltaLibrary for BeforeSwapDelta global;
using SafeCast for int256;
```

These using directives enable library functions to be used directly on `BeforeSwapDelta` values and provide safe casting operations for int256 values.

## Functions

### toBeforeSwapDelta

```solidity
function toBeforeSwapDelta(int128 deltaSpecified, int128 deltaUnspecified) pure returns (BeforeSwapDelta beforeSwapDelta);
```

Creates a `BeforeSwapDelta` value from two `int128` values representing `deltaSpecified` and `deltaUnspecified`.

| Param Name | Type    | Description                          |
|------------|---------|--------------------------------------|
| deltaSpecified    | int128  | The balance change for the specified token       |
| deltaUnspecified    | int128  | The balance change for the unspecified token      |

Returns the created `BeforeSwapDelta` value.

This function uses bitwise operations in assembly for gas-efficient packing of the two int128 values:

```solidity
assembly ("memory-safe") {
    beforeSwapDelta := or(shl(128, deltaSpecified), and(sub(shl(128, 1), 1), deltaUnspecified))
}
```

## Library Functions

### ZERO_DELTA

```solidity
BeforeSwapDelta public constant ZERO_DELTA = BeforeSwapDelta.wrap(0);
```

A constant representing a zero delta (no balance changes). It should be used as a default return value. It is most commonly used for hooks that are *not* implementing custom accounting.

### getSpecifiedDelta

```solidity
function getSpecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaSpecified);
```

Extracts the specified token delta from a `BeforeSwapDelta` value.

| Param Name | Type         | Description                          |
|------------|--------------|--------------------------------------|
| delta      | BeforeSwapDelta | The `BeforeSwapDelta` value       |

Returns the extracted specified token delta as an `int128`.

### getUnspecifiedDelta

```solidity
function getUnspecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaUnspecified);
```

Extracts the unspecified token delta from a BeforeSwapDelta value.

| Param Name | Type         | Description                          |
|------------|--------------|--------------------------------------|
| delta          | BeforeSwapDelta | The `BeforeSwapDelta`       |

Returns the extracted unspecified token delta as an `int128`.

## Usage in Hooks

When a hook is called during a swap operation, it can perform custom logic and interact with the pool's balances. The `beforeSwap` hook returns a `BeforeSwapDelta` value to indicate any balance changes the *hook* introduces. For example, hooks taking fees should return the value it took as a `BeforeSwapDelta`.

## Usage in PoolManager.sol

`BeforeSwapDelta` plays a crucial role in Uniswap V4's PoolManager contract, particularly in the swap process. Here's an overview of how it's used:

## Calling the `beforeSwap` Hook

In the `swap` function of the PoolManager contract, the `beforeSwap` hook is called:

```solidity
function swap(PoolKey memory key, IPoolManager.SwapParams memory params, bytes calldata hookData)
    // ...
    returns (BalanceDelta swapDelta)
{
    // ... (other code)

    BeforeSwapDelta beforeSwapDelta;
    {
        int256 amountToSwap;
        uint24 lpFeeOverride;
        (amountToSwap, beforeSwapDelta, lpFeeOverride) = key.hooks.beforeSwap(key, params, hookData);

        // ... (swap execution)
    }

    // ... (other code)
}
```

The `beforeSwap` hook returns a `BeforeSwapDelta` value along with other parameters.

### Interaction between `beforeSwapDelta` and `amountToSwap`

The `beforeSwapDelta` returned by the hook is used in conjunction with `params.amountSpecified` to determine the final `amountToSwap`. This allows hooks to modify the swap amount based on their custom logic. Here's a more detailed explanation of how this works:

1. The `beforeSwap` hook returns a `BeforeSwapDelta` value.
2. The `getSpecifiedDelta()` of this `BeforeSwapDelta` is used to adjust the original `params.amountSpecified`.
3. This adjustment results in the final `amountToSwap` that will be used for the actual swap operation.

Here's a simplified representation of this calculation:

```solidity
int256 amountToSwap = params.amountSpecified + beforeSwapDelta.getSpecifiedDelta();
```

In this example, the `amountToSwap` is calculated by adding the specified delta from `beforeSwapDelta` to the original `amountSpecified`. This calculation allows hooks to increase or decrease the swap amount, effectively implementing features like fees, rebates, or other custom logic.

**Detailed Example:**

Let's say a user wants to swap 100 tokens, but a hook implements a 1% fee:

1. `params.amountSpecified` would be 100
2. The hook calculates the fee as 1 token and returns a `beforeSwapDelta` with a specified delta of -1
3. `amountToSwap` is then calculated as 100 + (-1) = 99

This way, the actual amount swapped (99) reflects the fee taken by the hook, while still allowing the pool to execute the swap based on the original 100 token input from the user.

Here's how the `beforeSwap` hook might handle this:

```solidity
function _beforeSwap(
    address,
    PoolKey calldata,
    IPoolManager.SwapParams calldata params,
    bytes calldata
) internal override returns (int256 amountIn, BeforeSwapDelta delta, uint24) {
    int128 specifiedAmount = params.amountSpecified.toInt128();
    int128 fee = specifiedAmount / 100;  // 1% fee
    int128 adjustedAmount = specifiedAmount - fee;
    
    delta = BeforeSwapDelta.from(-fee, 0);  // Fee taken from specified token
    amountIn = params.amountSpecified;  // Original amount
    
    return (amountIn, delta, 0);
}
```

After this hook executes:

- `amountIn` remains 100 (the original `params.amountSpecified`)
- `delta` represents a change of -1 in the specified token (the fee)

Then, in the PoolManager:

```solidity
int256 amountToSwap = params.amountSpecified + beforeSwapDelta.getSpecifiedDelta();
// This effectively calculates: 100 + (-1) = 99
```

As a result:

- The pool sees the full input amount of 100 tokens.
- The actual amount swapped is 99 tokens.
- The 1 token difference becomes the hook's fee.

This mechanism allows hooks to influence the swap amount while maintaining transparency about the full input amount, enabling complex custom logic within the Uniswap V4 framework.

## Relation to `afterSwap`

While `beforeSwapDelta` is primarily used in the `beforeSwap` hook, it also plays a role in the `afterSwap` process. Specifically:

- The `afterSwap` hook receives the `beforeSwapDelta` as a parameter.
- The unspecified delta (`beforeSwapDelta.getUnspecifiedDelta()`) is particularly important in the `afterSwap` context.
- This unspecified delta is accounted for in `afterSwap`'s calculations, allowing for consistent balance tracking across the entire swap process.

This mechanism ensures that:

1. Changes made by the `beforeSwap` hook are properly considered when finalizing the swap.
2. The `afterSwap` hook can make informed decisions based on the full context of the swap, including any modifications made in `beforeSwap`.
3. Complex swap logic can be implemented across multiple hook points while maintaining consistency.

For example, if a fee was taken on the specified token in `beforeSwap`, the `afterSwap` hook can use this information to ensure the overall balance changes are correct, potentially adjusting the unspecified token amount accordingly.

Developers implementing custom hooks should be aware of this relationship and ensure their `beforeSwap` and `afterSwap` implementations work together coherently, especially when implementing features like fees or rebates that affect token balances.

## Key Purposes of BeforeSwapDelta

The `BeforeSwapDelta` serves several important purposes in the Uniswap V4 swap process:

1. **Customization of Swap Behavior:** It allows hooks to modify the swap parameters or even completely override the default swap behavior.
2. **Balance Adjustment:** The delta values can be used to adjust the final balance changes resulting from the swap, giving hooks fine-grained control over the swap's outcome.
3. **Gas Optimization:** By packing two `int128` values into a single `int256`, it reduces the number of stack variables and can lead to gas savings.
4. **Cross-Hook Communication:** It provides a way for the `beforeSwap` hook to pass information to the `afterSwap` hook, enabling more complex and stateful hook logic.
5. **Hook Fees Implementation:** `BeforeSwapDelta` offers flexible options for implementing hook fees:

- Fees can be charged on either the specified or unspecified token.
- Fees can be implemented in either the `beforeSwap` or `afterSwap` hook.
- For `beforeSwap`:

1. Adjust the specified amount to account for the fee.
2. Useful for scenarios where the fee needs to be known before the swap execution.


- For `afterSwap`:

1. Generally considered best practice to charge fees on the unspecified token.
2. Allows for more accurate fee calculation based on the actual swap outcome.

- As a result, developers can implement various fee structures, such as:

1. Fixed fee amounts
2. Percentage-based fees
3. Tiered fee structures based on swap volume or other criteria

Example of a simple percentage-based fee in `beforeSwap`:

```solidity
int128 fee = specifiedAmount * FEE_PERCENTAGE / 100;
int128 adjustedAmount = specifiedAmount - fee;
delta = BeforeSwapDelta.from(-adjustedAmount, 0);
```

This flexibility in fee implementation allows developers to create sophisticated economic models within their Uniswap V4 hooks, tailoring the behavior to specific use cases while maintaining the efficiency and standardization provided by the `BeforeSwapDelta` structure.

## Perspective

It's important to note that the `BeforeSwapDelta` is from the perspective of the hook itself, not the user. For example, if a user swaps 1 USDC for 1 USDT:

- User gives 1 USDC: balance0OfUser decreases
- Hook gets 1 USDC: balance0OfHook increases

This perspective is key to correctly interpreting and manipulating the delta values within hook implementations.

## Implementation Details

The `BeforeSwapDelta` type and its associated functions use low-level assembly code for efficient bit manipulation and gas optimization:

- The `toBeforeSwapDelta` function uses bitwise operations (`shl`, `or`, `and`, `sub`) to pack two `int128` values into a single `int256`.
- The `getSpecifiedDelta` function uses the `sar` (shift arithmetic right) operation to extract the upper 128 bits.
- The `getUnspecifiedDelta` function uses the `signextend` operation to extract and sign-extend the lower 128 bits.

The `toBeforeSwapDelta` function combines the specified and unspecified deltas into a single `int256` value using bitwise operations. The `getSpecifiedDelta` and `getUnspecifiedDelta` functions extract the respective deltas using bit shifting and sign extension.

By leveraging this compact representation and efficient arithmetic operations, Uniswap V4 can perform complex balance calculations and updates in a gas-optimized manner, reducing the overall cost of executing pool-related operations.

## Implementation Considerations

When working with `BeforeSwapDelta`, especially for implementing hook fees, consider the following:

- **Fee Timing:** While fees can be implemented in either `beforeSwap` or `afterSwap`, charging fees on the unspecified token in `afterSwap` is often considered best practice. This approach can provide more accurate fee calculations based on the final swap amounts.
- **Fee Direction:** Remember that the deltas in `BeforeSwapDelta` are from the perspective of the hook. A positive delta means the hook is receiving tokens, while a negative delta means the hook is paying out tokens.
- **Consistency:** Ensure that your fee implementation is consistent across both `beforeSwap` and `afterSwap` hooks to maintain the integrity of the swap process.
- **Gas Efficiency:** When implementing fees, consider the gas costs of your calculations. The compact nature of `BeforeSwapDelta` can help in optimizing gas usage, but complex fee structures might increase gas costs.

## Comparison with BalanceDelta

`BeforeSwapDelta` shares a similar structure with `BalanceDelta`, both packing two `int128` values into a single `int256`. However, there are key differences:

- `BalanceDelta` represents amount0 and amount1.
- `BeforeSwapDelta` represents specified and unspecified amounts, which may not directly correspond to token0 and token1, depending on the swap direction.

## Best Practices

When working with `BeforeSwapDelta`, consider the following best practices:

- Always use the provided library functions (`getSpecifiedDelta` and `getUnspecifiedDelta`) to extract delta values.
- Ensure that the signs of the delta values are correct from the hook's perspective.
- Use `SafeCast` when converting between different integer types to prevent overflow/underflow errors.

## Error Handling and Edge Cases

- **Overflow/Underflow:** Ensure that the input int128 values do not exceed their range when packing into BeforeSwapDelta.
- **Zero Values:** ZERO_DELTA represents no balance changes. Be cautious when interpreting zero values in specific contexts.
- **Sign Mismatch:** Ensure that the signs of the delta values correctly represent the intended balance changes from the hook's perspective.

## Example Usage in a Hook

### Basic Example

Here's a simple example of how `BeforeSwapDelta` might be used in a `beforeSwap` hook:

```solidity
function _beforeSwap(
    address,
    PoolKey calldata,
    IPoolManager.SwapParams calldata params,
    bytes calldata
) internal override returns (int256 amountIn, BeforeSwapDelta delta, uint24) {
    // Convert the specified amount to int128
    int128 specifiedAmount = params.amountSpecified.toInt128();
    
    // In this example, we're not modifying the unspecified amount
    int128 unspecifiedAmount = 0; // Calculated based on your custom logic
    
    // Create the BeforeSwapDelta
    delta = toBeforeSwapDelta(specifiedAmount, unspecifiedAmount);
    
    // Return the original amount as amountIn
    amountIn = params.amountSpecified;
    
    // Return 0 for lpFeeOverride as we're not changing the LP fee
    return (amountIn, delta, 0);
}
```

Let's break down what this basic hook is doing:

1. It converts the `params.amountSpecified` to `int128`, which is required for `BeforeSwapDelta`.
2. It sets the `unspecifiedAmount` to 0, which means this hook isn't modifying the counterpart token in the swap.
3. It creates a `BeforeSwapDelta` using these amounts.
4. It returns the original `amountIn`, the created `delta`, and 0 for `lpFeeOverride`.

This basic example doesn't modify the swap parameters or introduce any fees. It demonstrates the minimal structure of a `beforeSwap` hook using `BeforeSwapDelta`.

## Advanced Example: Implementing a Fee

For a more practical use case, here's an example that implements a simple fee mechanism:

```solidity
function _beforeSwap(
    address,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    bytes calldata
) internal override returns (int256 amountIn, BeforeSwapDelta delta, uint24) {
    // Determine if this is a swap for token0 or token1
    bool zeroForOne = params.zeroForOne;
    
    // Convert the specified amount to int128, ensuring it's positive
    int128 specifiedAmount = params.amountSpecified.abs().toInt128();
    
    // Calculate a 0.1% fee
    int128 fee = specifiedAmount / 1000;
    
    // Adjust the specified amount based on swap direction
    int128 adjustedSpecifiedAmount;
    if (params.exactInput) {
        // For exact input, reduce the amount by the fee
        adjustedSpecifiedAmount = specifiedAmount - fee;
    } else {
        // For exact output, increase the amount by the fee
        adjustedSpecifiedAmount = specifiedAmount + fee;
    }
    
    // Create the BeforeSwapDelta
    delta = zeroForOne 
        ? BeforeSwapDelta.from(-adjustedSpecifiedAmount, 0)
        : BeforeSwapDelta.from(0, -adjustedSpecifiedAmount);
    
    // Return the original amount as amountIn
    amountIn = params.amountSpecified;
    
    // Return 0 for lpFeeOverride as we're not changing the LP fee
    return (amountIn, delta, 0);
}
```

**Let's break down what this hook is doing:**

1. **Swap Direction Determination:**
   The hook checks `params.zeroForOne` to determine the direction of the swap (token0 to token1 or vice versa).
2. **Amount Conversion:** It converts `params.amountSpecified` to a positive `int128`. This is necessary because `BeforeSwapDelta` works with `int128` values.
3. **Fee Calculation:** A 0.1% fee is calculated based on the specified amount.
4. **Amount Adjustment:** Depending on whether the swap is exact input or exact output, the specified amount is adjusted:
   - For exact input, the fee is subtracted (user provides less to the pool).
   - For exact output, the fee is added (user needs to provide more to the pool).
5. **BeforeSwapDelta Creation:** The `BeforeSwapDelta` is created using the adjusted amount. The negative sign indicates that the pool will receive these tokens from the user. The amount is placed in either the first or second parameter of `BeforeSwapDelta.from()` depending on the swap direction.
6. **Return Values:**
   - `amountIn` is set to the original `params.amountSpecified`. This allows the pool to account for the full amount the user is putting in or expecting out.
   - The `delta` value contains our adjusted amounts.
   - `0` is returned for `lpFeeOverride`, meaning we're not changing the default LP fee.

**What This Accomplishes:**

- This hook implements a 0.1% fee on the swaps.
- It handles both exact input and exact output swaps correctly.
- It accounts for the swap direction (token0 to token1 or vice versa).
- The fee is taken from the input amount for exact input swaps, or added to the input amount for exact output swaps.
- The pool will see the full input/output amount, but will only swap the adjusted amount (after accounting for the fee).
- The difference between the original amount and the adjusted amount effectively becomes the hook's fee.

**Considerations:**

- This example assumes the fee is always taken in the input token. In practice, you might want to design more sophisticated fee structures.
- The hook doesn't handle storage of collected fees. In a real implementation, you'd need to account for and possibly transfer these fees.
- Always ensure that your hook's logic is consistent with the overall pool behavior and doesn't introduce unexpected side effects.
- This implementation doesn't change the LP fee (lpFeeOverride is 0). In some cases, you might want to adjust this as well.

As you can see from this example, by using `BeforeSwapDelta`, hooks can implement custom logic such as fees, rebates, or other modifications to the swap parameters, allowing for highly flexible and customizable pool behavior in Uniswap V4.
</file>

<file path="docs/contracts/v4/reference/core/types/BeforeSwapDelta.md">
# BeforeSwapDelta
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BeforeSwapDelta.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


```solidity
type BeforeSwapDelta is int256;
```

## BeforeSwapDeltaLibrary
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BeforeSwapDelta.sol)

Library for getting the specified and unspecified deltas from the BeforeSwapDelta type


## State Variables
### ZERO_DELTA
A BeforeSwapDelta of 0


```solidity
BeforeSwapDelta public constant ZERO_DELTA = BeforeSwapDelta.wrap(0);
```


## Functions
### getSpecifiedDelta

extracts int128 from the upper 128 bits of the BeforeSwapDelta
returned by beforeSwap


```solidity
function getSpecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaSpecified);
```

### getUnspecifiedDelta

extracts int128 from the lower 128 bits of the BeforeSwapDelta
returned by beforeSwap and afterSwap


```solidity
function getUnspecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaUnspecified);
```

# toBeforeSwapDelta
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/BeforeSwapDelta.sol)


```solidity
function toBeforeSwapDelta(int128 deltaSpecified, int128 deltaUnspecified)
    pure
    returns (BeforeSwapDelta beforeSwapDelta);
```
</file>

<file path="docs/contracts/v4/reference/core/types/currency-guide.mdx">
---
title: Currency Guide
---

`Currency` is a custom type that represents either native currency (ETH) or ERC20 tokens.

## Type Definition

```solidity
type Currency is address;
```

## Global Functions

### equals

```solidity
function equals(Currency currency, Currency other) pure returns (bool)
```

Checks if two `Currency` values are equal.

| Param Name | Type     | Description                |
|------------|----------|----------------------------|
| currency   | Currency | The first Currency value   |
| other      | Currency | The second Currency value  |

Returns `true` if the Currency values are equal, `false` otherwise.

### greaterThan

```solidity
function greaterThan(Currency currency, Currency other) pure returns (bool)
```

Compares two `Currency` values based on their underlying addresses.

| Param Name | Type     | Description                |
|------------|----------|----------------------------|
| currency   | Currency | The first Currency value   |
| other      | Currency | The second Currency value  |

Returns `true` if the underlying address of `currency` is numerically greater than the underlying address of `other`, `false` otherwise.

Note: This comparison is based on the numerical value of the addresses and does not imply any inherent ordering or value relationship between different currencies. It's primarily used for consistent ordering in data structures.

### lessThan

```solidity
function lessThan(Currency currency, Currency other) pure returns (bool)
```

Compares two `Currency` values based on their underlying addresses.

| Param Name | Type     | Description                |
|------------|----------|----------------------------|
| currency   | Currency | The first Currency value   |
| other      | Currency | The second Currency value  |

Returns `true` if the underlying address of `currency` is numerically less than the underlying address of `other`, `false` otherwise.

Note: As with `greaterThan`, this comparison is based on address values and does not imply any inherent ordering or value relationship between currencies.

### greaterThanOrEqualTo

```solidity
function greaterThanOrEqualTo(Currency currency, Currency other) pure returns (bool)
```

Checks if one `Currency` value is greater than or equal to another, based on their underlying addresses.

| Param Name | Type     | Description                |
|------------|----------|----------------------------|
| currency   | Currency | The first Currency value   |
| other      | Currency | The second Currency value  |

Returns `true` if the underlying address of `currency` is numerically greater than or equal to the underlying address of `other`, `false` otherwise.

## CurrencyLibrary

The `CurrencyLibrary` provides utility functions for handling both native currency (ETH) and ERC20 tokens.

### Constants

```solidity
Currency public constant NATIVE = Currency.wrap(address(0));
```

`NATIVE` represents the native currency (ETH). It is defined as a `Currency` with the underlying address of `address(0)`.

### Functions

#### transfer

```solidity
function transfer(Currency currency, address to, uint256 amount) internal
```

Transfers `amount` of `currency` to the `to` address.

| Param Name | Type     | Description                           |
|------------|----------|---------------------------------------|
| currency   | Currency | The currency to transfer              |
| to         | address  | The recipient address                 |
| amount     | uint256  | The amount of currency to transfer    |

#### balanceOfSelf

```solidity
function balanceOfSelf(Currency currency) internal view returns (uint256)
```

Returns the balance of `currency` held by the contract itself.

| Param Name | Type     | Description                |
|------------|----------|----------------------------|
| currency   | Currency | The currency to check      |

Returns the balance of the specified currency.

#### balanceOf

```solidity
function balanceOf(Currency currency, address owner) internal view returns (uint256)
```

Returns the balance of `currency` held by the `owner` address.

| Param Name | Type     | Description                |
|------------|----------|----------------------------|
| currency   | Currency | The currency to check      |
| owner      | address  | The address to check       |

Returns the balance of the specified currency for the given address.

#### isNative

```solidity
function isNative(Currency currency) internal pure returns (bool)
```

Checks if the given `currency` is the native currency (ETH).

| Param Name | Type     | Description                |
|------------|----------|----------------------------|
| currency   | Currency | The currency to check      |

Returns `true` if the currency is native (ETH), `false` otherwise.

#### toId

```solidity
function toId(Currency currency) internal pure returns (uint256)
```

Converts a `Currency` to its corresponding ID.

| Param Name | Type     | Description                |
|------------|----------|----------------------------|
| currency   | Currency | The currency to convert    |

Returns the ID of the currency.

#### fromId

```solidity
function fromId(uint256 id) internal pure returns (Currency)
```

Converts an ID to its corresponding `Currency`.

| Param Name | Type     | Description                |
|------------|----------|----------------------------|
| id         | uint256  | The ID to convert          |

Returns the Currency corresponding to the given ID.
</file>

<file path="docs/contracts/v4/reference/core/types/Currency.md">
# Currency
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Currency.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


```solidity
type Currency is address;
```

## CurrencyLibrary
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Currency.sol)

*This library allows for transferring and holding native tokens and ERC20 tokens*


## State Variables
### ADDRESS_ZERO
A constant to represent the native currency


```solidity
Currency public constant ADDRESS_ZERO = Currency.wrap(address(0));
```


## Functions
### transfer


```solidity
function transfer(Currency currency, address to, uint256 amount) internal;
```

### balanceOfSelf


```solidity
function balanceOfSelf(Currency currency) internal view returns (uint256);
```

### balanceOf


```solidity
function balanceOf(Currency currency, address owner) internal view returns (uint256);
```

### isAddressZero


```solidity
function isAddressZero(Currency currency) internal pure returns (bool);
```

### toId


```solidity
function toId(Currency currency) internal pure returns (uint256);
```

### fromId


```solidity
function fromId(uint256 id) internal pure returns (Currency);
```

## Errors
### NativeTransferFailed
Additional context for ERC-7751 wrapped error when a native transfer fails


```solidity
error NativeTransferFailed();
```

### ERC20TransferFailed
Additional context for ERC-7751 wrapped error when an ERC20 transfer fails


```solidity
error ERC20TransferFailed();
```

# greaterThanOrEqualTo
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Currency.sol)


```solidity
function greaterThanOrEqualTo(Currency currency, Currency other) pure returns (bool);
```

# lessThan
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Currency.sol)


```solidity
function lessThan(Currency currency, Currency other) pure returns (bool);
```

# equals
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Currency.sol)


```solidity
function equals(Currency currency, Currency other) pure returns (bool);
```

# greaterThan
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Currency.sol)


```solidity
function greaterThan(Currency currency, Currency other) pure returns (bool);
```
</file>

<file path="docs/contracts/v4/reference/core/types/PoolId.md">
# PoolId
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/PoolId.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


```solidity
type PoolId is bytes32;
```

## PoolIdLibrary
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/PoolId.sol)

Library for computing the ID of a pool


## Functions
### toId

Returns value equal to keccak256(abi.encode(poolKey))


```solidity
function toId(PoolKey memory poolKey) internal pure returns (PoolId poolId);
```
</file>

<file path="docs/contracts/v4/reference/core/types/poolkey-guide.mdx">
---
title: PoolKey Guide
---

`PoolKey` is a crucial struct in Uniswap V4 that uniquely identifies a liquidity pool. It encapsulates all the essential parameters that define a pool's characteristics.

## Structure

```solidity
struct PoolKey {
    Currency currency0;
    Currency currency1;
    uint24 fee;
    int24 tickSpacing;
    IHooks hooks;
}
```

## Fields

| Field Name  | Type     | Description                                                                            |
|-------------|----------|----------------------------------------------------------------------------------------|
| currency0   | Currency | The lower currency of the pool, sorted numerically                                     |
| currency1   | Currency | The higher currency of the pool, sorted numerically                                    |
| fee         | uint24   | The pool swap fee, capped at 1,000,000. If the first bit is 1, the pool has a dynamic fee |
| tickSpacing | int24    | The spacing between ticks for the pool                                                 |
| hooks       | IHooks   | The address of the hooks contract associated with the pool                             |

## Important Notes

- The `currency0` and `currency1` fields are always sorted numerically, with `currency0` being the lower value. This ensures consistent pool identification regardless of the order in which tokens are provided.
- The `fee` field can represent either a static fee or indicate that the pool uses a dynamic fee mechanism.
- The `tickSpacing` field determines the granularity of price ranges that can be used for liquidity provision.
- The `hooks` field is an interface of our Hooks that the PoolManager uses to call these functions
</file>

<file path="docs/contracts/v4/reference/core/types/PoolKey.md">
# PoolKey
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/PoolKey.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Returns the key for identifying a pool


```solidity
struct PoolKey {
    Currency currency0;
    Currency currency1;
    uint24 fee;
    int24 tickSpacing;
    IHooks hooks;
}
```
</file>

<file path="docs/contracts/v4/reference/core/types/Slot0.md">
# Slot0
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Slot0.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

*Slot0 is a packed version of solidity structure.
Using the packaged version saves gas by not storing the structure fields in memory slots.
Layout:
24 bits empty | 24 bits lpFee | 12 bits protocolFee 1->0 | 12 bits protocolFee 0->1 | 24 bits tick | 160 bits sqrtPriceX96
Fields in the direction from the least significant bit:
The current price
uint160 sqrtPriceX96;
The current tick
int24 tick;
Protocol fee, expressed in hundredths of a bip, upper 12 bits are for 1->0, and the lower 12 are for 0->1
the maximum is 1000 - meaning the maximum protocol fee is 0.1%
the protocolFee is taken from the input first, then the lpFee is taken from the remaining input
uint24 protocolFee;
The current LP fee of the pool. If the pool is dynamic, this does not include the dynamic fee flag.
uint24 lpFee;*


```solidity
type Slot0 is bytes32;
```

# Slot0Library
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/types/Slot0.sol)

Library for getting and setting values in the Slot0 type


## State Variables
### MASK_160_BITS

```solidity
uint160 internal constant MASK_160_BITS = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
```


### MASK_24_BITS

```solidity
uint24 internal constant MASK_24_BITS = 0xFFFFFF;
```


### TICK_OFFSET

```solidity
uint8 internal constant TICK_OFFSET = 160;
```


### PROTOCOL_FEE_OFFSET

```solidity
uint8 internal constant PROTOCOL_FEE_OFFSET = 184;
```


### LP_FEE_OFFSET

```solidity
uint8 internal constant LP_FEE_OFFSET = 208;
```


## Functions
### sqrtPriceX96


```solidity
function sqrtPriceX96(Slot0 _packed) internal pure returns (uint160 _sqrtPriceX96);
```

### tick


```solidity
function tick(Slot0 _packed) internal pure returns (int24 _tick);
```

### protocolFee


```solidity
function protocolFee(Slot0 _packed) internal pure returns (uint24 _protocolFee);
```

### lpFee


```solidity
function lpFee(Slot0 _packed) internal pure returns (uint24 _lpFee);
```

### setSqrtPriceX96


```solidity
function setSqrtPriceX96(Slot0 _packed, uint160 _sqrtPriceX96) internal pure returns (Slot0 _result);
```

### setTick


```solidity
function setTick(Slot0 _packed, int24 _tick) internal pure returns (Slot0 _result);
```

### setProtocolFee


```solidity
function setProtocolFee(Slot0 _packed, uint24 _protocolFee) internal pure returns (Slot0 _result);
```

### setLpFee


```solidity
function setLpFee(Slot0 _packed, uint24 _lpFee) internal pure returns (Slot0 _result);
```
</file>

<file path="docs/contracts/v4/reference/core/_category_.json">
{
  "label": "Core",
  "position": 1,
  "collapsed": false
}
</file>

<file path="docs/contracts/v4/reference/core/ERC6909.md">
# ERC6909
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/ERC6909.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IERC6909Claims](contracts/v4/reference/core/interfaces/IERC6909Claims.md)

**Author:**
Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC6909.sol)

Minimalist and gas efficient standard ERC6909 implementation.

*Copied from the commit at 4b47a19038b798b4a33d9749d25e570443520647*

*This contract has been modified from the implementation at the above link.*


## State Variables
### isOperator

```solidity
mapping(address owner => mapping(address operator => bool isOperator)) public isOperator;
```


### balanceOf

```solidity
mapping(address owner => mapping(uint256 id => uint256 balance)) public balanceOf;
```


### allowance

```solidity
mapping(address owner => mapping(address spender => mapping(uint256 id => uint256 amount))) public allowance;
```


## Functions
### transfer


```solidity
function transfer(address receiver, uint256 id, uint256 amount) public virtual returns (bool);
```

### transferFrom


```solidity
function transferFrom(address sender, address receiver, uint256 id, uint256 amount) public virtual returns (bool);
```

### approve


```solidity
function approve(address spender, uint256 id, uint256 amount) public virtual returns (bool);
```

### setOperator


```solidity
function setOperator(address operator, bool approved) public virtual returns (bool);
```

### supportsInterface


```solidity
function supportsInterface(bytes4 interfaceId) public view virtual returns (bool);
```

### _mint


```solidity
function _mint(address receiver, uint256 id, uint256 amount) internal virtual;
```

### _burn


```solidity
function _burn(address sender, uint256 id, uint256 amount) internal virtual;
```
</file>

<file path="docs/contracts/v4/reference/core/ERC6909Claims.md">
# ERC6909Claims
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/ERC6909Claims.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[ERC6909](contracts/v4/reference/core/ERC6909.md)

ERC6909Claims inherits ERC6909 and implements an internal burnFrom function


## Functions
### _burnFrom

Burn `amount` tokens of token type `id` from `from`.

*if sender is not `from` they must be an operator or have sufficient allowance.*


```solidity
function _burnFrom(address from, uint256 id, uint256 amount) internal;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`from`|`address`|The address to burn tokens from.|
|`id`|`uint256`|The currency to burn.|
|`amount`|`uint256`|The amount to burn.|
</file>

<file path="docs/contracts/v4/reference/core/Extsload.md">
# Extsload
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/Extsload.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IExtsload](contracts/v4/reference/core/interfaces/IExtsload.md)

Enables public storage access for efficient state retrieval by external contracts.
https://eips.ethereum.org/EIPS/eip-2330#rationale


## Functions
### extsload

Called by external contracts to access granular pool state


```solidity
function extsload(bytes32 slot) external view returns (bytes32);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`slot`|`bytes32`|Key of slot to sload|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes32`|value The value of the slot as bytes32|


### extsload

Called by external contracts to access granular pool state


```solidity
function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes32[] memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`startSlot`|`bytes32`||
|`nSlots`|`uint256`||

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes32[]`|value The value of the slot as bytes32|


### extsload

Called by external contracts to access granular pool state


```solidity
function extsload(bytes32[] calldata slots) external view returns (bytes32[] memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`slots`|`bytes32[]`||

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes32[]`|value The value of the slot as bytes32|
</file>

<file path="docs/contracts/v4/reference/core/Exttload.md">
# Exttload
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/Exttload.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IExttload](contracts/v4/reference/core/interfaces/IExttload.md)

Enables public transient storage access for efficient state retrieval by external contracts.
https://eips.ethereum.org/EIPS/eip-2330#rationale


## Functions
### exttload

Called by external contracts to access transient storage of the contract


```solidity
function exttload(bytes32 slot) external view returns (bytes32);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`slot`|`bytes32`|Key of slot to tload|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes32`|value The value of the slot as bytes32|


### exttload

Called by external contracts to access transient storage of the contract


```solidity
function exttload(bytes32[] calldata slots) external view returns (bytes32[] memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`slots`|`bytes32[]`||

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes32[]`|value The value of the slot as bytes32|
</file>

<file path="docs/contracts/v4/reference/core/IPoolManager.mdx">
---
title: IPoolManager
---

The `IPoolManager` interface defines the main methods for interacting with the Uniswap V4 pool manager contract. It exposes the core _swap lifecycle_ operations

## ModifyLiquidityParams

Structure used to modify liquidity in a pool.

- `tickLower`: Lower tick boundary of the position
- `tickUpper`: Upper tick boundary of the position
- `liquidityDelta`: Amount of liquidity to add (positive) or remove (negative)
- `salt`: A value to set if you want unique liquidity positions at the same range 

Used in the `modifyLiquidity` function to add or remove liquidity from a specific position in the pool.

## SwapParams

Structure used to execute a swap in a pool.

- `zeroForOne`: Direction of the swap (true for token0 to token1, false for token1 to token0)
- `amountSpecified`: The desired input amount if negative (exactIn), or the desired output amount if positive (exactOut)
- `sqrtPriceLimitX96`: Slippage limit represented as [Q64X96](https://uniswapv3book.com/milestone_3/more-on-fixed-point-numbers.html#:~:text=The%20Q64.,and%2018%20signify%20decimal%20places.) notation

Used in the `swap` function to define the behavior of our swap.

## Methods

### initialize

```solidity
function initialize(PoolKey memory key, uint160 sqrtPriceX96)
    external
    returns (int24 tick);
```

Initialize a new pool by defining its parameters: token pair, fee tier, tick spacing, hook contract, and starting price

| Param Name    | Type      | Description                                     |
|---------------|-----------|--------------------------------------------------|
| key           | PoolKey   | The key defining the pool to initialize          |
| sqrtPriceX96  | uint160   | The initial sqrt price of the pool as a Q64.96 value |

Returns the initial tick value of the pool.

### unlock

```solidity
function unlock(bytes calldata data) external returns (bytes memory);
```

Provides a single entry point for all pool operations. The provided data is passed to the callback for execution.

| Param Name | Type  | Description                                                                         |
|------------|-------|--------------------------------------------------------------------------------------|
| data       | bytes | Any data to pass to the callback via `IUnlockCallback(msg.sender).unlockCallback(data)` |

Returns the data returned by the callback.

### modifyLiquidity

```solidity
function modifyLiquidity(
    PoolKey memory key,
    ModifyLiquidityParams memory params,
    bytes calldata hookData
) external returns (BalanceDelta, BalanceDelta);
```

Modifies the liquidity for the given pool. Can be used to add or remove liquidity, or collect fees
> passing zero will collect fees for the given tick range

| Param Name | Type                  | Description                                     |
|------------|------------------------|--------------------------------------------------|
| key        | PoolKey               | The key of the pool to modify liquidity in       |
| params     | ModifyLiquidityParams | The parameters for modifying the liquidity position |
| hookData   | bytes                 | Any data to pass to a hook contract on the before/add liquidity hooks              |

Returns the balance delta for the caller (total of principal and fees) and the fee delta generated in the liquidity range.

### swap

```solidity
function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)
    external
    returns (BalanceDelta);
```

Executes a swap against the given pool using the provided parameters.

| Param Name | Type       | Description                             |
|------------|------------|-----------------------------------------|
| key        | PoolKey    | The key of the pool to swap in          |
| params     | SwapParams | The parameters for executing the swap   |
| hookData   | bytes      | Any data to pass to a hook contract on the before/afterSwap hooks     |

Returns the balance delta for the address initiating the swap. Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified. Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG, the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.

### donate

```solidity
function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    returns (BalanceDelta);
```

Donates the specified currency amounts to the pool.

| Param Name | Type     | Description                         |
|------------|----------|-------------------------------------|
| key        | PoolKey  | The key of the pool to donate to    |
| amount0    | uint256  | The amount of token0 to donate      |
| amount1    | uint256  | The amount of token1 to donate      |
| hookData   | bytes    | Any data to pass to a hook contract  on the before/afterDonate hooks|

Returns the balance delta representing the donated amounts.
</file>

<file path="docs/contracts/v4/reference/core/NoDelegateCall.md">
# NoDelegateCall
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/NoDelegateCall.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Base contract that provides a modifier for preventing delegatecall to methods in a child contract


## State Variables
### original
*The original address of this contract*


```solidity
address private immutable original;
```


## Functions
### constructor


```solidity
constructor();
```

### checkNotDelegateCall

*Private method is used instead of inlining into modifier because modifiers are copied into each method,
and the use of immutable means the address bytes are copied in every place the modifier is used.*


```solidity
function checkNotDelegateCall() private view;
```

### noDelegateCall

Prevents delegatecall into the modified method


```solidity
modifier noDelegateCall();
```

## Errors
### DelegateCallNotAllowed

```solidity
error DelegateCallNotAllowed();
```
</file>

<file path="docs/contracts/v4/reference/core/PoolManager.md">
# PoolManager
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/PoolManager.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IPoolManager](contracts/v4/reference/core/interfaces/IPoolManager.md), [ProtocolFees](contracts/v4/reference/core/ProtocolFees.md), [NoDelegateCall](contracts/v4/reference/core/NoDelegateCall.md), [ERC6909Claims](contracts/v4/reference/core/ERC6909Claims.md), [Extsload](contracts/v4/reference/core/Extsload.md), [Exttload](contracts/v4/reference/core/Exttload.md)

Holds the state for all pools


## State Variables
### MAX_TICK_SPACING

```solidity
int24 private constant MAX_TICK_SPACING = TickMath.MAX_TICK_SPACING;
```


### MIN_TICK_SPACING

```solidity
int24 private constant MIN_TICK_SPACING = TickMath.MIN_TICK_SPACING;
```


### _pools

```solidity
mapping(PoolId id => Pool.State) internal _pools;
```


## Functions
### onlyWhenUnlocked

This will revert if the contract is locked


```solidity
modifier onlyWhenUnlocked();
```

### constructor


```solidity
constructor(address initialOwner) ProtocolFees(initialOwner);
```

### unlock

All interactions on the contract that account deltas require unlocking. A caller that calls `unlock` must implement
`IUnlockCallback(msg.sender).unlockCallback(data)`, where they interact with the remaining functions on this contract.

*The only functions callable without an unlocking are `initialize` and `updateDynamicLPFee`*


```solidity
function unlock(bytes calldata data) external override returns (bytes memory result);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`data`|`bytes`|Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)`|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`result`|`bytes`|The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)`|


### initialize

Initialize the state for a given pool ID

*A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee*


```solidity
function initialize(PoolKey memory key, uint160 sqrtPriceX96) external noDelegateCall returns (int24 tick);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The pool key for the pool to initialize|
|`sqrtPriceX96`|`uint160`|The initial square root price|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`tick`|`int24`|The initial tick of the pool|


### modifyLiquidity

Modify the liquidity for the given pool

*Poke by calling with a zero liquidityDelta*


```solidity
function modifyLiquidity(PoolKey memory key, IPoolManager.ModifyLiquidityParams memory params, bytes calldata hookData)
    external
    onlyWhenUnlocked
    noDelegateCall
    returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The pool to modify liquidity in|
|`params`|`IPoolManager.ModifyLiquidityParams`|The parameters for modifying the liquidity|
|`hookData`|`bytes`|The data to pass through to the add/removeLiquidity hooks|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`callerDelta`|`BalanceDelta`|The balance delta of the caller of modifyLiquidity. This is the total of both principal, fee deltas, and hook deltas if applicable|
|`feesAccrued`|`BalanceDelta`|The balance delta of the fees generated in the liquidity range. Returned for informational purposes|


### swap

Swap against the given pool

*Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified.
Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG
the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.*


```solidity
function swap(PoolKey memory key, IPoolManager.SwapParams memory params, bytes calldata hookData)
    external
    onlyWhenUnlocked
    noDelegateCall
    returns (BalanceDelta swapDelta);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The pool to swap in|
|`params`|`IPoolManager.SwapParams`|The parameters for swapping|
|`hookData`|`bytes`|The data to pass through to the swap hooks|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`swapDelta`|`BalanceDelta`|The balance delta of the address swapping|


### _swap

Internal swap function to execute a swap, take protocol fees on input token, and emit the swap event


```solidity
function _swap(Pool.State storage pool, PoolId id, Pool.SwapParams memory params, Currency inputCurrency)
    internal
    returns (BalanceDelta);
```

### donate

Donate the given currency amounts to the in-range liquidity providers of a pool

*Calls to donate can be frontrun adding just-in-time liquidity, with the aim of receiving a portion donated funds.
Donors should keep this in mind when designing donation mechanisms.*


```solidity
function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    onlyWhenUnlocked
    noDelegateCall
    returns (BalanceDelta delta);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The key of the pool to donate to|
|`amount0`|`uint256`|The amount of currency0 to donate|
|`amount1`|`uint256`|The amount of currency1 to donate|
|`hookData`|`bytes`|The data to pass through to the donate hooks|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`delta`|`BalanceDelta`|BalanceDelta The delta of the caller after the donate|


### sync

Writes the current ERC20 balance of the specified currency to transient storage
This is used to checkpoint balances for the manager and derive deltas for the caller.

*This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped
for native tokens because the amount to settle is determined by the sent value.
However, if an ERC20 token has been synced and not settled, and the caller instead wants to settle
native funds, this function can be called with the native currency to then be able to settle the native currency*


```solidity
function sync(Currency currency) external;
```

### take

Called by the user to net out some value owed to the user

*Will revert if the requested amount is not available, consider using `mint` instead*


```solidity
function take(Currency currency, address to, uint256 amount) external onlyWhenUnlocked;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency`|`Currency`|The currency to withdraw from the pool manager|
|`to`|`address`|The address to withdraw to|
|`amount`|`uint256`|The amount of currency to withdraw|


### settle

Called by the user to pay what is owed


```solidity
function settle() external payable onlyWhenUnlocked returns (uint256);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint256`|paid The amount of currency settled|


### settleFor

Called by the user to pay on behalf of another address


```solidity
function settleFor(address recipient) external payable onlyWhenUnlocked returns (uint256);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`recipient`|`address`|The address to credit for the payment|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint256`|paid The amount of currency settled|


### clear

WARNING - Any currency that is cleared, will be non-retrievable, and locked in the contract permanently.
A call to clear will zero out a positive balance WITHOUT a corresponding transfer.

*This could be used to clear a balance that is considered dust.
Additionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.*


```solidity
function clear(Currency currency, uint256 amount) external onlyWhenUnlocked;
```

### mint

Called by the user to move value into ERC6909 balance

*The id is converted to a uint160 to correspond to a currency address
If the upper 12 bytes are not 0, they will be 0-ed out*


```solidity
function mint(address to, uint256 id, uint256 amount) external onlyWhenUnlocked;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`to`|`address`|The address to mint the tokens to|
|`id`|`uint256`|The currency address to mint to ERC6909s, as a uint256|
|`amount`|`uint256`|The amount of currency to mint|


### burn

Called by the user to move value from ERC6909 balance

*The id is converted to a uint160 to correspond to a currency address
If the upper 12 bytes are not 0, they will be 0-ed out*


```solidity
function burn(address from, uint256 id, uint256 amount) external onlyWhenUnlocked;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`from`|`address`|The address to burn the tokens from|
|`id`|`uint256`|The currency address to burn from ERC6909s, as a uint256|
|`amount`|`uint256`|The amount of currency to burn|


### updateDynamicLPFee

Updates the pools lp fees for the a pool that has enabled dynamic lp fees.

*A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee*


```solidity
function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The key of the pool to update dynamic LP fees for|
|`newDynamicLPFee`|`uint24`|The new dynamic pool LP fee|


### _settle


```solidity
function _settle(address recipient) internal returns (uint256 paid);
```

### _accountDelta

Adds a balance delta in a currency for a target address


```solidity
function _accountDelta(Currency currency, int128 delta, address target) internal;
```

### _accountPoolBalanceDelta

Accounts the deltas of 2 currencies to a target address


```solidity
function _accountPoolBalanceDelta(PoolKey memory key, BalanceDelta delta, address target) internal;
```

### _getPool

Implementation of the _getPool function defined in ProtocolFees


```solidity
function _getPool(PoolId id) internal view override returns (Pool.State storage);
```

### _isUnlocked

Implementation of the _isUnlocked function defined in ProtocolFees


```solidity
function _isUnlocked() internal view override returns (bool);
```
</file>

<file path="docs/contracts/v4/reference/core/ProtocolFees.md">
# ProtocolFees
[Git Source](https://github.com/uniswap/v4-core/blob/80311e34080fee64b6fc6c916e9a51a437d0e482/src/ProtocolFees.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IProtocolFees](contracts/v4/reference/core/interfaces/IProtocolFees.md), Owned

Contract handling the setting and accrual of protocol fees


## State Variables
### protocolFeesAccrued
Given a currency address, returns the protocol fees accrued in that currency


```solidity
mapping(Currency currency => uint256 amount) public protocolFeesAccrued;
```


### protocolFeeController
Returns the current protocol fee controller address


```solidity
address public protocolFeeController;
```


## Functions
### constructor


```solidity
constructor(address initialOwner) Owned(initialOwner);
```

### setProtocolFeeController

Sets the protocol fee controller


```solidity
function setProtocolFeeController(address controller) external onlyOwner;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`controller`|`address`|The new protocol fee controller|


### setProtocolFee

Sets the protocol fee for the given pool


```solidity
function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The key of the pool to set a protocol fee for|
|`newProtocolFee`|`uint24`|The fee to set|


### collectProtocolFees

Collects the protocol fees for a given recipient and currency, returning the amount collected

*This will revert if the contract is unlocked*


```solidity
function collectProtocolFees(address recipient, Currency currency, uint256 amount)
    external
    returns (uint256 amountCollected);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`recipient`|`address`|The address to receive the protocol fees|
|`currency`|`Currency`|The currency to withdraw|
|`amount`|`uint256`|The amount of currency to withdraw|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amountCollected`|`uint256`|The amount of currency successfully withdrawn|


### _isUnlocked

*abstract internal function to allow the ProtocolFees contract to access the lock*


```solidity
function _isUnlocked() internal virtual returns (bool);
```

### _getPool

*abstract internal function to allow the ProtocolFees contract to access pool state*

*this is overridden in PoolManager.sol to give access to the _pools mapping*


```solidity
function _getPool(PoolId id) internal virtual returns (Pool.State storage);
```

### _updateProtocolFees


```solidity
function _updateProtocolFees(Currency currency, uint256 amount) internal;
```
</file>

<file path="docs/contracts/v4/reference/errors/_category_.json">
{
  "label": "Errors",
  "position": 0,
  "collapsed": false
}
</file>

<file path="docs/contracts/v4/reference/errors/errors.mdx">
---
title: Custom Error Selectors
---

These are custom error selectors for Uniswap v4 contracts.

## IPoolManager.sol

| Error Selector                                      | Hex Value    |
|-----------------------------------------------------|--------------|
| `IPoolManager.CurrencyNotSettled.selector`          | `0x5212cba1` |
| `IPoolManager.PoolNotInitialized.selector`          | `0x486aa307` |
| `IPoolManager.AlreadyUnlocked.selector`             | `0x5090d6c6` |
| `IPoolManager.ManagerLocked.selector`               | `0x54e3ca0d` |
| `IPoolManager.TickSpacingTooLarge.selector`         | `0xb02b5dc2` |
| `IPoolManager.TickSpacingTooSmall.selector`         | `0x16fe7696` |
| `IPoolManager.CurrenciesOutOfOrderOrEqual.selector` | `0xeaa6c6eb` |
| `IPoolManager.UnauthorizedDynamicLPFeeUpdate.selector` | `0x30d21641` |
| `IPoolManager.SwapAmountCannotBeZero.selector`      | `0xbe8b8507` |
| `IPoolManager.NonZeroNativeValue.selector`          | `0x19d245cf` |

## Hooks.sol

| Error Selector                                      | Hex Value    |
|-----------------------------------------------------|--------------|
| `Hooks.HookAddressNotValid.selector`                | `0xe65af6a0` |
| `Hooks.InvalidHookResponse.selector`                | `0x1e048e1d` |
| `Hooks.FailedHookCall.selector`                     | `0x36bc48c5` |
| `Hooks.HookDeltaExceedsSwapAmount.selector`         | `0xfa0b71d6` |

## Pool.sol

| Error Selector                                      | Hex Value    |
|-----------------------------------------------------|--------------|
| `Pool.TicksMisordered.selector`                     | `0xc4433ed5` |
| `Pool.TickLowerOutOfBounds.selector`                | `0xd5e2f7ab` |
| `Pool.TickUpperOutOfBounds.selector`                | `0x1ad777f8` |
| `Pool.TickLiquidityOverflow.selector`               | `0xb8e3c385` |
| `Pool.TickNotInitialized.selector`                  | `0x82a774d3` |
| `Pool.PoolAlreadyInitialized.selector`              | `0x7983c051` |
| `Pool.PoolNotInitialized.selector`                  | `0x486aa307` |
| `Pool.PriceLimitAlreadyExceeded.selector`           | `0x7c9c6e8f` |
| `Pool.PriceLimitOutOfBounds.selector`               | `0x9e4d7cc7` |
| `Pool.NoLiquidityToReceiveFees.selector`            | `0xa74f97ab` |
| `Pool.InvalidFeeForExactOut.selector`               | `0x96206246` |

## IProtocolFees.sol

| Error Selector                                      | Hex Value    |
|-----------------------------------------------------|--------------|
| `IProtocolFees.ProtocolFeeCannotBeFetched.selector` | `0x1ee49702` |
| `IProtocolFees.InvalidProtocolFee.selector`         | `0xba97f838` |
| `IProtocolFees.InvalidCaller.selector`              | `0x48f5c3ed` |

## LPFeeLibrary.sol

| Error Selector                                      | Hex Value    |
|-----------------------------------------------------|--------------|
| `LPFeeLibrary.FeeTooLarge.selector`                 | `0xfc5bee12` |

## Position.sol

| Error Selector                                      | Hex Value      |
|-----------------------------------------------------|----------------|
| `Position.CannotUpdateEmptyPosition.selector`       | `0xaefeb924`   |

## Reserves.sol

| Error Selector                                      | Hex Value      |
|-----------------------------------------------------|----------------|
| `Reserves.ReservesMustBeSynced.selector`            | `0x8774be48`   |

## SqrtPriceMath.sol

| Error Selector                                      | Hex Value    |
|-----------------------------------------------------|--------------|
| `SqrtPriceMath.InvalidPriceOrLiquidity.selector`    | `0x4f2461b8` |
| `SqrtPriceMath.InvalidPrice.selector`               | `0x00bfc921` |
| `SqrtPriceMath.NotEnoughLiquidity.selector`         | `0x4323a555` |
| `SqrtPriceMath.PriceOverflow.selector`              | `0xf5c787f1` |

## TickBitmap.sol

| Error Selector                                      | Hex Value    |
|-----------------------------------------------------|--------------|
| `TickBitmap.TickMisaligned.selector`                | `0xd4d8f3e6` |

## TickMath.sol

| Error Selector                                      | Hex Value    |
|-----------------------------------------------------|--------------|
| `TickMath.InvalidTick.selector`                     | `0xce8ef7fc` |
| `TickMath.InvalidSqrtPrice.selector`                | `0x31efafe8` |
</file>

<file path="docs/contracts/v4/reference/periphery/base/BaseActionsRouter.md">
# BaseActionsRouter
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/BaseActionsRouter.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[SafeCallback](contracts/v4/reference/periphery/base/SafeCallback.md)

Abstract contract for performing a combination of actions on Uniswap v4.

*Suggested uint256 action values are defined in Actions.sol, however any definition can be used*


## Functions
### constructor


```solidity
constructor(IPoolManager _poolManager) SafeCallback(_poolManager);
```

### _executeActions

internal function that triggers the execution of a set of actions on v4

*inheriting contracts should call this function to trigger execution*


```solidity
function _executeActions(bytes calldata unlockData) internal;
```

### _unlockCallback

function that is called by the PoolManager through the SafeCallback.unlockCallback


```solidity
function _unlockCallback(bytes calldata data) internal override returns (bytes memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`data`|`bytes`|Abi encoding of (bytes actions, bytes[] params) where params[i] is the encoded parameters for actions[i]|


### _executeActionsWithoutUnlock


```solidity
function _executeActionsWithoutUnlock(bytes calldata actions, bytes[] calldata params) internal;
```

### _handleAction

function to handle the parsing and execution of an action and its parameters


```solidity
function _handleAction(uint256 action, bytes calldata params) internal virtual;
```

### msgSender

function that returns address considered executor of the actions

*The other context functions, _msgData and _msgValue, are not supported by this contract
In many contracts this will be the address that calls the initial entry point that calls `_executeActions`
`msg.sender` shouldn't be used, as this will be the v4 pool manager contract that calls `unlockCallback`
If using ReentrancyLock.sol, this function can return _getLocker()*


```solidity
function msgSender() public view virtual returns (address);
```

### _mapRecipient

Calculates the address for a action


```solidity
function _mapRecipient(address recipient) internal view returns (address);
```

### _mapPayer

Calculates the payer for an action


```solidity
function _mapPayer(bool payerIsUser) internal view returns (address);
```

## Errors
### InputLengthMismatch
emitted when different numbers of parameters and actions are provided


```solidity
error InputLengthMismatch();
```

### UnsupportedAction
emitted when an inheriting contract does not support an action


```solidity
error UnsupportedAction(uint256 action);
```
</file>

<file path="docs/contracts/v4/reference/periphery/base/BaseV4Quoter.md">
# BaseV4Quoter
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/BaseV4Quoter.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[SafeCallback](contracts/v4/reference/periphery/base/SafeCallback.md)


## Functions
### constructor


```solidity
constructor(IPoolManager _poolManager) SafeCallback(_poolManager);
```

### selfOnly

*Only this address may call this function. Used to mimic internal functions, using an
external call to catch and parse revert reasons*


```solidity
modifier selfOnly();
```

### _unlockCallback


```solidity
function _unlockCallback(bytes calldata data) internal override returns (bytes memory);
```

### _swap

if amountSpecified < 0, the swap is exactInput, otherwise exactOutput

*Execute a swap and return the balance delta*


```solidity
function _swap(PoolKey memory poolKey, bool zeroForOne, int256 amountSpecified, bytes calldata hookData)
    internal
    returns (BalanceDelta swapDelta);
```

## Errors
### NotEnoughLiquidity

```solidity
error NotEnoughLiquidity(PoolId poolId);
```

### NotSelf

```solidity
error NotSelf();
```

### UnexpectedCallSuccess

```solidity
error UnexpectedCallSuccess();
```
</file>

<file path="docs/contracts/v4/reference/periphery/base/DeltaResolver.md">
# DeltaResolver
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/DeltaResolver.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[ImmutableState](contracts/v4/reference/periphery/base/ImmutableState.md)

Abstract contract used to sync, send, and settle funds to the pool manager

*Note that sync() is called before any erc-20 transfer in `settle`.*


## Functions
### _take

Take an amount of currency out of the PoolManager

*Returns early if the amount is 0*


```solidity
function _take(Currency currency, address recipient, uint256 amount) internal;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency`|`Currency`|Currency to take|
|`recipient`|`address`|Address to receive the currency|
|`amount`|`uint256`|Amount to take|


### _settle

Pay and settle a currency to the PoolManager

*The implementing contract must ensure that the `payer` is a secure address*

*Returns early if the amount is 0*


```solidity
function _settle(Currency currency, address payer, uint256 amount) internal;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency`|`Currency`|Currency to settle|
|`payer`|`address`|Address of the payer|
|`amount`|`uint256`|Amount to send|


### _pay

Abstract function for contracts to implement paying tokens to the poolManager

*The recipient of the payment should be the poolManager*


```solidity
function _pay(Currency token, address payer, uint256 amount) internal virtual;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`token`|`Currency`|The token to settle. This is known not to be the native currency|
|`payer`|`address`|The address who should pay tokens|
|`amount`|`uint256`|The number of tokens to send|


### _getFullDebt

Obtain the full amount owed by this contract (negative delta)


```solidity
function _getFullDebt(Currency currency) internal view returns (uint256 amount);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency`|`Currency`|Currency to get the delta for|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amount`|`uint256`|The amount owed by this contract as a uint256|


### _getFullCredit

Obtain the full credit owed to this contract (positive delta)


```solidity
function _getFullCredit(Currency currency) internal view returns (uint256 amount);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency`|`Currency`|Currency to get the delta for|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amount`|`uint256`|The amount owed to this contract as a uint256|


### _mapSettleAmount

Calculates the amount for a settle action


```solidity
function _mapSettleAmount(uint256 amount, Currency currency) internal view returns (uint256);
```

### _mapTakeAmount

Calculates the amount for a take action


```solidity
function _mapTakeAmount(uint256 amount, Currency currency) internal view returns (uint256);
```

### _mapWrapUnwrapAmount

Calculates the sanitized amount before wrapping/unwrapping.


```solidity
function _mapWrapUnwrapAmount(Currency inputCurrency, uint256 amount, Currency outputCurrency)
    internal
    view
    returns (uint256);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`inputCurrency`|`Currency`|The currency, either native or wrapped native, that this contract holds|
|`amount`|`uint256`|The amount to wrap or unwrap. Can be CONTRACT_BALANCE, OPEN_DELTA or a specific amount|
|`outputCurrency`|`Currency`|The currency after the wrap/unwrap that the user may owe a balance in on the poolManager|


## Errors
### DeltaNotPositive
Emitted trying to settle a positive delta.


```solidity
error DeltaNotPositive(Currency currency);
```

### DeltaNotNegative
Emitted trying to take a negative delta.


```solidity
error DeltaNotNegative(Currency currency);
```

### InsufficientBalance
Emitted when the contract does not have enough balance to wrap or unwrap.


```solidity
error InsufficientBalance();
```
</file>

<file path="docs/contracts/v4/reference/periphery/base/EIP712_v4.md">
# EIP712_v4
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/EIP712_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IEIP712_v4](contracts/v4/reference/periphery/interfaces/IEIP712_v4.md)

Generic EIP712 implementation

*Maintains cross-chain replay protection in the event of a fork*

*Should not be delegatecall'd because DOMAIN_SEPARATOR returns the cached hash and does not recompute with the delegatecallers address*

*Reference: https://github.com/Uniswap/permit2/blob/3f17e8db813189a03950dc7fc8382524a095c053/src/EIP712.sol*

*Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7bd2b2aaf68c21277097166a9a51eb72ae239b34/contracts/utils/cryptography/EIP712.sol*


## State Variables
### _CACHED_DOMAIN_SEPARATOR

```solidity
bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
```


### _CACHED_CHAIN_ID

```solidity
uint256 private immutable _CACHED_CHAIN_ID;
```


### _HASHED_NAME

```solidity
bytes32 private immutable _HASHED_NAME;
```


### _TYPE_HASH

```solidity
bytes32 private constant _TYPE_HASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");
```


## Functions
### constructor


```solidity
constructor(string memory name);
```

### DOMAIN_SEPARATOR

Returns the domain separator for the current chain.


```solidity
function DOMAIN_SEPARATOR() public view returns (bytes32);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes32`|bytes32 The domain separator|


### _buildDomainSeparator

Builds a domain separator using the current chainId and contract address.


```solidity
function _buildDomainSeparator() private view returns (bytes32);
```

### _hashTypedData

Creates an EIP-712 typed data hash


```solidity
function _hashTypedData(bytes32 dataHash) internal view returns (bytes32 digest);
```
</file>

<file path="docs/contracts/v4/reference/periphery/base/ERC721Permit_v4.md">
# ERC721Permit_v4
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/ERC721Permit_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
ERC721, [IERC721Permit_v4](contracts/v4/reference/periphery/interfaces/IERC721Permit_v4.md), [EIP712_v4](contracts/v4/reference/periphery/base/EIP712_v4.md), [UnorderedNonce](contracts/v4/reference/periphery/base/UnorderedNonce.md)

Nonfungible tokens that support an approve via signature, i.e. permit


## Functions
### constructor

Computes the nameHash and versionHash


```solidity
constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) EIP712_v4(name_);
```

### checkSignatureDeadline

Checks if the block's timestamp is before a signature's deadline


```solidity
modifier checkSignatureDeadline(uint256 deadline);
```

### permit

Approve of a specific token ID for spending by spender via signature

*payable so it can be multicalled with NATIVE related actions*


```solidity
function permit(address spender, uint256 tokenId, uint256 deadline, uint256 nonce, bytes calldata signature)
    external
    payable
    checkSignatureDeadline(deadline);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`spender`|`address`|The account that is being approved|
|`tokenId`|`uint256`|The ID of the token that is being approved for spending|
|`deadline`|`uint256`|The deadline timestamp by which the call must be mined for the approve to work|
|`nonce`|`uint256`|a unique value, for an owner, to prevent replay attacks; an unordered nonce where the top 248 bits correspond to a word and the bottom 8 bits calculate the bit position of the word|
|`signature`|`bytes`|Concatenated data from a valid secp256k1 signature from the holder, i.e. abi.encodePacked(r, s, v)|


### permitForAll

Set an operator with full permission to an owner's tokens via signature

*payable so it can be multicalled with NATIVE related actions*


```solidity
function permitForAll(
    address owner,
    address operator,
    bool approved,
    uint256 deadline,
    uint256 nonce,
    bytes calldata signature
) external payable checkSignatureDeadline(deadline);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`owner`|`address`|The address that is setting the operator|
|`operator`|`address`|The address that will be set as an operator for the owner|
|`approved`|`bool`|The permission to set on the operator|
|`deadline`|`uint256`|The deadline timestamp by which the call must be mined for the approve to work|
|`nonce`|`uint256`|a unique value, for an owner, to prevent replay attacks; an unordered nonce where the top 248 bits correspond to a word and the bottom 8 bits calculate the bit position of the word|
|`signature`|`bytes`|Concatenated data from a valid secp256k1 signature from the holder, i.e. abi.encodePacked(r, s, v)|


### setApprovalForAll

Enable or disable approval for a third party ("operator") to manage
all of `msg.sender`'s assets

*Emits the ApprovalForAll event. The contract MUST allow
multiple operators per owner.*

*Override Solmate's ERC721 setApprovalForAll so setApprovalForAll() and permit() share the _approveForAll method*


```solidity
function setApprovalForAll(address operator, bool approved) public override;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`operator`|`address`|Address to add to the set of authorized operators|
|`approved`|`bool`|True if the operator is approved, false to revoke approval|


### _approveForAll


```solidity
function _approveForAll(address owner, address operator, bool approved) internal;
```

### approve

Change or reaffirm the approved address for an NFT

*override Solmate's ERC721 approve so approve() and permit() share the _approve method
Passing a spender address of zero can be used to remove any outstanding approvals
Throws error unless `msg.sender` is the current NFT owner,
or an authorized operator of the current owner.*


```solidity
function approve(address spender, uint256 id) public override;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`spender`|`address`|The new approved NFT controller|
|`id`|`uint256`|The tokenId of the NFT to approve|


### _approve


```solidity
function _approve(address owner, address spender, uint256 id) internal;
```

### _isApprovedOrOwner


```solidity
function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool);
```
</file>

<file path="docs/contracts/v4/reference/periphery/base/ImmutableState.md">
# ImmutableState
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/ImmutableState.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IImmutableState](contracts/v4/reference/periphery/interfaces/IImmutableState.md)

A collection of immutable state variables, commonly used across multiple contracts


## State Variables
### poolManager
The Uniswap v4 PoolManager contract


```solidity
IPoolManager public immutable poolManager;
```


## Functions
### onlyPoolManager

Only allow calls from the PoolManager contract


```solidity
modifier onlyPoolManager();
```

### constructor


```solidity
constructor(IPoolManager _poolManager);
```

## Errors
### NotPoolManager
Thrown when the caller is not PoolManager


```solidity
error NotPoolManager();
```
</file>

<file path="docs/contracts/v4/reference/periphery/base/Multicall_v4.md">
# Multicall_v4
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/Multicall_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IMulticall_v4](contracts/v4/reference/periphery/interfaces/IMulticall_v4.md)

Enables calling multiple methods in a single call to the contract


## Functions
### multicall

Call multiple functions in the current contract and return the data from all of them if they all succeed

*The `msg.value` is passed onto all subcalls, even if a previous subcall has consumed the ether.
Subcalls can instead use `address(this).value` to see the available ETH, and consume it using \{value: x\}.*


```solidity
function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`data`|`bytes[]`|The encoded function data for each of the calls to make to this contract|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`results`|`bytes[]`|The results from each of the calls passed in via data|
</file>

<file path="docs/contracts/v4/reference/periphery/base/NativeWrapper.md">
# NativeWrapper
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/NativeWrapper.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[ImmutableState](contracts/v4/reference/periphery/base/ImmutableState.md)

Used for wrapping and unwrapping native


## State Variables
### WETH9
The address for WETH9


```solidity
IWETH9 public immutable WETH9;
```


## Functions
### constructor


```solidity
constructor(IWETH9 _weth9);
```

### _wrap

*The amount should already be \<= the current balance in this contract.*


```solidity
function _wrap(uint256 amount) internal;
```

### _unwrap

*The amount should already be \<= the current balance in this contract.*


```solidity
function _unwrap(uint256 amount) internal;
```

### receive


```solidity
receive() external payable;
```

## Errors
### InvalidEthSender
Thrown when an unexpected address sends ETH to this contract


```solidity
error InvalidEthSender();
```
</file>

<file path="docs/contracts/v4/reference/periphery/base/Notifier.md">
# Notifier
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/Notifier.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[INotifier](contracts/v4/reference/periphery/interfaces/INotifier.md)

Notifier is used to opt in to sending updates to external contracts about position modifications or transfers


## State Variables
### NO_SUBSCRIBER

```solidity
ISubscriber private constant NO_SUBSCRIBER = ISubscriber(address(0));
```


### unsubscribeGasLimit
Returns and determines the maximum allowable gas-used for notifying unsubscribe


```solidity
uint256 public immutable unsubscribeGasLimit;
```


### subscriber
Returns the subscriber for a respective position


```solidity
mapping(uint256 tokenId => ISubscriber subscriber) public subscriber;
```


## Functions
### constructor


```solidity
constructor(uint256 _unsubscribeGasLimit);
```

### onlyIfApproved

Only allow callers that are approved as spenders or operators of the tokenId

*to be implemented by the parent contract (PositionManager)*


```solidity
modifier onlyIfApproved(address caller, uint256 tokenId) virtual;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`caller`|`address`|the address of the caller|
|`tokenId`|`uint256`|the tokenId of the position|


### onlyIfPoolManagerLocked

Enforces that the PoolManager is locked.


```solidity
modifier onlyIfPoolManagerLocked() virtual;
```

### _setUnsubscribed


```solidity
function _setUnsubscribed(uint256 tokenId) internal virtual;
```

### _setSubscribed


```solidity
function _setSubscribed(uint256 tokenId) internal virtual;
```

### subscribe

Enables the subscriber to receive notifications for a respective position

*Calling subscribe when a position is already subscribed will revert*


```solidity
function subscribe(uint256 tokenId, address newSubscriber, bytes calldata data)
    external
    payable
    onlyIfPoolManagerLocked
    onlyIfApproved(msg.sender, tokenId);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|the ERC721 tokenId|
|`newSubscriber`|`address`|the address of the subscriber contract|
|`data`|`bytes`|caller-provided data that's forwarded to the subscriber contract|


### unsubscribe

Removes the subscriber from receiving notifications for a respective position

*Callers must specify a high gas limit (remaining gas should be higher than unsubscriberGasLimit) such that the subscriber can be notified*


```solidity
function unsubscribe(uint256 tokenId) external payable onlyIfPoolManagerLocked onlyIfApproved(msg.sender, tokenId);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|the ERC721 tokenId|


### _unsubscribe


```solidity
function _unsubscribe(uint256 tokenId) internal;
```

### _removeSubscriberAndNotifyBurn

*note this function also deletes the subscriber address from the mapping*


```solidity
function _removeSubscriberAndNotifyBurn(
    uint256 tokenId,
    address owner,
    PositionInfo info,
    uint256 liquidity,
    BalanceDelta feesAccrued
) internal;
```

### _notifyModifyLiquidity


```solidity
function _notifyModifyLiquidity(uint256 tokenId, int256 liquidityChange, BalanceDelta feesAccrued) internal;
```

### _call


```solidity
function _call(address target, bytes memory encodedCall) internal returns (bool success);
```
</file>

<file path="docs/contracts/v4/reference/periphery/base/Permit2Forwarder.md">
# Permit2Forwarder
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/Permit2Forwarder.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IPermit2Forwarder](contracts/v4/reference/periphery/interfaces/IPermit2Forwarder.md)

Permit2Forwarder allows permitting this contract as a spender on permit2

*This contract does not enforce the spender to be this contract, but that is the intended use case*


## State Variables
### permit2
the Permit2 contract to forward approvals


```solidity
IAllowanceTransfer public immutable permit2;
```


## Functions
### constructor


```solidity
constructor(IAllowanceTransfer _permit2);
```

### permit

allows forwarding a single permit to permit2

*this function is payable to allow multicall with NATIVE based actions*


```solidity
function permit(address owner, IAllowanceTransfer.PermitSingle calldata permitSingle, bytes calldata signature)
    external
    payable
    returns (bytes memory err);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`owner`|`address`|the owner of the tokens|
|`permitSingle`|`IAllowanceTransfer.PermitSingle`|the permit data|
|`signature`|`bytes`|the signature of the permit; abi.encodePacked(r, s, v)|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`err`|`bytes`|the error returned by a reverting permit call, empty if successful|


### permitBatch

allows forwarding batch permits to permit2

*this function is payable to allow multicall with NATIVE based actions*


```solidity
function permitBatch(address owner, IAllowanceTransfer.PermitBatch calldata _permitBatch, bytes calldata signature)
    external
    payable
    returns (bytes memory err);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`owner`|`address`|the owner of the tokens|
|`_permitBatch`|`IAllowanceTransfer.PermitBatch`|a batch of approvals|
|`signature`|`bytes`|the signature of the permit; abi.encodePacked(r, s, v)|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`err`|`bytes`|the error returned by a reverting permit call, empty if successful|
</file>

<file path="docs/contracts/v4/reference/periphery/base/PoolInitializer_v4.md">
# PoolInitializer_v4
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/PoolInitializer_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[ImmutableState](contracts/v4/reference/periphery/base/ImmutableState.md), [IPoolInitializer_v4](contracts/v4/reference/periphery/interfaces/IPoolInitializer_v4.md)

Initializes a Uniswap v4 Pool

*Enables create pool + mint liquidity in a single transaction with multicall*


## Functions
### initializePool

Initialize a Uniswap v4 Pool

*If the pool is already initialized, this function will not revert and just return type(int24).max*


```solidity
function initializePool(PoolKey calldata key, uint160 sqrtPriceX96) external payable returns (int24);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The PoolKey of the pool to initialize|
|`sqrtPriceX96`|`uint160`|The initial starting price of the pool, expressed as a sqrtPriceX96|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`int24`|The current tick of the pool, or type(int24).max if the pool creation failed, or the pool already existed|
</file>

<file path="docs/contracts/v4/reference/periphery/base/ReentrancyLock.md">
# ReentrancyLock
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/ReentrancyLock.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

A transient reentrancy lock, that stores the caller's address as the lock


## Functions
### isNotLocked


```solidity
modifier isNotLocked();
```

### _getLocker


```solidity
function _getLocker() internal view returns (address);
```

## Errors
### ContractLocked

```solidity
error ContractLocked();
```
</file>

<file path="docs/contracts/v4/reference/periphery/base/SafeCallback.md">
# SafeCallback
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/SafeCallback.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[ImmutableState](contracts/v4/reference/periphery/base/ImmutableState.md), IUnlockCallback

A contract that only allows the Uniswap v4 PoolManager to call the unlockCallback


## Functions
### constructor


```solidity
constructor(IPoolManager _poolManager) ImmutableState(_poolManager);
```

### unlockCallback

Called by the pool manager on `msg.sender` when the manager is unlocked

*We force the onlyPoolManager modifier by exposing a virtual function after the onlyPoolManager check.*


```solidity
function unlockCallback(bytes calldata data) external onlyPoolManager returns (bytes memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`data`|`bytes`|The data that was passed to the call to unlock|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes`|Any data that you want to be returned from the unlock call|


### _unlockCallback

*to be implemented by the child contract, to safely guarantee the logic is only executed by the PoolManager*


```solidity
function _unlockCallback(bytes calldata data) internal virtual returns (bytes memory);
```
</file>

<file path="docs/contracts/v4/reference/periphery/base/UnorderedNonce.md">
# UnorderedNonce
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/base/UnorderedNonce.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IUnorderedNonce](contracts/v4/reference/periphery/interfaces/IUnorderedNonce.md)

Contract state and methods for using unordered nonces in signatures


## State Variables
### nonces
mapping of nonces consumed by each address, where a nonce is a single bit on the 256-bit bitmap

*word is at most type(uint248).max*


```solidity
mapping(address owner => mapping(uint256 word => uint256 bitmap)) public nonces;
```


## Functions
### _useUnorderedNonce

Consume a nonce, reverting if it has already been used


```solidity
function _useUnorderedNonce(address owner, uint256 nonce) internal;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`owner`|`address`|address, the owner/signer of the nonce|
|`nonce`|`uint256`|uint256, the nonce to consume. The top 248 bits are the word, the bottom 8 bits indicate the bit position|


### revokeNonce

Revoke a nonce by spending it, preventing it from being used again

*Used in cases where a valid nonce has not been broadcasted onchain, and the owner wants to revoke the validity of the nonce*


```solidity
function revokeNonce(uint256 nonce) external payable;
```
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/IEIP712_v4.md">
# IEIP712_v4
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IEIP712_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the EIP712 contract


## Functions
### DOMAIN_SEPARATOR

Returns the domain separator for the current chain.


```solidity
function DOMAIN_SEPARATOR() external view returns (bytes32);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes32`|bytes32 The domain separator|
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/IERC721Permit_v4.md">
# IERC721Permit_v4
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IERC721Permit_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the ERC721Permit_v4 contract


## Functions
### permit

Approve of a specific token ID for spending by spender via signature

*payable so it can be multicalled with NATIVE related actions*


```solidity
function permit(address spender, uint256 tokenId, uint256 deadline, uint256 nonce, bytes calldata signature)
    external
    payable;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`spender`|`address`|The account that is being approved|
|`tokenId`|`uint256`|The ID of the token that is being approved for spending|
|`deadline`|`uint256`|The deadline timestamp by which the call must be mined for the approve to work|
|`nonce`|`uint256`|a unique value, for an owner, to prevent replay attacks; an unordered nonce where the top 248 bits correspond to a word and the bottom 8 bits calculate the bit position of the word|
|`signature`|`bytes`|Concatenated data from a valid secp256k1 signature from the holder, i.e. abi.encodePacked(r, s, v)|


### permitForAll

Set an operator with full permission to an owner's tokens via signature

*payable so it can be multicalled with NATIVE related actions*


```solidity
function permitForAll(
    address owner,
    address operator,
    bool approved,
    uint256 deadline,
    uint256 nonce,
    bytes calldata signature
) external payable;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`owner`|`address`|The address that is setting the operator|
|`operator`|`address`|The address that will be set as an operator for the owner|
|`approved`|`bool`|The permission to set on the operator|
|`deadline`|`uint256`|The deadline timestamp by which the call must be mined for the approve to work|
|`nonce`|`uint256`|a unique value, for an owner, to prevent replay attacks; an unordered nonce where the top 248 bits correspond to a word and the bottom 8 bits calculate the bit position of the word|
|`signature`|`bytes`|Concatenated data from a valid secp256k1 signature from the holder, i.e. abi.encodePacked(r, s, v)|


## Errors
### SignatureDeadlineExpired

```solidity
error SignatureDeadlineExpired();
```

### NoSelfPermit

```solidity
error NoSelfPermit();
```

### Unauthorized

```solidity
error Unauthorized();
```
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/IImmutableState.md">
# IImmutableState
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IImmutableState.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the ImmutableState contract


## Functions
### poolManager

The Uniswap v4 PoolManager contract


```solidity
function poolManager() external view returns (IPoolManager);
```
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/IMulticall_v4.md">
# IMulticall_v4
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IMulticall_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the Multicall_v4 contract


## Functions
### multicall

Call multiple functions in the current contract and return the data from all of them if they all succeed

*The `msg.value` is passed onto all subcalls, even if a previous subcall has consumed the ether.
Subcalls can instead use `address(this).value` to see the available ETH, and consume it using \{value: x\}.*


```solidity
function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`data`|`bytes[]`|The encoded function data for each of the calls to make to this contract|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`results`|`bytes[]`|The results from each of the calls passed in via data|
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/INotifier.md">
# INotifier
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/INotifier.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the Notifier contract


## Functions
### subscriber

Returns the subscriber for a respective position


```solidity
function subscriber(uint256 tokenId) external view returns (ISubscriber subscriber);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|the ERC721 tokenId|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`subscriber`|`ISubscriber`|the subscriber contract|


### subscribe

Enables the subscriber to receive notifications for a respective position

*Calling subscribe when a position is already subscribed will revert*

*payable so it can be multicalled with NATIVE related actions*

*will revert if pool manager is locked*


```solidity
function subscribe(uint256 tokenId, address newSubscriber, bytes calldata data) external payable;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|the ERC721 tokenId|
|`newSubscriber`|`address`|the address of the subscriber contract|
|`data`|`bytes`|caller-provided data that's forwarded to the subscriber contract|


### unsubscribe

Removes the subscriber from receiving notifications for a respective position

*Callers must specify a high gas limit (remaining gas should be higher than unsubscriberGasLimit) such that the subscriber can be notified*

*payable so it can be multicalled with NATIVE related actions*

*Must always allow a user to unsubscribe. In the case of a malicious subscriber, a user can always unsubscribe safely, ensuring liquidity is always modifiable.*

*will revert if pool manager is locked*


```solidity
function unsubscribe(uint256 tokenId) external payable;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|the ERC721 tokenId|


### unsubscribeGasLimit

Returns and determines the maximum allowable gas-used for notifying unsubscribe


```solidity
function unsubscribeGasLimit() external view returns (uint256);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint256`|uint256 the maximum gas limit when notifying a subscriber's `notifyUnsubscribe` function|


## Events
### Subscription
Emitted on a successful call to subscribe


```solidity
event Subscription(uint256 indexed tokenId, address indexed subscriber);
```

### Unsubscription
Emitted on a successful call to unsubscribe


```solidity
event Unsubscription(uint256 indexed tokenId, address indexed subscriber);
```

## Errors
### NotSubscribed
Thrown when unsubscribing without a subscriber


```solidity
error NotSubscribed();
```

### NoCodeSubscriber
Thrown when a subscriber does not have code


```solidity
error NoCodeSubscriber();
```

### GasLimitTooLow
Thrown when a user specifies a gas limit too low to avoid valid unsubscribe notifications


```solidity
error GasLimitTooLow();
```

### SubscriptionReverted
Wraps the revert message of the subscriber contract on a reverting subscription


```solidity
error SubscriptionReverted(address subscriber, bytes reason);
```

### ModifyLiquidityNotificationReverted
Wraps the revert message of the subscriber contract on a reverting modify liquidity notification


```solidity
error ModifyLiquidityNotificationReverted(address subscriber, bytes reason);
```

### BurnNotificationReverted
Wraps the revert message of the subscriber contract on a reverting burn notification


```solidity
error BurnNotificationReverted(address subscriber, bytes reason);
```

### AlreadySubscribed
Thrown when a tokenId already has a subscriber


```solidity
error AlreadySubscribed(uint256 tokenId, address subscriber);
```
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/IPermit2Forwarder.md">
# IPermit2Forwarder
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IPermit2Forwarder.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the Permit2Forwarder contract


## Functions
### permit

allows forwarding a single permit to permit2

*this function is payable to allow multicall with NATIVE based actions*


```solidity
function permit(address owner, IAllowanceTransfer.PermitSingle calldata permitSingle, bytes calldata signature)
    external
    payable
    returns (bytes memory err);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`owner`|`address`|the owner of the tokens|
|`permitSingle`|`IAllowanceTransfer.PermitSingle`|the permit data|
|`signature`|`bytes`|the signature of the permit; abi.encodePacked(r, s, v)|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`err`|`bytes`|the error returned by a reverting permit call, empty if successful|


### permitBatch

allows forwarding batch permits to permit2

*this function is payable to allow multicall with NATIVE based actions*


```solidity
function permitBatch(address owner, IAllowanceTransfer.PermitBatch calldata _permitBatch, bytes calldata signature)
    external
    payable
    returns (bytes memory err);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`owner`|`address`|the owner of the tokens|
|`_permitBatch`|`IAllowanceTransfer.PermitBatch`|a batch of approvals|
|`signature`|`bytes`|the signature of the permit; abi.encodePacked(r, s, v)|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`err`|`bytes`|the error returned by a reverting permit call, empty if successful|
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/IPoolInitializer_v4.md">
# IPoolInitializer_v4
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IPoolInitializer_v4.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the PoolInitializer_v4 contract


## Functions
### initializePool

Initialize a Uniswap v4 Pool

*If the pool is already initialized, this function will not revert and just return type(int24).max*


```solidity
function initializePool(PoolKey calldata key, uint160 sqrtPriceX96) external payable returns (int24);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`key`|`PoolKey`|The PoolKey of the pool to initialize|
|`sqrtPriceX96`|`uint160`|The initial starting price of the pool, expressed as a sqrtPriceX96|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`int24`|The current tick of the pool, or type(int24).max if the pool creation failed, or the pool already existed|
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/IPositionDescriptor.md">
# IPositionDescriptor
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IPositionDescriptor.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the PositionDescriptor contract


## Functions
### tokenURI

Produces the URI describing a particular token ID

*Note this URI may be a data: URI with the JSON contents directly inlined*


```solidity
function tokenURI(IPositionManager positionManager, uint256 tokenId) external view returns (string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`positionManager`|`IPositionManager`|The position manager for which to describe the token|
|`tokenId`|`uint256`|The ID of the token for which to produce a description, which may not be valid|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|The URI of the ERC721-compliant metadata|


### flipRatio

Returns true if currency0 has higher priority than currency1


```solidity
function flipRatio(address currency0, address currency1) external view returns (bool);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency0`|`address`|The first currency address|
|`currency1`|`address`|The second currency address|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bool`|True if currency0 has higher priority than currency1|


### currencyRatioPriority

Returns the priority of a currency.
For certain currencies on mainnet, the smaller the currency, the higher the priority
And those with the higher priority values (more positive values) will be in the numerator of the price ratio


```solidity
function currencyRatioPriority(address currency) external view returns (int256);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency`|`address`|The currency address|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`int256`|The priority of the currency|


### wrappedNative


```solidity
function wrappedNative() external view returns (address);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`address`|The wrapped native token for this descriptor|


### nativeCurrencyLabel


```solidity
function nativeCurrencyLabel() external view returns (string memory);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|The native currency label for this descriptor|


### poolManager


```solidity
function poolManager() external view returns (IPoolManager);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`IPoolManager`|The pool manager for this descriptor|


## Errors
### InvalidTokenId

```solidity
error InvalidTokenId(uint256 tokenId);
```
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/IPositionManager.md">
# IPositionManager
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IPositionManager.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[INotifier](contracts/v4/reference/periphery/interfaces/INotifier.md), [IImmutableState](contracts/v4/reference/periphery/interfaces/IImmutableState.md), [IERC721Permit_v4](contracts/v4/reference/periphery/interfaces/IERC721Permit_v4.md), [IEIP712_v4](contracts/v4/reference/periphery/interfaces/IEIP712_v4.md), [IMulticall_v4](contracts/v4/reference/periphery/interfaces/IMulticall_v4.md), [IPoolInitializer_v4](contracts/v4/reference/periphery/interfaces/IPoolInitializer_v4.md), [IUnorderedNonce](contracts/v4/reference/periphery/interfaces/IUnorderedNonce.md), [IPermit2Forwarder](contracts/v4/reference/periphery/interfaces/IPermit2Forwarder.md)

Interface for the PositionManager contract


## Functions
### modifyLiquidities

Unlocks Uniswap v4 PoolManager and batches actions for modifying liquidity

*This is the standard entrypoint for the PositionManager*


```solidity
function modifyLiquidities(bytes calldata unlockData, uint256 deadline) external payable;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`unlockData`|`bytes`|is an encoding of actions, and parameters for those actions|
|`deadline`|`uint256`|is the deadline for the batched actions to be executed|


### modifyLiquiditiesWithoutUnlock

Batches actions for modifying liquidity without unlocking v4 PoolManager

*This must be called by a contract that has already unlocked the v4 PoolManager*


```solidity
function modifyLiquiditiesWithoutUnlock(bytes calldata actions, bytes[] calldata params) external payable;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`actions`|`bytes`|the actions to perform|
|`params`|`bytes[]`|the parameters to provide for the actions|


### nextTokenId

Used to get the ID that will be used for the next minted liquidity position


```solidity
function nextTokenId() external view returns (uint256);
```
**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint256`|uint256 The next token ID|


### getPositionLiquidity

Returns the liquidity of a position

*this value can be processed as an amount0 and amount1 by using the LiquidityAmounts library*


```solidity
function getPositionLiquidity(uint256 tokenId) external view returns (uint128 liquidity);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|the ERC721 tokenId|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|the position's liquidity, as a liquidityAmount|


### getPoolAndPositionInfo

Returns the pool key and position info of a position


```solidity
function getPoolAndPositionInfo(uint256 tokenId) external view returns (PoolKey memory, PositionInfo);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|the ERC721 tokenId|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`PoolKey`|poolKey the pool key of the position|
|`<none>`|`PositionInfo`|PositionInfo a uint256 packed value holding information about the position including the range (tickLower, tickUpper)|


### positionInfo

Returns the position info of a position


```solidity
function positionInfo(uint256 tokenId) external view returns (PositionInfo);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|the ERC721 tokenId|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`PositionInfo`|a uint256 packed value holding information about the position including the range (tickLower, tickUpper)|


## Errors
### NotApproved
Thrown when the caller is not approved to modify a position


```solidity
error NotApproved(address caller);
```

### DeadlinePassed
Thrown when the block.timestamp exceeds the user-provided deadline


```solidity
error DeadlinePassed(uint256 deadline);
```

### PoolManagerMustBeLocked
Thrown when calling transfer, subscribe, or unsubscribe when the PoolManager is unlocked.

*This is to prevent hooks from being able to trigger notifications at the same time the position is being modified.*


```solidity
error PoolManagerMustBeLocked();
```
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/IStateView.md">
# IStateView
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IStateView.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IImmutableState](contracts/v4/reference/periphery/interfaces/IImmutableState.md)

Interface for the StateView contract


## Functions
### getSlot0

Get Slot0 of the pool: sqrtPriceX96, tick, protocolFee, lpFee

*Corresponds to pools[poolId].slot0*


```solidity
function getSlot0(PoolId poolId)
    external
    view
    returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 lpFee);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceX96`|`uint160`|The square root of the price of the pool, in Q96 precision.|
|`tick`|`int24`|The current tick of the pool.|
|`protocolFee`|`uint24`|The protocol fee of the pool.|
|`lpFee`|`uint24`|The swap fee of the pool.|


### getTickInfo

Retrieves the tick information of a pool at a specific tick.

*Corresponds to pools[poolId].ticks[tick]*


```solidity
function getTickInfo(PoolId poolId, int24 tick)
    external
    view
    returns (uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`tick`|`int24`|The tick to retrieve information for.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidityGross`|`uint128`|The total position liquidity that references this tick|
|`liquidityNet`|`int128`|The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left)|
|`feeGrowthOutside0X128`|`uint256`|fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)|
|`feeGrowthOutside1X128`|`uint256`|fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)|


### getTickLiquidity

Retrieves the liquidity information of a pool at a specific tick.

*Corresponds to pools[poolId].ticks[tick].liquidityGross and pools[poolId].ticks[tick].liquidityNet. A more gas efficient version of getTickInfo*


```solidity
function getTickLiquidity(PoolId poolId, int24 tick)
    external
    view
    returns (uint128 liquidityGross, int128 liquidityNet);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`tick`|`int24`|The tick to retrieve liquidity for.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidityGross`|`uint128`|The total position liquidity that references this tick|
|`liquidityNet`|`int128`|The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left)|


### getTickFeeGrowthOutside

Retrieves the fee growth outside a tick range of a pool

*Corresponds to pools[poolId].ticks[tick].feeGrowthOutside0X128 and pools[poolId].ticks[tick].feeGrowthOutside1X128. A more gas efficient version of getTickInfo*


```solidity
function getTickFeeGrowthOutside(PoolId poolId, int24 tick)
    external
    view
    returns (uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`tick`|`int24`|The tick to retrieve fee growth for.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`feeGrowthOutside0X128`|`uint256`|fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)|
|`feeGrowthOutside1X128`|`uint256`|fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)|


### getFeeGrowthGlobals

Retrieves the global fee growth of a pool.

*Corresponds to pools[poolId].feeGrowthGlobal0X128 and pools[poolId].feeGrowthGlobal1X128*


```solidity
function getFeeGrowthGlobals(PoolId poolId)
    external
    view
    returns (uint256 feeGrowthGlobal0, uint256 feeGrowthGlobal1);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`feeGrowthGlobal0`|`uint256`|The global fee growth for token0.|
|`feeGrowthGlobal1`|`uint256`|The global fee growth for token1.|


### getLiquidity

Retrieves the total liquidity of a pool.

*Corresponds to pools[poolId].liquidity*


```solidity
function getLiquidity(PoolId poolId) external view returns (uint128 liquidity);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The liquidity of the pool.|


### getTickBitmap

Retrieves the tick bitmap of a pool at a specific tick.

*Corresponds to pools[poolId].tickBitmap[tick]*


```solidity
function getTickBitmap(PoolId poolId, int16 tick) external view returns (uint256 tickBitmap);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`tick`|`int16`|The tick to retrieve the bitmap for.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`tickBitmap`|`uint256`|The bitmap of the tick.|


### getPositionInfo

Retrieves the position info without needing to calculate the `positionId`.

*Corresponds to pools[poolId].positions[positionId]*


```solidity
function getPositionInfo(PoolId poolId, address owner, int24 tickLower, int24 tickUpper, bytes32 salt)
    external
    view
    returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`owner`|`address`|The owner of the liquidity position.|
|`tickLower`|`int24`|The lower tick of the liquidity range.|
|`tickUpper`|`int24`|The upper tick of the liquidity range.|
|`salt`|`bytes32`|The bytes32 randomness to further distinguish position state.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The liquidity of the position.|
|`feeGrowthInside0LastX128`|`uint256`|The fee growth inside the position for token0.|
|`feeGrowthInside1LastX128`|`uint256`|The fee growth inside the position for token1.|


### getPositionInfo

Retrieves the position information of a pool at a specific position ID.

*Corresponds to pools[poolId].positions[positionId]*


```solidity
function getPositionInfo(PoolId poolId, bytes32 positionId)
    external
    view
    returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`positionId`|`bytes32`|The ID of the position.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The liquidity of the position.|
|`feeGrowthInside0LastX128`|`uint256`|The fee growth inside the position for token0.|
|`feeGrowthInside1LastX128`|`uint256`|The fee growth inside the position for token1.|


### getPositionLiquidity

Retrieves the liquidity of a position.

*Corresponds to pools[poolId].positions[positionId].liquidity. More gas efficient for just retrieving liquidity as compared to getPositionInfo*


```solidity
function getPositionLiquidity(PoolId poolId, bytes32 positionId) external view returns (uint128 liquidity);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`positionId`|`bytes32`|The ID of the position.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The liquidity of the position.|


### getFeeGrowthInside

Calculate the fee growth inside a tick range of a pool

*pools[poolId].feeGrowthInside0LastX128 in Position.Info is cached and can become stale. This function will calculate the up to date feeGrowthInside*


```solidity
function getFeeGrowthInside(PoolId poolId, int24 tickLower, int24 tickUpper)
    external
    view
    returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`tickLower`|`int24`|The lower tick of the range.|
|`tickUpper`|`int24`|The upper tick of the range.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`feeGrowthInside0X128`|`uint256`|The fee growth inside the tick range for token0.|
|`feeGrowthInside1X128`|`uint256`|The fee growth inside the tick range for token1.|
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/ISubscriber.md">
# ISubscriber
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/ISubscriber.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface that a Subscriber contract should implement to receive updates from the v4 position manager


## Functions
### notifySubscribe

Called when a position subscribes to this subscriber contract


```solidity
function notifySubscribe(uint256 tokenId, bytes memory data) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|the token ID of the position|
|`data`|`bytes`|additional data passed in by the caller|


### notifyUnsubscribe

Called when a position unsubscribes from the subscriber

*This call's gas is capped at `unsubscribeGasLimit` (set at deployment)*

*Because of EIP-150, solidity may only allocate 63/64 of gasleft()*


```solidity
function notifyUnsubscribe(uint256 tokenId) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|the token ID of the position|


### notifyBurn

Called when a position is burned


```solidity
function notifyBurn(uint256 tokenId, address owner, PositionInfo info, uint256 liquidity, BalanceDelta feesAccrued)
    external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|the token ID of the position|
|`owner`|`address`|the current owner of the tokenId|
|`info`|`PositionInfo`|information about the position|
|`liquidity`|`uint256`|the amount of liquidity decreased in the position, may be 0|
|`feesAccrued`|`BalanceDelta`|the fees accrued by the position if liquidity was decreased|


### notifyModifyLiquidity

Called when a position modifies its liquidity or collects fees

*Note that feesAccrued can be artificially inflated by a malicious user
Pools with a single liquidity position can inflate feeGrowthGlobal (and consequently feesAccrued) by donating to themselves;
atomically donating and collecting fees within the same unlockCallback may further inflate feeGrowthGlobal/feesAccrued*


```solidity
function notifyModifyLiquidity(uint256 tokenId, int256 liquidityChange, BalanceDelta feesAccrued) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|the token ID of the position|
|`liquidityChange`|`int256`|the change in liquidity on the underlying position|
|`feesAccrued`|`BalanceDelta`|the fees to be collected from the position as a result of the modifyLiquidity call|
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/IUniswapV4DeployerCompetition.md">
# IUniswapV4DeployerCompetition
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IUniswapV4DeployerCompetition.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the UniswapV4DeployerCompetition contract


## Functions
### updateBestAddress

Updates the best address if the new address has a better vanity score

*The first 20 bytes of the salt must be either address(0) or msg.sender*


```solidity
function updateBestAddress(bytes32 salt) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`salt`|`bytes32`|The salt to use to compute the new address with CREATE2|


### deploy

deploys the Uniswap v4 PoolManager contract

*The bytecode must match the initCodeHash*


```solidity
function deploy(bytes memory bytecode) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`bytecode`|`bytes`|The bytecode of the Uniswap v4 PoolManager contract|


## Events
### NewAddressFound

```solidity
event NewAddressFound(address indexed bestAddress, address indexed submitter, uint256 score);
```

## Errors
### InvalidBytecode

```solidity
error InvalidBytecode();
```

### CompetitionNotOver

```solidity
error CompetitionNotOver(uint256 currentTime, uint256 deadline);
```

### CompetitionOver

```solidity
error CompetitionOver(uint256 currentTime, uint256 deadline);
```

### NotAllowedToDeploy

```solidity
error NotAllowedToDeploy(address sender, address deployer);
```

### WorseAddress

```solidity
error WorseAddress(address newAddress, address bestAddress, uint256 newScore, uint256 bestScore);
```

### InvalidSender

```solidity
error InvalidSender(bytes32 salt, address sender);
```
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/IUnorderedNonce.md">
# IUnorderedNonce
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IUnorderedNonce.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Interface for the UnorderedNonce contract


## Functions
### nonces

mapping of nonces consumed by each address, where a nonce is a single bit on the 256-bit bitmap

*word is at most type(uint248).max*


```solidity
function nonces(address owner, uint256 word) external view returns (uint256);
```

### revokeNonce

Revoke a nonce by spending it, preventing it from being used again

*Used in cases where a valid nonce has not been broadcasted onchain, and the owner wants to revoke the validity of the nonce*

*payable so it can be multicalled with native-token related actions*


```solidity
function revokeNonce(uint256 nonce) external payable;
```

## Errors
### NonceAlreadyUsed

```solidity
error NonceAlreadyUsed();
```
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/IV4Quoter.md">
# IV4Quoter
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IV4Quoter.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IImmutableState](contracts/v4/reference/periphery/interfaces/IImmutableState.md)

Interface for the V4Quoter contract


## Functions
### quoteExactInputSingle

Returns the delta amounts for a given exact input swap of a single pool


```solidity
function quoteExactInputSingle(QuoteExactSingleParams memory params)
    external
    returns (uint256 amountOut, uint256 gasEstimate);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`params`|`QuoteExactSingleParams`|The params for the quote, encoded as `QuoteExactSingleParams` poolKey The key for identifying a V4 pool zeroForOne If the swap is from currency0 to currency1 exactAmount The desired input amount hookData arbitrary hookData to pass into the associated hooks|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amountOut`|`uint256`|The output quote for the exactIn swap|
|`gasEstimate`|`uint256`|Estimated gas units used for the swap|


### quoteExactInput

Returns the delta amounts along the swap path for a given exact input swap


```solidity
function quoteExactInput(QuoteExactParams memory params) external returns (uint256 amountOut, uint256 gasEstimate);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`params`|`QuoteExactParams`|the params for the quote, encoded as 'QuoteExactParams' currencyIn The input currency of the swap path The path of the swap encoded as PathKeys that contains currency, fee, tickSpacing, and hook info exactAmount The desired input amount|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amountOut`|`uint256`|The output quote for the exactIn swap|
|`gasEstimate`|`uint256`|Estimated gas units used for the swap|


### quoteExactOutputSingle

Returns the delta amounts for a given exact output swap of a single pool


```solidity
function quoteExactOutputSingle(QuoteExactSingleParams memory params)
    external
    returns (uint256 amountIn, uint256 gasEstimate);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`params`|`QuoteExactSingleParams`|The params for the quote, encoded as `QuoteExactSingleParams` poolKey The key for identifying a V4 pool zeroForOne If the swap is from currency0 to currency1 exactAmount The desired output amount hookData arbitrary hookData to pass into the associated hooks|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amountIn`|`uint256`|The input quote for the exactOut swap|
|`gasEstimate`|`uint256`|Estimated gas units used for the swap|


### quoteExactOutput

Returns the delta amounts along the swap path for a given exact output swap


```solidity
function quoteExactOutput(QuoteExactParams memory params) external returns (uint256 amountIn, uint256 gasEstimate);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`params`|`QuoteExactParams`|the params for the quote, encoded as 'QuoteExactParams' currencyOut The output currency of the swap path The path of the swap encoded as PathKeys that contains currency, fee, tickSpacing, and hook info exactAmount The desired output amount|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amountIn`|`uint256`|The input quote for the exactOut swap|
|`gasEstimate`|`uint256`|Estimated gas units used for the swap|


## Structs
### QuoteExactSingleParams

```solidity
struct QuoteExactSingleParams {
    PoolKey poolKey;
    bool zeroForOne;
    uint128 exactAmount;
    bytes hookData;
}
```

### QuoteExactParams

```solidity
struct QuoteExactParams {
    Currency exactCurrency;
    PathKey[] path;
    uint128 exactAmount;
}
```
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/IV4Router.md">
# IV4Router
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/IV4Router.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IImmutableState](contracts/v4/reference/periphery/interfaces/IImmutableState.md)

Interface for the V4Router contract


## Errors
### V4TooLittleReceived
Emitted when an exactInput swap does not receive its minAmountOut


```solidity
error V4TooLittleReceived(uint256 minAmountOutReceived, uint256 amountReceived);
```

### V4TooMuchRequested
Emitted when an exactOutput is asked for more than its maxAmountIn


```solidity
error V4TooMuchRequested(uint256 maxAmountInRequested, uint256 amountRequested);
```

## Structs
### ExactInputSingleParams
Parameters for a single-hop exact-input swap


```solidity
struct ExactInputSingleParams {
    PoolKey poolKey;
    bool zeroForOne;
    uint128 amountIn;
    uint128 amountOutMinimum;
    bytes hookData;
}
```

### ExactInputParams
Parameters for a multi-hop exact-input swap


```solidity
struct ExactInputParams {
    Currency currencyIn;
    PathKey[] path;
    uint128 amountIn;
    uint128 amountOutMinimum;
}
```

### ExactOutputSingleParams
Parameters for a single-hop exact-output swap


```solidity
struct ExactOutputSingleParams {
    PoolKey poolKey;
    bool zeroForOne;
    uint128 amountOut;
    uint128 amountInMaximum;
    bytes hookData;
}
```

### ExactOutputParams
Parameters for a multi-hop exact-output swap


```solidity
struct ExactOutputParams {
    Currency currencyOut;
    PathKey[] path;
    uint128 amountOut;
    uint128 amountInMaximum;
}
```
</file>

<file path="docs/contracts/v4/reference/periphery/interfaces/IWETH9.md">
# IWETH9
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/interfaces/external/IWETH9.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
IERC20


## Functions
### deposit

Deposit ether to get wrapped ether


```solidity
function deposit() external payable;
```

### withdraw

Withdraw wrapped ether to get ether


```solidity
function withdraw(uint256) external;
```
</file>

<file path="docs/contracts/v4/reference/periphery/lens/StateView.md">
# StateView
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/lens/StateView.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[ImmutableState](contracts/v4/reference/periphery/base/ImmutableState.md), [IStateView](contracts/v4/reference/periphery/interfaces/IStateView.md)

A view only contract wrapping the StateLibrary.sol library for reading storage in v4-core.

*The contract is intended for offchain clients. Use StateLibrary.sol directly if reading state onchain.*


## Functions
### constructor


```solidity
constructor(IPoolManager _poolManager) ImmutableState(_poolManager);
```

### getSlot0

Get Slot0 of the pool: sqrtPriceX96, tick, protocolFee, lpFee

*Corresponds to pools[poolId].slot0*


```solidity
function getSlot0(PoolId poolId)
    external
    view
    returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 lpFee);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceX96`|`uint160`|The square root of the price of the pool, in Q96 precision.|
|`tick`|`int24`|The current tick of the pool.|
|`protocolFee`|`uint24`|The protocol fee of the pool.|
|`lpFee`|`uint24`|The swap fee of the pool.|


### getTickInfo

Retrieves the tick information of a pool at a specific tick.

*Corresponds to pools[poolId].ticks[tick]*


```solidity
function getTickInfo(PoolId poolId, int24 tick)
    external
    view
    returns (uint128 liquidityGross, int128 liquidityNet, uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`tick`|`int24`|The tick to retrieve information for.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidityGross`|`uint128`|The total position liquidity that references this tick|
|`liquidityNet`|`int128`|The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left)|
|`feeGrowthOutside0X128`|`uint256`|fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)|
|`feeGrowthOutside1X128`|`uint256`|fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)|


### getTickLiquidity

Retrieves the liquidity information of a pool at a specific tick.

*Corresponds to pools[poolId].ticks[tick].liquidityGross and pools[poolId].ticks[tick].liquidityNet. A more gas efficient version of getTickInfo*


```solidity
function getTickLiquidity(PoolId poolId, int24 tick)
    external
    view
    returns (uint128 liquidityGross, int128 liquidityNet);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`tick`|`int24`|The tick to retrieve liquidity for.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidityGross`|`uint128`|The total position liquidity that references this tick|
|`liquidityNet`|`int128`|The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left)|


### getTickFeeGrowthOutside

Retrieves the fee growth outside a tick range of a pool

*Corresponds to pools[poolId].ticks[tick].feeGrowthOutside0X128 and pools[poolId].ticks[tick].feeGrowthOutside1X128. A more gas efficient version of getTickInfo*


```solidity
function getTickFeeGrowthOutside(PoolId poolId, int24 tick)
    external
    view
    returns (uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`tick`|`int24`|The tick to retrieve fee growth for.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`feeGrowthOutside0X128`|`uint256`|fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)|
|`feeGrowthOutside1X128`|`uint256`|fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)|


### getFeeGrowthGlobals

Retrieves the global fee growth of a pool.

*Corresponds to pools[poolId].feeGrowthGlobal0X128 and pools[poolId].feeGrowthGlobal1X128*


```solidity
function getFeeGrowthGlobals(PoolId poolId)
    external
    view
    returns (uint256 feeGrowthGlobal0, uint256 feeGrowthGlobal1);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`feeGrowthGlobal0`|`uint256`|The global fee growth for token0.|
|`feeGrowthGlobal1`|`uint256`|The global fee growth for token1.|


### getLiquidity

Retrieves the total liquidity of a pool.

*Corresponds to pools[poolId].liquidity*


```solidity
function getLiquidity(PoolId poolId) external view returns (uint128 liquidity);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The liquidity of the pool.|


### getTickBitmap

Retrieves the tick bitmap of a pool at a specific tick.

*Corresponds to pools[poolId].tickBitmap[tick]*


```solidity
function getTickBitmap(PoolId poolId, int16 tick) external view returns (uint256 tickBitmap);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`tick`|`int16`|The tick to retrieve the bitmap for.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`tickBitmap`|`uint256`|The bitmap of the tick.|


### getPositionInfo

Retrieves the position info without needing to calculate the `positionId`.

*Corresponds to pools[poolId].positions[positionId]*


```solidity
function getPositionInfo(PoolId poolId, address owner, int24 tickLower, int24 tickUpper, bytes32 salt)
    external
    view
    returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`owner`|`address`|The owner of the liquidity position.|
|`tickLower`|`int24`|The lower tick of the liquidity range.|
|`tickUpper`|`int24`|The upper tick of the liquidity range.|
|`salt`|`bytes32`|The bytes32 randomness to further distinguish position state.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The liquidity of the position.|
|`feeGrowthInside0LastX128`|`uint256`|The fee growth inside the position for token0.|
|`feeGrowthInside1LastX128`|`uint256`|The fee growth inside the position for token1.|


### getPositionInfo

Retrieves the position info without needing to calculate the `positionId`.

*Corresponds to pools[poolId].positions[positionId]*


```solidity
function getPositionInfo(PoolId poolId, bytes32 positionId)
    external
    view
    returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`positionId`|`bytes32`||

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The liquidity of the position.|
|`feeGrowthInside0LastX128`|`uint256`|The fee growth inside the position for token0.|
|`feeGrowthInside1LastX128`|`uint256`|The fee growth inside the position for token1.|


### getPositionLiquidity

Retrieves the liquidity of a position.

*Corresponds to pools[poolId].positions[positionId].liquidity. More gas efficient for just retrieving liquidity as compared to getPositionInfo*


```solidity
function getPositionLiquidity(PoolId poolId, bytes32 positionId) external view returns (uint128 liquidity);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`positionId`|`bytes32`|The ID of the position.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The liquidity of the position.|


### getFeeGrowthInside

Calculate the fee growth inside a tick range of a pool

*pools[poolId].feeGrowthInside0LastX128 in Position.Info is cached and can become stale. This function will calculate the up to date feeGrowthInside*


```solidity
function getFeeGrowthInside(PoolId poolId, int24 tickLower, int24 tickUpper)
    external
    view
    returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`poolId`|`PoolId`|The ID of the pool.|
|`tickLower`|`int24`|The lower tick of the range.|
|`tickUpper`|`int24`|The upper tick of the range.|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`feeGrowthInside0X128`|`uint256`|The fee growth inside the tick range for token0.|
|`feeGrowthInside1X128`|`uint256`|The fee growth inside the tick range for token1.|
</file>

<file path="docs/contracts/v4/reference/periphery/lens/V4Quoter.md">
# V4Quoter
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/lens/V4Quoter.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IV4Quoter](contracts/v4/reference/periphery/interfaces/IV4Quoter.md), [BaseV4Quoter](contracts/v4/reference/periphery/base/BaseV4Quoter.md)

Supports quoting the delta amounts for exact input or exact output swaps.

*These functions are not marked view because they rely on calling non-view functions and reverting
to compute the result. They are also not gas efficient and should not be called on-chain.*


## Functions
### constructor


```solidity
constructor(IPoolManager _poolManager) BaseV4Quoter(_poolManager);
```

### quoteExactInputSingle

Returns the delta amounts for a given exact input swap of a single pool


```solidity
function quoteExactInputSingle(QuoteExactSingleParams memory params)
    external
    returns (uint256 amountOut, uint256 gasEstimate);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`params`|`QuoteExactSingleParams`|The params for the quote, encoded as `QuoteExactSingleParams` poolKey The key for identifying a V4 pool zeroForOne If the swap is from currency0 to currency1 exactAmount The desired input amount hookData arbitrary hookData to pass into the associated hooks|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amountOut`|`uint256`|The output quote for the exactIn swap|
|`gasEstimate`|`uint256`|Estimated gas units used for the swap|


### quoteExactInput

Returns the delta amounts along the swap path for a given exact input swap


```solidity
function quoteExactInput(QuoteExactParams memory params) external returns (uint256 amountOut, uint256 gasEstimate);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`params`|`QuoteExactParams`|the params for the quote, encoded as 'QuoteExactParams' currencyIn The input currency of the swap path The path of the swap encoded as PathKeys that contains currency, fee, tickSpacing, and hook info exactAmount The desired input amount|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amountOut`|`uint256`|The output quote for the exactIn swap|
|`gasEstimate`|`uint256`|Estimated gas units used for the swap|


### quoteExactOutputSingle

Returns the delta amounts for a given exact output swap of a single pool


```solidity
function quoteExactOutputSingle(QuoteExactSingleParams memory params)
    external
    returns (uint256 amountIn, uint256 gasEstimate);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`params`|`QuoteExactSingleParams`|The params for the quote, encoded as `QuoteExactSingleParams` poolKey The key for identifying a V4 pool zeroForOne If the swap is from currency0 to currency1 exactAmount The desired output amount hookData arbitrary hookData to pass into the associated hooks|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amountIn`|`uint256`|The input quote for the exactOut swap|
|`gasEstimate`|`uint256`|Estimated gas units used for the swap|


### quoteExactOutput

Returns the delta amounts along the swap path for a given exact output swap


```solidity
function quoteExactOutput(QuoteExactParams memory params) external returns (uint256 amountIn, uint256 gasEstimate);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`params`|`QuoteExactParams`|the params for the quote, encoded as 'QuoteExactParams' currencyOut The output currency of the swap path The path of the swap encoded as PathKeys that contains currency, fee, tickSpacing, and hook info exactAmount The desired output amount|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`amountIn`|`uint256`|The input quote for the exactOut swap|
|`gasEstimate`|`uint256`|Estimated gas units used for the swap|


### _quoteExactInput

*external function called within the _unlockCallback, to simulate an exact input swap, then revert with the result*


```solidity
function _quoteExactInput(QuoteExactParams calldata params) external selfOnly returns (bytes memory);
```

### _quoteExactInputSingle

*external function called within the _unlockCallback, to simulate a single-hop exact input swap, then revert with the result*


```solidity
function _quoteExactInputSingle(QuoteExactSingleParams calldata params) external selfOnly returns (bytes memory);
```

### _quoteExactOutput

*external function called within the _unlockCallback, to simulate an exact output swap, then revert with the result*


```solidity
function _quoteExactOutput(QuoteExactParams calldata params) external selfOnly returns (bytes memory);
```

### _quoteExactOutputSingle

*external function called within the _unlockCallback, to simulate a single-hop exact output swap, then revert with the result*


```solidity
function _quoteExactOutputSingle(QuoteExactSingleParams calldata params) external selfOnly returns (bytes memory);
```
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/ActionConstants.md">
# ActionConstants
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/ActionConstants.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Common constants used in actions

*Constants are gas efficient alternatives to their literal values*


## State Variables
### OPEN_DELTA
used to signal that an action should use the input value of the open delta on the pool manager
or of the balance that the contract holds


```solidity
uint128 internal constant OPEN_DELTA = 0;
```


### CONTRACT_BALANCE
used to signal that an action should use the contract's entire balance of a currency
This value is equivalent to 1\<\<255, i.e. a singular 1 in the most significant bit.


```solidity
uint256 internal constant CONTRACT_BALANCE = 0x8000000000000000000000000000000000000000000000000000000000000000;
```


### MSG_SENDER
used to signal that the recipient of an action should be the msgSender


```solidity
address internal constant MSG_SENDER = address(1);
```


### ADDRESS_THIS
used to signal that the recipient of an action should be the address(this)


```solidity
address internal constant ADDRESS_THIS = address(2);
```
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/Actions.md">
# Actions
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/Actions.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Library to define different pool actions.

*These are suggested common commands, however additional commands should be defined as required
Some of these actions are not supported in the Router contracts or Position Manager contracts, but are left as they may be helpful commands for other peripheral contracts.*


## State Variables
### INCREASE_LIQUIDITY

```solidity
uint256 internal constant INCREASE_LIQUIDITY = 0x00;
```


### DECREASE_LIQUIDITY

```solidity
uint256 internal constant DECREASE_LIQUIDITY = 0x01;
```


### MINT_POSITION

```solidity
uint256 internal constant MINT_POSITION = 0x02;
```


### BURN_POSITION

```solidity
uint256 internal constant BURN_POSITION = 0x03;
```


### INCREASE_LIQUIDITY_FROM_DELTAS

```solidity
uint256 internal constant INCREASE_LIQUIDITY_FROM_DELTAS = 0x04;
```


### MINT_POSITION_FROM_DELTAS

```solidity
uint256 internal constant MINT_POSITION_FROM_DELTAS = 0x05;
```


### SWAP_EXACT_IN_SINGLE

```solidity
uint256 internal constant SWAP_EXACT_IN_SINGLE = 0x06;
```


### SWAP_EXACT_IN

```solidity
uint256 internal constant SWAP_EXACT_IN = 0x07;
```


### SWAP_EXACT_OUT_SINGLE

```solidity
uint256 internal constant SWAP_EXACT_OUT_SINGLE = 0x08;
```


### SWAP_EXACT_OUT

```solidity
uint256 internal constant SWAP_EXACT_OUT = 0x09;
```


### DONATE

```solidity
uint256 internal constant DONATE = 0x0a;
```


### SETTLE

```solidity
uint256 internal constant SETTLE = 0x0b;
```


### SETTLE_ALL

```solidity
uint256 internal constant SETTLE_ALL = 0x0c;
```


### SETTLE_PAIR

```solidity
uint256 internal constant SETTLE_PAIR = 0x0d;
```


### TAKE

```solidity
uint256 internal constant TAKE = 0x0e;
```


### TAKE_ALL

```solidity
uint256 internal constant TAKE_ALL = 0x0f;
```


### TAKE_PORTION

```solidity
uint256 internal constant TAKE_PORTION = 0x10;
```


### TAKE_PAIR

```solidity
uint256 internal constant TAKE_PAIR = 0x11;
```


### CLOSE_CURRENCY

```solidity
uint256 internal constant CLOSE_CURRENCY = 0x12;
```


### CLEAR_OR_TAKE

```solidity
uint256 internal constant CLEAR_OR_TAKE = 0x13;
```


### SWEEP

```solidity
uint256 internal constant SWEEP = 0x14;
```


### WRAP

```solidity
uint256 internal constant WRAP = 0x15;
```


### UNWRAP

```solidity
uint256 internal constant UNWRAP = 0x16;
```


### MINT_6909

```solidity
uint256 internal constant MINT_6909 = 0x17;
```


### BURN_6909

```solidity
uint256 internal constant BURN_6909 = 0x18;
```
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/AddressStringUtil.md">
# AddressStringUtil
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/AddressStringUtil.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

provides utility functions for converting addresses to strings

*Reference: https://github.com/Uniswap/solidity-lib/blob/master/contracts/libraries/AddressStringUtil.sol*


## Functions
### toAsciiString

Converts an address to the uppercase hex string, extracting only len bytes (up to 20, multiple of 2)


```solidity
function toAsciiString(address addr, uint256 len) internal pure returns (string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`addr`|`address`|the address to convert|
|`len`|`uint256`|the number of bytes to extract|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|the hex string|


### char

Converts a value into is corresponding ASCII character for the hex representation


```solidity
function char(uint8 b) private pure returns (bytes1 c);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`b`|`uint8`|the value to convert|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`c`|`bytes1`|the ASCII character|


## Errors
### InvalidAddressLength

```solidity
error InvalidAddressLength(uint256 len);
```
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/BipsLibrary.md">
# BipsLibrary
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/BipsLibrary.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


## State Variables
### BPS_DENOMINATOR

```solidity
uint256 internal constant BPS_DENOMINATOR = 10_000;
```


## Functions
### calculatePortion


```solidity
function calculatePortion(uint256 amount, uint256 bips) internal pure returns (uint256);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`amount`|`uint256`|The total amount to calculate a percentage of|
|`bips`|`uint256`|The percentage to calculate, in bips|


## Errors
### InvalidBips
emitted when an invalid percentage is provided


```solidity
error InvalidBips();
```
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/CalldataDecoder.md">
# CalldataDecoder
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/CalldataDecoder.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


## State Variables
### OFFSET_OR_LENGTH_MASK
mask used for offsets and lengths to ensure no overflow

*no sane abi encoding will pass in an offset or length greater than type(uint32).max
(note that this does deviate from standard solidity behavior and offsets/lengths will
be interpreted as mod type(uint32).max which will only impact malicious/buggy callers)*


```solidity
uint256 constant OFFSET_OR_LENGTH_MASK = 0xffffffff;
```


### OFFSET_OR_LENGTH_MASK_AND_WORD_ALIGN

```solidity
uint256 constant OFFSET_OR_LENGTH_MASK_AND_WORD_ALIGN = 0xffffffe0;
```


### SLICE_ERROR_SELECTOR
equivalent to SliceOutOfBounds.selector, stored in least-significant bits


```solidity
uint256 constant SLICE_ERROR_SELECTOR = 0x3b99b53d;
```


## Functions
### decodeActionsRouterParams

*equivalent to: abi.decode(params, (bytes, bytes[])) in calldata (requires strict abi encoding)*


```solidity
function decodeActionsRouterParams(bytes calldata _bytes)
    internal
    pure
    returns (bytes calldata actions, bytes[] calldata params);
```

### decodeModifyLiquidityParams

*equivalent to: abi.decode(params, (uint256, uint256, uint128, uint128, bytes)) in calldata*


```solidity
function decodeModifyLiquidityParams(bytes calldata params)
    internal
    pure
    returns (uint256 tokenId, uint256 liquidity, uint128 amount0, uint128 amount1, bytes calldata hookData);
```

### decodeIncreaseLiquidityFromDeltasParams

*equivalent to: abi.decode(params, (uint256, uint128, uint128, bytes)) in calldata*


```solidity
function decodeIncreaseLiquidityFromDeltasParams(bytes calldata params)
    internal
    pure
    returns (uint256 tokenId, uint128 amount0Max, uint128 amount1Max, bytes calldata hookData);
```

### decodeMintParams

*equivalent to: abi.decode(params, (PoolKey, int24, int24, uint256, uint128, uint128, address, bytes)) in calldata*


```solidity
function decodeMintParams(bytes calldata params)
    internal
    pure
    returns (
        PoolKey calldata poolKey,
        int24 tickLower,
        int24 tickUpper,
        uint256 liquidity,
        uint128 amount0Max,
        uint128 amount1Max,
        address owner,
        bytes calldata hookData
    );
```

### decodeMintFromDeltasParams

*equivalent to: abi.decode(params, (PoolKey, int24, int24, uint128, uint128, address, bytes)) in calldata*


```solidity
function decodeMintFromDeltasParams(bytes calldata params)
    internal
    pure
    returns (
        PoolKey calldata poolKey,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Max,
        uint128 amount1Max,
        address owner,
        bytes calldata hookData
    );
```

### decodeBurnParams

*equivalent to: abi.decode(params, (uint256, uint128, uint128, bytes)) in calldata*


```solidity
function decodeBurnParams(bytes calldata params)
    internal
    pure
    returns (uint256 tokenId, uint128 amount0Min, uint128 amount1Min, bytes calldata hookData);
```

### decodeSwapExactInParams

*equivalent to: abi.decode(params, (IV4Router.ExactInputParams))*


```solidity
function decodeSwapExactInParams(bytes calldata params)
    internal
    pure
    returns (IV4Router.ExactInputParams calldata swapParams);
```

### decodeSwapExactInSingleParams

*equivalent to: abi.decode(params, (IV4Router.ExactInputSingleParams))*


```solidity
function decodeSwapExactInSingleParams(bytes calldata params)
    internal
    pure
    returns (IV4Router.ExactInputSingleParams calldata swapParams);
```

### decodeSwapExactOutParams

*equivalent to: abi.decode(params, (IV4Router.ExactOutputParams))*


```solidity
function decodeSwapExactOutParams(bytes calldata params)
    internal
    pure
    returns (IV4Router.ExactOutputParams calldata swapParams);
```

### decodeSwapExactOutSingleParams

*equivalent to: abi.decode(params, (IV4Router.ExactOutputSingleParams))*


```solidity
function decodeSwapExactOutSingleParams(bytes calldata params)
    internal
    pure
    returns (IV4Router.ExactOutputSingleParams calldata swapParams);
```

### decodeCurrency

*equivalent to: abi.decode(params, (Currency)) in calldata*


```solidity
function decodeCurrency(bytes calldata params) internal pure returns (Currency currency);
```

### decodeCurrencyPair

*equivalent to: abi.decode(params, (Currency, Currency)) in calldata*


```solidity
function decodeCurrencyPair(bytes calldata params) internal pure returns (Currency currency0, Currency currency1);
```

### decodeCurrencyPairAndAddress

*equivalent to: abi.decode(params, (Currency, Currency, address)) in calldata*


```solidity
function decodeCurrencyPairAndAddress(bytes calldata params)
    internal
    pure
    returns (Currency currency0, Currency currency1, address _address);
```

### decodeCurrencyAndAddress

*equivalent to: abi.decode(params, (Currency, address)) in calldata*


```solidity
function decodeCurrencyAndAddress(bytes calldata params) internal pure returns (Currency currency, address _address);
```

### decodeCurrencyAddressAndUint256

*equivalent to: abi.decode(params, (Currency, address, uint256)) in calldata*


```solidity
function decodeCurrencyAddressAndUint256(bytes calldata params)
    internal
    pure
    returns (Currency currency, address _address, uint256 amount);
```

### decodeCurrencyAndUint256

*equivalent to: abi.decode(params, (Currency, uint256)) in calldata*


```solidity
function decodeCurrencyAndUint256(bytes calldata params) internal pure returns (Currency currency, uint256 amount);
```

### decodeUint256

*equivalent to: abi.decode(params, (uint256)) in calldata*


```solidity
function decodeUint256(bytes calldata params) internal pure returns (uint256 amount);
```

### decodeCurrencyUint256AndBool

*equivalent to: abi.decode(params, (Currency, uint256, bool)) in calldata*


```solidity
function decodeCurrencyUint256AndBool(bytes calldata params)
    internal
    pure
    returns (Currency currency, uint256 amount, bool boolean);
```

### toBytes

Decode the `_arg`-th element in `_bytes` as `bytes`


```solidity
function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`_bytes`|`bytes`|The input bytes string to extract a bytes string from|
|`_arg`|`uint256`|The index of the argument to extract|


## Errors
### SliceOutOfBounds

```solidity
error SliceOutOfBounds();
```
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/CurrencyRatioSortOrder.md">
# CurrencyRatioSortOrder
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/CurrencyRatioSortOrder.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Provides constants for sorting currencies when displaying price ratios
Currencies given larger values will be in the numerator of the price ratio

*Reference: https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/TokenRatioSortOrder.sol*


## State Variables
### NUMERATOR_MOST

```solidity
int256 constant NUMERATOR_MOST = 300;
```


### NUMERATOR_MORE

```solidity
int256 constant NUMERATOR_MORE = 200;
```


### NUMERATOR

```solidity
int256 constant NUMERATOR = 100;
```


### DENOMINATOR_MOST

```solidity
int256 constant DENOMINATOR_MOST = -300;
```


### DENOMINATOR_MORE

```solidity
int256 constant DENOMINATOR_MORE = -200;
```


### DENOMINATOR

```solidity
int256 constant DENOMINATOR = -100;
```
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/Descriptor.md">
# Descriptor
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/Descriptor.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Describes NFT token positions

*Reference: https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/NFTDescriptor.sol*


## State Variables
### sqrt10X128

```solidity
uint256 constant sqrt10X128 = 1076067327063303206878105757264492625226;
```


## Functions
### constructTokenURI

Constructs the token URI for a Uniswap v4 NFT


```solidity
function constructTokenURI(ConstructTokenURIParams memory params) internal pure returns (string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`params`|`ConstructTokenURIParams`|Parameters needed to construct the token URI|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|The token URI as a string|


### escapeSpecialCharacters

Escapes special characters in a string if they are present


```solidity
function escapeSpecialCharacters(string memory symbol) internal pure returns (string memory);
```

### generateDescriptionPartOne

Generates the first part of the description for a Uniswap v4 NFT


```solidity
function generateDescriptionPartOne(
    string memory quoteCurrencySymbol,
    string memory baseCurrencySymbol,
    string memory poolManager
) private pure returns (string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`quoteCurrencySymbol`|`string`|The symbol of the quote currency|
|`baseCurrencySymbol`|`string`|The symbol of the base currency|
|`poolManager`|`string`|The address of the pool manager|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|The first part of the description|


### generateDescriptionPartTwo

Generates the second part of the description for a Uniswap v4 NFTs


```solidity
function generateDescriptionPartTwo(
    string memory tokenId,
    string memory baseCurrencySymbol,
    string memory quoteCurrency,
    string memory baseCurrency,
    string memory hooks,
    string memory feeTier
) private pure returns (string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`string`|The token ID|
|`baseCurrencySymbol`|`string`|The symbol of the base currency|
|`quoteCurrency`|`string`|The address of the quote currency|
|`baseCurrency`|`string`|The address of the base currency|
|`hooks`|`string`|The address of the hooks contract|
|`feeTier`|`string`|The fee tier of the pool|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|The second part of the description|


### generateName

Generates the name for a Uniswap v4 NFT


```solidity
function generateName(ConstructTokenURIParams memory params, string memory feeTier)
    private
    pure
    returns (string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`params`|`ConstructTokenURIParams`|Parameters needed to generate the name|
|`feeTier`|`string`|The fee tier of the pool|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|The name of the NFT|


### generateDecimalString


```solidity
function generateDecimalString(DecimalStringParams memory params) private pure returns (string memory);
```

### tickToDecimalString

Gets the price (quote/base) at a specific tick in decimal form
MIN or MAX are returned if tick is at the bottom or top of the price curve


```solidity
function tickToDecimalString(
    int24 tick,
    int24 tickSpacing,
    uint8 baseCurrencyDecimals,
    uint8 quoteCurrencyDecimals,
    bool flipRatio
) internal pure returns (string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tick`|`int24`|The tick (either tickLower or tickUpper)|
|`tickSpacing`|`int24`|The tick spacing of the pool|
|`baseCurrencyDecimals`|`uint8`|The decimals of the base currency|
|`quoteCurrencyDecimals`|`uint8`|The decimals of the quote currency|
|`flipRatio`|`bool`|True if the ratio was flipped|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|The ratio value as a string|


### sigfigsRounded


```solidity
function sigfigsRounded(uint256 value, uint8 digits) private pure returns (uint256, bool);
```

### adjustForDecimalPrecision

Adjusts the sqrt price for different currencies with different decimals


```solidity
function adjustForDecimalPrecision(uint160 sqrtRatioX96, uint8 baseCurrencyDecimals, uint8 quoteCurrencyDecimals)
    private
    pure
    returns (uint256 adjustedSqrtRatioX96);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtRatioX96`|`uint160`|The sqrt price at a specific tick|
|`baseCurrencyDecimals`|`uint8`|The decimals of the base currency|
|`quoteCurrencyDecimals`|`uint8`|The decimals of the quote currency|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`adjustedSqrtRatioX96`|`uint256`|The adjusted sqrt price|


### abs

Absolute value of a signed integer


```solidity
function abs(int256 x) private pure returns (uint256);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`x`|`int256`|The signed integer|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint256`|The absolute value of x|


### fixedPointToDecimalString


```solidity
function fixedPointToDecimalString(uint160 sqrtRatioX96, uint8 baseCurrencyDecimals, uint8 quoteCurrencyDecimals)
    internal
    pure
    returns (string memory);
```

### feeToPercentString

Converts fee amount in pips to decimal string with percent sign


```solidity
function feeToPercentString(uint24 fee) internal pure returns (string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`fee`|`uint24`|fee amount|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|fee as a decimal string with percent sign|


### addressToString


```solidity
function addressToString(address addr) internal pure returns (string memory);
```

### generateSVGImage

Generates the SVG image for a Uniswap v4 NFT


```solidity
function generateSVGImage(ConstructTokenURIParams memory params) internal pure returns (string memory svg);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`params`|`ConstructTokenURIParams`|Parameters needed to generate the SVG image|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`svg`|`string`|The SVG image as a string|


### overRange

Checks if the current price is within your position range, above, or below


```solidity
function overRange(int24 tickLower, int24 tickUpper, int24 tickCurrent) private pure returns (int8);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tickLower`|`int24`|The lower tick|
|`tickUpper`|`int24`|The upper tick|
|`tickCurrent`|`int24`|The current tick|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`int8`|0 if the current price is within the position range, -1 if below, 1 if above|


### isSpecialCharacter


```solidity
function isSpecialCharacter(bytes1 b) private pure returns (bool);
```

### scale


```solidity
function scale(uint256 n, uint256 inMn, uint256 inMx, uint256 outMn, uint256 outMx)
    private
    pure
    returns (string memory);
```

### currencyToColorHex


```solidity
function currencyToColorHex(uint256 currency, uint256 offset) internal pure returns (string memory str);
```

### getCircleCoord


```solidity
function getCircleCoord(uint256 currency, uint256 offset, uint256 tokenId) internal pure returns (uint256);
```

### sliceCurrencyHex


```solidity
function sliceCurrencyHex(uint256 currency, uint256 offset) internal pure returns (uint256);
```

## Structs
### ConstructTokenURIParams

```solidity
struct ConstructTokenURIParams {
    uint256 tokenId;
    address quoteCurrency;
    address baseCurrency;
    string quoteCurrencySymbol;
    string baseCurrencySymbol;
    uint8 quoteCurrencyDecimals;
    uint8 baseCurrencyDecimals;
    bool flipRatio;
    int24 tickLower;
    int24 tickUpper;
    int24 tickCurrent;
    int24 tickSpacing;
    uint24 fee;
    address poolManager;
    address hooks;
}
```

### DecimalStringParams

```solidity
struct DecimalStringParams {
    uint256 sigfigs;
    uint8 bufferLength;
    uint8 sigfigIndex;
    uint8 decimalIndex;
    uint8 zerosStartIndex;
    uint8 zerosEndIndex;
    bool isLessThanOne;
    bool isPercent;
}
```
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/ERC721PermitHash.md">
# ERC721PermitHash
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/ERC721PermitHash.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


## State Variables
### PERMIT_TYPEHASH
*Value is equal to keccak256("Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)");*


```solidity
bytes32 constant PERMIT_TYPEHASH = 0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;
```


### PERMIT_FOR_ALL_TYPEHASH
*Value is equal to keccak256("PermitForAll(address operator,bool approved,uint256 nonce,uint256 deadline)");*


```solidity
bytes32 constant PERMIT_FOR_ALL_TYPEHASH = 0x6673cb397ee2a50b6b8401653d3638b4ac8b3db9c28aa6870ffceb7574ec2f76;
```


## Functions
### hashPermit

Hashes the data that will be signed for IERC721Permit_v4.permit()


```solidity
function hashPermit(address spender, uint256 tokenId, uint256 nonce, uint256 deadline)
    internal
    pure
    returns (bytes32 digest);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`spender`|`address`|The address which may spend the tokenId|
|`tokenId`|`uint256`|The tokenId of the owner, which may be spent by spender|
|`nonce`|`uint256`|A unique non-ordered value for each signature to prevent replay attacks|
|`deadline`|`uint256`|The time at which the signature expires|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`digest`|`bytes32`|The hash of the data to be signed; the equivalent to keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, nonce, deadline));|


### hashPermitForAll

Hashes the data that will be signed for IERC721Permit_v4.permit()


```solidity
function hashPermitForAll(address operator, bool approved, uint256 nonce, uint256 deadline)
    internal
    pure
    returns (bytes32 digest);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`operator`|`address`|The address which may spend any of the owner's tokenIds|
|`approved`|`bool`|true if the operator is to have full permission over the owner's tokenIds; false otherwise|
|`nonce`|`uint256`|A unique non-ordered value for each signature to prevent replay attacks|
|`deadline`|`uint256`|The time at which the signature expires|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`digest`|`bytes32`|The hash of the data to be signed; the equivalent to keccak256(abi.encode(PERMIT_FOR_ALL_TYPEHASH, operator, approved, nonce, deadline));|
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/HexStrings.md">
# HexStrings
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/HexStrings.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Provides function for converting numbers to hexadecimal strings

*Reference: https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/HexStrings.sol*


## State Variables
### ALPHABET

```solidity
bytes16 internal constant ALPHABET = "0123456789abcdef";
```


## Functions
### toHexStringNoPrefix

Convert a number to a hex string without the '0x' prefix with a fixed length


```solidity
function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`value`|`uint256`|The number to convert|
|`length`|`uint256`|The length of the output string, starting from the last character of the string|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|The hex string|
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/LiquidityAmounts.md">
# LiquidityAmounts
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/LiquidityAmounts.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Provides functions for computing liquidity amounts from token amounts and prices


## Functions
### getLiquidityForAmount0

Computes the amount of liquidity received for a given amount of token0 and price range

*Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))*


```solidity
function getLiquidityForAmount0(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount0)
    internal
    pure
    returns (uint128 liquidity);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceAX96`|`uint160`|A sqrt price representing the first tick boundary|
|`sqrtPriceBX96`|`uint160`|A sqrt price representing the second tick boundary|
|`amount0`|`uint256`|The amount0 being sent in|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The amount of returned liquidity|


### getLiquidityForAmount1

Computes the amount of liquidity received for a given amount of token1 and price range

*Calculates amount1 / (sqrt(upper) - sqrt(lower)).*


```solidity
function getLiquidityForAmount1(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount1)
    internal
    pure
    returns (uint128 liquidity);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceAX96`|`uint160`|A sqrt price representing the first tick boundary|
|`sqrtPriceBX96`|`uint160`|A sqrt price representing the second tick boundary|
|`amount1`|`uint256`|The amount1 being sent in|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The amount of returned liquidity|


### getLiquidityForAmounts

Computes the maximum amount of liquidity received for a given amount of token0, token1, the current
pool prices and the prices at the tick boundaries


```solidity
function getLiquidityForAmounts(
    uint160 sqrtPriceX96,
    uint160 sqrtPriceAX96,
    uint160 sqrtPriceBX96,
    uint256 amount0,
    uint256 amount1
) internal pure returns (uint128 liquidity);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sqrtPriceX96`|`uint160`|A sqrt price representing the current pool prices|
|`sqrtPriceAX96`|`uint160`|A sqrt price representing the first tick boundary|
|`sqrtPriceBX96`|`uint160`|A sqrt price representing the second tick boundary|
|`amount0`|`uint256`|The amount of token0 being sent in|
|`amount1`|`uint256`|The amount of token1 being sent in|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|The maximum amount of liquidity received|
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/Locker.md">
# Locker
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/Locker.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

This is a temporary library that allows us to use transient storage (tstore/tload)
TODO: This library can be deleted when we have the transient keyword support in solidity.


## State Variables
### LOCKED_BY_SLOT

```solidity
bytes32 constant LOCKED_BY_SLOT = 0x0aedd6bde10e3aa2adec092b02a3e3e805795516cda41f27aa145b8f300af87a;
```


## Functions
### set


```solidity
function set(address locker) internal;
```

### get


```solidity
function get() internal view returns (address locker);
```
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/PathKey.md">
# PathKey
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PathKey.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


```solidity
struct PathKey {
    Currency intermediateCurrency;
    uint24 fee;
    int24 tickSpacing;
    IHooks hooks;
    bytes hookData;
}
```

## PathKeyLibrary
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PathKey.sol)

Functions for working with PathKeys


## Functions
### getPoolAndSwapDirection

Get the pool and swap direction for a given PathKey


```solidity
function getPoolAndSwapDirection(PathKey calldata params, Currency currencyIn)
    internal
    pure
    returns (PoolKey memory poolKey, bool zeroForOne);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`params`|`PathKey`|the given PathKey|
|`currencyIn`|`Currency`|the input currency|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`poolKey`|`PoolKey`|the pool key of the swap|
|`zeroForOne`|`bool`|the direction of the swap, true if currency0 is being swapped for currency1|
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/PositionConfig.md">
# PositionConfig
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PositionConfig.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


```solidity
struct PositionConfig {
    PoolKey poolKey;
    int24 tickLower;
    int24 tickUpper;
}
```

## PositionConfigLibrary
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PositionConfig.sol)

Library to calculate the PositionConfigId from the PositionConfig struct


## Functions
### toId


```solidity
function toId(PositionConfig calldata config) internal pure returns (bytes32 id);
```
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/PositionConfigId.md">
# PositionConfigId
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PositionConfigId.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

A configId is set per tokenId
The lower 255 bits are used to store the truncated hash of the corresponding PositionConfig
The upper bit is used to signal if the tokenId has a subscriber


```solidity
struct PositionConfigId {
    bytes32 id;
}
```

## PositionConfigIdLibrary
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PositionConfigId.sol)


## State Variables
### MASK_UPPER_BIT

```solidity
bytes32 constant MASK_UPPER_BIT = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
```


### DIRTY_UPPER_BIT

```solidity
bytes32 constant DIRTY_UPPER_BIT = 0x8000000000000000000000000000000000000000000000000000000000000000;
```


## Functions
### getConfigId

returns the truncated hash of the PositionConfig for a given tokenId


```solidity
function getConfigId(PositionConfigId storage _configId) internal view returns (bytes32 configId);
```

### setConfigId

*We only set the config on mint, guaranteeing that the most significant bit is unset, so we can just assign the entire 32 bytes to the id.*


```solidity
function setConfigId(PositionConfigId storage _configId, bytes32 configId) internal;
```

### setSubscribe


```solidity
function setSubscribe(PositionConfigId storage configId) internal;
```

### setUnsubscribe


```solidity
function setUnsubscribe(PositionConfigId storage configId) internal;
```

### hasSubscriber


```solidity
function hasSubscriber(PositionConfigId storage configId) internal view returns (bool subscribed);
```
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/PositionInfoLibrary.md">
# PositionInfo
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PositionInfoLibrary.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

*PositionInfo is a packed version of solidity structure.
Using the packaged version saves gas and memory by not storing the structure fields in memory slots.
Layout:
200 bits poolId | 24 bits tickUpper | 24 bits tickLower | 8 bits hasSubscriber
Fields in the direction from the least significant bit:
A flag to know if the tokenId is subscribed to an address
uint8 hasSubscriber;
The tickUpper of the position
int24 tickUpper;
The tickLower of the position
int24 tickLower;
The truncated poolId. Truncates a bytes32 value so the most signifcant (highest) 200 bits are used.
bytes25 poolId;
Note: If more bits are needed, hasSubscriber can be a single bit.*


```solidity
type PositionInfo is uint256;
```

## PositionInfoLibrary
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/PositionInfoLibrary.sol)


## State Variables
### EMPTY_POSITION_INFO

```solidity
PositionInfo internal constant EMPTY_POSITION_INFO = PositionInfo.wrap(0);
```


### MASK_UPPER_200_BITS

```solidity
uint256 internal constant MASK_UPPER_200_BITS = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000;
```


### MASK_8_BITS

```solidity
uint256 internal constant MASK_8_BITS = 0xFF;
```


### MASK_24_BITS

```solidity
uint24 internal constant MASK_24_BITS = 0xFFFFFF;
```


### SET_UNSUBSCRIBE

```solidity
uint256 internal constant SET_UNSUBSCRIBE = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00;
```


### SET_SUBSCRIBE

```solidity
uint256 internal constant SET_SUBSCRIBE = 0x01;
```


### TICK_LOWER_OFFSET

```solidity
uint8 internal constant TICK_LOWER_OFFSET = 8;
```


### TICK_UPPER_OFFSET

```solidity
uint8 internal constant TICK_UPPER_OFFSET = 32;
```


## Functions
### poolId

*This poolId is NOT compatible with the poolId used in UniswapV4 core. It is truncated to 25 bytes, and just used to lookup PoolKey in the poolKeys mapping.*


```solidity
function poolId(PositionInfo info) internal pure returns (bytes25 _poolId);
```

### tickLower


```solidity
function tickLower(PositionInfo info) internal pure returns (int24 _tickLower);
```

### tickUpper


```solidity
function tickUpper(PositionInfo info) internal pure returns (int24 _tickUpper);
```

### hasSubscriber


```solidity
function hasSubscriber(PositionInfo info) internal pure returns (bool _hasSubscriber);
```

### setSubscribe

*this does not actually set any storage*


```solidity
function setSubscribe(PositionInfo info) internal pure returns (PositionInfo _info);
```

### setUnsubscribe

*this does not actually set any storage*


```solidity
function setUnsubscribe(PositionInfo info) internal pure returns (PositionInfo _info);
```

### initialize

Creates the default PositionInfo struct

*Called when minting a new position*


```solidity
function initialize(PoolKey memory _poolKey, int24 _tickLower, int24 _tickUpper)
    internal
    pure
    returns (PositionInfo info);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`_poolKey`|`PoolKey`|the pool key of the position|
|`_tickLower`|`int24`|the lower tick of the position|
|`_tickUpper`|`int24`|the upper tick of the position|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`info`|`PositionInfo`|packed position info, with the truncated poolId and the hasSubscriber flag set to false|
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/QuoterRevert.md">
# QuoterRevert
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/QuoterRevert.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)


## Functions
### revertQuote

reverts, where the revert data is the provided bytes

*called when quoting, to record the quote amount in an error*

*QuoteSwap is used to differentiate this error from other errors thrown when simulating the swap*


```solidity
function revertQuote(uint256 quoteAmount) internal pure;
```

### bubbleReason

reverts using the revertData as the reason

*to bubble up both the valid QuoteSwap(amount) error, or an alternative error thrown during simulation*


```solidity
function bubbleReason(bytes memory revertData) internal pure;
```

### parseQuoteAmount

validates whether a revert reason is a valid swap quote or not
if valid, it decodes the quote to return. Otherwise it reverts.


```solidity
function parseQuoteAmount(bytes memory reason) internal pure returns (uint256 quoteAmount);
```

## Errors
### UnexpectedRevertBytes
error thrown when invalid revert bytes are thrown by the quote


```solidity
error UnexpectedRevertBytes(bytes revertData);
```

### QuoteSwap
error thrown containing the quote as the data, to be caught and parsed later


```solidity
error QuoteSwap(uint256 amount);
```
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/SafeCurrencyMetadata.md">
# SafeCurrencyMetadata
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/SafeCurrencyMetadata.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

can produce symbols and decimals from inconsistent or absent ERC20 implementations

*Reference: https://github.com/Uniswap/solidity-lib/blob/master/contracts/libraries/SafeERC20Namer.sol*


## State Variables
### MAX_SYMBOL_LENGTH

```solidity
uint8 constant MAX_SYMBOL_LENGTH = 12;
```


## Functions
### currencySymbol

attempts to extract the currency symbol. if it does not implement symbol, returns a symbol derived from the address


```solidity
function currencySymbol(address currency, string memory nativeLabel) internal view returns (string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency`|`address`|The currency address|
|`nativeLabel`|`string`|The native label|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|the currency symbol|


### currencyDecimals

attempts to extract the token decimals, returns 0 if not implemented or not a uint8


```solidity
function currencyDecimals(address currency) internal view returns (uint8);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency`|`address`|The currency address|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`uint8`|the currency decimals|


### bytes32ToString


```solidity
function bytes32ToString(bytes32 x) private pure returns (string memory);
```

### addressToSymbol

produces a symbol from the address - the first 6 hex of the address string in upper case


```solidity
function addressToSymbol(address currencyAddress) private pure returns (string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currencyAddress`|`address`|the address of the currency|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|the symbol|


### callAndParseStringReturn

calls an external view contract method that returns a symbol, and parses the output into a string


```solidity
function callAndParseStringReturn(address currencyAddress, bytes4 selector) private view returns (string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currencyAddress`|`address`|the address of the currency|
|`selector`|`bytes4`|the selector of the symbol method|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|the symbol|


### truncateSymbol

truncates the symbol to the MAX_SYMBOL_LENGTH

*assumes the string is already longer than MAX_SYMBOL_LENGTH (or the same)*


```solidity
function truncateSymbol(string memory str) internal pure returns (string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`str`|`string`|the symbol|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|the truncated symbol|
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/SlippageCheck.md">
# SlippageCheck
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/SlippageCheck.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

a library for checking if a delta exceeds a maximum ceiling or fails to meet a minimum floor


## Functions
### validateMinOut

Revert if one or both deltas does not meet a minimum output

*This should be called when removing liquidity (burn or decrease)*


```solidity
function validateMinOut(BalanceDelta delta, uint128 amount0Min, uint128 amount1Min) internal pure;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`delta`|`BalanceDelta`|The principal amount of tokens to be removed, does not include any fees accrued|
|`amount0Min`|`uint128`|The minimum amount of token0 to receive|
|`amount1Min`|`uint128`|The minimum amount of token1 to receive|


### validateMaxIn

Revert if one or both deltas exceeds a maximum input

*This should be called when adding liquidity (mint or increase)*


```solidity
function validateMaxIn(BalanceDelta delta, uint128 amount0Max, uint128 amount1Max) internal pure;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`delta`|`BalanceDelta`|The principal amount of tokens to be added, does not include any fees accrued (which is possible on increase)|
|`amount0Max`|`uint128`|The maximum amount of token0 to spend|
|`amount1Max`|`uint128`|The maximum amount of token1 to spend|


## Errors
### MaximumAmountExceeded

```solidity
error MaximumAmountExceeded(uint128 maximumAmount, uint128 amountRequested);
```

### MinimumAmountInsufficient

```solidity
error MinimumAmountInsufficient(uint128 minimumAmount, uint128 amountReceived);
```
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/SVG.md">
# SVG
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/SVG.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

Provides a function for generating an SVG associated with a Uniswap NFT

*Reference: https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/NFTSVG.sol*


## State Variables
### curve1

```solidity
string constant curve1 = "M1 1C41 41 105 105 145 145";
```


### curve2

```solidity
string constant curve2 = "M1 1C33 49 97 113 145 145";
```


### curve3

```solidity
string constant curve3 = "M1 1C33 57 89 113 145 145";
```


### curve4

```solidity
string constant curve4 = "M1 1C25 65 81 121 145 145";
```


### curve5

```solidity
string constant curve5 = "M1 1C17 73 73 129 145 145";
```


### curve6

```solidity
string constant curve6 = "M1 1C9 81 65 137 145 145";
```


### curve7

```solidity
string constant curve7 = "M1 1C1 89 57.5 145 145 145";
```


### curve8

```solidity
string constant curve8 = "M1 1C1 97 49 145 145 145";
```


## Functions
### generateSVG

Generate the SVG associated with a Uniswap v4 NFT


```solidity
function generateSVG(SVGParams memory params) internal pure returns (string memory svg);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`params`|`SVGParams`|The SVGParams struct containing the parameters for the SVG|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`svg`|`string`|The SVG string associated with the NFT|


### generateSVGDefs

Generate the SVG defs that create the color scheme for the SVG


```solidity
function generateSVGDefs(SVGParams memory params) private pure returns (string memory svg);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`params`|`SVGParams`|The SVGParams struct containing the parameters to generate the SVG defs|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`svg`|`string`|The SVG defs string|


### generateSVGBorderText

Generate the SVG for the moving border text displaying the quote and base currency addresses with their symbols


```solidity
function generateSVGBorderText(
    string memory quoteCurrency,
    string memory baseCurrency,
    string memory quoteCurrencySymbol,
    string memory baseCurrencySymbol
) private pure returns (string memory svg);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`quoteCurrency`|`string`|The quote currency|
|`baseCurrency`|`string`|The base currency|
|`quoteCurrencySymbol`|`string`|The quote currency symbol|
|`baseCurrencySymbol`|`string`|The base currency symbol|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`svg`|`string`|The SVG for the border NFT's border text|


### generateSVGCardMantle

Generate the SVG for the card mantle displaying the quote and base currency symbols and fee tier


```solidity
function generateSVGCardMantle(
    string memory quoteCurrencySymbol,
    string memory baseCurrencySymbol,
    string memory feeTier
) private pure returns (string memory svg);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`quoteCurrencySymbol`|`string`|The quote currency symbol|
|`baseCurrencySymbol`|`string`|The base currency symbol|
|`feeTier`|`string`|The fee tier|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`svg`|`string`|The SVG for the card mantle|


### generageSvgCurve

Generate the SVG for the curve that represents the position. Fade up (top is faded) if current price is above your position range, fade down (bottom is faded) if current price is below your position range
Circles are generated at the ends of the curve if the position is in range, or at one end of the curve it is on if not in range


```solidity
function generageSvgCurve(int24 tickLower, int24 tickUpper, int24 tickSpacing, int8 overRange)
    private
    pure
    returns (string memory svg);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tickLower`|`int24`|The lower tick|
|`tickUpper`|`int24`|The upper tick|
|`tickSpacing`|`int24`|The tick spacing|
|`overRange`|`int8`|Whether the current tick is in range, over range, or under range|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`svg`|`string`|The SVG for the curve|


### getCurve

Get the curve based on the tick range
The smaller the tick range, the smaller/more linear the curve


```solidity
function getCurve(int24 tickLower, int24 tickUpper, int24 tickSpacing) internal pure returns (string memory curve);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tickLower`|`int24`|The lower tick|
|`tickUpper`|`int24`|The upper tick|
|`tickSpacing`|`int24`|The tick spacing|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`curve`|`string`|The curve path|


### generateSVGCurveCircle

Generate the SVG for the circles on the curve


```solidity
function generateSVGCurveCircle(int8 overRange) internal pure returns (string memory svg);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`overRange`|`int8`|0 if the current tick is in range, 1 if the current tick is over range, -1 if the current tick is under range|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`svg`|`string`|The SVG for the circles|


### generateSVGPositionDataAndLocationCurve

If the position is over or under range, generate one circle at the end of the curve on the side of the range it is on with a larger circle around it
If the position is in range, generate two circles at the ends of the curve

Generate the SVG for the position data (token ID, hooks address, min tick, max tick) and the location curve (where your position falls on the curve)


```solidity
function generateSVGPositionDataAndLocationCurve(string memory tokenId, address hook, int24 tickLower, int24 tickUpper)
    private
    pure
    returns (string memory svg);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`string`|The token ID|
|`hook`|`address`|The hooks address|
|`tickLower`|`int24`|The lower tick|
|`tickUpper`|`int24`|The upper tick|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`svg`|`string`|The SVG for the position data and location curve|


### substring


```solidity
function substring(string memory str, uint256 startIndex, uint256 endIndex) internal pure returns (string memory);
```

### tickToString


```solidity
function tickToString(int24 tick) private pure returns (string memory);
```

### rangeLocation

Get the location of where your position falls on the curve


```solidity
function rangeLocation(int24 tickLower, int24 tickUpper) internal pure returns (string memory, string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tickLower`|`int24`|The lower tick|
|`tickUpper`|`int24`|The upper tick|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|The x and y coordinates of the location of the liquidity|
|`<none>`|`string`||


### generateSVGRareSparkle

Generates the SVG for a rare sparkle if the NFT is rare. Else, returns an empty string


```solidity
function generateSVGRareSparkle(uint256 tokenId, address hooks) private pure returns (string memory svg);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|The token ID|
|`hooks`|`address`|The hooks address|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`svg`|`string`|The SVG for the rare sparkle|


### isRare

Determines if an NFT is rare based on the token ID and hooks address


```solidity
function isRare(uint256 tokenId, address hooks) internal pure returns (bool);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|The token ID|
|`hooks`|`address`|The hooks address|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bool`|Whether the NFT is rare or not|


## Structs
### SVGParams

```solidity
struct SVGParams {
    string quoteCurrency;
    string baseCurrency;
    address hooks;
    string quoteCurrencySymbol;
    string baseCurrencySymbol;
    string feeTier;
    int24 tickLower;
    int24 tickUpper;
    int24 tickSpacing;
    int8 overRange;
    uint256 tokenId;
    string color0;
    string color1;
    string color2;
    string color3;
    string x1;
    string y1;
    string x2;
    string y2;
    string x3;
    string y3;
}
```
</file>

<file path="docs/contracts/v4/reference/periphery/libraries/VanityAddressLib.md">
# VanityAddressLib
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/libraries/VanityAddressLib.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

A library to score addresses based on their vanity


## Functions
### betterThan

Compares two addresses and returns true if the first address has a better vanity score


```solidity
function betterThan(address first, address second) internal pure returns (bool better);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`first`|`address`|The first address to compare|
|`second`|`address`|The second address to compare|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`better`|`bool`|True if the first address has a better vanity score|


### score

Scores an address based on its vanity

*Scoring rules:
Requirement: The first nonzero nibble must be 4
10 points for every leading 0 nibble
40 points if the first 4 is followed by 3 more 4s
20 points if the first nibble after the 4 4s is NOT a 4
20 points if the last 4 nibbles are 4s
1 point for every 4*


```solidity
function score(address addr) internal pure returns (uint256 calculatedScore);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`addr`|`address`|The address to score|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`calculatedScore`|`uint256`|The vanity score of the address|


### getLeadingNibbleCount

Returns the number of leading nibbles in an address that match a given value


```solidity
function getLeadingNibbleCount(bytes20 addrBytes, uint256 startIndex, uint8 comparison)
    internal
    pure
    returns (uint256 count);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`addrBytes`|`bytes20`|The address to count the leading zero nibbles in|
|`startIndex`|`uint256`||
|`comparison`|`uint8`||


### getNibble

Returns the nibble at a given index in an address


```solidity
function getNibble(bytes20 input, uint256 nibbleIndex) internal pure returns (uint8 currentNibble);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`input`|`bytes20`|The address to get the nibble from|
|`nibbleIndex`|`uint256`|The index of the nibble to get|
</file>

<file path="docs/contracts/v4/reference/periphery/utils/BaseHook.md">
# BaseHook
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/utils/BaseHook.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
IHooks, [ImmutableState](contracts/v4/reference/periphery/base/ImmutableState.md)

abstract contract for hook implementations


## Functions
### constructor


```solidity
constructor(IPoolManager _manager) ImmutableState(_manager);
```

### getHookPermissions

Returns a struct of permissions to signal which hook functions are to be implemented

*Used at deployment to validate the address correctly represents the expected permissions*


```solidity
function getHookPermissions() public pure virtual returns (Hooks.Permissions memory);
```

### validateHookAddress

Validates the deployed hook address agrees with the expected permissions of the hook

*this function is virtual so that we can override it during testing,
which allows us to deploy an implementation to any address
and then etch the bytecode into the correct address*


```solidity
function validateHookAddress(BaseHook _this) internal pure virtual;
```

### beforeInitialize

The hook called before the state of a pool is initialized


```solidity
function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96)
    external
    onlyPoolManager
    returns (bytes4);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the initialize call|
|`key`|`PoolKey`|The key for the pool being initialized|
|`sqrtPriceX96`|`uint160`|The sqrt(price) of the pool as a Q64.96|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|


### _beforeInitialize


```solidity
function _beforeInitialize(address, PoolKey calldata, uint160) internal virtual returns (bytes4);
```

### afterInitialize

The hook called after the state of a pool is initialized


```solidity
function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)
    external
    onlyPoolManager
    returns (bytes4);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the initialize call|
|`key`|`PoolKey`|The key for the pool being initialized|
|`sqrtPriceX96`|`uint160`|The sqrt(price) of the pool as a Q64.96|
|`tick`|`int24`|The current tick after the state of a pool is initialized|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|


### _afterInitialize


```solidity
function _afterInitialize(address, PoolKey calldata, uint160, int24) internal virtual returns (bytes4);
```

### beforeAddLiquidity

The hook called before liquidity is added


```solidity
function beforeAddLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata hookData
) external onlyPoolManager returns (bytes4);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the add liquidity call|
|`key`|`PoolKey`|The key for the pool|
|`params`|`IPoolManager.ModifyLiquidityParams`|The parameters for adding liquidity|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|


### _beforeAddLiquidity


```solidity
function _beforeAddLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)
    internal
    virtual
    returns (bytes4);
```

### beforeRemoveLiquidity

The hook called before liquidity is removed


```solidity
function beforeRemoveLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata hookData
) external onlyPoolManager returns (bytes4);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the remove liquidity call|
|`key`|`PoolKey`|The key for the pool|
|`params`|`IPoolManager.ModifyLiquidityParams`|The parameters for removing liquidity|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|


### _beforeRemoveLiquidity


```solidity
function _beforeRemoveLiquidity(address, PoolKey calldata, IPoolManager.ModifyLiquidityParams calldata, bytes calldata)
    internal
    virtual
    returns (bytes4);
```

### afterAddLiquidity

The hook called after liquidity is added


```solidity
function afterAddLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    BalanceDelta delta,
    BalanceDelta feesAccrued,
    bytes calldata hookData
) external onlyPoolManager returns (bytes4, BalanceDelta);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the add liquidity call|
|`key`|`PoolKey`|The key for the pool|
|`params`|`IPoolManager.ModifyLiquidityParams`|The parameters for adding liquidity|
|`delta`|`BalanceDelta`|The caller's balance delta after adding liquidity; the sum of principal delta, fees accrued, and hook delta|
|`feesAccrued`|`BalanceDelta`|The fees accrued since the last time fees were collected from this position|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|
|`<none>`|`BalanceDelta`|BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency|


### _afterAddLiquidity


```solidity
function _afterAddLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata
) internal virtual returns (bytes4, BalanceDelta);
```

### afterRemoveLiquidity

The hook called after liquidity is removed


```solidity
function afterRemoveLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    BalanceDelta delta,
    BalanceDelta feesAccrued,
    bytes calldata hookData
) external onlyPoolManager returns (bytes4, BalanceDelta);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the remove liquidity call|
|`key`|`PoolKey`|The key for the pool|
|`params`|`IPoolManager.ModifyLiquidityParams`|The parameters for removing liquidity|
|`delta`|`BalanceDelta`|The caller's balance delta after removing liquidity; the sum of principal delta, fees accrued, and hook delta|
|`feesAccrued`|`BalanceDelta`|The fees accrued since the last time fees were collected from this position|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|
|`<none>`|`BalanceDelta`|BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency|


### _afterRemoveLiquidity


```solidity
function _afterRemoveLiquidity(
    address,
    PoolKey calldata,
    IPoolManager.ModifyLiquidityParams calldata,
    BalanceDelta,
    BalanceDelta,
    bytes calldata
) internal virtual returns (bytes4, BalanceDelta);
```

### beforeSwap

The hook called before a swap


```solidity
function beforeSwap(
    address sender,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    bytes calldata hookData
) external onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the swap call|
|`key`|`PoolKey`|The key for the pool|
|`params`|`IPoolManager.SwapParams`|The parameters for the swap|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|
|`<none>`|`BeforeSwapDelta`|BeforeSwapDelta The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency|
|`<none>`|`uint24`|uint24 Optionally override the lp fee, only used if three conditions are met: 1. the Pool has a dynamic fee, 2. the value's 2nd highest bit is set (23rd bit, 0x400000), and 3. the value is less than or equal to the maximum fee (1 million)|


### _beforeSwap


```solidity
function _beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)
    internal
    virtual
    returns (bytes4, BeforeSwapDelta, uint24);
```

### afterSwap

The hook called after a swap


```solidity
function afterSwap(
    address sender,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    BalanceDelta delta,
    bytes calldata hookData
) external onlyPoolManager returns (bytes4, int128);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the swap call|
|`key`|`PoolKey`|The key for the pool|
|`params`|`IPoolManager.SwapParams`|The parameters for the swap|
|`delta`|`BalanceDelta`|The amount owed to the caller (positive) or owed to the pool (negative)|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|
|`<none>`|`int128`|int128 The hook's delta in unspecified currency. Positive: the hook is owed/took currency, negative: the hook owes/sent currency|


### _afterSwap


```solidity
function _afterSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)
    internal
    virtual
    returns (bytes4, int128);
```

### beforeDonate

The hook called before donate


```solidity
function beforeDonate(address sender, PoolKey calldata key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    onlyPoolManager
    returns (bytes4);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the donate call|
|`key`|`PoolKey`|The key for the pool|
|`amount0`|`uint256`|The amount of token0 being donated|
|`amount1`|`uint256`|The amount of token1 being donated|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|


### _beforeDonate


```solidity
function _beforeDonate(address, PoolKey calldata, uint256, uint256, bytes calldata) internal virtual returns (bytes4);
```

### afterDonate

The hook called after donate


```solidity
function afterDonate(address sender, PoolKey calldata key, uint256 amount0, uint256 amount1, bytes calldata hookData)
    external
    onlyPoolManager
    returns (bytes4);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`sender`|`address`|The initial msg.sender for the donate call|
|`key`|`PoolKey`|The key for the pool|
|`amount0`|`uint256`|The amount of token0 being donated|
|`amount1`|`uint256`|The amount of token1 being donated|
|`hookData`|`bytes`|Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bytes4`|bytes4 The function selector for the hook|


### _afterDonate


```solidity
function _afterDonate(address, PoolKey calldata, uint256, uint256, bytes calldata) internal virtual returns (bytes4);
```

## Errors
### HookNotImplemented

```solidity
error HookNotImplemented();
```
</file>

<file path="docs/contracts/v4/reference/periphery/_category_.json">
{
  "label": "Periphery",
  "position": 2,
  "collapsed": true
}
</file>

<file path="docs/contracts/v4/reference/periphery/PositionDescriptor.md">
# PositionDescriptor
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/PositionDescriptor.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IPositionDescriptor](contracts/v4/reference/periphery/interfaces/IPositionDescriptor.md)

Produces a string containing the data URI for a JSON metadata string


## State Variables
### DAI

```solidity
address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
```


### USDC

```solidity
address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
```


### USDT

```solidity
address private constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
```


### TBTC

```solidity
address private constant TBTC = 0x8dAEBADE922dF735c38C80C7eBD708Af50815fAa;
```


### WBTC

```solidity
address private constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
```


### wrappedNative

```solidity
address public immutable wrappedNative;
```


### nativeCurrencyLabelBytes

```solidity
bytes32 private immutable nativeCurrencyLabelBytes;
```


### poolManager

```solidity
IPoolManager public immutable poolManager;
```


## Functions
### constructor


```solidity
constructor(IPoolManager _poolManager, address _wrappedNative, bytes32 _nativeCurrencyLabelBytes);
```

### nativeCurrencyLabel

Returns the native currency label as a string


```solidity
function nativeCurrencyLabel() public view returns (string memory);
```

### tokenURI

Produces the URI describing a particular token ID

*Note this URI may be a data: URI with the JSON contents directly inlined*


```solidity
function tokenURI(IPositionManager positionManager, uint256 tokenId) external view override returns (string memory);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`positionManager`|`IPositionManager`|The position manager for which to describe the token|
|`tokenId`|`uint256`|The ID of the token for which to produce a description, which may not be valid|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`string`|The URI of the ERC721-compliant metadata|


### flipRatio

Returns true if currency0 has higher priority than currency1


```solidity
function flipRatio(address currency0, address currency1) public view returns (bool);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency0`|`address`|The first currency address|
|`currency1`|`address`|The second currency address|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`bool`|True if currency0 has higher priority than currency1|


### currencyRatioPriority

Returns the priority of a currency.
For certain currencies on mainnet, the smaller the currency, the higher the priority
And those with the higher priority values (more positive values) will be in the numerator of the price ratio


```solidity
function currencyRatioPriority(address currency) public view returns (int256);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`currency`|`address`|The currency address|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`<none>`|`int256`|The priority of the currency|
</file>

<file path="docs/contracts/v4/reference/periphery/PositionManager.md">
# PositionManager
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/PositionManager.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IPositionManager](contracts/v4/reference/periphery/interfaces/IPositionManager.md), [ERC721Permit_v4](contracts/v4/reference/periphery/base/ERC721Permit_v4.md), [PoolInitializer_v4](contracts/v4/reference/periphery/base/PoolInitializer_v4.md), [Multicall_v4](contracts/v4/reference/periphery/base/Multicall_v4.md), [DeltaResolver](contracts/v4/reference/periphery/base/DeltaResolver.md), [ReentrancyLock](contracts/v4/reference/periphery/base/ReentrancyLock.md), [BaseActionsRouter](contracts/v4/reference/periphery/base/BaseActionsRouter.md), [Notifier](contracts/v4/reference/periphery/base/Notifier.md), [Permit2Forwarder](contracts/v4/reference/periphery/base/Permit2Forwarder.md), [NativeWrapper](contracts/v4/reference/periphery/base/NativeWrapper.md)

The PositionManager (PosM) contract is responsible for creating liquidity positions on v4.
PosM mints and manages ERC721 tokens associated with each position.


## State Variables
### nextTokenId
Used to get the ID that will be used for the next minted liquidity position

*The ID of the next token that will be minted. Skips 0*


```solidity
uint256 public nextTokenId = 1;
```


### tokenDescriptor

```solidity
IPositionDescriptor public immutable tokenDescriptor;
```


### positionInfo

```solidity
mapping(uint256 tokenId => PositionInfo info) public positionInfo;
```


### poolKeys

```solidity
mapping(bytes25 poolId => PoolKey poolKey) public poolKeys;
```


## Functions
### constructor


```solidity
constructor(
    IPoolManager _poolManager,
    IAllowanceTransfer _permit2,
    uint256 _unsubscribeGasLimit,
    IPositionDescriptor _tokenDescriptor,
    IWETH9 _weth9
)
    BaseActionsRouter(_poolManager)
    Permit2Forwarder(_permit2)
    ERC721Permit_v4("Uniswap v4 Positions NFT", "UNI-V4-POSM")
    Notifier(_unsubscribeGasLimit)
    NativeWrapper(_weth9);
```

### checkDeadline

Reverts if the deadline has passed


```solidity
modifier checkDeadline(uint256 deadline);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`deadline`|`uint256`|The timestamp at which the call is no longer valid, passed in by the caller|


### onlyIfApproved

Reverts if the caller is not the owner or approved for the ERC721 token

*either msg.sender or msgSender() is passed in as the caller
msgSender() should ONLY be used if this is called from within the unlockCallback, unless the codepath has reentrancy protection*


```solidity
modifier onlyIfApproved(address caller, uint256 tokenId) override;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`caller`|`address`|The address of the caller|
|`tokenId`|`uint256`|the unique identifier of the ERC721 token|


### onlyIfPoolManagerLocked

Enforces that the PoolManager is locked.


```solidity
modifier onlyIfPoolManagerLocked() override;
```

### tokenURI


```solidity
function tokenURI(uint256 tokenId) public view override returns (string memory);
```

### modifyLiquidities

Unlocks Uniswap v4 PoolManager and batches actions for modifying liquidity

*This is the standard entrypoint for the PositionManager*


```solidity
function modifyLiquidities(bytes calldata unlockData, uint256 deadline)
    external
    payable
    isNotLocked
    checkDeadline(deadline);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`unlockData`|`bytes`|is an encoding of actions, and parameters for those actions|
|`deadline`|`uint256`|is the deadline for the batched actions to be executed|


### modifyLiquiditiesWithoutUnlock

Batches actions for modifying liquidity without unlocking v4 PoolManager

*This must be called by a contract that has already unlocked the v4 PoolManager*


```solidity
function modifyLiquiditiesWithoutUnlock(bytes calldata actions, bytes[] calldata params) external payable isNotLocked;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`actions`|`bytes`|the actions to perform|
|`params`|`bytes[]`|the parameters to provide for the actions|


### msgSender

function that returns address considered executor of the actions

*The other context functions, _msgData and _msgValue, are not supported by this contract
In many contracts this will be the address that calls the initial entry point that calls `_executeActions`
`msg.sender` shouldn't be used, as this will be the v4 pool manager contract that calls `unlockCallback`
If using ReentrancyLock.sol, this function can return _getLocker()*


```solidity
function msgSender() public view override returns (address);
```

### _handleAction


```solidity
function _handleAction(uint256 action, bytes calldata params) internal virtual override;
```

### _increase

*Calling increase with 0 liquidity will credit the caller with any underlying fees of the position*


```solidity
function _increase(uint256 tokenId, uint256 liquidity, uint128 amount0Max, uint128 amount1Max, bytes calldata hookData)
    internal
    onlyIfApproved(msgSender(), tokenId);
```

### _increaseFromDeltas

*The liquidity delta is derived from open deltas in the pool manager.*


```solidity
function _increaseFromDeltas(uint256 tokenId, uint128 amount0Max, uint128 amount1Max, bytes calldata hookData)
    internal
    onlyIfApproved(msgSender(), tokenId);
```

### _decrease

*Calling decrease with 0 liquidity will credit the caller with any underlying fees of the position*


```solidity
function _decrease(uint256 tokenId, uint256 liquidity, uint128 amount0Min, uint128 amount1Min, bytes calldata hookData)
    internal
    onlyIfApproved(msgSender(), tokenId);
```

### _mint


```solidity
function _mint(
    PoolKey calldata poolKey,
    int24 tickLower,
    int24 tickUpper,
    uint256 liquidity,
    uint128 amount0Max,
    uint128 amount1Max,
    address owner,
    bytes calldata hookData
) internal;
```

### _mintFromDeltas


```solidity
function _mintFromDeltas(
    PoolKey calldata poolKey,
    int24 tickLower,
    int24 tickUpper,
    uint128 amount0Max,
    uint128 amount1Max,
    address owner,
    bytes calldata hookData
) internal;
```

### _burn

*this is overloaded with ERC721Permit_v4._burn*


```solidity
function _burn(uint256 tokenId, uint128 amount0Min, uint128 amount1Min, bytes calldata hookData)
    internal
    onlyIfApproved(msgSender(), tokenId);
```

### _settlePair


```solidity
function _settlePair(Currency currency0, Currency currency1) internal;
```

### _takePair


```solidity
function _takePair(Currency currency0, Currency currency1, address recipient) internal;
```

### _close


```solidity
function _close(Currency currency) internal;
```

### _clearOrTake

*integrators may elect to forfeit positive deltas with clear
if the forfeit amount exceeds the user-specified max, the amount is taken instead
if there is no credit, no call is made.*


```solidity
function _clearOrTake(Currency currency, uint256 amountMax) internal;
```

### _sweep

Sweeps the entire contract balance of specified currency to the recipient


```solidity
function _sweep(Currency currency, address to) internal;
```

### _modifyLiquidity

*if there is a subscriber attached to the position, this function will notify the subscriber*


```solidity
function _modifyLiquidity(
    PositionInfo info,
    PoolKey memory poolKey,
    int256 liquidityChange,
    bytes32 salt,
    bytes calldata hookData
) internal returns (BalanceDelta liquidityDelta, BalanceDelta feesAccrued);
```

### _pay


```solidity
function _pay(Currency currency, address payer, uint256 amount) internal override;
```

### _setSubscribed

an internal helper used by Notifier


```solidity
function _setSubscribed(uint256 tokenId) internal override;
```

### _setUnsubscribed

an internal helper used by Notifier


```solidity
function _setUnsubscribed(uint256 tokenId) internal override;
```

### transferFrom

*overrides solmate transferFrom in case a notification to subscribers is needed*

*will revert if pool manager is locked*


```solidity
function transferFrom(address from, address to, uint256 id) public virtual override onlyIfPoolManagerLocked;
```

### getPoolAndPositionInfo

Returns the pool key and position info of a position


```solidity
function getPoolAndPositionInfo(uint256 tokenId) public view returns (PoolKey memory poolKey, PositionInfo info);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|the ERC721 tokenId|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`poolKey`|`PoolKey`|the pool key of the position|
|`info`|`PositionInfo`|a uint256 packed value holding information about the position including the range (tickLower, tickUpper)|


### getPositionLiquidity

Returns the liquidity of a position

*this value can be processed as an amount0 and amount1 by using the LiquidityAmounts library*


```solidity
function getPositionLiquidity(uint256 tokenId) external view returns (uint128 liquidity);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`tokenId`|`uint256`|the ERC721 tokenId|

**Returns**

|Name|Type|Description|
|----|----|-----------|
|`liquidity`|`uint128`|the position's liquidity, as a liquidityAmount|


### _getLiquidity


```solidity
function _getLiquidity(uint256 tokenId, PoolKey memory poolKey, int24 tickLower, int24 tickUpper)
    internal
    view
    returns (uint128 liquidity);
```
</file>

<file path="docs/contracts/v4/reference/periphery/UniswapV4DeployerCompetition.md">
# UniswapV4DeployerCompetition
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/UniswapV4DeployerCompetition.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IUniswapV4DeployerCompetition](contracts/v4/reference/periphery/interfaces/IUniswapV4DeployerCompetition.md)

A contract to crowdsource a salt for the best Uniswap V4 address


## State Variables
### bestAddressSalt
*The salt for the best address found so far*


```solidity
bytes32 public bestAddressSalt;
```


### bestAddressSubmitter
*The submitter of the best address found so far*


```solidity
address public bestAddressSubmitter;
```


### competitionDeadline
*The deadline for the competition*


```solidity
uint256 public immutable competitionDeadline;
```


### initCodeHash
*The init code hash of the V4 contract*


```solidity
bytes32 public immutable initCodeHash;
```


### deployer
*The deployer who can initiate the deployment of the v4 PoolManager, until the exclusive deploy deadline.*

*After this deadline anyone can deploy.*


```solidity
address public immutable deployer;
```


### exclusiveDeployDeadline
*The deadline for exclusive deployment by deployer after deadline*


```solidity
uint256 public immutable exclusiveDeployDeadline;
```


## Functions
### constructor


```solidity
constructor(
    bytes32 _initCodeHash,
    uint256 _competitionDeadline,
    address _exclusiveDeployer,
    uint256 _exclusiveDeployLength
);
```

### updateBestAddress

Updates the best address if the new address has a better vanity score

*The first 20 bytes of the salt must be either address(0) or msg.sender*


```solidity
function updateBestAddress(bytes32 salt) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`salt`|`bytes32`|The salt to use to compute the new address with CREATE2|


### deploy

deploys the Uniswap v4 PoolManager contract

*The bytecode must match the initCodeHash*


```solidity
function deploy(bytes memory bytecode) external;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`bytecode`|`bytes`|The bytecode of the Uniswap v4 PoolManager contract|


### bestAddress

*returns the best address found so far*


```solidity
function bestAddress() public view returns (address);
```
</file>

<file path="docs/contracts/v4/reference/periphery/V4Router.md">
# V4Router
[Git Source](https://github.com/uniswap/v4-periphery/blob/ea2bf2e1ba6863bb809fc2ff791744f308c4a26d/src/V4Router.sol) - Generated with [forge doc](https://book.getfoundry.sh/reference/forge/forge-doc)

**Inherits:**
[IV4Router](contracts/v4/reference/periphery/interfaces/IV4Router.md), [BaseActionsRouter](contracts/v4/reference/periphery/base/BaseActionsRouter.md), [DeltaResolver](contracts/v4/reference/periphery/base/DeltaResolver.md)

Abstract contract that contains all internal logic needed for routing through Uniswap v4 pools

*the entry point to executing actions in this contract is calling `BaseActionsRouter._executeActions`
An inheriting contract should call _executeActions at the point that they wish actions to be executed*


## Functions
### constructor


```solidity
constructor(IPoolManager _poolManager) BaseActionsRouter(_poolManager);
```

### _handleAction


```solidity
function _handleAction(uint256 action, bytes calldata params) internal override;
```

### _swapExactInputSingle


```solidity
function _swapExactInputSingle(IV4Router.ExactInputSingleParams calldata params) private;
```

### _swapExactInput


```solidity
function _swapExactInput(IV4Router.ExactInputParams calldata params) private;
```

### _swapExactOutputSingle


```solidity
function _swapExactOutputSingle(IV4Router.ExactOutputSingleParams calldata params) private;
```

### _swapExactOutput


```solidity
function _swapExactOutput(IV4Router.ExactOutputParams calldata params) private;
```

### _swap


```solidity
function _swap(PoolKey memory poolKey, bool zeroForOne, int256 amountSpecified, bytes calldata hookData)
    private
    returns (int128 reciprocalAmount);
```
</file>

<file path="docs/contracts/v4/reference/_category_.json">
{
  "label": "Technical Reference",
  "position": 6,
  "collapsed": true
}
</file>

<file path="docs/contracts/v4/_category_.json">
{
  "label": "v4 Protocol",
  "position": 1,
  "collapsed": false
}
</file>

<file path="docs/contracts/v4/deployments.mdx">
---
id: deployments
title: Deployments
sidebar_position: 1.1
---

The Uniswap Protocol is made up of multiple contracts on many networks.

The latest version of `@uniswap/v4-core`, `@uniswap/v4-periphery`, and `@uniswap/universal-router` are deployed at the addresses listed below. Integrators should **no longer assume that they are deployed to the same addresses across chains** and be extremely careful to confirm mappings below.

## Mainnet Deployments

### Ethereum: 1
| Contract | Address |
|----------|---------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x000000000004444c5dc75cB358380D2e3dE08A90`](https://etherscan.io/address/0x000000000004444c5dc75cB358380D2e3dE08A90) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0xd1428ba554f4c8450b763a0b2040a4935c63f06c`](https://etherscan.io/address/0xd1428ba554f4c8450b763a0b2040a4935c63f06c) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0xbd216513d74c8cf14cf4747e6aaa6420ff64ee9e`](https://etherscan.io/address/0xbd216513d74c8cf14cf4747e6aaa6420ff64ee9e) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x52f0e24d1c21c8a0cb1e5a5dd6198556bd9e1203`](https://etherscan.io/address/0x52f0e24d1c21c8a0cb1e5a5dd6198556bd9e1203) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x7ffe42c4a5deea5b0fec41c94c136cf115597227`](https://etherscan.io/address/0x7ffe42c4a5deea5b0fec41c94c136cf115597227) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x66a9893cc07d91d95644aedd05d03f95e1dba8af`](https://etherscan.io/address/0x66a9893cc07d91d95644aedd05d03f95e1dba8af) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Unichain: 130
| Contract                                                                                               | Address                                                                                                               |
| ------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------- |
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol)                        | [`0x1f98400000000000000000000000000000000004`](https://uniscan.xyz/address/0x1f98400000000000000000000000000000000004) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol)     | [`0x9fb28449a191cd8c03a1b7abfb0f5996ecf7f722`](https://uniscan.xyz/address/0x9fb28449a191cd8c03a1b7abfb0f5996ecf7f722) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol)           | [`0x4529a01c7a0410167c5740c487a8de60232617bf`](https://uniscan.xyz/address/0x4529a01c7a0410167c5740c487a8de60232617bf) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol)                      | [`0x333e3c607b141b18ff6de9f258db6e77fe7491e0`](https://uniscan.xyz/address/0x333e3c607b141b18ff6de9f258db6e77fe7491e0) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol)                  | [`0x86e8631a016f9068c3f085faf484ee3f5fdee8f2`](https://uniscan.xyz/address/0x86e8631a016f9068c3f085faf484ee3f5fdee8f2) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0xef740bf23acae26f6492b10de645d6b98dc8eaf3`](https://uniscan.xyz/address/0xef740bf23acae26f6492b10de645d6b98dc8eaf3) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://uniscan.xyz/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Optimism: 10
| Contract | Address |
|----------|---------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x9a13f98cb987694c9f086b1f5eb990eea8264ec3`](https://optimistic.etherscan.io/address/0x9a13f98cb987694c9f086b1f5eb990eea8264ec3) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0xedd81496169c46df161b8513a52ffecaaaa66743`](https://optimistic.etherscan.io/address/0xedd81496169c46df161b8513a52ffecaaaa66743) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x3c3ea4b57a46241e54610e5f022e5c45859a1017`](https://optimistic.etherscan.io/address/0x3c3ea4b57a46241e54610e5f022e5c45859a1017) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x1f3131a13296fb91c90870043742c3cdbff1a8d7`](https://optimistic.etherscan.io/address/0x1f3131a13296fb91c90870043742c3cdbff1a8d7) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0xc18a3169788f4f75a170290584eca6395c75ecdb`](https://optimistic.etherscan.io/address/0xc18a3169788f4f75a170290584eca6395c75ecdb) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x851116d9223fabed8e56c0e6b8ad0c31d98b3507`](https://optimistic.etherscan.io/address/0x851116d9223fabed8e56c0e6b8ad0c31d98b3507) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://optimistic.etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Base: 8453
| Contract | Address |
|----------|---------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x498581ff718922c3f8e6a244956af099b2652b2b`](https://basescan.org/address/0x498581ff718922c3f8e6a244956af099b2652b2b) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x25d093633990dc94bedeed76c8f3cdaa75f3e7d5`](https://basescan.org/address/0x25d093633990dc94bedeed76c8f3cdaa75f3e7d5) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x7c5f5a4bbd8fd63184577525326123b519429bdc`](https://basescan.org/address/0x7c5f5a4bbd8fd63184577525326123b519429bdc) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x0d5e0f971ed27fbff6c2837bf31316121532048d`](https://basescan.org/address/0x0d5e0f971ed27fbff6c2837bf31316121532048d) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0xa3c0c9b65bad0b08107aa264b0f3db444b867a71`](https://basescan.org/address/0xa3c0c9b65bad0b08107aa264b0f3db444b867a71) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x6ff5693b99212da76ad316178a184ab56d299b43`](https://basescan.org/address/0x6ff5693b99212da76ad316178a184ab56d299b43) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://basescan.org/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Arbitrum One: 42161
| Contract | Address |
|----------|---------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x360e68faccca8ca495c1b759fd9eee466db9fb32`](https://arbiscan.io/address/0x360e68faccca8ca495c1b759fd9eee466db9fb32) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0xe2023f3fa515cf070e07fd9d51c1d236e07843f4`](https://arbiscan.io/address/0xe2023f3fa515cf070e07fd9d51c1d236e07843f4) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0xd88f38f930b7952f2db2432cb002e7abbf3dd869`](https://arbiscan.io/address/0xd88f38f930b7952f2db2432cb002e7abbf3dd869) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x3972c00f7ed4885e145823eb7c655375d275a1c5`](https://arbiscan.io/address/0x3972c00f7ed4885e145823eb7c655375d275a1c5) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x76fd297e2d437cd7f76d50f01afe6160f86e9990`](https://arbiscan.io/address/0x76fd297e2d437cd7f76d50f01afe6160f86e9990) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0xa51afafe0263b40edaef0df8781ea9aa03e381a3`](https://arbiscan.io/address/0xa51afafe0263b40edaef0df8781ea9aa03e381a3) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://arbiscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Polygon: 137
| Contract | Address |
|----------|---------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x67366782805870060151383f4bbff9dab53e5cd6`](https://polygonscan.com/address/0x67366782805870060151383f4bbff9dab53e5cd6) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x0892771f0c1b78ad6013d6e5536007e1c16e6794`](https://polygonscan.com/address/0x0892771f0c1b78ad6013d6e5536007e1c16e6794) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x1ec2ebf4f37e7363fdfe3551602425af0b3ceef9`](https://polygonscan.com/address/0x1ec2ebf4f37e7363fdfe3551602425af0b3ceef9) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0xb3d5c3dfc3a7aebff71895a7191796bffc2c81b9`](https://polygonscan.com/address/0xb3d5c3dfc3a7aebff71895a7191796bffc2c81b9) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x5ea1bd7974c8a611cbab0bdcafcb1d9cc9b3ba5a`](https://polygonscan.com/address/0x5ea1bd7974c8a611cbab0bdcafcb1d9cc9b3ba5a) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x1095692a6237d83c6a72f3f5efedb9a670c49223`](https://polygonscan.com/address/0x1095692a6237d83c6a72f3f5efedb9a670c49223) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://polygonscan.com/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Blast: 81457
| Contract | Address |
|----------|---------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x1631559198a9e474033433b2958dabc135ab6446`](https://blastscan.io/address/0x1631559198a9e474033433b2958dabc135ab6446) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x0747ad2b2e1f5761b1dcf0d8672bd1ffc3676f97`](https://blastscan.io/address/0x0747ad2b2e1f5761b1dcf0d8672bd1ffc3676f97) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x4ad2f4cca2682cbb5b950d660dd458a1d3f1baad`](https://blastscan.io/address/0x4ad2f4cca2682cbb5b950d660dd458a1d3f1baad) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x6f71cdcb0d119ff72c6eb501abceb576fbf62bcf`](https://blastscan.io/address/0x6f71cdcb0d119ff72c6eb501abceb576fbf62bcf) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x12a88ae16f46dce4e8b15368008ab3380885df30`](https://blastscan.io/address/0x12a88ae16f46dce4e8b15368008ab3380885df30) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0xeabbcb3e8e415306207ef514f660a3f820025be3`](https://blastscan.io/address/0xeabbcb3e8e415306207ef514f660a3f820025be3) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://blastscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Zora: 7777777
| Contract | Address |
|----------|---------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x0575338e4c17006ae181b47900a84404247ca30f`](https://explorer.zora.energy/address/0x0575338e4c17006ae181b47900a84404247ca30f) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x7d64630bbb4993b5578dbd65e400961c9e68d55a`](https://explorer.zora.energy/address/0x7d64630bbb4993b5578dbd65e400961c9e68d55a) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0xf66c7b99e2040f0d9b326b3b7c152e9663543d63`](https://explorer.zora.energy/address/0xf66c7b99e2040f0d9b326b3b7c152e9663543d63) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x5edaccc0660e0a2c44b06e07ce8b915e625dc2c6`](https://explorer.zora.energy/address/0x5edaccc0660e0a2c44b06e07ce8b915e625dc2c6) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x385785af07d63b50d0a0ea57c4ff89d06adf7328`](https://explorer.zora.energy/address/0x385785af07d63b50d0a0ea57c4ff89d06adf7328) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x3315ef7ca28db74abadc6c44570efdf06b04b020`](https://explorer.zora.energy/address/0x3315ef7ca28db74abadc6c44570efdf06b04b020) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://explorer.zora.energy/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Worldchain: 480
| Contract | Address |
|----------|---------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0xb1860d529182ac3bc1f51fa2abd56662b7d13f33`](https://worldscan.org/address/0xb1860d529182ac3bc1f51fa2abd56662b7d13f33) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x7da419153bd420b689f312363756d76836aeace4`](https://worldscan.org/address/0x7da419153bd420b689f312363756d76836aeace4) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0xc585e0f504613b5fbf874f21af14c65260fb41fa`](https://worldscan.org/address/0xc585e0f504613b5fbf874f21af14c65260fb41fa) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x55d235b3ff2daf7c3ede0defc9521f1d6fe6c5c0`](https://worldscan.org/address/0x55d235b3ff2daf7c3ede0defc9521f1d6fe6c5c0) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x51d394718bc09297262e368c1a481217fdeb71eb`](https://worldscan.org/address/0x51d394718bc09297262e368c1a481217fdeb71eb) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x8ac7bee993bb44dab564ea4bc9ea67bf9eb5e743`](https://worldscan.org/address/0x8ac7bee993bb44dab564ea4bc9ea67bf9eb5e743) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://worldscan.org/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Ink: 57073
| Contract | Address |
|----------|---------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x360e68faccca8ca495c1b759fd9eee466db9fb32`](https://explorer.inkonchain.com/address/0x360e68faccca8ca495c1b759fd9eee466db9fb32) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x42e3ccd9b7f67b5b2ee0c12074b84ccf2a8e7f36`](https://explorer.inkonchain.com/address/0x42e3ccd9b7f67b5b2ee0c12074b84ccf2a8e7f36) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x1b35d13a2e2528f192637f14b05f0dc0e7deb566`](https://explorer.inkonchain.com/address/0x1b35d13a2e2528f192637f14b05f0dc0e7deb566) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x3972c00f7ed4885e145823eb7c655375d275a1c5`](https://explorer.inkonchain.com/address/0x3972c00f7ed4885e145823eb7c655375d275a1c5) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x76fd297e2d437cd7f76d50f01afe6160f86e9990`](https://explorer.inkonchain.com/address/0x76fd297e2d437cd7f76d50f01afe6160f86e9990) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x112908dac86e20e7241b0927479ea3bf935d1fa0`](https://explorer.inkonchain.com/address/0x112908dac86e20e7241b0927479ea3bf935d1fa0) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://explorer.inkonchain.com/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Soneium: 1868
| Contract | Address |
|----------|---------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x360e68faccca8ca495c1b759fd9eee466db9fb32`](https://soneium.blockscout.com/address/0x360e68faccca8ca495c1b759fd9eee466db9fb32) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x42e3ccd9b7f67b5b2ee0c12074b84ccf2a8e7f36`](https://soneium.blockscout.com/address/0x42e3ccd9b7f67b5b2ee0c12074b84ccf2a8e7f36) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x1b35d13a2e2528f192637f14b05f0dc0e7deb566`](https://soneium.blockscout.com/address/0x1b35d13a2e2528f192637f14b05f0dc0e7deb566) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x3972c00f7ed4885e145823eb7c655375d275a1c5`](https://soneium.blockscout.com/address/0x3972c00f7ed4885e145823eb7c655375d275a1c5) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0x76fd297e2d437cd7f76d50f01afe6160f86e9990`](https://soneium.blockscout.com/address/0x76fd297e2d437cd7f76d50f01afe6160f86e9990) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x4cded7edf52c8aa5259a54ec6a3ce7c6d2a455df`](https://soneium.blockscout.com/address/0x4cded7edf52c8aa5259a54ec6a3ce7c6d2a455df) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://soneium.blockscout.com/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Avalanche: 43114
| Contract | Address |
|----------|---------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x06380c0e0912312b5150364b9dc4542ba0dbbc85`](https://snowscan.xyz/address/0x06380c0e0912312b5150364b9dc4542ba0dbbc85) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x2b1aed9445b05ac1a3b203eccc1e25dd9351f0a9`](https://snowscan.xyz/address/0x2b1aed9445b05ac1a3b203eccc1e25dd9351f0a9) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0xb74b1f14d2754acfcbbe1a221023a5cf50ab8acd`](https://snowscan.xyz/address/0xb74b1f14d2754acfcbbe1a221023a5cf50ab8acd) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0xbe40675bb704506a3c2ccfb762dcfd1e979845c2`](https://snowscan.xyz/address/0xbe40675bb704506a3c2ccfb762dcfd1e979845c2) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0xc3c9e198c735a4b97e3e683f391ccbdd60b69286`](https://snowscan.xyz/address/0xc3c9e198c735a4b97e3e683f391ccbdd60b69286) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x94b75331ae8d42c1b61065089b7d48fe14aa73b7`](https://snowscan.xyz/address/0x94b75331ae8d42c1b61065089b7d48fe14aa73b7) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://snowscan.xyz/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### BNB Smart Chain: 56
| Contract | Address |
|----------|---------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x28e2ea090877bf75740558f6bfb36a5ffee9e9df`](https://bscscan.com/address/0x28e2ea090877bf75740558f6bfb36a5ffee9e9df) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0xf0432f360703ec3d33931a8356a75a77d8d380e1`](https://bscscan.com/address/0xf0432f360703ec3d33931a8356a75a77d8d380e1) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0x7a4a5c919ae2541aed11041a1aeee68f1287f95b`](https://bscscan.com/address/0x7a4a5c919ae2541aed11041a1aeee68f1287f95b) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x9f75dd27d6664c475b90e105573e550ff69437b0`](https://bscscan.com/address/0x9f75dd27d6664c475b90e105573e550ff69437b0) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0xd13dd3d6e93f276fafc9db9e6bb47c1180aee0c4`](https://bscscan.com/address/0xd13dd3d6e93f276fafc9db9e6bb47c1180aee0c4) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0x1906c1d672b88cd1b9ac7593301ca990f94eae07`](https://bscscan.com/address/0x1906c1d672b88cd1b9ac7593301ca990f94eae07) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://bscscan.com/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

### Celo: 42220
| Contract | Address |
|----------|---------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol) | [`0x288dc841A52FCA2707c6947B3A777c5E56cd87BC`](https://celoscan.io/address/0x288dc841A52FCA2707c6947B3A777c5E56cd87BC) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol) | [`0x5727E22b25fEEe05E8dFa83C752B86F19D102D8A`](https://celoscan.io/address/0x5727E22b25fEEe05E8dFa83C752B86F19D102D8A) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol) | [`0xf7965f3981e4d5bc383bfbcb61501763e9068ca9`](https://celoscan.io/address/0xf7965f3981e4d5bc383bfbcb61501763e9068ca9) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol) | [`0x28566da1093609182dff2cb2a91cfd72e61d66cd`](https://celoscan.io/address/0x28566da1093609182dff2cb2a91cfd72e61d66cd) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol) | [`0xbc21f8720babf4b20d195ee5c6e99c52b76f2bfb`](https://celoscan.io/address/0xbc21f8720babf4b20d195ee5c6e99c52b76f2bfb) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol) | [`0xcb695bc5d3aa22cad1e6df07801b061a05a0233a`](https://celoscan.io/address/0xcb695bc5d3aa22cad1e6df07801b061a05a0233a) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://celoscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3) |

## Testnet Deployments

### Unichain Sepolia: 1301

| Contract                                                                                                     | Address                                                                                                                              |
|--------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol)                              | [`0x00b036b58a818b1bc34d502d3fe730db729e62ac`](https://sepolia.uniscan.xyz/address/0x00b036b58a818b1bc34d502d3fe730db729e62ac#code) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol)       | [`0xf70536b3bcc1bd1a972dc186a2cf84cc6da6be5d`](https://sepolia.uniscan.xyz/address/0xf70536b3bcc1bd1a972dc186a2cf84cc6da6be5d#code) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol)                 | [`0xf969aee60879c54baaed9f3ed26147db216fd664`](https://sepolia.uniscan.xyz/address/0xf969aee60879c54baaed9f3ed26147db216fd664#code) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol)                        | [`0xc199f1072a74d4e905aba1a84d9a45e2546b6222`](https://sepolia.uniscan.xyz/address/0xc199f1072a74d4e905aba1a84d9a45e2546b6222#code) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol)                              | [`0x56dcd40a3f2d466f48e7f48bdbe5cc9b92ae4472`](https://sepolia.uniscan.xyz/address/0x56dcd40a3f2d466f48e7f48bdbe5cc9b92ae4472#code) |
| [PoolSwapTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolSwapTest.sol)                       | [`0x9140a78c1a137c7ff1c151ec8231272af78a99a4`](https://sepolia.uniscan.xyz/address/0x9140a78c1a137c7ff1c151ec8231272af78a99a4#code) |
| [PoolModifyLiquidityTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolModifyLiquidityTest.sol) | [`0x5fa728c0a5cfd51bee4b060773f50554c0c8a7ab`](https://sepolia.uniscan.xyz/address/0x5fa728c0a5cfd51bee4b060773f50554c0c8a7ab#code) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://sepolia.uniscan.xyz/address/0x000000000022D473030F116dDEE9F6B43aC78BA3#code) |

### Sepolia: 11155111

| Contract                                                                                                     | Address                                                                                                                              |
|--------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol)                              | [`0xE03A1074c86CFeDd5C142C4F04F1a1536e203543`](https://sepolia.etherscan.io/address/0xE03A1074c86CFeDd5C142C4F04F1a1536e203543#code) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol)       | [`0x3A9D48AB9751398BbFa63ad67599Bb04e4BdF98b`](https://sepolia.etherscan.io/address/0x3A9D48AB9751398BbFa63ad67599Bb04e4BdF98b#code) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol)                 | [`0x429ba70129df741B2Ca2a85BC3A2a3328e5c09b4`](https://sepolia.etherscan.io/address/0x429ba70129df741B2Ca2a85BC3A2a3328e5c09b4#code) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol)                        | [`0xe1dd9c3fa50edb962e442f60dfbc432e24537e4c`](https://sepolia.etherscan.io/address/0xe1dd9c3fa50edb962e442f60dfbc432e24537e4c#code) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol)                              | [`0x61b3f2011a92d183c7dbadbda940a7555ccf9227`](https://sepolia.etherscan.io/address/0x61b3f2011a92d183c7dbadbda940a7555ccf9227#code) |
| [PoolSwapTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolSwapTest.sol)                       | [`0x9b6b46e2c869aa39918db7f52f5557fe577b6eee`](https://sepolia.etherscan.io/address/0x9b6b46e2c869aa39918db7f52f5557fe577b6eee#code) |
| [PoolModifyLiquidityTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolModifyLiquidityTest.sol) | [`0x0c478023803a644c94c4ce1c1e7b9a087e411b0a`](https://sepolia.etherscan.io/address/0x0c478023803a644c94c4ce1c1e7b9a087e411b0a#code) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://sepolia.etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3#code) |

### Base Sepolia: 84532

| Contract                                                                                                     | Address                                                                                                                              |
|--------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol)                              | [`0x05E73354cFDd6745C338b50BcFDfA3Aa6fA03408`](https://sepolia.basescan.org/address/0x05E73354cFDd6745C338b50BcFDfA3Aa6fA03408#code) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol)       | [`0x492e6456d9528771018deb9e87ef7750ef184104`](https://sepolia.basescan.org/address/0x492e6456d9528771018deb9e87ef7750ef184104#code) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol)                 | [`0x4b2c77d209d3405f41a037ec6c77f7f5b8e2ca80`](https://sepolia.basescan.org/address/0x4b2c77d209d3405f41a037ec6c77f7f5b8e2ca80#code) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol)                        | [`0x571291b572ed32ce6751a2cb2486ebee8defb9b4`](https://sepolia.basescan.org/address/0x571291b572ed32ce6751a2cb2486ebee8defb9b4#code) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol)                              | [`0x4a6513c898fe1b2d0e78d3b0e0a4a151589b1cba`](https://sepolia.basescan.org/address/0x4a6513c898fe1b2d0e78d3b0e0a4a151589b1cba#code) |
| [PoolSwapTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolSwapTest.sol)                       | [`0x8b5bcc363dde2614281ad875bad385e0a785d3b9`](https://sepolia.basescan.org/address/0x8b5bcc363dde2614281ad875bad385e0a785d3b9#code) |
| [PoolModifyLiquidityTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolModifyLiquidityTest.sol) | [`0x37429cd17cb1454c34e7f50b09725202fd533039`](https://sepolia.basescan.org/address/0x37429cd17cb1454c34e7f50b09725202fd533039#code) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://sepolia.basescan.org/address/0x000000000022D473030F116dDEE9F6B43aC78BA3#code) |

### Arbitrum Sepolia: 421614

| Contract                                                                                                     | Address                                                                                                                              |
|--------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol)                              | [`0xFB3e0C6F74eB1a21CC1Da29aeC80D2Dfe6C9a317`](https://sepolia.arbiscan.io/address/0xFB3e0C6F74eB1a21CC1Da29aeC80D2Dfe6C9a317#code) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol)       | [`0xefd1d4bd4cf1e86da286bb4cb1b8bced9c10ba47`](https://sepolia.arbiscan.io/address/0xefd1d4bd4cf1e86da286bb4cb1b8bced9c10ba47#code) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol)                 | [`0xAc631556d3d4019C95769033B5E719dD77124BAc`](https://sepolia.arbiscan.io/address/0xAc631556d3d4019C95769033B5E719dD77124BAc#code) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol)                        | [`0x9d467fa9062b6e9b1a46e26007ad82db116c67cb`](https://sepolia.arbiscan.io/address/0x9d467fa9062b6e9b1a46e26007ad82db116c67cb#code) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol)                              | [`0x7de51022d70a725b508085468052e25e22b5c4c9`](https://sepolia.arbiscan.io/address/0x7de51022d70a725b508085468052e25e22b5c4c9#code) |
| [PoolSwapTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolSwapTest.sol)                       | [`0xf3a39c86dbd13c45365e57fb90fe413371f65af8`](https://sepolia.arbiscan.io/address/0xf3a39c86dbd13c45365e57fb90fe413371f65af8#code) |
| [PoolModifyLiquidityTest](https://github.com/Uniswap/v4-core/blob/main/src/test/PoolModifyLiquidityTest.sol) | [`0x9a8ca723f5dccb7926d00b71dec55c2fea1f50f7`](https://sepolia.arbiscan.io/address/0x9a8ca723f5dccb7926d00b71dec55c2fea1f50f7#code) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://sepolia.arbiscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3#code) |

### interop-alpha-0: 420120000

| Contract                                                                                                     | Address                                                                                                                                                                     |
|--------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol)                              | [`0x9131B9084E6017Be19c6a0ef23f73dbB1Bf41f96`](https://optimism-interop-alpha-0.blockscout.com/address/0x9131B9084E6017Be19c6a0ef23f73dbB1Bf41f96?tab=contract_source_code) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol)       | [`0x4a5C956e6626c552c9e830beFDDf8F5e02bBf60a`](https://optimism-interop-alpha-0.blockscout.com/address/0x4a5C956e6626c552c9e830beFDDf8F5e02bBf60a?tab=contract_source_code) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol)                 | [`0x4498FE0b1DF6B476453440664A16E269B7587D0F`](https://optimism-interop-alpha-0.blockscout.com/address/0x4498FE0b1DF6B476453440664A16E269B7587D0F?tab=contract_source_code) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol)                        | [`0xF3c2E547e8da2052E2fC997ee94d54FbE59a6375`](https://optimism-interop-alpha-0.blockscout.com/address/0xF3c2E547e8da2052E2fC997ee94d54FbE59a6375?tab=contract_source_code) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol)                            | [`0x7C594D9B533ac43D3595dd4117549111Ec48F8B2`](https://optimism-interop-alpha-0.blockscout.com/address/0x7C594D9B533ac43D3595dd4117549111Ec48F8B2?tab=contract_source_code) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol)           | [`0x0ebb8526647744204cda2edb3f6bded2ec56403f`](https://optimism-interop-alpha-0.blockscout.com/address/0x0ebb8526647744204cda2edb3f6bded2ec56403f?tab=contract_source_code) |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/transparent/TransparentUpgradeableProxy.sol) | [`0x73162af50bf62750ff1b28c926e092b55022324d`](https://optimism-interop-alpha-0.blockscout.com/address/0x73162af50bf62750ff1b28c926e092b55022324d?tab=contract_source_code) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://optimism-interop-alpha-0.blockscout.com/address/0x000000000022D473030F116dDEE9F6B43aC78BA3?tab=contract_source_code) |

### interop-alpha-1: 420120001

| Contract                                                                                                     | Address                                                                                                                                                                     |
|--------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [PoolManager](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol)                              | [`0x9131B9084E6017Be19c6a0ef23f73dbB1Bf41f96`](https://optimism-interop-alpha-1.blockscout.com/address/0x9131B9084E6017Be19c6a0ef23f73dbB1Bf41f96?tab=contract_source_code) |
| [Universal Router](https://github.com/Uniswap/universal-router/blob/dev/contracts/UniversalRouter.sol)       | [`0x4a5C956e6626c552c9e830beFDDf8F5e02bBf60a`](https://optimism-interop-alpha-1.blockscout.com/address/0x4a5C956e6626c552c9e830beFDDf8F5e02bBf60a?tab=contract_source_code) |
| [PositionManager](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionManager.sol)                 | [`0x4498FE0b1DF6B476453440664A16E269B7587D0F`](https://optimism-interop-alpha-1.blockscout.com/address/0x4498FE0b1DF6B476453440664A16E269B7587D0F?tab=contract_source_code) |
| [StateView](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/StateView.sol)                        | [`0xF3c2E547e8da2052E2fC997ee94d54FbE59a6375`](https://optimism-interop-alpha-1.blockscout.com/address/0xF3c2E547e8da2052E2fC997ee94d54FbE59a6375?tab=contract_source_code) |
| [Quoter](https://github.com/Uniswap/v4-periphery/blob/main/src/lens/V4Quoter.sol)                            | [`0x7C594D9B533ac43D3595dd4117549111Ec48F8B2`](https://optimism-interop-alpha-1.blockscout.com/address/0x7C594D9B533ac43D3595dd4117549111Ec48F8B2?tab=contract_source_code) |
| [PositionDescriptor](https://github.com/Uniswap/v4-periphery/blob/main/src/PositionDescriptor.sol)           | [`0x0ebb8526647744204cda2edb3f6bded2ec56403f`](https://optimism-interop-alpha-1.blockscout.com/address/0x0ebb8526647744204cda2edb3f6bded2ec56403f?tab=contract_source_code) |
| [TransparentUpgradeableProxy](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/transparent/TransparentUpgradeableProxy.sol) | [`0x73162af50bf62750ff1b28c926e092b55022324d`](https://optimism-interop-alpha-1.blockscout.com/address/0x73162af50bf62750ff1b28c926e092b55022324d?tab=contract_source_code) |
| [Permit2](https://github.com/Uniswap/permit2) | [`0x000000000022D473030F116dDEE9F6B43aC78BA3`](https://optimism-interop-alpha-1.blockscout.com/address/0x000000000022D473030F116dDEE9F6B43aC78BA3?tab=contract_source_code) |
</file>

<file path="docs/contracts/v4/overview.mdx">
---
id: overview
title: Overview
sidebar_position: 1
pagination_next: contracts/v4/deployments
---

Uniswap v4 inherits all of the capital efficiency gains of Uniswap v3, but provides flexibility via *hooks* and gas optimizations across the entire lifecycle.

For additional information, see the [Uniswap v4 whitepaper](https://app.uniswap.org/whitepaper-v4.pdf)

## Hooks

Developers can attach solidity logic to the _swap lifecycle_ through Hooks. The logic is executed before and/or after major operations such as
pool creation, liquidity addition and removal, swapping, and donations. Hooks are deployed contracts, and are called by the Uniswap v4 PoolManager,
for permissionless execution.

The flexibility of hooks can enable: 
* Limit orders
* Custom oracles
* Fee management
* Automated liquidity management

## Dynamic Fees

Uniswap v4 supports dynamic fees, allowing pools to adjust their fees up or down. While other AMMs may have hard-coded logic for dynamic fees,
v4 provides no opinionated calculation of the fee. The frequency of *liquidity fee* updates is also flexible and determined by the developer. Fee updates can
occur on every swap, every block, or on an arbitrary schedule (weekly, monthly, yearly, etc).

Dynamic fees open up the design space for fee optimization, value redistribution, and research.


## Singleton Design

Architecturally, all pool state and operations are managed by a single contract -- `PoolManager.sol`. The singleton design provides major gas
savings. For example, creating a pool is now a state update instead of the deployment of a new contract. Swapping through multiple pools no longer requires
transferring tokens for intermediate pools.

## Flash Accounting

By leveraging EIP-1153 Transient Storage, v4 provides an optimization referred to as *flash accounting*. Swapping, liquidity modification, and donations
incur *balance changes*, i.e. tokens to be sent in and tokens to be taken out. With *flash accounting* these balance changes are efficiently recorded in transient storage and
netted against each other. This system allows users to only pay the final balance change, without the need for resolving intermediate balance changes.

## Native ETH

Uniswap v4 supports native token assets (Ether), without the need to wrap/unwrap the native token to Wrapped Ether (WETH9).

## Custom Accounting

The flexibility of custom accounting allows developers to alter token amounts for swaps and liquidity modifications. The feature opens up the design
space for hooks to charge fees or forgo the underlying concentrated liquidity model.

Example use-cases:
* Custom curves, opt-out of the concentrated liquidity curve in favor of an entirely independent pricing mechanism
* Hook swap fees, charge and collect fees on swaps
* Liquidity withdrawal fees, penalize and/or redistribute fee revenue
</file>

<file path="docs/llms/overview.md">
---
id: overview
sidebar_position: 1
title: Overview
---

# LLMs and AI Integration

Large Language Models (LLMs) and AI tools can help developers better understand and work with the Uniswap Protocol. This section provides resources and guidance for leveraging AI assistance when building on Uniswap.

## AI-Powered Documentation

The Uniswap documentation is designed to work seamlessly with modern AI tools to provide enhanced developer support and assistance.

### Getting AI Help

Use the built-in AI integration features throughout the documentation:

- **Copy to AI**: Use the dropdown button on any documentation page to quickly get AI assistance
- **Context-Aware**: AI tools receive relevant documentation context for better responses
- **Multiple Platforms**: Integrate with popular AI assistants like Claude and ChatGPT

## LLMs.txt

This documentation includes an [LLMs.txt file](/llms.txt) that provides comprehensive context about Uniswap for AI systems. This file helps ensure AI assistants can provide accurate and up-to-date information about:

- Protocol architecture and concepts
- Smart contract interfaces and functionality
- SDK usage and integration patterns
- Development best practices

## Best Practices for AI-Assisted Development

When using AI tools for Uniswap development:

1. **Provide Context**: Always include relevant protocol version (v2, v3, v4) in your queries
2. **Verify Code**: Always test and verify AI-generated code before deployment
3. **Reference Documentation**: Cross-check AI responses against official documentation
4. **Security First**: Have AI-generated smart contracts audited before production use

## Supported AI Platforms

The documentation provides optimized integration with:

- **Claude**: Advanced reasoning for complex DeFi concepts
- **ChatGPT**: Code generation and debugging assistance
- **Other LLMs**: Compatible with any AI tool that supports context injection

## Contributing AI Resources

Help improve AI assistance for the Uniswap community by:

- Reporting AI-generated errors or inaccuracies
- Suggesting improvements to the LLMs.txt context file
- Contributing examples of effective AI prompts for Uniswap development
</file>

<file path="docs/sdk/core/reference/classes/CurrencyAmount.md">
[@uniswap/sdk-core](../README.md) / [Exports](../modules.md) / CurrencyAmount

# Class: CurrencyAmount\<T\>

## Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends [`Currency`](../modules.md#currency) |

## Hierarchy

- [`Fraction`](Fraction.md)

  ↳ **`CurrencyAmount`**

## Table of contents

### Constructors

- [constructor](CurrencyAmount.md#constructor)

### Properties

- [currency](CurrencyAmount.md#currency)
- [decimalScale](CurrencyAmount.md#decimalscale)
- [denominator](CurrencyAmount.md#denominator)
- [numerator](CurrencyAmount.md#numerator)

### Accessors

- [asFraction](CurrencyAmount.md#asfraction)
- [quotient](CurrencyAmount.md#quotient)
- [remainder](CurrencyAmount.md#remainder)
- [wrapped](CurrencyAmount.md#wrapped)

### Methods

- [add](CurrencyAmount.md#add)
- [divide](CurrencyAmount.md#divide)
- [equalTo](CurrencyAmount.md#equalto)
- [greaterThan](CurrencyAmount.md#greaterthan)
- [invert](CurrencyAmount.md#invert)
- [lessThan](CurrencyAmount.md#lessthan)
- [multiply](CurrencyAmount.md#multiply)
- [subtract](CurrencyAmount.md#subtract)
- [toExact](CurrencyAmount.md#toexact)
- [toFixed](CurrencyAmount.md#tofixed)
- [toSignificant](CurrencyAmount.md#tosignificant)
- [fromFractionalAmount](CurrencyAmount.md#fromfractionalamount)
- [fromRawAmount](CurrencyAmount.md#fromrawamount)

## Constructors

### constructor

• `Protected` **new CurrencyAmount**\<`T`\>(`currency`, `numerator`, `denominator?`)

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends [`Currency`](../modules.md#currency) |

#### Parameters

| Name | Type |
| :------ | :------ |
| `currency` | `T` |
| `numerator` | [`BigintIsh`](../modules.md#bigintish) |
| `denominator?` | [`BigintIsh`](../modules.md#bigintish) |

#### Overrides

[Fraction](Fraction.md).[constructor](Fraction.md#constructor)

#### Defined in

[entities/fractions/currencyAmount.ts:40](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L40)

## Properties

### currency

• `Readonly` **currency**: `T`

#### Defined in

[entities/fractions/currencyAmount.ts:14](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L14)

___

### decimalScale

• `Readonly` **decimalScale**: `default`

#### Defined in

[entities/fractions/currencyAmount.ts:15](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L15)

___

### denominator

• `Readonly` **denominator**: `default`

#### Inherited from

[Fraction](Fraction.md).[denominator](Fraction.md#denominator)

#### Defined in

[entities/fractions/fraction.ts:26](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L26)

___

### numerator

• `Readonly` **numerator**: `default`

#### Inherited from

[Fraction](Fraction.md).[numerator](Fraction.md#numerator)

#### Defined in

[entities/fractions/fraction.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L25)

## Accessors

### asFraction

• `get` **asFraction**(): [`Fraction`](Fraction.md)

Helper method for converting any super class back to a fraction

#### Returns

[`Fraction`](Fraction.md)

#### Inherited from

Fraction.asFraction

#### Defined in

[entities/fractions/fraction.ts:154](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L154)

___

### quotient

• `get` **quotient**(): `default`

#### Returns

`default`

#### Inherited from

Fraction.quotient

#### Defined in

[entities/fractions/fraction.ts:42](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L42)

___

### remainder

• `get` **remainder**(): [`Fraction`](Fraction.md)

#### Returns

[`Fraction`](Fraction.md)

#### Inherited from

Fraction.remainder

#### Defined in

[entities/fractions/fraction.ts:47](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L47)

___

### wrapped

• `get` **wrapped**(): [`CurrencyAmount`](CurrencyAmount.md)\<[`Token`](Token.md)\>

#### Returns

[`CurrencyAmount`](CurrencyAmount.md)\<[`Token`](Token.md)\>

#### Defined in

[entities/fractions/currencyAmount.ts:91](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L91)

## Methods

### add

▸ **add**(`other`): [`CurrencyAmount`](CurrencyAmount.md)\<`T`\>

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`CurrencyAmount`](CurrencyAmount.md)\<`T`\> |

#### Returns

[`CurrencyAmount`](CurrencyAmount.md)\<`T`\>

#### Overrides

[Fraction](Fraction.md).[add](Fraction.md#add)

#### Defined in

[entities/fractions/currencyAmount.ts:47](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L47)

___

### divide

▸ **divide**(`other`): [`CurrencyAmount`](CurrencyAmount.md)\<`T`\>

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

[`CurrencyAmount`](CurrencyAmount.md)\<`T`\>

#### Overrides

[Fraction](Fraction.md).[divide](Fraction.md#divide)

#### Defined in

[entities/fractions/currencyAmount.ts:64](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L64)

___

### equalTo

▸ **equalTo**(`other`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

`boolean`

#### Inherited from

[Fraction](Fraction.md).[equalTo](Fraction.md#equalto)

#### Defined in

[entities/fractions/fraction.ts:91](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L91)

___

### greaterThan

▸ **greaterThan**(`other`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

`boolean`

#### Inherited from

[Fraction](Fraction.md).[greaterThan](Fraction.md#greaterthan)

#### Defined in

[entities/fractions/fraction.ts:99](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L99)

___

### invert

▸ **invert**(): [`Fraction`](Fraction.md)

#### Returns

[`Fraction`](Fraction.md)

#### Inherited from

[Fraction](Fraction.md).[invert](Fraction.md#invert)

#### Defined in

[entities/fractions/fraction.ts:51](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L51)

___

### lessThan

▸ **lessThan**(`other`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

`boolean`

#### Inherited from

[Fraction](Fraction.md).[lessThan](Fraction.md#lessthan)

#### Defined in

[entities/fractions/fraction.ts:83](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L83)

___

### multiply

▸ **multiply**(`other`): [`CurrencyAmount`](CurrencyAmount.md)\<`T`\>

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

[`CurrencyAmount`](CurrencyAmount.md)\<`T`\>

#### Overrides

[Fraction](Fraction.md).[multiply](Fraction.md#multiply)

#### Defined in

[entities/fractions/currencyAmount.ts:59](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L59)

___

### subtract

▸ **subtract**(`other`): [`CurrencyAmount`](CurrencyAmount.md)\<`T`\>

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`CurrencyAmount`](CurrencyAmount.md)\<`T`\> |

#### Returns

[`CurrencyAmount`](CurrencyAmount.md)\<`T`\>

#### Overrides

[Fraction](Fraction.md).[subtract](Fraction.md#subtract)

#### Defined in

[entities/fractions/currencyAmount.ts:53](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L53)

___

### toExact

▸ **toExact**(`format?`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `format` | `object` |

#### Returns

`string`

#### Defined in

[entities/fractions/currencyAmount.ts:86](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L86)

___

### toFixed

▸ **toFixed**(`decimalPlaces?`, `format?`, `rounding?`): `string`

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `decimalPlaces` | `number` | `undefined` |
| `format?` | `object` | `undefined` |
| `rounding` | [`Rounding`](../enums/Rounding.md) | `Rounding.ROUND_DOWN` |

#### Returns

`string`

#### Overrides

[Fraction](Fraction.md).[toFixed](Fraction.md#tofixed)

#### Defined in

[entities/fractions/currencyAmount.ts:77](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L77)

___

### toSignificant

▸ **toSignificant**(`significantDigits?`, `format?`, `rounding?`): `string`

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `significantDigits` | `number` | `6` |
| `format?` | `object` | `undefined` |
| `rounding` | [`Rounding`](../enums/Rounding.md) | `Rounding.ROUND_DOWN` |

#### Returns

`string`

#### Overrides

[Fraction](Fraction.md).[toSignificant](Fraction.md#tosignificant)

#### Defined in

[entities/fractions/currencyAmount.ts:69](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L69)

___

### fromFractionalAmount

▸ `Static` **fromFractionalAmount**\<`T`\>(`currency`, `numerator`, `denominator`): [`CurrencyAmount`](CurrencyAmount.md)\<`T`\>

Construct a currency amount with a denominator that is not equal to 1

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends [`Currency`](../modules.md#currency) |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `currency` | `T` | the currency |
| `numerator` | [`BigintIsh`](../modules.md#bigintish) | the numerator of the fractional token amount |
| `denominator` | [`BigintIsh`](../modules.md#bigintish) | the denominator of the fractional token amount |

#### Returns

[`CurrencyAmount`](CurrencyAmount.md)\<`T`\>

#### Defined in

[entities/fractions/currencyAmount.ts:32](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L32)

___

### fromRawAmount

▸ `Static` **fromRawAmount**\<`T`\>(`currency`, `rawAmount`): [`CurrencyAmount`](CurrencyAmount.md)\<`T`\>

Returns a new currency amount instance from the unitless amount of token, i.e. the raw amount

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends [`Currency`](../modules.md#currency) |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `currency` | `T` | the currency in the amount |
| `rawAmount` | [`BigintIsh`](../modules.md#bigintish) | the raw token or ether amount |

#### Returns

[`CurrencyAmount`](CurrencyAmount.md)\<`T`\>

#### Defined in

[entities/fractions/currencyAmount.ts:22](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/currencyAmount.ts#L22)
</file>

<file path="docs/sdk/core/reference/classes/Ether.md">
[@uniswap/sdk-core](../README.md) / [Exports](../modules.md) / Ether

# Class: Ether

Ether is the main usage of a 'native' currency, i.e. for Ethereum mainnet and all testnets

## Hierarchy

- [`NativeCurrency`](NativeCurrency.md)

  ↳ **`Ether`**

## Table of contents

### Constructors

- [constructor](Ether.md#constructor)

### Properties

- [chainId](Ether.md#chainid)
- [decimals](Ether.md#decimals)
- [isNative](Ether.md#isnative)
- [isToken](Ether.md#istoken)
- [name](Ether.md#name)
- [symbol](Ether.md#symbol)
- [\_etherCache](Ether.md#_ethercache)

### Accessors

- [wrapped](Ether.md#wrapped)

### Methods

- [equals](Ether.md#equals)
- [onChain](Ether.md#onchain)

## Constructors

### constructor

• `Protected` **new Ether**(`chainId`)

#### Parameters

| Name | Type |
| :------ | :------ |
| `chainId` | `number` |

#### Overrides

[NativeCurrency](NativeCurrency.md).[constructor](NativeCurrency.md#constructor)

#### Defined in

[entities/ether.ts:11](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/ether.ts#L11)

## Properties

### chainId

• `Readonly` **chainId**: `number`

The chain ID on which this currency resides

#### Inherited from

[NativeCurrency](NativeCurrency.md).[chainId](NativeCurrency.md#chainid)

#### Defined in

[entities/baseCurrency.ts:21](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L21)

___

### decimals

• `Readonly` **decimals**: `number`

The decimals used in representing currency amounts

#### Inherited from

[NativeCurrency](NativeCurrency.md).[decimals](NativeCurrency.md#decimals)

#### Defined in

[entities/baseCurrency.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L25)

___

### isNative

• `Readonly` **isNative**: ``true``

#### Inherited from

[NativeCurrency](NativeCurrency.md).[isNative](NativeCurrency.md#isnative)

#### Defined in

[entities/nativeCurrency.ts:7](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/nativeCurrency.ts#L7)

___

### isToken

• `Readonly` **isToken**: ``false``

#### Inherited from

[NativeCurrency](NativeCurrency.md).[isToken](NativeCurrency.md#istoken)

#### Defined in

[entities/nativeCurrency.ts:8](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/nativeCurrency.ts#L8)

___

### name

• `Optional` `Readonly` **name**: `string`

The name of the currency, i.e. a descriptive textual non-unique identifier

#### Inherited from

[NativeCurrency](NativeCurrency.md).[name](NativeCurrency.md#name)

#### Defined in

[entities/baseCurrency.ts:33](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L33)

___

### symbol

• `Optional` `Readonly` **symbol**: `string`

The symbol of the currency, i.e. a short textual non-unique identifier

#### Inherited from

[NativeCurrency](NativeCurrency.md).[symbol](NativeCurrency.md#symbol)

#### Defined in

[entities/baseCurrency.ts:29](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L29)

___

### \_etherCache

▪ `Static` `Private` **\_etherCache**: `Object` = `{}`

#### Index signature

▪ [chainId: `number`]: [`Ether`](Ether.md)

#### Defined in

[entities/ether.ts:21](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/ether.ts#L21)

## Accessors

### wrapped

• `get` **wrapped**(): [`Token`](Token.md)

Return the wrapped version of this currency that can be used with the Uniswap contracts. Currencies must
implement this to be used in Uniswap

#### Returns

[`Token`](Token.md)

#### Overrides

NativeCurrency.wrapped

#### Defined in

[entities/ether.ts:15](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/ether.ts#L15)

## Methods

### equals

▸ **equals**(`other`): `boolean`

Returns whether this currency is functionally equivalent to the other currency

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `other` | [`Currency`](../modules.md#currency) | the other currency |

#### Returns

`boolean`

#### Overrides

[NativeCurrency](NativeCurrency.md).[equals](NativeCurrency.md#equals)

#### Defined in

[entities/ether.ts:27](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/ether.ts#L27)

___

### onChain

▸ `Static` **onChain**(`chainId`): [`Ether`](Ether.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `chainId` | `number` |

#### Returns

[`Ether`](Ether.md)

#### Defined in

[entities/ether.ts:23](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/ether.ts#L23)
</file>

<file path="docs/sdk/core/reference/classes/Fraction.md">
[@uniswap/sdk-core](../README.md) / [Exports](../modules.md) / Fraction

# Class: Fraction

## Hierarchy

- **`Fraction`**

  ↳ [`CurrencyAmount`](CurrencyAmount.md)

  ↳ [`Percent`](Percent.md)

  ↳ [`Price`](Price.md)

## Table of contents

### Constructors

- [constructor](Fraction.md#constructor)

### Properties

- [denominator](Fraction.md#denominator)
- [numerator](Fraction.md#numerator)

### Accessors

- [asFraction](Fraction.md#asfraction)
- [quotient](Fraction.md#quotient)
- [remainder](Fraction.md#remainder)

### Methods

- [add](Fraction.md#add)
- [divide](Fraction.md#divide)
- [equalTo](Fraction.md#equalto)
- [greaterThan](Fraction.md#greaterthan)
- [invert](Fraction.md#invert)
- [lessThan](Fraction.md#lessthan)
- [multiply](Fraction.md#multiply)
- [subtract](Fraction.md#subtract)
- [toFixed](Fraction.md#tofixed)
- [toSignificant](Fraction.md#tosignificant)
- [tryParseFraction](Fraction.md#tryparsefraction)

## Constructors

### constructor

• **new Fraction**(`numerator`, `denominator?`)

#### Parameters

| Name | Type |
| :------ | :------ |
| `numerator` | [`BigintIsh`](../modules.md#bigintish) |
| `denominator` | [`BigintIsh`](../modules.md#bigintish) |

#### Defined in

[entities/fractions/fraction.ts:28](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L28)

## Properties

### denominator

• `Readonly` **denominator**: `default`

#### Defined in

[entities/fractions/fraction.ts:26](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L26)

___

### numerator

• `Readonly` **numerator**: `default`

#### Defined in

[entities/fractions/fraction.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L25)

## Accessors

### asFraction

• `get` **asFraction**(): [`Fraction`](Fraction.md)

Helper method for converting any super class back to a fraction

#### Returns

[`Fraction`](Fraction.md)

#### Defined in

[entities/fractions/fraction.ts:154](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L154)

___

### quotient

• `get` **quotient**(): `default`

#### Returns

`default`

#### Defined in

[entities/fractions/fraction.ts:42](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L42)

___

### remainder

• `get` **remainder**(): [`Fraction`](Fraction.md)

#### Returns

[`Fraction`](Fraction.md)

#### Defined in

[entities/fractions/fraction.ts:47](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L47)

## Methods

### add

▸ **add**(`other`): [`Fraction`](Fraction.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

[`Fraction`](Fraction.md)

#### Defined in

[entities/fractions/fraction.ts:55](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L55)

___

### divide

▸ **divide**(`other`): [`Fraction`](Fraction.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

[`Fraction`](Fraction.md)

#### Defined in

[entities/fractions/fraction.ts:115](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L115)

___

### equalTo

▸ **equalTo**(`other`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

`boolean`

#### Defined in

[entities/fractions/fraction.ts:91](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L91)

___

### greaterThan

▸ **greaterThan**(`other`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

`boolean`

#### Defined in

[entities/fractions/fraction.ts:99](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L99)

___

### invert

▸ **invert**(): [`Fraction`](Fraction.md)

#### Returns

[`Fraction`](Fraction.md)

#### Defined in

[entities/fractions/fraction.ts:51](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L51)

___

### lessThan

▸ **lessThan**(`other`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

`boolean`

#### Defined in

[entities/fractions/fraction.ts:83](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L83)

___

### multiply

▸ **multiply**(`other`): [`Fraction`](Fraction.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

[`Fraction`](Fraction.md)

#### Defined in

[entities/fractions/fraction.ts:107](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L107)

___

### subtract

▸ **subtract**(`other`): [`Fraction`](Fraction.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

[`Fraction`](Fraction.md)

#### Defined in

[entities/fractions/fraction.ts:69](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L69)

___

### toFixed

▸ **toFixed**(`decimalPlaces`, `format?`, `rounding?`): `string`

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `decimalPlaces` | `number` | `undefined` |
| `format` | `object` | `undefined` |
| `rounding` | [`Rounding`](../enums/Rounding.md) | `Rounding.ROUND_HALF_UP` |

#### Returns

`string`

#### Defined in

[entities/fractions/fraction.ts:138](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L138)

___

### toSignificant

▸ **toSignificant**(`significantDigits`, `format?`, `rounding?`): `string`

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `significantDigits` | `number` | `undefined` |
| `format` | `object` | `undefined` |
| `rounding` | [`Rounding`](../enums/Rounding.md) | `Rounding.ROUND_HALF_UP` |

#### Returns

`string`

#### Defined in

[entities/fractions/fraction.ts:123](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L123)

___

### tryParseFraction

▸ `Static` `Private` **tryParseFraction**(`fractionish`): [`Fraction`](Fraction.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `fractionish` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

[`Fraction`](Fraction.md)

#### Defined in

[entities/fractions/fraction.ts:33](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L33)
</file>

<file path="docs/sdk/core/reference/classes/NativeCurrency.md">
[@uniswap/sdk-core](../README.md) / [Exports](../modules.md) / NativeCurrency

# Class: NativeCurrency

Represents the native currency of the chain on which it resides, e.g.

## Hierarchy

- `BaseCurrency`

  ↳ **`NativeCurrency`**

  ↳↳ [`Ether`](Ether.md)

## Table of contents

### Constructors

- [constructor](NativeCurrency.md#constructor)

### Properties

- [chainId](NativeCurrency.md#chainid)
- [decimals](NativeCurrency.md#decimals)
- [isNative](NativeCurrency.md#isnative)
- [isToken](NativeCurrency.md#istoken)
- [name](NativeCurrency.md#name)
- [symbol](NativeCurrency.md#symbol)

### Accessors

- [wrapped](NativeCurrency.md#wrapped)

### Methods

- [equals](NativeCurrency.md#equals)

## Constructors

### constructor

• `Protected` **new NativeCurrency**(`chainId`, `decimals`, `symbol?`, `name?`)

Constructs an instance of the base class `BaseCurrency`.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `chainId` | `number` | the chain ID on which this currency resides |
| `decimals` | `number` | decimals of the currency |
| `symbol?` | `string` | symbol of the currency |
| `name?` | `string` | of the currency |

#### Inherited from

BaseCurrency.constructor

#### Defined in

[entities/baseCurrency.ts:42](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L42)

## Properties

### chainId

• `Readonly` **chainId**: `number`

The chain ID on which this currency resides

#### Inherited from

BaseCurrency.chainId

#### Defined in

[entities/baseCurrency.ts:21](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L21)

___

### decimals

• `Readonly` **decimals**: `number`

The decimals used in representing currency amounts

#### Inherited from

BaseCurrency.decimals

#### Defined in

[entities/baseCurrency.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L25)

___

### isNative

• `Readonly` **isNative**: ``true``

#### Overrides

BaseCurrency.isNative

#### Defined in

[entities/nativeCurrency.ts:7](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/nativeCurrency.ts#L7)

___

### isToken

• `Readonly` **isToken**: ``false``

#### Overrides

BaseCurrency.isToken

#### Defined in

[entities/nativeCurrency.ts:8](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/nativeCurrency.ts#L8)

___

### name

• `Optional` `Readonly` **name**: `string`

The name of the currency, i.e. a descriptive textual non-unique identifier

#### Inherited from

BaseCurrency.name

#### Defined in

[entities/baseCurrency.ts:33](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L33)

___

### symbol

• `Optional` `Readonly` **symbol**: `string`

The symbol of the currency, i.e. a short textual non-unique identifier

#### Inherited from

BaseCurrency.symbol

#### Defined in

[entities/baseCurrency.ts:29](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L29)

## Accessors

### wrapped

• `Abstract` `get` **wrapped**(): [`Token`](Token.md)

Return the wrapped version of this currency that can be used with the Uniswap contracts. Currencies must
implement this to be used in Uniswap

#### Returns

[`Token`](Token.md)

#### Inherited from

BaseCurrency.wrapped

#### Defined in

[entities/baseCurrency.ts:62](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L62)

## Methods

### equals

▸ `Abstract` **equals**(`other`): `boolean`

Returns whether this currency is functionally equivalent to the other currency

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `other` | [`Currency`](../modules.md#currency) | the other currency |

#### Returns

`boolean`

#### Inherited from

BaseCurrency.equals

#### Defined in

[entities/baseCurrency.ts:56](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L56)
</file>

<file path="docs/sdk/core/reference/classes/Percent.md">
[@uniswap/sdk-core](../README.md) / [Exports](../modules.md) / Percent

# Class: Percent

## Hierarchy

- [`Fraction`](Fraction.md)

  ↳ **`Percent`**

## Table of contents

### Constructors

- [constructor](Percent.md#constructor)

### Properties

- [denominator](Percent.md#denominator)
- [isPercent](Percent.md#ispercent)
- [numerator](Percent.md#numerator)

### Accessors

- [asFraction](Percent.md#asfraction)
- [quotient](Percent.md#quotient)
- [remainder](Percent.md#remainder)

### Methods

- [add](Percent.md#add)
- [divide](Percent.md#divide)
- [equalTo](Percent.md#equalto)
- [greaterThan](Percent.md#greaterthan)
- [invert](Percent.md#invert)
- [lessThan](Percent.md#lessthan)
- [multiply](Percent.md#multiply)
- [subtract](Percent.md#subtract)
- [toFixed](Percent.md#tofixed)
- [toSignificant](Percent.md#tosignificant)

## Constructors

### constructor

• **new Percent**(`numerator`, `denominator?`)

#### Parameters

| Name | Type |
| :------ | :------ |
| `numerator` | [`BigintIsh`](../modules.md#bigintish) |
| `denominator` | [`BigintIsh`](../modules.md#bigintish) |

#### Inherited from

[Fraction](Fraction.md).[constructor](Fraction.md#constructor)

#### Defined in

[entities/fractions/fraction.ts:28](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L28)

## Properties

### denominator

• `Readonly` **denominator**: `default`

#### Inherited from

[Fraction](Fraction.md).[denominator](Fraction.md#denominator)

#### Defined in

[entities/fractions/fraction.ts:26](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L26)

___

### isPercent

• `Readonly` **isPercent**: ``true``

This boolean prevents a fraction from being interpreted as a Percent

#### Defined in

[entities/fractions/percent.ts:19](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/percent.ts#L19)

___

### numerator

• `Readonly` **numerator**: `default`

#### Inherited from

[Fraction](Fraction.md).[numerator](Fraction.md#numerator)

#### Defined in

[entities/fractions/fraction.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L25)

## Accessors

### asFraction

• `get` **asFraction**(): [`Fraction`](Fraction.md)

Helper method for converting any super class back to a fraction

#### Returns

[`Fraction`](Fraction.md)

#### Inherited from

Fraction.asFraction

#### Defined in

[entities/fractions/fraction.ts:154](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L154)

___

### quotient

• `get` **quotient**(): `default`

#### Returns

`default`

#### Inherited from

Fraction.quotient

#### Defined in

[entities/fractions/fraction.ts:42](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L42)

___

### remainder

• `get` **remainder**(): [`Fraction`](Fraction.md)

#### Returns

[`Fraction`](Fraction.md)

#### Inherited from

Fraction.remainder

#### Defined in

[entities/fractions/fraction.ts:47](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L47)

## Methods

### add

▸ **add**(`other`): [`Percent`](Percent.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

[`Percent`](Percent.md)

#### Overrides

[Fraction](Fraction.md).[add](Fraction.md#add)

#### Defined in

[entities/fractions/percent.ts:21](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/percent.ts#L21)

___

### divide

▸ **divide**(`other`): [`Percent`](Percent.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

[`Percent`](Percent.md)

#### Overrides

[Fraction](Fraction.md).[divide](Fraction.md#divide)

#### Defined in

[entities/fractions/percent.ts:33](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/percent.ts#L33)

___

### equalTo

▸ **equalTo**(`other`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

`boolean`

#### Inherited from

[Fraction](Fraction.md).[equalTo](Fraction.md#equalto)

#### Defined in

[entities/fractions/fraction.ts:91](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L91)

___

### greaterThan

▸ **greaterThan**(`other`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

`boolean`

#### Inherited from

[Fraction](Fraction.md).[greaterThan](Fraction.md#greaterthan)

#### Defined in

[entities/fractions/fraction.ts:99](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L99)

___

### invert

▸ **invert**(): [`Fraction`](Fraction.md)

#### Returns

[`Fraction`](Fraction.md)

#### Inherited from

[Fraction](Fraction.md).[invert](Fraction.md#invert)

#### Defined in

[entities/fractions/fraction.ts:51](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L51)

___

### lessThan

▸ **lessThan**(`other`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

`boolean`

#### Inherited from

[Fraction](Fraction.md).[lessThan](Fraction.md#lessthan)

#### Defined in

[entities/fractions/fraction.ts:83](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L83)

___

### multiply

▸ **multiply**(`other`): [`Percent`](Percent.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

[`Percent`](Percent.md)

#### Overrides

[Fraction](Fraction.md).[multiply](Fraction.md#multiply)

#### Defined in

[entities/fractions/percent.ts:29](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/percent.ts#L29)

___

### subtract

▸ **subtract**(`other`): [`Percent`](Percent.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

[`Percent`](Percent.md)

#### Overrides

[Fraction](Fraction.md).[subtract](Fraction.md#subtract)

#### Defined in

[entities/fractions/percent.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/percent.ts#L25)

___

### toFixed

▸ **toFixed**(`decimalPlaces?`, `format?`, `rounding?`): `string`

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `decimalPlaces` | `number` | `2` |
| `format?` | `object` | `undefined` |
| `rounding?` | [`Rounding`](../enums/Rounding.md) | `undefined` |

#### Returns

`string`

#### Overrides

[Fraction](Fraction.md).[toFixed](Fraction.md#tofixed)

#### Defined in

[entities/fractions/percent.ts:41](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/percent.ts#L41)

___

### toSignificant

▸ **toSignificant**(`significantDigits?`, `format?`, `rounding?`): `string`

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `significantDigits` | `number` | `5` |
| `format?` | `object` | `undefined` |
| `rounding?` | [`Rounding`](../enums/Rounding.md) | `undefined` |

#### Returns

`string`

#### Overrides

[Fraction](Fraction.md).[toSignificant](Fraction.md#tosignificant)

#### Defined in

[entities/fractions/percent.ts:37](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/percent.ts#L37)
</file>

<file path="docs/sdk/core/reference/classes/Price.md">
[@uniswap/sdk-core](../README.md) / [Exports](../modules.md) / Price

# Class: Price\<TBase, TQuote\>

## Type parameters

| Name | Type |
| :------ | :------ |
| `TBase` | extends [`Currency`](../modules.md#currency) |
| `TQuote` | extends [`Currency`](../modules.md#currency) |

## Hierarchy

- [`Fraction`](Fraction.md)

  ↳ **`Price`**

## Table of contents

### Constructors

- [constructor](Price.md#constructor)

### Properties

- [baseCurrency](Price.md#basecurrency)
- [denominator](Price.md#denominator)
- [numerator](Price.md#numerator)
- [quoteCurrency](Price.md#quotecurrency)
- [scalar](Price.md#scalar)

### Accessors

- [adjustedForDecimals](Price.md#adjustedfordecimals)
- [asFraction](Price.md#asfraction)
- [quotient](Price.md#quotient)
- [remainder](Price.md#remainder)

### Methods

- [add](Price.md#add)
- [divide](Price.md#divide)
- [equalTo](Price.md#equalto)
- [greaterThan](Price.md#greaterthan)
- [invert](Price.md#invert)
- [lessThan](Price.md#lessthan)
- [multiply](Price.md#multiply)
- [quote](Price.md#quote)
- [subtract](Price.md#subtract)
- [toFixed](Price.md#tofixed)
- [toSignificant](Price.md#tosignificant)

## Constructors

### constructor

• **new Price**\<`TBase`, `TQuote`\>(...`args`)

Construct a price, either with the base and quote currency amount, or the

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TBase` | extends [`Currency`](../modules.md#currency) |
| `TQuote` | extends [`Currency`](../modules.md#currency) |

#### Parameters

| Name | Type |
| :------ | :------ |
| `...args` | [`TBase`, `TQuote`, [`BigintIsh`](../modules.md#bigintish), [`BigintIsh`](../modules.md#bigintish)] \| [\{ `baseAmount`: [`CurrencyAmount`](CurrencyAmount.md)\<`TBase`\> ; `quoteAmount`: [`CurrencyAmount`](CurrencyAmount.md)\<`TQuote`\>  \}] |

#### Overrides

[Fraction](Fraction.md).[constructor](Fraction.md#constructor)

#### Defined in

[entities/fractions/price.ts:18](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L18)

## Properties

### baseCurrency

• `Readonly` **baseCurrency**: `TBase`

#### Defined in

[entities/fractions/price.ts:10](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L10)

___

### denominator

• `Readonly` **denominator**: `default`

#### Inherited from

[Fraction](Fraction.md).[denominator](Fraction.md#denominator)

#### Defined in

[entities/fractions/fraction.ts:26](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L26)

___

### numerator

• `Readonly` **numerator**: `default`

#### Inherited from

[Fraction](Fraction.md).[numerator](Fraction.md#numerator)

#### Defined in

[entities/fractions/fraction.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L25)

___

### quoteCurrency

• `Readonly` **quoteCurrency**: `TQuote`

#### Defined in

[entities/fractions/price.ts:11](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L11)

___

### scalar

• `Readonly` **scalar**: [`Fraction`](Fraction.md)

#### Defined in

[entities/fractions/price.ts:12](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L12)

## Accessors

### adjustedForDecimals

• `Private` `get` **adjustedForDecimals**(): [`Fraction`](Fraction.md)

Get the value scaled by decimals for formatting

#### Returns

[`Fraction`](Fraction.md)

#### Defined in

[entities/fractions/price.ts:77](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L77)

___

### asFraction

• `get` **asFraction**(): [`Fraction`](Fraction.md)

Helper method for converting any super class back to a fraction

#### Returns

[`Fraction`](Fraction.md)

#### Inherited from

Fraction.asFraction

#### Defined in

[entities/fractions/fraction.ts:154](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L154)

___

### quotient

• `get` **quotient**(): `default`

#### Returns

`default`

#### Inherited from

Fraction.quotient

#### Defined in

[entities/fractions/fraction.ts:42](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L42)

___

### remainder

• `get` **remainder**(): [`Fraction`](Fraction.md)

#### Returns

[`Fraction`](Fraction.md)

#### Inherited from

Fraction.remainder

#### Defined in

[entities/fractions/fraction.ts:47](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L47)

## Methods

### add

▸ **add**(`other`): [`Fraction`](Fraction.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

[`Fraction`](Fraction.md)

#### Inherited from

[Fraction](Fraction.md).[add](Fraction.md#add)

#### Defined in

[entities/fractions/fraction.ts:55](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L55)

___

### divide

▸ **divide**(`other`): [`Fraction`](Fraction.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

[`Fraction`](Fraction.md)

#### Inherited from

[Fraction](Fraction.md).[divide](Fraction.md#divide)

#### Defined in

[entities/fractions/fraction.ts:115](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L115)

___

### equalTo

▸ **equalTo**(`other`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

`boolean`

#### Inherited from

[Fraction](Fraction.md).[equalTo](Fraction.md#equalto)

#### Defined in

[entities/fractions/fraction.ts:91](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L91)

___

### greaterThan

▸ **greaterThan**(`other`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

`boolean`

#### Inherited from

[Fraction](Fraction.md).[greaterThan](Fraction.md#greaterthan)

#### Defined in

[entities/fractions/fraction.ts:99](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L99)

___

### invert

▸ **invert**(): [`Price`](Price.md)\<`TQuote`, `TBase`\>

Flip the price, switching the base and quote currency

#### Returns

[`Price`](Price.md)\<`TQuote`, `TBase`\>

#### Overrides

[Fraction](Fraction.md).[invert](Fraction.md#invert)

#### Defined in

[entities/fractions/price.ts:49](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L49)

___

### lessThan

▸ **lessThan**(`other`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

`boolean`

#### Inherited from

[Fraction](Fraction.md).[lessThan](Fraction.md#lessthan)

#### Defined in

[entities/fractions/fraction.ts:83](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L83)

___

### multiply

▸ **multiply**\<`TOtherQuote`\>(`other`): [`Price`](Price.md)\<`TBase`, `TOtherQuote`\>

Multiply the price by another price, returning a new price. The other price must have the same base currency as this price's quote currency

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TOtherQuote` | extends [`Currency`](../modules.md#currency) |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `other` | [`Price`](Price.md)\<`TQuote`, `TOtherQuote`\> | the other price |

#### Returns

[`Price`](Price.md)\<`TBase`, `TOtherQuote`\>

#### Overrides

[Fraction](Fraction.md).[multiply](Fraction.md#multiply)

#### Defined in

[entities/fractions/price.ts:57](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L57)

___

### quote

▸ **quote**(`currencyAmount`): [`CurrencyAmount`](CurrencyAmount.md)\<`TQuote`\>

Return the amount of quote currency corresponding to a given amount of the base currency

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `currencyAmount` | [`CurrencyAmount`](CurrencyAmount.md)\<`TBase`\> | the amount of base currency to quote against the price |

#### Returns

[`CurrencyAmount`](CurrencyAmount.md)\<`TQuote`\>

#### Defined in

[entities/fractions/price.ts:67](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L67)

___

### subtract

▸ **subtract**(`other`): [`Fraction`](Fraction.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `other` | [`BigintIsh`](../modules.md#bigintish) \| [`Fraction`](Fraction.md) |

#### Returns

[`Fraction`](Fraction.md)

#### Inherited from

[Fraction](Fraction.md).[subtract](Fraction.md#subtract)

#### Defined in

[entities/fractions/fraction.ts:69](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/fraction.ts#L69)

___

### toFixed

▸ **toFixed**(`decimalPlaces?`, `format?`, `rounding?`): `string`

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `decimalPlaces` | `number` | `4` |
| `format?` | `object` | `undefined` |
| `rounding?` | [`Rounding`](../enums/Rounding.md) | `undefined` |

#### Returns

`string`

#### Overrides

[Fraction](Fraction.md).[toFixed](Fraction.md#tofixed)

#### Defined in

[entities/fractions/price.ts:85](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L85)

___

### toSignificant

▸ **toSignificant**(`significantDigits?`, `format?`, `rounding?`): `string`

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `significantDigits` | `number` | `6` |
| `format?` | `object` | `undefined` |
| `rounding?` | [`Rounding`](../enums/Rounding.md) | `undefined` |

#### Returns

`string`

#### Overrides

[Fraction](Fraction.md).[toSignificant](Fraction.md#tosignificant)

#### Defined in

[entities/fractions/price.ts:81](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/fractions/price.ts#L81)
</file>

<file path="docs/sdk/core/reference/classes/Token.md">
[@uniswap/sdk-core](../README.md) / [Exports](../modules.md) / Token

# Class: Token

Represents an ERC20 token with a unique address and some metadata.

## Hierarchy

- `BaseCurrency`

  ↳ **`Token`**

## Table of contents

### Constructors

- [constructor](Token.md#constructor)

### Properties

- [address](Token.md#address)
- [chainId](Token.md#chainid)
- [decimals](Token.md#decimals)
- [isNative](Token.md#isnative)
- [isToken](Token.md#istoken)
- [name](Token.md#name)
- [symbol](Token.md#symbol)

### Accessors

- [wrapped](Token.md#wrapped)

### Methods

- [equals](Token.md#equals)
- [sortsBefore](Token.md#sortsbefore)

## Constructors

### constructor

• **new Token**(`chainId`, `address`, `decimals`, `symbol?`, `name?`, `bypassChecksum?`)

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `chainId` | `number` | BaseCurrency#chainId |
| `address` | `string` | The contract address on the chain on which this token lives |
| `decimals` | `number` | BaseCurrency#decimals |
| `symbol?` | `string` | BaseCurrency#symbol |
| `name?` | `string` | BaseCurrency#name |
| `bypassChecksum?` | `boolean` | If true it only checks for length === 42, startsWith 0x and contains only hex characters |

#### Overrides

BaseCurrency.constructor

#### Defined in

[entities/token.ts:27](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/token.ts#L27)

## Properties

### address

• `Readonly` **address**: `string`

The contract address on the chain on which this token lives

#### Defined in

[entities/token.ts:16](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/token.ts#L16)

___

### chainId

• `Readonly` **chainId**: `number`

The chain ID on which this currency resides

#### Inherited from

BaseCurrency.chainId

#### Defined in

[entities/baseCurrency.ts:21](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L21)

___

### decimals

• `Readonly` **decimals**: `number`

The decimals used in representing currency amounts

#### Inherited from

BaseCurrency.decimals

#### Defined in

[entities/baseCurrency.ts:25](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L25)

___

### isNative

• `Readonly` **isNative**: ``false``

#### Overrides

BaseCurrency.isNative

#### Defined in

[entities/token.ts:10](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/token.ts#L10)

___

### isToken

• `Readonly` **isToken**: ``true``

#### Overrides

BaseCurrency.isToken

#### Defined in

[entities/token.ts:11](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/token.ts#L11)

___

### name

• `Optional` `Readonly` **name**: `string`

The name of the currency, i.e. a descriptive textual non-unique identifier

#### Inherited from

BaseCurrency.name

#### Defined in

[entities/baseCurrency.ts:33](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L33)

___

### symbol

• `Optional` `Readonly` **symbol**: `string`

The symbol of the currency, i.e. a short textual non-unique identifier

#### Inherited from

BaseCurrency.symbol

#### Defined in

[entities/baseCurrency.ts:29](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/baseCurrency.ts#L29)

## Accessors

### wrapped

• `get` **wrapped**(): [`Token`](Token.md)

Return this token, which does not need to be wrapped

#### Returns

[`Token`](Token.md)

#### Overrides

BaseCurrency.wrapped

#### Defined in

[entities/token.ts:66](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/token.ts#L66)

## Methods

### equals

▸ **equals**(`other`): `boolean`

Returns true if the two tokens are equivalent, i.e. have the same chainId and address.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `other` | [`Currency`](../modules.md#currency) | other token to compare |

#### Returns

`boolean`

#### Overrides

BaseCurrency.equals

#### Defined in

[entities/token.ts:47](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/token.ts#L47)

___

### sortsBefore

▸ **sortsBefore**(`other`): `boolean`

Returns true if the address of this token sorts before the address of the other token

**`Throws`**

if the tokens have the same address

**`Throws`**

if the tokens are on different chains

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `other` | [`Token`](Token.md) | other token to compare |

#### Returns

`boolean`

#### Defined in

[entities/token.ts:57](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/token.ts#L57)
</file>

<file path="docs/sdk/core/reference/enums/ChainId.md">
[@uniswap/sdk-core](../README.md) / Exports / ChainId

# Enumeration: ChainId

## Table of contents

### Enumeration Members

- [ARBITRUM\_ONE](ChainId.md#arbitrum_one)
- [ARBITRUM\_GOERLI](ChainId.md#arbitrum_goerli)
- [CELO](ChainId.md#celo)
- [CELO\_ALFAJORES](ChainId.md#celo_alfajores)
- [GOERLI](ChainId.md#goerli)
- [MAINNET](ChainId.md#mainnet)
- [OPTIMISM](ChainId.md#optimism)
- [OPTIMISM\_GOERLI](ChainId.md#optimism_goerli)
- [POLYGON](ChainId.md#polygon)
- [POLYGON\_MUMBAI](ChainId.md#polygon_mumbai)
- [SEPOLIA](ChainId.md#sepolia)
- [GNOSIS](ChainId.md#gnosis)
- [MOONBEAM](ChainId.md#moonbeam)
- [BNB](ChainId.md#bnb)
- [AVALANCHE](ChainId.md#avalanche)

## Enumeration Members

### ARBITRUM\_ONE

• **ARBITRUM\_ONE** = ``42161``

#### Defined in

[chains.ts:7](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L7)

___

### ARBITRUM\_GOERLI

• **ARBITRUM\_GOERLI** = ``421613``

#### Defined in

[chains.ts:8](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L8)

___

### CELO

• **CELO** = ``42220``

#### Defined in

[chains.ts:11](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L11)

___

### CELO\_ALFAJORES

• **CELO\_ALFAJORES** = ``44787``

#### Defined in

[chains.ts:12](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L12)

___

### GOERLI

• **GOERLI** = ``5``

#### Defined in

[chains.ts:3](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L3)

___

### MAINNET

• **MAINNET** = ``1``

#### Defined in

[chains.ts:2](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L2)

___

### OPTIMISM

• **OPTIMISM** = ``10``

#### Defined in

[chains.ts:5](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L5)

___

### OPTIMISM\_GOERLI

• **OPTIMISM\_GOERLI** = ``420``

#### Defined in

[chains.ts:6](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L6)

___

### POLYGON

• **POLYGON** = ``137``

#### Defined in

[chains.ts:9](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L9)

___

### POLYGON\_MUMBAI

• **POLYGON\_MUMBAI** = ``80001``

#### Defined in

[chains.ts:10](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L10)

___

### SEPOLIA

• **SEPOLIA** = ``11155111``

#### Defined in

[chains.ts:4](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L4)

___

### GNOSIS

• **GNOSIS** = ``100``

#### Defined in

[chains.ts:13](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L13)

___

### MOONBEAM

• **MOONBEAM** = ``1284``

#### Defined in

[chains.ts:14](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L14)

___

### BNB

• **BNB** = ``56``

#### Defined in

[chains.ts:15](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L15)

___

### AVALANCHE

• **AVALANCHE** = ``43114``

#### Defined in

[chains.ts:16](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L16)
</file>

<file path="docs/sdk/core/reference/enums/NativeCurrencyName.md">
[@uniswap/sdk-core](../README.md) / Exports / NativeCurrencyName

# Enumeration: NativeCurrencyName

## Table of Contents

### Enumeration Members

- [ETHER](NativeCurrencyName.md#ether)
- [MATIC](NativeCurrencyName.md#matic)
- [CELO](NativeCurrencyName.md#celo)
- [GNOSIS](NativeCurrencyName.md#gnosis)
- [MOONBEAM](NativeCurrencyName.md#moonbeam)
- [BNB](NativeCurrencyName.md#bnb)
- [AVAX](NativeCurrencyName.md#avax)

### ETHER

• **ETHER** = ``ETH``

#### Defined in

[chains.ts:38](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L38)

___

### MATIC

• **MATIC** = ``MATIC``

#### Defined in

[chains.ts:39](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L39)

___

### CELO

• **CELO** = ``CELO``

#### Defined in

[chains.ts:40](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L40)

___

### GNOSIS

• **GNOSIS** = ``XDAI``

#### Defined in

[chains.ts:41](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L41)

___

### MOONBEAM

• **MOONBEAM** = ``GLMR``

#### Defined in

[chains.ts:42](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L42)

___

### BNB

• **BNB** = ``BNB``

#### Defined in

[chains.ts:43](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L43)

___

### AVAX

• **AVAX** = ``AVAX``

#### Defined in

[chains.ts:44](https://github.com/Uniswap/sdk-core/blob/main/src/chains.ts#L44)
</file>

<file path="docs/sdk/core/reference/enums/Rounding.md">
[@uniswap/sdk-core](../README.md) / [Exports](../modules.md) / Rounding

# Enumeration: Rounding

## Table of contents

### Enumeration Members

- [ROUND\_DOWN](Rounding.md#round_down)
- [ROUND\_HALF\_UP](Rounding.md#round_half_up)
- [ROUND\_UP](Rounding.md#round_up)

## Enumeration Members

### ROUND\_DOWN

• **ROUND\_DOWN** = ``0``

#### Defined in

[constants.ts:32](https://github.com/Uniswap/sdk-core/blob/9997e88/src/constants.ts#L32)

___

### ROUND\_HALF\_UP

• **ROUND\_HALF\_UP** = ``1``

#### Defined in

[constants.ts:33](https://github.com/Uniswap/sdk-core/blob/9997e88/src/constants.ts#L33)

___

### ROUND\_UP

• **ROUND\_UP** = ``2``

#### Defined in

[constants.ts:34](https://github.com/Uniswap/sdk-core/blob/9997e88/src/constants.ts#L34)
</file>

<file path="docs/sdk/core/reference/enums/TradeType.md">
[@uniswap/sdk-core](../README.md) / [Exports](../modules.md) / TradeType

# Enumeration: TradeType

## Table of contents

### Enumeration Members

- [EXACT\_INPUT](TradeType.md#exact_input)
- [EXACT\_OUTPUT](TradeType.md#exact_output)

## Enumeration Members

### EXACT\_INPUT

• **EXACT\_INPUT** = ``0``

#### Defined in

[constants.ts:27](https://github.com/Uniswap/sdk-core/blob/9997e88/src/constants.ts#L27)

___

### EXACT\_OUTPUT

• **EXACT\_OUTPUT** = ``1``

#### Defined in

[constants.ts:28](https://github.com/Uniswap/sdk-core/blob/9997e88/src/constants.ts#L28)
</file>

<file path="docs/sdk/core/reference/_category_.json">
{
  "label": "Technical Reference",
  "position": 1,
  "collapsed": true
}
</file>

<file path="docs/sdk/core/reference/modules.md">
---
id: modules
title: Type Definitions
---

This page documents the core type definitions and interfaces used throughout the Uniswap SDK Core.

## Core Types

### Currency

Base interface for all currencies (tokens and native currencies).

```typescript
interface Currency {
  readonly isNative: boolean
  readonly isToken: boolean
  readonly chainId: number
  readonly decimals: number
  readonly symbol?: string
  readonly name?: string
}
```

### BigintIsh

Union type for values that can be converted to BigInt.

```typescript
type BigintIsh = JSBI | string | number
```

Used throughout the SDK for numeric inputs that need high precision.

## Utility Types

### TradeType

Enum for specifying trade direction:

```typescript
enum TradeType {
  EXACT_INPUT,
  EXACT_OUTPUT
}
```

### Rounding

Enum for mathematical rounding modes:

```typescript
enum Rounding {
  ROUND_DOWN,
  ROUND_HALF_UP,
  ROUND_UP
}
```

## Chain Support

### ChainId

Supported blockchain networks:

```typescript
enum ChainId {
  MAINNET = 1,
  GOERLI = 5,
  SEPOLIA = 11155111,
  OPTIMISM = 10,
  OPTIMISM_GOERLI = 420,
  ARBITRUM_ONE = 42161,
  ARBITRUM_GOERLI = 421613,
  POLYGON = 137,
  POLYGON_MUMBAI = 80001,
  CELO = 42220,
  CELO_ALFAJORES = 44787,
  GNOSIS = 100,
  MOONBEAM = 1284,
  BNB = 56,
  AVALANCHE = 43114,
  BASE_GOERLI = 84531,
  BASE = 8453
}
```

## Constants

Key constants used throughout the SDK:

- **`MaxUint256`** - Maximum uint256 value
- **`ZERO`** - BigInt zero value  
- **`ONE`** - BigInt one value
- **`TWO`** - BigInt two value
- **`THREE`** - BigInt three value

## Usage Examples

### Working with Currencies

```typescript
import { Token, Ether } from '@uniswap/sdk-core'

// Native ETH
const ETH = Ether.onChain(1)

// ERC-20 Token
const USDC = new Token(
  1, // chainId
  '0xA0b86a33E6417c29C8F6e3b6E4E12A82aA4Ca8e9', // address
  6, // decimals
  'USDC', // symbol
  'USD Coin' // name
)
```

### Working with Amounts

```typescript
import { CurrencyAmount } from '@uniswap/sdk-core'

const amount = CurrencyAmount.fromRawAmount(USDC, '1000000') // 1 USDC
const readable = amount.toSignificant(6) // "1.000000"
```

For more detailed usage, see the individual class documentation and the [SDK Guides](../../v3/guides/01-background.md).
</file>

<file path="docs/sdk/core/reference/overview.md">
---
id: overview
sidebar_position: 1
title: Overview
---

## Table of contents

### Enumerations

- [Rounding](enums/Rounding.md)
- [ChainId](enums/ChainId.md)
- [NativeCurrencyName](enums/NativeCurrencyName.md)
- [TradeType](enums/TradeType.md)

### Classes

- [CurrencyAmount](classes/CurrencyAmount.md)
- [Ether](classes/Ether.md)
- [Fraction](classes/Fraction.md)
- [NativeCurrency](classes/NativeCurrency.md)
- [Percent](classes/Percent.md)
- [Price](classes/Price.md)
- [Token](classes/Token.md)

### Type Aliases

- [BigintIsh](#bigintish)
- [Currency](#currency)

### Variables

- [MaxUint256](#maxuint256)
- [WETH9](#weth9)

### Functions

- [computePriceImpact](#computepriceimpact)
- [sortedInsert](#sortedinsert)
- [sqrt](#sqrt)
- [validateAndParseAddress](#validateandparseaddress)

## Type Aliases

### BigintIsh

Ƭ **BigintIsh**: `JSBI` \| `string` \| `number`

#### Defined in

[constants.ts:24](https://github.com/Uniswap/sdk-core/blob/9997e88/src/constants.ts#L24)

___

### Currency

Ƭ **Currency**: [`NativeCurrency`](classes/NativeCurrency.md) \| [`Token`](classes/Token.md)

#### Defined in

[entities/currency.ts:4](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/currency.ts#L4)

## Variables

### MaxUint256

• `Const` **MaxUint256**: `default`

#### Defined in

[constants.ts:37](https://github.com/Uniswap/sdk-core/blob/9997e88/src/constants.ts#L37)

___

### WETH9

• `Const` **WETH9**: `Object`

Known WETH9 implementation addresses, used in our implementation of Ether#wrapped

#### Index signature

▪ [chainId: `number`]: [`Token`](classes/Token.md)

#### Defined in

[entities/weth9.ts:6](https://github.com/Uniswap/sdk-core/blob/9997e88/src/entities/weth9.ts#L6)

## Functions

### computePriceImpact

▸ **computePriceImpact**\<`TBase`, `TQuote`\>(`midPrice`, `inputAmount`, `outputAmount`): [`Percent`](classes/Percent.md)

Returns the percent difference between the mid price and the execution price, i.e. price impact.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TBase` | extends [`Currency`](modules.md#currency) |
| `TQuote` | extends [`Currency`](modules.md#currency) |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `midPrice` | [`Price`](classes/Price.md)\<`TBase`, `TQuote`\> | mid price before the trade |
| `inputAmount` | [`CurrencyAmount`](classes/CurrencyAmount.md)\<`TBase`\> | the input amount of the trade |
| `outputAmount` | [`CurrencyAmount`](classes/CurrencyAmount.md)\<`TQuote`\> | the output amount of the trade |

#### Returns

[`Percent`](classes/Percent.md)

#### Defined in

[utils/computePriceImpact.ts:9](https://github.com/Uniswap/sdk-core/blob/9997e88/src/utils/computePriceImpact.ts#L9)

___

### sortedInsert

▸ **sortedInsert**\<`T`\>(`items`, `add`, `maxSize`, `comparator`): `T` \| ``null``

#### Type parameters

| Name |
| :------ |
| `T` |

#### Parameters

| Name | Type |
| :------ | :------ |
| `items` | `T`[] |
| `add` | `T` |
| `maxSize` | `number` |
| `comparator` | (`a`: `T`, `b`: `T`) => `number` |

#### Returns

`T` \| ``null``

#### Defined in

[utils/sortedInsert.ts:5](https://github.com/Uniswap/sdk-core/blob/9997e88/src/utils/sortedInsert.ts#L5)

___

### sqrt

▸ **sqrt**(`value`): `JSBI`

Computes floor(sqrt(value))

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `value` | `default` | the value for which to compute the square root, rounded down |

#### Returns

`JSBI`

#### Defined in

[utils/sqrt.ts:14](https://github.com/Uniswap/sdk-core/blob/9997e88/src/utils/sqrt.ts#L14)

___

### validateAndParseAddress

▸ **validateAndParseAddress**(`address`): `string`

Validates an address and returns the parsed (checksummed) version of that address

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `address` | `string` | the unchecksummed hex address |

#### Returns

`string`

#### Defined in

[utils/validateAndParseAddress.ts:7](https://github.com/Uniswap/sdk-core/blob/9997e88/src/utils/validateAndParseAddress.ts#L7)
</file>

<file path="docs/sdk/core/reference/README.md">
---
id: readme
title: SDK Core Reference
---

The Uniswap SDK Core provides the foundational classes and utilities for working with the Uniswap protocol. This package contains essential primitives like currencies, amounts, and mathematical utilities that are used across all Uniswap SDK packages.

## Overview

This reference documentation covers:

- **[Classes](./classes/overview)** - Core classes like `Token`, `CurrencyAmount`, `Fraction`, and `Price`
- **[Enums](./enums/ChainId)** - Supported chains, trade types, and other enumerations
- **[Types](./modules.md)** - TypeScript type definitions and interfaces

## Key Components

### Currency Primitives
- [`Currency`](./modules.md#currency) - Base currency interface
- [`Token`](./classes/Token.md) - ERC-20 token representation
- [`Ether`](./classes/Ether.md) - Native ETH currency
- [`CurrencyAmount`](./classes/CurrencyAmount.md) - Typed currency amounts

### Mathematical Utilities
- [`Fraction`](./classes/Fraction.md) - Precise fractional arithmetic
- [`Percent`](./classes/Percent.md) - Percentage calculations
- [`Price`](./classes/Price.md) - Exchange rates between currencies

### Chain Support
- [`ChainId`](./enums/ChainId.md) - Supported blockchain networks
- Network-specific configurations and constants

## Getting Started

```typescript
import { Token, CurrencyAmount, TradeType } from '@uniswap/sdk-core'

// Create a token
const USDC = new Token(1, '0xA0b86a33E6417c29C8F6e3b6E4E12A82aA4Ca8e9', 6, 'USDC', 'USD Coin')

// Create an amount
const amount = CurrencyAmount.fromRawAmount(USDC, '1000000') // 1 USDC
```

For practical integration examples, see the [SDK v3 Guides](../../v3/guides/01-background.md) and [SDK v4 Guides](../../v4/overview.md).
</file>

<file path="docs/sdk/core/_category_.json">
{
  "label": "Core SDK",
  "position": 5,
  "collapsed": true
}
</file>

<file path="docs/sdk/core/overview.md">
---
id: overview
sidebar_position: 1
title: Overview
---
## The Uniswap Core SDK

The Uniswap Core SDK provides abstractions for other SDKs to use in a Typescript/Javascript environment. It is used throughout the Uniswap SDKs, such as the [v3 SDK](../v3/overview.md).

This SDK is not expected to be used in isolation, but only as part of other SDKs.

We recommend taking a look at the [**Technical Reference**](./reference/overview).


## Resources

- [**SDK Core GitHub Repo**](https://github.com/Uniswap/sdk-core)
- [**Core SDK NPM Package**](https://www.npmjs.com/package/@uniswap/sdk-core)

[![Unit Tests](https://github.com/Uniswap/uniswap-sdk-core/workflows/Unit%20Tests/badge.svg)](https://github.com/Uniswap/uniswap-sdk-core/actions?query=workflow%3A%22Unit+Tests%22)
[![Lint](https://github.com/Uniswap/uniswap-sdk-core/workflows/Lint/badge.svg)](https://github.com/Uniswap/uniswap-sdk-core/actions?query=workflow%3ALint)
[![npm version](https://img.shields.io/npm/v/@uniswap/sdk-core/latest.svg)](https://www.npmjs.com/package/@uniswap/sdk-core/v/latest)
[![npm bundle size (scoped version)](https://img.shields.io/bundlephobia/minzip/@uniswap/sdk-core/latest.svg)](https://bundlephobia.com/result?p=@uniswap/sdk-core@latest)
[![Discord](https://img.shields.io/badge/discord-join%20chat-blue.svg)](https://discord.com/channels/597638925346930701/607978109089611786)
</file>

<file path="docs/sdk/v1/guides/_category_.json">
{
  "label": "Guides",
  "position": 2,
  "collapsed": false
}
</file>

<file path="docs/sdk/v1/guides/getting-started.md">
---
id: getting-started
title: Getting Started
sidebar_position: 1
---

The [Uniswap SDK](https://github.com/Uniswap/uniswap-sdk/tree/v1) is meant to simplify every aspect of integrating Uniswap into your project. It's written in [TypeScript](https://www.typescriptlang.org), has a [robust test suite](https://github.com/Uniswap/uniswap-sdk/tree/v1/src/__tests__), uses [bignumber.js](https://github.com/MikeMcl/bignumber.js) for math, and includes an optional data-fetching module which relies on [ethers.js](https://github.com/ethers-io/ethers.js/).

The SDK was built to be extremely easy to use, but also feature-rich. It offers various levels of abstraction that make it suitable for use nearly anywhere, from hackathon projects to production applications.

## Overview

The SDK is divided into several modular components that perform tightly scoped tasks:

- [Data](/sdk/1.0.0/reference/data) - Fetches Uniswap data from the blockchain
- [Computation](/sdk/1.0.0/reference/computation) - Computes market- and trade-specific statistics using blockchain data
- [Format](/sdk/1.0.0/reference/format) - Formats data for display
- [Orchestration](/sdk/1.0.0/reference/orchestration) - Offers named abstraction functions that seamlessly combine lower-level data- and computation-related functions
- [Transact](/sdk/1.0.0/reference/transact) - Prepares computed trades for execution against Uniswap smart contracts
- [Constants](/sdk/1.0.0/reference/constants) - Exports various helpful constants for use throughout the SDK

Additionally, it exports a number of custom types:

- [Types](/sdk/1.0.0/reference/types) - Exports all types used by the SDK

## Installation

To start using the SDK, simply install it into your project...

```bash
yarn add @uniswap/sdk
```

...import some functions...

```javascript
import { ... } from '@uniswap/sdk'
```

...and dive into the rest of the documentation to learn more!
</file>

<file path="docs/sdk/v1/reference/_category_.json">
{
  "label": "Technical Reference",
  "position": 2,
  "collapsed": false
}
</file>

<file path="docs/sdk/v1/reference/02-data.md">
---
id: data
title: Data
---

## getTokenReserves

This function fetches Uniswap reserve data for a given token address on a given network.

- If only a chain id is specified, the Ethereum node used to fulfill data requests is determined by [`ethers.getDefaultProvider`](https://docs.ethers.io/ethers.js/html/api-providers.html#connecting-to-ethereum), else it is the one specified by the passed provider.
- This function throws an error if the provided tokenAddress is not a token with a Uniswap exchange.

### Function Signature

```typescript
export async function getTokenReserves(
  tokenAddress: string,
  chainIdOrProvider: ChainIdOrProvider = 1
): Promise<TokenReservesNormalized>
```

### Input Parameters

| Parameter         | Type                | Description                                                                                                                                                                                                                            |
| :---------------- | :------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tokenAddress      | `string`            | The checksummed address of a token with a Uniswap exchange.                                                                                                                                                                            |
| chainIdOrProvider | `ChainIdOrProvider` | A supported chain id \(`1`, `3`, `4`, or `42`\), or an [underlying web3 provider](https://docs.ethers.io/ethers.js/html/api-providers.html#web3provider-inherits-from-jsonrpcprovider) connected to a chain with a supported chain id. |

### Example Usage

```typescript
const tokenAddress = '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359' // DAI Mainnet
const chainIdOrProvider: ChainIdOrProvider = 1 // could be e.g. window.ethereum instead

const tokenReserves: TokenReservesNormalized = await getTokenReserves(tokenAddress, chainIdOrProvider)

/*
{
  // details for the passed token
  token: {
    chainId: 1,
    address: '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359',
    decimals: 18
  },

  // details for the Uniswap exchange of the passed token
  exchange: {
    chainId: 1,
    address: '0x09cabEC1eAd1c0Ba254B09efb3EE13841712bE14',
    decimals: 18
  },

  // details for the ETH portion of the reserves of the passed token
  ethReserve: {
    token: {
      chainId: 1,
      address: 'ETH',
      decimals: 18
    },
    amount: <BigNumber>
  },

  // details for the token portion of the reserves of the passed token
  tokenReserve: {
    token: {
      chainId: 1,
      address: '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359',
      decimals: 18
    },
    amount: <BigNumber>
  }
}
*/
```
</file>

<file path="docs/sdk/v1/reference/03-computation.md">
---
id: computation
title: Computation
---

## getMarketDetails

This function computes market details for the passed reserves data. Markets are defined as ETH&lt;&gt;ERC20, ERC20&lt;&gt;ETH, or ERC20&lt;&gt;ERC20 pairs, where the first currency is the input and the second is the output. Reserves must be specified for both the input and output currency.

- In the case of ETH, `undefined` should be passed as the reserves data. [`getTokenReserves`](/sdk/1.0.0/reference/data/#getttokenreserves) formatted ERC20 reserves, or the requisite data can be fetched manually and passed in.

- Rates are calculated to 18 decimal places of precision.

### Function Signature

```typescript
export function getMarketDetails(
  optionalReservesInput: OptionalReserves,
  optionalReservesOutput: OptionalReserves
): MarketDetails
```

### Input Parameters

| Parameter              | Type               | Description                            |
| :--------------------- | :----------------- | :------------------------------------- |
| optionalReservesInput  | `OptionalReserves` | Reserves data for the input currency.  |
| optionalReservesOutput | `OptionalReserves` | Reserves data for the output currency. |

### Example Usage

```typescript
const reserves: ChainIdOrProvider = await getTokenReserves(tokenAddress)

const marketDetails: MarketDetails = getMarketDetails(undefined, reserves) // ETH<>ERC20

/*
{
  // market type
  tradeType: 'ETH_TO_TOKEN',

  // dummy ETH reserves
  inputReserves: {
    token: {
      chainId: 1,
      address: 'ETH',
      decimals: 18
    }
  },

  // normalized token reserves
  outputReserves: <NormalizedReserves>,

  // market rate calculated to 18 decimals of precision
  marketRate: {
    rate: <BigNumber>,        // x output / 1 input
    rateInverted: <BigNumber> // x input / 1 output
  }
}
*/
```

## getTradeDetails

This function computes trade details for the passed market data.

-This function throws an error if the passed \_tradeAmount is greater than the amount of ETH/tokens in the relevant Uniswap exchange.

- Trade amounts must be passed in non-decimal form \(where e.g. 1 ETH is represented as 1000000000000000000 wei\).

### Function Signature

```typescript
export function getTradeDetails(
  tradeExact: TRADE_EXACT,
  _tradeAmount: BigNumberish,
  marketDetails: MarketDetails
): TradeDetails
```

### Input Parameters

| Parameter     | Type            | Description                                                                      |
| :------------ | :-------------- | :------------------------------------------------------------------------------- |
| tradeExact    | `TRADE_EXACT`   | Whether either the input or the output currency is the exact amount.             |
| \_tradeAmount | `BigNumberish`  | The amount to buy/sell \(of the output/input currency, depending on tradeExact\) |
| marketDetails | `MarketDetails` | Market details.                                                                  |

### Example Usage

```typescript
const _purchaseAmount: BigNumber = new BigNumber('2.5')
const _decimals: number = 18
const tradeAmount: BigNumber = _purchaseAmount.multipliedBy(10 ** _decimals)
const marketDetails: MarketDetails = getMarketDetails(undefined, reserves) // ETH<>ERC20

// buy exactly 2.5 of an 18 decimal ERC20 with ETH
const tradeDetails: TradeDetails = getTradeDetails(TRADE_EXACT.OUTPUT, tradeAmount, marketDetails)

/*
{
  marketDetailsPre: <MarketDetails>,

  marketDetailsPost: <MarketDetails>,

  tradeType: 'ETH_TO_TOKEN',

  tradeExact: 'OUTPUT',

  inputAmount: {
    token: <Token>,
    amount: <BigNumber>
  },

  outputAmount: {
    token: <Token>,
    amount: <BigNumber>
  },

  // execution rate calculated to 18 decimals of precision
  executionRate: {
    rate: <BigNumber>         // x output / 1 input
    rateInverted: <BigNumber> // x input / 1 output
  },

  // slippage between the pre- and post-trade market rates, in basis points, calculated to 18 decimals of precision
  marketRateSlippage: <BigNumber>,

  // slippage between the execution and pre-trade market rate, in basis points, calculated to 18 decimals of precision
  executionRateSlippage: <BigNumber>
}
*/
```
</file>

<file path="docs/sdk/v1/reference/04-format.md">
---
id: format
title: Format
---

## formatSignificant

This function formats values to a specified number of significant digits.

### Function Signature

```typescript
export function formatSignificant(bigNumberish: BigNumberish, options?: FormatSignificantOptions): string
```

### Input Parameters

| Parameter    | Type                       | Description                |
| :----------- | :------------------------- | :------------------------- |
| bigNumberish | `BigNumberish`             | The value to be formatted. |
| options?     | `FormatSignificantOptions` | Formatting options.        |

### Example Usage

```typescript
const formatted: string = formatSignificant('123456', { significantDigits: 3 }) // 1.23
```

## formatSignificantDecimals

This function formats token and ethereum values to a specified number of significant digits.

### Function Signature

```typescript
export function formatSignificantDecimals(
  bigNumberish: BigNumberish,
  decimals: number,
  options?: FormatSignificantOptions
): string
```

### Input Parameters

| Parameter    | Type                       | Description                       |
| :----------- | :------------------------- | :-------------------------------- |
| bigNumberish | `BigNumberish`             | The value to be formatted.        |
| decimals     | `number`                   | The decimals of the passed value. |
| options?     | `FormatSignificantOptions` | Formatting options.               |

### Example Usage

```typescript
const formatted: string = formatSignificantDecimals('1234560000000000000', 18, {
  significantDigits: 3,
}) // 1.23
```

## formatFixed

This function formats values to a specified number of decimal places.

### Function Signature

```typescript
export function formatFixed(bigNumberish: BigNumberish, options?: FormatFixedOptions): string
```

### Input Parameters

| Parameter    | Type                 | Description                |
| :----------- | :------------------- | :------------------------- |
| bigNumberish | `BigNumberish`       | The value to be formatted. |
| options?     | `FormatFixedOptions` | Formatting options.        |

### Example Usage

```typescript
const formatted: string = formatFixed('1.2345', { decimalPlaces: 2 }) // 1.23
```

## formatFixedDecimals

This function formats token and ethereum values to a specified number of decimal places.

### Function Signature

```typescript
export function formatFixedDecimals(bigNumberish: BigNumberish, decimals: number, options?: FormatFixedOptions): string
```

### Input Parameters

| Parameter    | Type                 | Description                       |
| :----------- | :------------------- | :-------------------------------- |
| bigNumberish | `BigNumberish`       | The value to be formatted.        |
| decimals     | `number`             | The decimals of the passed value. |
| options?     | `FormatFixedOptions` | Formatting options.               |

### Example Usage

```typescript
const formatted: string = formatFixedDecimals('1234560000000000000', 18, {
  decimalPlaces: 2,
}) // 1.23
```
</file>

<file path="docs/sdk/v1/reference/05-orchestration.md">
---
id: orchestration
title: Orchestration
---

Orchestration functions are plain-english wrappers for the function defined in [/sdk/1.0.0/reference/data](Data) and [Computation](/sdk/1.0.0/reference/computation).

Functions suffixed with `WithData` are synchronous, and require token reserves to be passed in as arguments. Functions without the suffix are asychronous, and require token addresses to be passed in as arguments.

## tradeExactEthForTokensWithData

The function facilitates trading an exact amount of ETH for a specified token.

### Function Signature

```typescript
export function tradeExactEthForTokensWithData(reserves: OptionalReserves, ethAmount: BigNumberish): TradeDetails
```

### Input Parameters

| Parameter | Type               | Description                         |
| :-------- | :----------------- | :---------------------------------- |
| reserves  | `OptionalReserves` | Reserves data for the output token. |
| ethAmount | `BigNumberish`     | The input amount of ETH.            |

### Example Usage

```typescript
const tradeDetails: TradeDetails = tradeExactEthForTokensWithData(reserves, '1000000000000000000')
```

## tradeExactEthForTokens

The function facilitates trading an exact amount of ETH for a specified token.

### Function Signature

```typescript
export async function tradeExactEthForTokens(
  tokenAddress: string,
  ethAmount: BigNumberish,
  chainIdOrProvider?: ChainIdOrProvider
): Promise<TradeDetails>
```

### Input Parameters

| Parameter          | Type                | Description                                                                                                                                                                                                                            |
| :----------------- | :------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tokenAddress       | `string`            | Address of output token.                                                                                                                                                                                                               |
| ethAmount          | `BigNumberish`      | The input amount of ETH.                                                                                                                                                                                                               |
| chainIdOrProvider? | `ChainIdOrProvider` | A supported chain id \(`1`, `3`, `4`, or `42`\), or an [underlying web3 provider](https://docs.ethers.io/ethers.js/html/api-providers.html#web3provider-inherits-from-jsonrpcprovider) connected to a chain with a supported chain id. |

### Example Usage

```typescript
const tradeDetails: TradeDetails = await tradeExactEthForTokens(tokenAddress, '1000000000000000000')
```

## tradeEthForExactTokensWithData

The function facilitates trading ETH for an exact amount of a specified token.

### Function Signature

```typescript
export function tradeEthForExactTokensWithData(reserves: OptionalReserves, tokenAmount: BigNumberish): TradeDetails
```

### Input Parameters

| Parameter   | Type               | Description                         |
| :---------- | :----------------- | :---------------------------------- |
| reserves    | `OptionalReserves` | Reserves data for the output token. |
| tokenAmount | `BigNumberish`     | The output amount of tokens.        |

### Example Usage

```typescript
const tradeDetails: TradeDetails = tradeEthForExactTokensWithData(reserves, '1000000000000000000')
```

## tradeEthForExactTokens

The function facilitates trading ETH for an exact amount of a specified token.

### Function Signature

```typescript
export async function tradeEthForExactTokens(
  tokenAddress: string,
  tokenAmount: BigNumberish,
  chainIdOrProvider?: ChainIdOrProvider
): Promise<TradeDetails>
```

### Input Parameters

| Parameter          | Type                | Description                                                                                                                                                                                                                            |
| :----------------- | :------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tokenAddress       | `string`            | Address of output token.                                                                                                                                                                                                               |
| tokenAmount        | `BigNumberish`      | The output amount of tokens.                                                                                                                                                                                                           |
| chainIdOrProvider? | `ChainIdOrProvider` | A supported chain id \(`1`, `3`, `4`, or `42`\), or an [underlying web3 provider](https://docs.ethers.io/ethers.js/html/api-providers.html#web3provider-inherits-from-jsonrpcprovider) connected to a chain with a supported chain id. |

### Example Usage

```typescript
const tradeDetails: TradeDetails = await tradeEthForExactTokens(tokenAddress, '1000000000000000000')
```

## tradeExactTokensForEthWithData

The function facilitates trading an exact amount of a specified token for ETH.

### Function Signature

```typescript
export function tradeExactTokensForEthWithData(reserves: OptionalReserves, tokenAmount: BigNumberish): TradeDetails
```

### Input Parameters

| Parameter   | Type               | Description                        |
| :---------- | :----------------- | :--------------------------------- |
| reserves    | `OptionalReserves` | Reserves data for the input token. |
| tokenAmount | `BigNumberish`     | The input amount of tokens.        |

### Example Usage

```typescript
const tradeDetails: TradeDetails = tradeExactTokensForEthWithData(reserves, '1000000000000000000')
```

## tradeExactTokensForEth

The function facilitates trading an exact amount of a specified token for ETH.

### Function Signature

```typescript
export async function tradeExactTokensForEth(
  tokenAddress: string,
  tokenAmount: BigNumberish,
  chainIdOrProvider?: ChainIdOrProvider
): Promise<TradeDetails>
```

### Input Parameters

| Parameter          | Type                | Description                                                                                                                                                                                                                            |
| :----------------- | :------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tokenAddress       | `string`            | Address of input token.                                                                                                                                                                                                                |
| tokenAmount        | `BigNumberish`      | The input amount of tokens.                                                                                                                                                                                                            |
| chainIdOrProvider? | `ChainIdOrProvider` | A supported chain id \(`1`, `3`, `4`, or `42`\), or an [underlying web3 provider](https://docs.ethers.io/ethers.js/html/api-providers.html#web3provider-inherits-from-jsonrpcprovider) connected to a chain with a supported chain id. |

### Example Usage

```typescript
const tradeDetails: TradeDetails = await tradeExactTokensForEth(tokenAddress, '1000000000000000000')
```

## tradeTokensForExactEthWithData

The function facilitates trading a specified token for an exact amount of ETH.

### Function Signature

```typescript
export function tradeTokensForExactEthWithData(reserves: OptionalReserves, ethAmount: BigNumberish): TradeDetails
```

### Input Parameters

| Parameter | Type               | Description                        |
| :-------- | :----------------- | :--------------------------------- |
| reserves  | `OptionalReserves` | Reserves data for the input token. |
| ethAmount | `BigNumberish`     | The outpute amount of ETH.         |

### Example Usage

```typescript
const tradeDetails: TradeDetails = tradeTokensForExactEthWithData(reserves, '1000000000000000000')
```

## tradeTokensForExactEth

The function facilitates trading a specified token for an exact amount of ETH.

### Function Signature

```typescript
export async function tradeTokensForExactEth(
  tokenAddress: string,
  ethAmount: BigNumberish,
  chainIdOrProvider?: ChainIdOrProvider
): Promise<TradeDetails>
```

### Input Parameters

| Parameter          | Type                | Description                                                                                                                                                                                                                            |
| :----------------- | :------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tokenAddress       | `string`            | Address of input token.                                                                                                                                                                                                                |
| ethAmount          | `BigNumberish`      | The output amount of ETH.                                                                                                                                                                                                              |
| chainIdOrProvider? | `ChainIdOrProvider` | A supported chain id \(`1`, `3`, `4`, or `42`\), or an [underlying web3 provider](https://docs.ethers.io/ethers.js/html/api-providers.html#web3provider-inherits-from-jsonrpcprovider) connected to a chain with a supported chain id. |

### Example Usage

```typescript
const tradeDetails: TradeDetails = await tradeTokensForExactEth(tokenAddress, '1000000000000000000')
```

## tradeExactTokensForTokensWithData

The function facilitates trading an exact amount of a specified token for another token.

### Function Signature

```typescript
export function tradeExactTokensForTokensWithData(
  reservesInput: OptionalReserves,
  reservesOutput: OptionalReserves,
  tokenAmount: BigNumberish
): TradeDetails
```

### Input Parameters

| Parameter      | Type               | Description                         |
| :------------- | :----------------- | :---------------------------------- |
| reservesInput  | `OptionalReserves` | Reserves data for the input token.  |
| reservesOutput | `OptionalReserves` | Reserves data for the output token. |
| tokenAmount    | `BigNumberish`     | The input amount of tokens.         |

### Example Usage

```typescript
const tradeDetails: TradeDetails = tradeExactTokensForTokensWithData(
  reservesInput,
  reservesOutput,
  '1000000000000000000'
)
```

## tradeExactTokensForTokens

The function facilitates trading an exact amount of a specified token for another token.

### Function Signature

```typescript
export async function tradeExactTokensForTokens(
  tokenAddressInput: string,
  tokenAddressOutput: string,
  tokenAmount: BigNumberish,
  chainIdOrProvider?: ChainIdOrProvider
): Promise<TradeDetails>
```

### Input Parameters

| Parameter          | Type                | Description                                                                                                                                                                                                                            |
| :----------------- | :------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tokenAddressInput  | `string`            | Address of input token.                                                                                                                                                                                                                |
| tokenAddressOutput | `string`            | Address of output token.                                                                                                                                                                                                               |
| tokenAmount        | `BigNumberish`      | The input amount of tokens.                                                                                                                                                                                                            |
| chainIdOrProvider? | `ChainIdOrProvider` | A supported chain id \(`1`, `3`, `4`, or `42`\), or an [underlying web3 provider](https://docs.ethers.io/ethers.js/html/api-providers.html#web3provider-inherits-from-jsonrpcprovider) connected to a chain with a supported chain id. |

### Example Usage

```typescript
const tradeDetails: TradeDetails = await tradeExactTokensForTokens(
  tokenAddressInput,
  tokenAddressOutput,
  '1000000000000000000'
)
```

## tradeTokensForExactTokensWithData

The function facilitates trading a specified token for an exact amount of another token.

### Function Signature

```typescript
export function tradeTokensForExactTokensWithData(
  reservesInput: OptionalReserves,
  reservesOutput: OptionalReserves,
  tokenAmount: BigNumberish
): TradeDetails
```

### Input Parameters

| Parameter      | Type               | Description                         |
| :------------- | :----------------- | :---------------------------------- |
| reservesInput  | `OptionalReserves` | Reserves data for the input token.  |
| reservesOutput | `OptionalReserves` | Reserves data for the output token. |
| tokenAmount    | `BigNumberish`     | The output amount of tokens.        |

### Example Usage

```typescript
const tradeDetails: TradeDetails = tradeTokensForExactTokensWithData(
  reservesInput,
  reservesOutput,
  '1000000000000000000'
)
```

## tradeTokensForExactTokens

The function facilitates trading an exact amount of a specified token for another token.

### Function Signature

```typescript
export async function tradeTokensForExactTokens(
  tokenAddressInput: string,
  tokenAddressOutput: string,
  tokenAmount: BigNumberish,
  chainIdOrProvider?: ChainIdOrProvider
): Promise<TradeDetails>
```

### Input Parameters

| Parameter          | Type                | Description                                                                                                                                                                                                                            |
| :----------------- | :------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tokenAddressInput  | `string`            | Address of input token.                                                                                                                                                                                                                |
| tokenAddressOutput | `string`            | Address of output token.                                                                                                                                                                                                               |
| tokenAmount        | `BigNumberish`      | The output amount of tokens.                                                                                                                                                                                                           |
| chainIdOrProvider? | `ChainIdOrProvider` | A supported chain id \(`1`, `3`, `4`, or `42`\), or an [underlying web3 provider](https://docs.ethers.io/ethers.js/html/api-providers.html#web3provider-inherits-from-jsonrpcprovider) connected to a chain with a supported chain id. |

### Example Usage

```typescript
const tradeDetails: TradeDetails = await tradeTokensForExactTokens(
  tokenAddressInput,
  tokenAddressOutput,
  '1000000000000000000'
)
```
</file>

<file path="docs/sdk/v1/reference/06-transact.md">
---
id: transact
title: Transact
---

### getExecutionDetails

The function formats trade data for execution against the relevant Uniswap exchange.

### Function Signature

```typescript
export function getExecutionDetails(
  trade: TradeDetails,
  maxSlippage?: number,
  deadline?: number,
  recipient?: string
): ExecutionDetails
```

### Input Parameters

| Parameter    | Type           | Description                                                             |
| :----------- | :------------- | :---------------------------------------------------------------------- |
| trade        | `TradeDetails` | The trade to execute.                                                   |
| maxSlippage? | `number`       | The maximum slippage to allow, in basis points. Defaults to 200 \(2%\). |
| deadline?    | `number`       | When the transaction will expire. Defaults to 10 minutes in the future. |
| recipient?   | `number`       | An optional recipient address. Defaults to the `msg.sender`             |

### Example Usage

Method arguments are returned as one of: `BigNumber`, `number`, or `string`. `BigNumber`s are large number objects, `numbers` are small numbers in base 10, and `string`s are addresses.

```typescript
const tradeDetails: TradeDetails = tradeExactEthForTokensWithData(reserves, '1000000000000000000')

const executionDetails: ExecutionDetails = await getExecutionDetails(tradeDetails)

/*
{
  // the address of the relevant exchange
  exchangeAddress: 0x09cabEC1eAd1c0Ba254B09efb3EE13841712bE14,

  // the name of the method that must be called
  methodName: "ethToTokenSwapInput",

  // the id of the method name
  methodId: "0xf39b5b9b",

  // the ether value that must be sent with the transaction
  value: <BigNumber>,

  // method arguments as an array
  methodArguments: MethodArgument[]
}
*/
```
</file>

<file path="docs/sdk/v1/reference/07-constants.md">
---
id: constants
title: Constants
---

Below is an exhaustive list of all external constants used in the SDK.

```typescript
import BigNumber from 'bignumber.js'

import ERC20 from './abis/ERC20.json'
import FACTORY from './abis/FACTORY.json'
import EXCHANGE from './abis/EXCHANGE.json'

export const ETH = 'ETH'

export enum SUPPORTED_CHAIN_ID {
  Mainnet = 1,
  Ropsten = 3,
  Rinkeby = 4,
  Kovan = 42,
}

export const FACTORY_ADDRESS: { [key: number]: string } = {}

export const FACTORY_ABI: string = JSON.stringify(FACTORY)
export const EXCHANGE_ABI: string = JSON.stringify(EXCHANGE)

export enum TRADE_TYPE {
  ETH_TO_TOKEN = 'ETH_TO_TOKEN',
  TOKEN_TO_ETH = 'TOKEN_TO_ETH',
  TOKEN_TO_TOKEN = 'TOKEN_TO_TOKEN',
}

export enum TRADE_EXACT {
  INPUT = 'INPUT',
  OUTPUT = 'OUTPUT',
}

export enum TRADE_METHODS {
  ethToTokenSwapInput = 'ethToTokenSwapInput',
  ethToTokenTransferInput = 'ethToTokenTransferInput',
  ethToTokenSwapOutput = 'ethToTokenSwapOutput',
  ethToTokenTransferOutput = 'ethToTokenTransferOutput',
  tokenToEthSwapInput = 'tokenToEthSwapInput',
  tokenToEthTransferInput = 'tokenToEthTransferInput',
  tokenToEthSwapOutput = 'tokenToEthSwapOutput',
  tokenToEthTransferOutput = 'tokenToEthTransferOutput',
  tokenToTokenSwapInput = 'tokenToTokenSwapInput',
  tokenToTokenTransferInput = 'tokenToTokenTransferInput',
  tokenToTokenSwapOutput = 'tokenToTokenSwapOutput',
  tokenToTokenTransferOutput = 'tokenToTokenTransferOutput',
}

export const TRADE_METHOD_IDS: { [key: string]: string } = {}

export enum FIXED_UNDERFLOW_BEHAVIOR {
  ZERO = 'ZERO',
  LESS_THAN = 'LESS_THAN',
  ONE_DIGIT = 'ONE_DIGIT',
}
```
</file>

<file path="docs/sdk/v1/reference/08-types.md">
---
id: types
title: Types
---

Below is an exhaustive list of all the external types used in the SDK.

```typescript
import BigNumber from 'bignumber.js'
import { ethers } from 'ethers'

import { SUPPORTED_CHAIN_ID, TRADE_TYPE, TRADE_EXACT, FIXED_UNDERFLOW_BEHAVIOR } from './constants'

export type BigNumberish = BigNumber | ethers.utils.BigNumber | string | number

//// types for on-chain, submitted, and normalized data
export type ChainIdOrProvider = SUPPORTED_CHAIN_ID | ethers.providers.AsyncSendable | ethers.providers.Provider

// type guard for ChainIdOrProvider
export function isChainId(chainIdOrProvider: ChainIdOrProvider): chainIdOrProvider is SUPPORTED_CHAIN_ID {
  const chainId: SUPPORTED_CHAIN_ID = chainIdOrProvider as SUPPORTED_CHAIN_ID
  return typeof chainId === 'number'
}

// type guard for ChainIdOrProvider
export function isLowLevelProvider(
  chainIdOrProvider: ChainIdOrProvider
): chainIdOrProvider is ethers.providers.AsyncSendable {
  if (isChainId(chainIdOrProvider)) {
    return false
  } else {
    const provider: ethers.providers.AsyncSendable = chainIdOrProvider as ethers.providers.AsyncSendable
    return 'send' in provider || 'sendAsync' in provider
  }
}

export interface Token {
  chainId?: SUPPORTED_CHAIN_ID
  address?: string
  decimals: number
}

export interface TokenAmount {
  token: Token
  amount: BigNumberish
}

export interface TokenAmountNormalized {
  token: Token
  amount: BigNumber
}

export interface TokenReserves {
  token: Token
  exchange?: Token
  ethReserve: TokenAmount
  tokenReserve: TokenAmount
}

export interface TokenReservesNormalized {
  token: Token
  exchange?: Token
  ethReserve: TokenAmountNormalized
  tokenReserve: TokenAmountNormalized
}

export interface EthReserves {
  token: Token
}

// type for input data
export type OptionalReserves = TokenReserves | EthReserves | undefined

// type guard for OptionalReserves
export function areTokenReserves(reserves: OptionalReserves): reserves is TokenReserves {
  const tokenReserves: TokenReserves = reserves as TokenReserves
  return (
    tokenReserves !== undefined && tokenReserves.ethReserve !== undefined && tokenReserves.tokenReserve !== undefined
  )
}

// type guard for OptionalReserves
export function areETHReserves(reserves: OptionalReserves): reserves is EthReserves {
  const tokenReserves: TokenReserves = reserves as TokenReserves
  return (
    tokenReserves !== undefined && tokenReserves.ethReserve === undefined && tokenReserves.tokenReserve === undefined
  )
}

// type for output data
export type NormalizedReserves = TokenReservesNormalized | EthReserves

// type guard for NormalizedReserves
export function areTokenReservesNormalized(reserves: NormalizedReserves): reserves is TokenReservesNormalized {
  const tokenReservesNormalized: TokenReservesNormalized = reserves as TokenReservesNormalized
  return tokenReservesNormalized.ethReserve !== undefined && tokenReservesNormalized.tokenReserve !== undefined
}

//// types for computed data
export interface Rate {
  rate: BigNumber
  rateInverted: BigNumber
}
export interface MarketDetails {
  tradeType: TRADE_TYPE
  inputReserves: NormalizedReserves
  outputReserves: NormalizedReserves
  marketRate: Rate
}

export interface TradeDetails {
  marketDetailsPre: MarketDetails
  marketDetailsPost: MarketDetails
  tradeType: TRADE_TYPE
  tradeExact: TRADE_EXACT
  inputAmount: TokenAmountNormalized
  outputAmount: TokenAmountNormalized
  executionRate: Rate
  marketRateSlippage: BigNumber
  executionRateSlippage: BigNumber
}

export type MethodArgument = BigNumber | number | string

export interface ExecutionDetails {
  exchangeAddress: string
  methodName: string
  methodId: string
  value: BigNumber
  methodArguments: MethodArgument[]
}

//// types for formatting data
export type FlexibleFormat = BigNumber.Format | boolean

// type guard for FlexibleFormat
export function isFormat(flexibleFormat: FlexibleFormat): flexibleFormat is BigNumber.Format {
  const format: BigNumber.Format = flexibleFormat as BigNumber.Format
  return typeof format !== 'boolean'
}

export interface FormatSignificantOptions {
  significantDigits: number
  roundingMode: BigNumber.RoundingMode
  forceIntegerSignificance: boolean
  format: FlexibleFormat
}

export interface FormatFixedOptions {
  decimalPlaces: number
  roundingMode: BigNumber.RoundingMode
  dropTrailingZeros: boolean
  underflowBehavior: FIXED_UNDERFLOW_BEHAVIOR
  format: FlexibleFormat
}
```
</file>

<file path="docs/sdk/v1/_category_.json">
{
  "label": "v1 SDK",
  "position": 7,
  "collapsed": true
}
</file>

<file path="docs/sdk/v1/overview.md">
---
id: overview
sidebar_position: 1
title: Overview
---

This is the original documentation for the Uniswap v1 SDK, released in 2019. 
The Uniswap v1 SDK is no longer under development, for the most recent implementation of the SDK, see the [v3 SDK](../v3/overview.md).
</file>

<file path="docs/sdk/v2/guides/_category_.json">
{
  "label": "Guides",
  "position": 2,
  "collapsed": false
}
</file>

<file path="docs/sdk/v2/guides/01-quick-start.md">
---
id: quick-start
title: SDK Quick start
---

The Uniswap SDK exists to help developers build on top of Uniswap. It's designed to run in any environment that can execute JavaScript (think websites, node scripts, etc.). While simple enough to use in a hackathon project, it's also robust enough to power production applications.

## Installation

The easiest way to consume the SDK is via [npm](https://github.com/Uniswap/uniswap-v2-sdk). To install it in your project, simply run `yarn add @uniswap/v2-sdk` (or `npm install @uniswap/v2-sdk`). This also installs the sdk-core package that is used by both the V2 and V3 SDK and ethers as dependencies.

## Usage

To run code from the SDK in your application, use an `import` or `require` statement, depending on which your environment supports. Note that the guides following this page will use ES6 syntax.

## ES6 (import)

```typescript
import { ChainId } from '@uniswap/sdk-core'
import {Pair} from '@uniswap/v2-sdk'
console.log(`The chainId of mainnet is ${ChainId.MAINNET}.`)
```

## CommonJS (require)

```typescript
const CORE = require('@uniswap/sdk-core')
const V2_SDK = require('@uniswap/v2-sdk')
console.log(`The chainId of mainnet is ${CORE.ChainId.MAINNET}.`)
```

## Reference

Comprehensive reference material for the SDK is publicly available on the [Uniswap Labs GitHub](https://github.com/Uniswap).
</file>

<file path="docs/sdk/v2/guides/02-fetching-data.md">
---
id: fetching-data
title: Fetching Data
---

> Looking for a [quickstart](quick-start)?

While the SDK is fully self-contained, there are two cases where it needs _on-chain data_ to function.
This guide will detail both of these cases, and offer a sample that you can use to fetch this data.

# Case 1: Tokens

Unsurprisingly, the SDK needs some notion of an ERC-20 token to be able to function. This immediately raises the question of _where data about tokens comes from_.

As an example, let's try to represent DAI in a format the SDK can work with. To do so, we need at least 3 pieces of data: a **chainId**, a **token address**, and how many **decimals** the token has. We also may be interested in the **symbol** and/or **name** of the token.

## Identifying Data

The first two pieces of data — **chainId** and **token address** — must be provided by us. Thinking about it, this makes sense, as there's really no other way to unambiguously identify a token.

So, in the case of DAI, we know that the **chainId** is `1` (we're on mainnet), and the **token address** is `0x6B175474E89094C44Da98b954EedeAC495271d0F`. Note that it's very important to externally verify token addresses. Don't use addresses from sources you don't trust!

## Required Data

The next piece of data we need is **decimals**.

### Provided by the User

One option here is to simply pass in the correct value, which we may know is `18`. At this point, we're ready to represent DAI as a [Token](../../core/reference/classes/Token.md):

```typescript
import { ChainId, Token } from '@uniswap/sdk-core'

const chainId = ChainId.MAINNET
const tokenAddress = '0x6B175474E89094C44Da98b954EedeAC495271d0F' // must be checksummed
const decimals = 18

const DAI = new Token(chainId, tokenAddress, decimals)
```

If we don't know or don't want to hardcode the value, we could look it up ourselves via any method of retrieving on-chain data in a function that looks something like:

```typescript
import { ChainId } from '@uniswap/sdk-core'

async function getDecimals(chainId: ChainId, tokenAddress: string): Promise<number> {
  // Setup provider, import necessary ABI ...
  const tokenContract = new ethers.Contract(tokenAddress, erc20abi, provider)
  return tokenContract["decimals"]()
}
```

## Optional Data

Finally, we can talk about **symbol** and **name**. Because these fields aren't used anywhere in the SDK itself, they're optional, and can be provided if you want to use them in your application. However, the SDK will not fetch them for you, so you'll have to provide them:

```typescript
import { ChainId, Token } from '@uniswap/sdk-core'

const DAI = new Token(ChainId.MAINNET, '0x6B175474E89094C44Da98b954EedeAC495271d0F', 18, 'DAI', 'Dai Stablecoin')
```

# Case 2: Pairs

Now that we've explored how to define a token, let's talk about pairs. To read more about what Uniswap pairs are, see [Pair](../../../contracts/v2/reference/smart-contracts/pair)

As an example, let's try to represent the DAI-WETH pair.

## Identifying Data

Each pair consists of two tokens (see previous section). Note that WETH used by the router is [exported by the SDK Core as WETH9](../../core/reference/overview.md).

## Required Data

The data we need is the _reserves_ of the pair. To read more about reserves, see [getReserves](../../../contracts/v2/reference/smart-contracts/pair#getreserves).

### Provided by the User

One option here is to simply pass in values which we've fetched ourselves to create a [Pair](../reference/pair). In this example we use ethers to fetch the data directly from the blockchain:

```typescript
import { ChainId, Token, WETH9, CurrencyAmount } from '@uniswap/sdk-core'
import { Pair } from '@uniswap/v2-sdk'

const DAI = new Token(ChainId.MAINNET, '0x6B175474E89094C44Da98b954EedeAC495271d0F', 18)

async function createPair(): Promise<Pair> {
  const pairAddress = Pair.getAddress(DAI, WETH9[DAI.chainId])

  // Setup provider, import necessary ABI ...
  const pairContract = new ethers.Contract(pairAddress, uniswapV2poolABI, provider)
  const reserves = await pairContract["getReserves"]()
  const [reserve0, reserve1] = reserves

  const tokens = [DAI, WETH9[DAI.chainId]]
  const [token0, token1] = tokens[0].sortsBefore(tokens[1]) ? tokens : [tokens[1], tokens[0]]

  const pair = new Pair(CurrencyAmount.fromRawAmount(token0, reserve0), CurrencyAmount.fromRawAmount(token1, reserve1))
  return pair
}
```

Note that these values can change as frequently as every block, and should be kept up-to-date.
</file>

<file path="docs/sdk/v2/guides/03-pricing.md">
---
id: pricing
title: Pricing
---

> Looking for a [quickstart](quick-start)?

Let's talk pricing. This guide will focus on the two most important Uniswap prices: the **mid price** and the **execution price**.

# Mid Price

The mid price, in the context of Uniswap, is the price that reflects the _ratio of reserves in one or more pairs_. There are three ways we can think about this price. Perhaps most simply, it defines the relative value of one token in terms of the other. It also represents the price at which you could theoretically trade an infinitesimal amount (ε) of one token for the other. Finally, it can be interpreted as the current _market-clearing or fair value price_ of the assets.

Let's consider the mid price for DAI-WETH (that is, the amount of DAI per 1 WETH).

## Direct

The simplest way to get the DAI-WETH mid price is to observe the pair directly:

```typescript
import { ChainId, Token, WETH9 } from '@uniswap/sdk-core'
import { Route } from '@uniswap/v2-sdk'

const DAI = new Token(ChainId.MAINNET, '0x6B175474E89094C44Da98b954EedeAC495271d0F', 18)

// To learn how to get Pair data, refer to the previous guide.
const pair = await createPair(DAI, WETH9[ChainId.MAINNET])

const route = new Route([pair], WETH9[DAI.chainId], DAI)

console.log(route.midPrice.toSignificant(6)) // 1901.08
console.log(route.midPrice.invert().toSignificant(6)) // 0.000526017
```

You may be wondering why we have to construct a _route_ to get the mid price, as opposed to simply getting it from the pair (which, after all, includes all the necessary data). The reason is simple: a route forces us to be opinionated about the _direction_ of trading. Routes consist of one or more pairs, an input token and an output token (which fully defines a trading path). In this case, we passed WETH as the input token and DAI as the output token, meaning we're interested in a WETH -> DAI trade.

Now we understand that the mid price is going to be defined in terms of DAI/WETH. Not to worry though, if we need the WETH/DAI price, we can easily invert.

Finally, you may have noticed that we're formatting the price to 6 significant digits. This is because internally, prices are stored as exact-precision fractions, which can be converted to other representations on demand. For a full list of options, see [Price](../../core/reference/classes/Price.md).

## Indirect

For the sake of example, let's imagine a direct pair between DAI and WETH _doesn't exist_. In order to get a DAI-WETH mid price we'll need to pick a valid route. Imagine both DAI and WETH have pairs with a third token, USDC. In that case, we can calculate an indirect mid price through the USDC pairs:

```typescript
import { ChainId, Token, WETH9} from '@uniswap/sdk-core'
import { Route, Pair } from '@uniswap/v2-sdk'

const USDC = new Token(ChainId.MAINNET, '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', 6)
const DAI = new Token(ChainId.MAINNET, '0x6B175474E89094C44Da98b954EedeAC495271d0F', 18)

// To learn how to get Pair data, refer to the previous guide.
const USDCWETHPair = await createPair(USDC, WETH9[ChainId.MAINNET])
const DAIUSDCPair = await createPair(DAI, USDC)

const route = new Route([USDCWETHPair, DAIUSDCPair], WETH9[ChainId.MAINNET], DAI)

console.log(route.midPrice.toSignificant(6)) // 1896.34
console.log(route.midPrice.invert().toSignificant(6)) // 0.000527331
```

# Execution Price

Mid prices are great representations of the _current_ state of a route, but what about trades? It turns out that it makes sense to define another price, the _execution_ price of a trade, as the ratio of assets sent/received.

Imagine we're interested in trading 1 WETH for DAI:

```typescript
import { ChainId, Token, WETH9, CurrencyAmount, TradeType } from '@uniswap/sdk-core'
import { Route, Pair, Trade } from '@uniswap/v2-sdk'

const DAI = new Token(ChainId.MAINNET, '0x6B175474E89094C44Da98b954EedeAC495271d0F', 18)

// To learn how to get Pair data, refer to the previous guide.
const pair = await createPair(DAI, WETH9[DAI.chainId])

const route = new Route([pair], WETH9[DAI.chainId], DAI)

const trade = new Trade(route, CurrencyAmount.fromRawAmount(WETH9[DAI.chainId], '1000000000000000000'), TradeType.EXACT_INPUT)

console.log(trade.executionPrice.toSignificant(6)) // 1894.91
```

Notice that we're constructing a trade of 1 WETH for as much DAI as possible, _given the current reserves of the direct pair_. The execution price represents the average DAI/WETH price for this trade. Of course, the reserves of any pair can change every block, which would affect the execution price.
</file>

<file path="docs/sdk/v2/guides/04-trading.md">
---
id: trading
title: Trading
---

> Looking for a [quickstart](quick-start)?

The SDK _cannot execute trades or send transactions on your behalf_. Rather, it offers utility classes and functions which make it easy to calculate the data required to safely interact with Uniswap. Nearly everything you need to safely transact with Uniswap is provided by the [Trade](../reference/trade) entity. However, it is your responsibility to use this data to send transactions in whatever context makes sense for your application.

This guide will focus exclusively on sending a transaction to the [latest Uniswap V2 router](../../../contracts/v2/reference/smart-contracts/router-02)

# Sending a Transaction to the Router

Let's say we want to trade 1 WETH for as much DAI as possible:

```typescript
import { ChainId, Token, WETH9, CurrencyAmount, TradeType } from '@uniswap/sdk-core'
import {Trade, Route} from '@uniswap/v2-sdk'

const DAI = new Token(ChainId.MAINNET, '0x6B175474E89094C44Da98b954EedeAC495271d0F', 18)

// See the Fetching Data guide to learn how to get Pair data
const pair = await createPair(DAI, WETH9[DAI.chainId])

const route = new Route([pair], WETH9[DAI.chainId], DAI)

const amountIn = '1000000000000000000' // 1 WETH

const trade = new Trade(route, CurrencyAmount.fromRawAmount(WETH9[DAI.chainId], amountIn), TradeType.EXACT_INPUT)
```

So, we've constructed a trade entity, but how do we use it to actually send a transaction? There are still a few pieces we need to put in place.

Before going on, we should explore how ETH works in the context of trading. Internally, the SDK uses WETH, as all Uniswap V2 pairs use WETH under the hood. However, it's perfectly possible for you as an end user to use ETH, and rely on the router to handle converting to/from WETH. So, let's use ETH.

The first step is selecting the appropriate router function. The names of router functions are intended to be self-explanatory; in this case we want [swapExactETHForTokens](../../../contracts/v2/reference/smart-contracts/router-02#swapexactethfortokens), because we're swapping an exact amount of ETH for tokens.

That Solidity interface for this function is:

```solidity
function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
  external
  payable
  returns (uint[] memory amounts);
```

Jumping back to our trading code, we can construct all the necessary parameters:

```typescript
import {Percent} from '@uniswap/sdk-core'

const slippageTolerance = new Percent('50', '10000') // 50 bips, or 0.50%

const amountOutMin = trade.minimumAmountOut(slippageTolerance).toExact() // needs to be converted to e.g. decimal string
const path = [WETH9[DAI.chainId].address, DAI.address]
const to = '' // should be a checksummed recipient address
const deadline = Math.floor(Date.now() / 1000) + 60 * 20 // 20 minutes from the current Unix time
const value = trade.inputAmount.toExact() // // needs to be converted to e.g. decimal string
```

The slippage tolerance encodes _how large of a price movement we're willing to tolerate before our trade will fail to execute_. Since Ethereum transactions are broadcast and confirmed in an adversarial environment, this tolerance is the best we can do to protect ourselves against price movements. We use this slippage tolerance to calculate the _minumum_ amount of DAI we must receive before our trade reverts, thanks to [minimumAmountOut](../reference/trade#minimumamountout-since-204). Note that this code calculates this worst-case outcome _assuming that the current price, i.e the route's mid price,_ is fair (usually a good assumption because of arbitrage).

The path is simply the ordered list of token addresses we're trading through, in our case WETH and DAI (note that we use the WETH address, even though we're using ETH).

The to address is the address that will receive the DAI.

The deadline is the Unix timestamp after which the transaction will fail, to protect us in the case that our transaction takes a long time to confirm and we wish to rescind our trade.

The value is the amount of ETH that must be included as the `msg.value` in our transaction.
</file>

<file path="docs/sdk/v2/guides/05-getting-pair-addresses.md">
---
id: getting-pair-addresses
title: Pair Addresses
---

## getPair

The most obvious way to get the address for a pair is to call [getPair](../../../contracts/v2/reference/smart-contracts/factory#getpair) on the factory. If the pair exists, this function will return its address, else `address(0)` (`0x0000000000000000000000000000000000000000`).

- The "canonical" way to determine whether or not a pair exists.
- Requires an on-chain lookup.

## CREATE2

Thanks to some [fancy footwork in the factory](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Factory.sol#L32), we can also compute pair addresses _without any on-chain lookups_ because of [CREATE2](https://eips.ethereum.org/EIPS/eip-1014). The following values are required for this technique:

|                        |                                                                                |
| :--------------------- | :----------------------------------------------------------------------------- |
| `address`              | The [factory address](../../../contracts/v2/reference/smart-contracts/factory) |
| `salt`                 | `keccak256(abi.encodePacked(token0, token1))`                                  |
| `keccak256(init_code)` | `0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f`           |

- `token0` must be strictly less than `token1` by sort order.

* Can be computed offline.
* Requires the ability to perform `keccak256`.

## Examples

### TypeScript

This example makes use of the [Uniswap V2 SDK](../reference/getting-started). In reality, the SDK computes pair addresses behind the scenes, obviating the need to compute them manually like this.

```typescript
import { FACTORY_ADDRESS, INIT_CODE_HASH } from '@uniswap/v2-sdk'
import { pack, keccak256 } from '@ethersproject/solidity'
import { getCreate2Address } from '@ethersproject/address'

const token0 = '0xCAFE000000000000000000000000000000000000' // change me!
const token1 = '0xF00D000000000000000000000000000000000000' // change me!

const pair = getCreate2Address(
  FACTORY_ADDRESS,
  keccak256(['bytes'], [pack(['address', 'address'], [token0, token1])]),
  INIT_CODE_HASH
)
```
</file>

<file path="docs/sdk/v2/reference/_category_.json">
{
  "label": "Technical Reference",
  "position": 3,
  "collapsed": false
}
</file>

<file path="docs/sdk/v2/reference/01-getting-started.md">
---
id: getting-started
title: Getting Started
---

The pages that follow contain technical reference information on the Uniswap SDK.
Looking for a [quick start](../guides/quick-start) instead?
You may also want to jump into a [guide](../guides/fetching-data),
which offers a friendlier introduction to the SDK!

The SDK is written in TypeScript, has a robust test suite, performs arbitrary precision arithmetic,
and supports rounding to significant digits or fixed decimal places.
The principal exports of the SDK are _entities_: classes that contain initialization and validation checks,
necessary data fields, and helper functions.

An important concept in the SDK is _fractions_. Because Solidity performs integer math, care must be taken in
non-EVM environments to faithfully replicate the actual computation carried out on-chain.
The first concern here is to ensure that an overflow-safe integer implementation is used.
Ideally, the SDK would be able to use native [BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)s.
However, until support becomes more widespread, [JSBI](https://github.com/GoogleChromeLabs/jsbi) objects are used instead,
with the idea that once BigInts proliferate, this dependency can be compiled away.
The second concern is precision loss due to, for example, chained price ratio calculations.
To address this issue, all math operations are performed as fraction operations, ensuring arbitrary precision up
until the point that values are rounded for display purposes, or truncated to fit inside a fixed bit width.

The Fractions class, among others that the V2 SDK depends on, are exported from the SDK Core to allow interoperability with the V3 SDK. 
Refer to the [Core SDK section of the docs](../../core/overview.md) to learn more about these classes.

The SDK works for all chains on which the [factory](../../../contracts/v2/reference/smart-contracts/factory#address) is deployed.

## Code

The [source code is available on GitHub](https://github.com/Uniswap/uniswap-sdk).

## Dependencies

The SDK installs a small number of dependencies(https://github.com/Uniswap/v2-sdk/blob/main/package.json#L24).
The most important dependency of the V2 SDK is the SDK core, which was previously part of the V2 SDK itself, but later released as its own package to avoid duplicate code between the V2 and V3 SDK.
</file>

<file path="docs/sdk/v2/reference/02-pair.md">
---
id: pair
title: Pair
---

```typescript
constructor(tokenAmountA: CurrencyAmount, tokenAmountB: CurrencyAmount)
```

The Pair entity represents a Uniswap pair with a balance of each of its pair tokens.

## Example

```typescript
import { Pair } from '@uniswap/sdk-core'
import {ChainId, Token, CurrencyAmount } from '@uniswap/v2-sdk'

const HOT = new Token(ChainId.MAINNET, '0xc0FFee0000000000000000000000000000000000', 18, 'HOT', 'Caffeine')
const NOT = new Token(ChainId.MAINNET, '0xDeCAf00000000000000000000000000000000000', 18, 'NOT', 'Caffeine')

const pair = new Pair(CurrencyAmount.fromRawAmount(HOT, '2000000000000000000'), CurrencyAmount.fromRawAmount(NOT, '1000000000000000000'))
```

## Static Methods

### getAddress

```typescript
getAddress(tokenA: Token, tokenB: Token): string
```

Computes the pair address for the passed [Tokens](token). See [Pair Addresses](../../../contracts/v2/guides/smart-contract-integration/getting-pair-addresses).

## Properties

### liquidityToken

```typescript
liquidityToken: Token
```

A Token representing the liquidity token for the pair. See [Pair (ERC-20)](../../../contracts/v2/reference/smart-contracts/pair-erc-20).

### token0

```typescript
token0: Token
```

See [Token0](../../../contracts/v2/reference/smart-contracts/pair#token0).

### token1

```typescript
token1: Token
```

See [Token1](../../../contracts/v2/reference/smart-contracts/pair#token1).

### reserve0

```typescript
reserve0: CurrencyAmount
```

The reserve of token0.

### reserve1

```typescript
reserve1: CurrencyAmount
```

The reserve of token1.

## Methods

### reserveOf

```typescript
reserveOf(token: Token): CurrencyAmount
```

Returns reserve0 or reserve1, depending on whether token0 or token1 is passed in.

### getOutputAmount

```typescript
getOutputAmount(inputAmount: CurrencyAmount): [CurrencyAmount, Pair]
```

Pricing function for exact input amounts. Returns maximum output amount based on current reserves and the new Pair that would exist if the trade were executed.

### getInputAmount

```typescript
getInputAmount(outputAmount: CurrencyAmount): [CurrencyAmount, Pair]
```

Pricing function for exact output amounts. Returns minimum input amount based on current reserves and the new Pair that would exist if the trade were executed.

### getLiquidityMinted

```typescript
getLiquidityMinted(totalSupply: CurrencyAmount, tokenAmountA: CurrencyAmount, tokenAmountB: CurrencyAmount): CurrencyAmount
```

Calculates the exact amount of liquidity tokens minted from a given amount of token0 and token1.

- totalSupply must be looked up on-chain.
- The value returned from this function _cannot_ be used as an input to getLiquidityValue.

### getLiquidityValue

```typescript
getLiquidityValue(
  token: Token,
  totalSupply: CurrencyAmount,
  liquidity: CurrencyAmount,
  feeOn: boolean = false,
  kLast?: BigintIsh
): CurrencyAmount
```

Calculates the exact amount of token0 or token1 that the given amount of liquidity tokens represent.

- totalSupply must be looked up on-chain.
- If the protocol charge is on, feeOn must be set to true, and kLast must be provided from an on-chain lookup.
- Values returned from this function _cannot_ be used as inputs to getLiquidityMinted.
</file>

<file path="docs/sdk/v2/reference/03-route.md">
---
id: route
title: Route
---

```typescript
constructor(pairs: Pair[], input: Token, output: Token)
```

The Route entity represents one or more ordered Uniswap pairs with a fully specified path from input token to output token.

## Example

```typescript
import { ChainId, Token, CurrencyAmount } from '@uniswap/sdk-core'
import { Pair, Route } from '@uniswap/v2-sdk'

const HOT = new Token(ChainId.MAINNET, '0xc0FFee0000000000000000000000000000000000', 18, 'HOT', 'Caffeine')
const NOT = new Token(ChainId.MAINNET, '0xDeCAf00000000000000000000000000000000000', 18, 'NOT', 'Caffeine')
const HOT_NOT = new Pair(CurrencyAmount.fromRawAmount(HOT, '2000000000000000000'), CurrencyAmount.fromRawAmount(NOT, '1000000000000000000'))

const route = new Route([HOT_NOT], NOT, HOT)
```

## Properties

### pairs

```typescript
pairs: Pair[]
```

The ordered pairs that the route is comprised of.

### path

```typescript
path: Token[]
```

The full path from input token to output token.

### input

```typescript
input: Token
```

The input token.

### output

```typescript
output: Token
```

The output token.

### midPrice

```typescript
midPrice: Price
```

Returns the current mid price along the route.
</file>

<file path="docs/sdk/v2/reference/04-trade.md">
---
id: trade
title: Trade
---

```typescript
constructor(route: Route, amount: CurrencyAmount, tradeType: TradeType)
```

The Trade entity represents a fully specified trade along a route. This entity supplies all the information necessary to craft a router transaction.

## Example

```typescript
import { ChainId, Token, CurrencyAmount, TradeType } from '@uniswap/sdk-core'
import { Pair, Trade, Route }

const HOT = new Token(ChainId.MAINNET, '0xc0FFee0000000000000000000000000000000000', 18, 'HOT', 'Caffeine')
const NOT = new Token(ChainId.MAINNET, '0xDeCAf00000000000000000000000000000000000', 18, 'NOT', 'Caffeine')
const HOT_NOT = new Pair(CurrencyAmount.fromRawAmount(HOT, '2000000000000000000'), CurrencyAmount.fromRawAmount(NOT, '1000000000000000000'))
const NOT_TO_HOT = new Route([HOT_NOT], NOT, HOT)

const trade = new Trade(NOT_TO_HOT, CurrencyAmount.fromRawAmount(NOT, '1000000000000000'), TradeType.EXACT_INPUT)
```

## Properties

### route

```typescript
route: Route
```

The [path](route#path) property of the route should be passed as the path parameter to router functions.

### tradeType

```typescript
tradeType: TradeType
```

`TradeType.EXACT_INPUT` corresponds to `swapExact*For*` router functions. `TradeType.EXACT_OUTPUT` corresponds to `swap*ForExact*` router functions.

### inputAmount

```typescript
inputAmount: CurrencyAmount
```

For exact input trades, this value should be passed as amountIn to router functions. For exact output trades, this value should be multiplied by a factor >1, representing slippage tolerance, and passed as amountInMax to router functions.

### outputAmount

```typescript
outputAmount: CurrencyAmount
```

For exact output trades, this value should be passed as amountOut to router functions. For exact input trades, this value should be multiplied by a factor \<1, representing slippage tolerance, and passed as amountOutMin to router functions.

### executionPrice

```typescript
executionPrice: Price
```

The average price that the trade would execute at.

### priceImpact

```typescript
priceImpact: Percent
```

The percent difference between the mid price before the trade and the trade execution price.

## Methods

In the context of the following two methods, slippage refers to the percent difference between the actual price and the trade `executionPrice`.

### minimumAmountOut (since 2.0.4)

```typescript
minimumAmountOut(slippageTolerance: Percent): CurrencyAmount
```

Returns the minimum amount of the output token that should be received from a trade, given the slippage tolerance.

Useful when constructing a transaction for a trade of type `EXACT_INPUT`.

### maximumAmountIn (since 2.0.4)

```typescript
maximumAmountIn(slippageTolerance: Percent): CurrencyAmount
```

Returns the maximum amount of the input token that should be spent on the trade, given the slippage tolerance.

Useful when constructing a transaction for a trade of type `EXACT_OUTPUT`.

### worstExecutionPrice

Return the execution price after accounting for slippage tolerance

```typescript
worstExecutionPrice(slippageTolerance: Percent): Price
```

## Static methods

These static methods provide ways to construct ideal trades from lists of pairs.
Note these methods do not perform any aggregation across routes, as routes are linear.
It's possible that a better price can be had by combining multiple trades across
different routes.

### exactIn

Constructs an exact in trade with the given amount in and route.

```typescript
Trade.exactIn(route: Route, amountIn: CurrencyAmount): Trade
```

### exactOut

Constructs an exact out trade with the given amount out and route

```typescript
Trade.exactOut(route: Route, amountOut: CurrencyAmount): Trade
```

### bestTradeExactIn

Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token
amount to an output token, making at most `maxHops` hops.
Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting
the amount in among multiple routes.

```typescript
Trade.bestTradeExactIn(
    pairs: Pair[],
    nextAmountIn: CurrencyAmount,
    currencyOut: Token,
    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {}): Trade[]
```

### bestTradeExactOut

Similar to the above method but instead targets a fixed output amount given a list of pairs,
and a fixed amount out, returns the top `maxNumResults` trades that go from an input token to an output token amount,
making at most `maxHops` hops. Note this does not consider aggregation, as routes are linear.
It is possible a better route exists by splitting the amountIn among multiple routes.

```typescript
Trade.bestTradeExactOut(
    pairs: Pair[],
    currencyIn: Token,
    nextAmountOut: CurrencyAmount,
    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {}): Trade[]
```
</file>

<file path="docs/sdk/v2/reference/05-other-exports.md">
---
id: other-exports
title: Other Exports
---

A enum denominating supported rounding options.

## FACTORY_ADDRESS

```typescript
import { FACTORY_ADDRESS } from '@uniswap/v2-sdk'
```

The [factory address](../../../contracts/v2/reference/smart-contracts/factory#address).

## INIT_CODE_HASH

```typescript
import { INIT_CODE_HASH } from '@uniswap/v2-sdk'
```

See [pair addresses](../../../contracts/v2/guides/smart-contract-integration/getting-pair-addresses).

## MINIMUM_LIQUIDITY

```typescript
import { MINIMUM_LIQUIDITY } from '@uniswap/v2-sdk'
```

See [minimum liquidity](../../../contracts/v2/reference/smart-contracts/pair#minimum-liquidity).

## InsufficientReservesError

```typescript
import { InsufficientReservesError } from '@uniswap/v2-sdk'
```

## InsufficientInputAmountError

```typescript
import { InsufficientInputAmountError } from '@uniswap/v2-sdk'
```
</file>

<file path="docs/sdk/v2/_category_.json">
{
  "label": "v2 SDK",
  "position": 6,
  "collapsed": true
}
</file>

<file path="docs/sdk/v2/overview.md">
---
id: overview
sidebar_position: 1
title: Overview
---

Welcome to the Uniswap Protocol v2 SDK. To begin, we recommend looking at the [**Guides**](./guides/01-quick-start.md) and for deeper reference see the [**v2 SDK GitHub**](https://github.com/Uniswap/v2-sdk) repo.


## Uniswap v2 SDK

- [**v2 SDK GitHub**](https://github.com/Uniswap/v2-sdk)
- [**SDK Core GitHub**](https://github.com/Uniswap/sdk-core)
- [**SDK NPM Package**](https://www.npmjs.com/package/@uniswap/v2-sdk)

[![Unit Tests](https://github.com/Uniswap/v2-sdk/workflows/Unit%20Tests/badge.svg)](https://github.com/Uniswap/v2-sdk/actions?query=workflow%3A%22Unit+Tests%22)
[![Lint](https://github.com/Uniswap/v2-sdk/workflows/Lint/badge.svg)](https://github.com/Uniswap/v2-sdk/actions?query=workflow%3ALint)
[![npm version](https://img.shields.io/npm/v/@uniswap/v2-sdk/latest.svg)](https://www.npmjs.com/package/@uniswap/v2-sdk/v/latest)
[![npm bundle size (scoped version)](https://img.shields.io/bundlephobia/minzip/@uniswap/v2-sdk/latest.svg)](https://bundlephobia.com/result?p=@uniswap/v2-sdk@latest)
</file>

<file path="docs/sdk/v3/guides/advanced/_category_.json">
{
  "label": "Advanced",
  "position": 6,
  "collapsed": true
}
</file>

<file path="docs/sdk/v3/guides/advanced/01-introduction.md">
---
id: introduction
title: Introduction
---

For some more advanced use cases, it is necessary to use multiple tools in the Uniswap toolchain.

:::info
If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](../01-background.md) page!
:::

The following examples use **ethersJS** and the **Uniswap V3 subgraph** hosted on The Graph's hosted service. To learn more about Uniswap's subgraphs, visit the [API](../../../../api/subgraph/overview.md) section.

We will take a deep dive into the Uniswap V3 protocol and use practical examples to understand the data stored by the Uniswap smart contracts.
We will explore how we can compute the available liquidity in a specific price range, visualize **liquidity density** in pools, use Uniswap as a **price oracle** and swap by creating **Range Orders**.

These guides are a bit longer than the previous ones and provide more theoretical background.

## Theoretical background

Some of the guides presented here require a bit of theoretical and mathematical background.
To get the most out of the advanced guides, we encourage you to take a step back and read a bit about the math and theories behind the Uniswap protocol.

The most complete source of information on the Uniswap protocol is the [Uniswap V3 book](https://uniswapv3book.com/).

Besides the [concepts](../../../../concepts/uniswap-protocol.md) section of the Docs, the [Uniswap V3 whitepaper](https://uniswap.org/whitepaper-v3.pdf) is a great introduction to the protocol.
If you haven't checked it out yet, it is probably more concise and easier to understand than you would expect.

### Datatypes in Solidity

Uniswap V3 pools make use of a number of Datatypes Solidity offers to efficiently store their state.
If you are not familiar with Solidity data types yet, it can help to take a look at the [Solidity language reference](https://docs.soliditylang.org/en/v0.8.7/types.html#).
For the following guides, it is beneficial to take a look at two of them, which  we will outline here.

Ticks are stored as a [mapping(int24 => Tick.Info)](https://github.com/Uniswap/v3-core/blob/main/contracts/UniswapV3Pool.sol#L93).
Solidity [mappings](https://docs.soliditylang.org/en/v0.8.7/types.html#mapping-types) are very similar to hash maps, such that we can access any Value with their key with just one read operation.
The [`Tick.Info`](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/Tick.sol#L17) stores the values of the Tick that we need to work with the Pool:

```solidity
struct Info {
        // the total position liquidity that references this tick
        uint128 liquidityGross;
        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),
        int128 liquidityNet;
        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
        // only has relative meaning, not absolute — the value depends on when the tick is initialized
        uint256 feeGrowthOutside0X128;
        uint256 feeGrowthOutside1X128;
        // the cumulative tick value on the other side of the tick
        int56 tickCumulativeOutside;
        // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)
        // only has relative meaning, not absolute — the value depends on when the tick is initialized
        uint160 secondsPerLiquidityOutsideX128;
        // the seconds spent on the other side of the tick (relative to the current tick)
        // only has relative meaning, not absolute — the value depends on when the tick is initialized
        uint32 secondsOutside;
        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0
        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks
        bool initialized;
    }
```

We will use most of these values in the following guides.

In our case, we can access any `Tick.Info` value stored in the pool by its `int24` key.
The key of the Tick is usually called its *index*.
Mappings are not iterable, so if we are trying to fetch all the Ticks stored in a Pool, we can't just iterate over the mapping.
Instead, we have to know the keys (indices) of the mapping, we will explore how to do that in the [Pool data guide](./02-pool-data.md).

The second Solidity datatype we need to understand are normal unsigned [Integers](https://docs.soliditylang.org/en/v0.8.7/types.html#integers).
Solidity supports unsigned integer sizes between `uint8` and `uint256`, which are 8 and 256 bits long respectively.

Let's take a look at the `tickBitmap` function of a V3 Pool:

```solidity
  function tickBitmap(
      int16 wordPosition
  ) external view returns (uint256)
```

Similar to the tick mapping, the tickBitmap is a mapping of type [mapping(int16 => uint256)](https://github.com/Uniswap/v3-core/blob/main/contracts/UniswapV3Pool.sol#L95).

Let's look at the WETH/USDC pool with LOW fee on [Etherscan](https://etherscan.io/address/0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640#readContract).
If we call the `tickBitmap` function with the input `0` we get the following response (at the time of writing):

<img src={require('./images/tickBitmap-etherscan.png').default} alt="TickBitmapEtherscan" box-shadow="none"/>

The `uint256` return value is interpreted as the representation of a decimal number by Etherscan.
The actual raw return value are 256 bits, that look something like this:

```raw
0x0000 ... lots of zeros and ones ... 000000110000000000
```

We interpret this string of zeros and ones not as the representation of a number, but rather as 256 booleans.

If the value of a position in the value is 1, the Tick at this position is **initialized**, meaning it holds a value.

With this trick, V3 Pools allow us to fetch the status of **256 ticks** with one call.
We will go into more details on how to calculate the tick indices from the tickBitmaps we fetch in the following guides.

## History of Uniswap

To get a better understanding of the V3 protocol, it can also be beneficial to understand the **history of decentralized exchanges** and the Uniswap protocol since it was founded in 2018.
You can read more about the older versions of Uniswap in the [V1](https://hackmd.io/@HaydenAdams/HJ9jLsfTz?type=view#Swaps-vs-Transfers) and [V2](https://uniswap.org/whitepaper.pdf) whitepapers, as well as the [V1](../../../../contracts/v1/overview.md) and [V2](../../../../contracts/v2/overview.md) section in the contract section.
</file>

<file path="docs/sdk/v3/guides/advanced/02-pool-data.md">
---
id: pool-data
title: Fetching Pool Data
---

## Introduction

This guide will cover how to initialize a Pool with full tick data to allow offchain calculations. It is based on the [Fetching Pool data example](https://github.com/Uniswap/examples/tree/main/v3-sdk/pool-data), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the guide's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/pool-data/README.md) and follow the setup instructions.

:::info
If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](../01-background.md) page!
:::

In this example we will use **ethers JS** and **ethers-multicall** to construct a `Pool` object that we can use in the following guides.

This guide will **cover**:

1. Computing the Pool's address
2. Referencing the Pool contract and fetching metadata
3. Fetching the positions of all initialized Ticks with multicall
4. Fetching all ticks by their indices with a multicall
5. Constructing the Pool object

At the end of the guide, we will have created a `Pool` Object that accurately represents the state of a V3 pool at the time we fetched it.

For this guide, the following Uniswap packages are used:
  
- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

We will also use the `ethers-multicall` npm package:

- [`ethers-multicall`](https://www.npmjs.com/package/ethers-multicall)

The core code of this guide can be found in [`fetcher.ts`](https://github.com/Uniswap/examples/tree/main/v3-sdk/multicall/src/libs/fetcher.ts)

## Configuration

The example accompanying this guide can be configured in the [`config.ts`](https://github.com/Uniswap/examples/tree/main/v3-sdk/multicall/src/config.ts) file.
The default configuration defines the rpc endpoint and the pool that is used for this guide:

```typescript
export const CurrentConfig: ExampleConfig = {
  env: Environment.MAINNET,
  rpc: {
    local: 'http://localhost:8545',
    mainnet: 'https://mainnet.infura.io/v3/0ac57a06f2994538829c14745750d721',
  },
  ...
  pool: {
    token0: USDC_TOKEN,
    token1: WETH_TOKEN,
    fee: FeeAmount.MEDIUM,
  },
}
```

FeeAmount.MEDIUM means that the pool has a swap fee of **0.3%**.
The `USDC_TOKEN` and `WETH_TOKEN` are defined in the [`constants.ts`](https://github.com/Uniswap/examples/tree/main/v3-sdk/multicall/src/libs/constants.ts) file:

```typescript
export const WETH_TOKEN = new Token(
  SupportedChainId.MAINNET,
  '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
  18,
  'WETH',
  'Wrapped Ether'
)

export const USDC_TOKEN = new Token(
  SupportedChainId.MAINNET,
  '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  6,
  'USDC',
  'USD//C'
)
```

## Computing the Pool's deployment address

In this example, we will construct the **USDC - WETH** Pool with **MEDIUM** fees. The SDK provides a method to compute the address:

```typescript
import { Pool } from '@uniswap/v3-sdk'
import { CurrentConfig } from '../config.ts'

const poolAddress = Pool.getAddress(
    CurrentConfig.pool.token0, 
    CurrentConfig.pool.token1, 
    CurrentConfig.pool.fee
  )
```

Uniswap V3 allows 4 different Fee tiers when deploying a pool, so multiple pools can exist for each pair of tokens.

## Creating a Pool Contract instance and fetching metadata

Now that we have the address of a **USDC - ETH** Pool, we can construct an instance of an **ethers** `Contract` to interact with it.
To construct the Contract we need to provide the address of the contract, its ABI and a provider connected to an [RPC endpoint](https://www.chainnodes.org/docs). We get access to the contract's ABI through the `@uniswap/v3-core` package, which holds the core smart contracts of the Uniswap V3 protocol:

```typescript
import { ethers } from 'ethers'
import IUniswapV3PoolABI from '@uniswap/v3-core/artifacts/contracts/interfaces/IUniswapV3Pool.sol/IUniswapV3Pool.json'

const provider = getProvider()
const poolContract = new ethers.Contract(
    poolAddress,
    IUniswapV3PoolABI.abi,
    provider
)
```

The `getProvider()` function returns an `ethers.providers.JsonRpcProvider` with either the local or mainnet rpc url that we defined, depending on the Environment that we set in `config.ts`.

Once we have set up our reference to the contract, we can proceed to access its methods. To construct our offchain representation of the Pool Contract, we need to fetch its liquidity, sqrtPrice, currently active tick and the full Tick data.
We get the **liquidity**, **sqrtPrice** and **tick** directly from the blockchain by calling `liquidity()`and `slot0()` on the Pool contract:

```typescript
const [liquidity, slot0] =
  await Promise.all([
    poolContract.liquidity(),
    poolContract.slot0(),
  ])
```

The [slot0 function](../../../../contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolState.md#slot0) represents the first (0th) storage slot of the pool and exposes multiple useful values in a single function:

```solidity
  function slot0(
  ) external view returns (
    uint160 sqrtPriceX96, 
    int24 tick, 
    uint16 observationIndex, 
    uint16 observationCardinality, 
    uint16 observationCardinalityNext, 
    uint8 feeProtocol, 
    bool unlocked
  )
```

For our use case, we only need the `sqrtPriceX96` and the currently active `tick`.

## Fetching all Ticks

V3 pools use ticks to [concentrate liquidity](../../../../concepts/protocol/concentrated-liquidity.md) in price ranges and allow for better pricing of trades.
Even though most Pools only have a couple of **initialized ticks**, it is possible that a pools liquidity is defined by thousands of **initialized ticks**.
In that case, it can be very expensive or slow to get all of them with normal RPC calls.

If you are not familiar with the concept of ticks, check out the [`introduction`](./01-introduction.md).

To access tick data, we will use the `ticks` function of the V3 Pool contract:

```solidity
  function ticks(
    int24 tick
  ) external view returns (
    uint128 liquidityGross, 
    int128 liquidityNet, 
    uint256 feeGrowthOutside0X128, 
    uint256 feeGrowthOutside1X128, 
    int56 tickCumulativeOutside, 
    uint160 secondsPerLiquidityOutsideX128, 
    uint32 secondsOutside, 
    bool initialized
  )
```

The `tick` parameter that we provide the function with is the **index** (memory position) of the Tick we are trying to fetch.
To get the indices of all initialized Ticks of the Pool, we can calculate them from the **tickBitmaps**.
To fetch a `tickBitmap` function of the V3 Pool:

```solidity
  function tickBitmap(
      int16 wordPosition
  ) external view returns (uint256)
```

A pool stores lots of bitmaps, each of which contain the status of 256 Ticks.
The parameter `int16 wordPosition` the function accepts is the position of the bitMap we want to fetch.
We can calculate all the position of bitMaps (or words as they are sometimes called) from the `tickSpacing` of the Pool, which is in turn dependant on the Fee tier.

So to summarise we need 4 steps to fetch all initialized ticks:

1. Calculate all bitMap positions from the tickSpacing of the Pool.
2. Fetch all bitMaps using their positions.
3. Calculate the memory positions of all Ticks from the bitMaps.
4. Fetch all Ticks by their memory position.

We will use multicalls for the fetch calls.

## Multicall

Multicall contracts **aggregate results** from multiple contract calls and therefore allow sending multiple contract calls in **one RPC request**.
This can improve the **speed** of fetching large amounts of data significantly and ensures that the data fetched is all from the **same block**.

We will use the Multicall2 contract by MakerDAO.
We use the `ethers-muticall` npm package to easily interact with the Contract.

## Calculating all bitMap positions

As mentioned, Uniswap V3 Pools store **bitmaps**, also called *words*, that represent the state of **256 initializable ticks** at a time.
The value at a bit of a word is 1 if the tick at this index is initialized and 0 if it isn't.
We can calculate the positions of initialized ticks from the **words** of the Pool.

All ticks of Uniswap V3 pools are between the indices `-887272` and `887272`.
We can calculate the minimum and maximum word from these indices and the Pool's tickSpacing:

```typescript
function tickToWord(tick: number): number {
  let compressed = Math.floor(tick / tickSpacing)
  if (tick < 0 && tick % tickSpacing !== 0) {
    compressed -= 1
  }
  return compressed >> 8
}

const minWord = tickToWord(-887272)
const maxWord = tickToWord(887272)
```

Ticks can only be initialized at indices that are **divisible by the tickSpacing**.
One word contains 256 ticks, so we can compress the ticks by right shifting 8 bit.

## Fetching bitMaps from their position

Knowing the positions of words in the Pool contract, we can now fetch them from the Pool using multicall and the `tickBitmap` read call.

First we initialize our multicall providers and Pool Contract:

```typescript
import { ethers } from 'ethers'
import { Contract, Provider } from 'ethers-multicall'

const ethersProvider = new ethers.providers.JsonRpcProvider("...rpcUrl")
const multicallProvider = new Provider(ethersProvider)
await multicallProvider.init()

const poolContract = new Contract(poolAddress, IUniswapV3PoolABI.abi)
```

The `multicallProvider` creates the multicall request and sends it via the ethers Provider.

Next we loop through all possible word positions and add a `tickBitmap` call for each:

```typescript
let calls: any[] = []
let wordPosIndices: number[] = []
for (let i = minWord; i <= maxWord; i++) {
  wordPosIndices.push(i)
  calls.push(poolContract.tickBitmap(i))
}
```

We also keep track of the word position indices to be able to loop through them in the same order we added the calls to the array.

We use the `multicallProvider.all()` function to send a multicall and map the results:

```typescript
const results: bigint[] = (await multicallProvider.all(calls)).map(
    (ethersResponse) => {
      return BigInt(ethersResponse.toString())
    }
  )
```

A great visualization of what the bitMaps look like can be found in the [Uniswap V3 development book](https://uniswapv3book.com/milestone_2/tick-bitmap-index.html):

<img src={require('./images/tickBitmap_cut.png').default} alt="TickBitmap" box-shadow="none"/>

We encourage anyone trying to get a deeper understanding of the Uniswap protocol to read the Uniswap V3 Book.

## Calculating the memory positions of all Ticks

Now that we fetched all **bitMaps**, we check which ticks are initialized and calculate the **tick position** from the **word index** and the **tickSpacing** of the pool.

We check if a tick is **initialized** inside the word by shifting a bit by the index we are looking at and performing a bitwise AND operation:

```typescript
const bit = 1n
const initialized = (bitmap & (bit << BigInt(i))) !== 0n
```

If the tick is **initialized**, we revert the compression from tick to word we made earlier by multiplying the word index with 256, which is the same as left shifting by 8 bit, adding the position we are currently at, and multiplying with the tickSpacing:

```typescript
const tickIndex = (ind * 256 + i) * tickSpacing
```

The whole loop looks like this:

```typescript
const tickIndices: number[] = []

  for (let j = 0; j < wordPosIndices.length; j++) {
    const ind = wordPosIndices[j]
    const bitmap = results[j]

    if (bitmap !== 0n) {
      for (let i = 0; i < 256; i++) {
        const bit = 1n
        const initialized = (bitmap & (bit << BigInt(i))) !== 0n
        if (initialized) {
          const tickIndex = (ind * 256 + i) * tickSpacing
          tickIndices.push(tickIndex)
        }
      }
    }
  }
```

We now have an array containing the indices of all initialized Ticks.

## Fetching all Ticks by their indices

We use the multicallProvider again to execute an aggregated read call for all tick indices.
We create an array of call Promises again and use `.all()` to make our multicall:

```typescript
const calls: any[] = []

for (const index of tickIndices) {
  calls.push(poolContract.ticks(index))
}

const results = await multicallProvider.all(calls)
```

Again, the order of the results array is the same as the elements in **tickIndices**.

We are able to combine the **tickIndices** and **results** array to create an array of `Tick` objects:

```typescript
const allTicks: Tick[] = []

  for (let i = 0; i < tickIndices.length; i++) {
    const index = tickIndices[i]
    const ethersResponse = results[i]
    const tick = new Tick({
      index,
      liquidityGross: JSBI.BigInt(ethersResponse.liquidityGross.toString()),
      liquidityNet: JSBI.BigInt(ethersResponse.liquidityNet.toString()),
    })
    allTicks.push(tick)
  }
```

We need to parse the response from our RPC provider to JSBI values that the v3-sdk can work with.

## Constructing the Pool

We have everything to construct our `Pool` now:

```typescript
const usdcWethPool = new Pool(
    USDC,
    WETH,
    feeAmount,
    slot0.sqrtPriceX96,
    liquidity,
    slot0.tick,
    allTicks
)
```

With this fully initialized Pool, we can make accurate offchain calculations.

## Next Steps

Now that you are familiar with fetching Pool data, continue your journey with the [next example](./03-active-liquidity.md) on visualizing the Liquidity density of a pool.
</file>

<file path="docs/sdk/v3/guides/advanced/03-active-liquidity.md">
---
id: active-liquidity
title: Active Liquidity
---

## Introduction

This guide will cover how to fetch and compute the active liquidity in the specific Tick ranges of a pool. It is based on the [Liquidity Density example](https://github.com/Uniswap/examples/tree/main/v3-sdk/pool-data) and can be seen used in production, albeit in a more sophisticated way, in the [Uniswap Analytics](https://info.uniswap.org/#/pools) website.

:::info
If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](../01-background.md) page!
:::

In this guide, we will use the V3 subgraph to fetch all ticks from **theGraph** and compute the active liquidity our Pool can use at each Tick. We then use `recharts` to draw a chart that visualizes our Pool's liqudity density.

This guide will cover:

1. Getting the tickSpacing and currently active Tick from the Pool
2. Calculating active liquidity from net liquidity
3. Drawing a chart from the Tick data

This guide will not cover:

- Specifics of working with the recharts library. You can read more about that [here](https://recharts.org/en-US/).

At the end of the guide, we should be able to visualize the liquidity of any V3 Pool.

## Understanding Active Liquidity

To visualize the distribution of active liquidity in our Pool, we want to draw our Chart around the currently active Tick. For that we have to first understand:

- What is an initialized Tick?
- What is the current Tick?

### Initialized Ticks

When providing liquidity for a pool, the LP decides the **price range** in which the liquidity should be provided, and the amount of liquidity to be provided.
The pool understands the position as **liquidity between the lower and upper Tick**. The Tick Index in this context is a representation of the price between the Pool's assets.

Looking at this [visualization](https://www.desmos.com/calculator/oduetjzfp4) of multiple positions in a V3 Pool, we can see that the liquidity available for a swap does not change inside a position, but when crossing into the next position.
This is what the **Initialized Ticks** of a Pool represent - they are a representation of the start or end of one or more positions.

<img src={require('./images/liquidityNetComparison.png').default} alt="LiquidityNet1" box-shadow="none"/>

When entering or leaving a position, its liquidity is added or removed from the **active liquidity available** for a Swap.
The initialized Ticks store this **change in available liquidity** in the `liquidityNet` field.
The change is always stored in relation to the currently active Tick - the current price.
When the price crosses an initialized Tick, it gets updated and liqudity that was previously added when crossing the Tick would now be removed and vice versa.

The `liquidityGross` value represents the gross value of liquidity referencing the tick.
This is important for the edge case that one position ends at a Tick and a second position with exactly the same liquidity value would start at the Tick.
In this case `liquidityNet` would be **0** but `liquidityGross` would still have a value, which ensures that the Tick is not deleted from the Pool.

To visualize liquidity in a graph, we will only need to consider the changes, so it's sufficient to fetch the Ticks with `liquidityNet` not 0.

### Fetching initialized Ticks

To fetch all ticks of our Pool, we will use the [Uniswap V3 graph](../../../../api/subgraph/overview.md).
To visualize active liquidity, we need the **tickIdx**, the **liquidityGross** and the **liquidityNet**.

We define our GraphQL query and [send a POST request](https://axios-http.com/docs/post_example) to the V3 subgraph API endpoint:

```typescript
axios.post(
        "https://gateway.thegraph.com/api/${api_key}/subgraphs/id/5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV",
        {"query": `{ ticks(
              where: {poolAddress: "${poolAddress.toLowerCase()}", liquidityNet_not: "0"}
              first: 1000,
              skip: ${skip},
              orderBy: tickIdx,
              orderDirection: asc
            ) {
              tickIdx
              liquidityGross
              liquidityNet
            }
          }`
        },
        {
            headers: {
                "Content-Type": "application/json"
            }
        }
    )
```

We only fetch the ticks that **have liquidity**, and we convert the poolAddress to **lower case** for the subgraph to work with. To make sure the Ticks are ordered correctly, we also define the **order direction** in the query.

:::note
GraphQL is only able to fetch 1000 records at a time. If a pool has more than 1000 initialized ticks, multiple calls are necessary to get all of them.
:::

The ticks we got from **theGraph** have this format:

```typescript
interface GraphTick {
    tickIdx: string
    liquidityGross: string
    liquidityNet: string
}
```

### Current Tick

The current Tick of the Pool represents the **current Price** after the last swap.
Considering that the initialized Ticks only represent positions, we see that it is not necessarily one of the initialized Ticks but can be at any point in between them.
The active liqudity at the current Price is also stored in the smart contract - we already fetched it with the `liquidity` function in the [previous guide](./02-pool-data.md).

### Tickspacing

Only the Ticks with indices that are divisible with 0 remainder by the tickspacing of a Pool are initializable.
This is a convention defined by the protocol to save gas.
The Tickspacing of the Pool is dependent on the Fee Tier.
Pools with lower fees are meant to be used for more stable Token Pairs and allow for more granularity in where LPs position their liquidity.

We can get the `tickSpacing` from the `TICK_SPACINGS` enum exposed by the `v3-sdk`:

```typescript
import { TICK_SPACINGS }

const tickSpacing = TICK_SPACINGS[fee]
```

Alternatively, if we have already constructed a `Pool` object, we could just call `Pool.tickSpacing()`.

### Putting it all together

For the purpose of visualizing the liquidity density of the Pool, it rarely makes sense to display the full Tick Range of the Pool, as the vast majority of liquidity will be focused in a narrow price range.

Instead, we will display a sensible number of Ticks around the current price.

## Calculating active liquidity

We know the spacing between Ticks and the Initialized Ticks where active liquidity changes.
All we have to do is start calculating from the current Tick and iterate outwards.

The code mentioned in the following snippets can be found in [`active-liquidity.ts`](https://github.com/Uniswap/examples/tree/main/v3-sdk/pool-data/src/libs/active-liquidity.ts).

To draw our chart we want a data structure that looks something like this:

```typescript
interface TickProcessed {
    tickIdx: number,
    liquidityActive: JSBI,
    liquidityNet: JSBI,
    price0: string,
    price1: string,
    isCurrent: boolean
}
```

To access the initialized Ticks directly from their Tick Index, we store them in a [Record](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type):

```typescript
const tickIdxToTickDictionary: Record<string, GraphTick> = Object.fromEntries(
    ticks.map((graphTick) => [graphTick.tickIdx, graphTick])
  ) 
```

The `ticks` variable in this code snippet is the result we got from the V3 Subgraph earlier.

We want to mark the Tick closest to the current Price and we want to be able to display the prices at a Tick to the user.
We calculate the **initializable Tick** closest to the current price and create the active Tick that we start from:

```typescript
import { tickToPrice } from '@uniswap/v3-sdk'

const activeTickIdx = Math.floor(pool.tickCurrent / tickSpacing) * tickSpacing

const activeTickProcessed: TickProcessed = {
    tickIdx: activeTickIdx,
    liquidityActive: pool.liquidity,
    liquidityNet: JSBI.BigInt(0),
    price0: tickToPrice(tokenA, tokenB, activeTickIdx).toFixed(6),
    price1: tickToPrice(tokenB, tokenA, activeTickIdx).toFixed(6),
    isCurrent: true
}
```

Here we also calculate the price of the tokens from the tickIdx, the `v3-sdk` exports a handy utility function for that, `tickToPrice`.
We store the Price as a string as we won't make any further calculations in this example. We will instead use it to display prices in the tooltip of our chart.
Notice how the `price0` is the Price of tokenA in terms of tokenB and the `price1` is the Price of tokenB in terms of tokenA **at the specified Tick**.

If the **current Tick is initialized**, we also need to set the **liquidityNet** to correctly handle moving out of the position:

```typescript
const currentTickInitialized = tickIdxToTickDictionary[activeTickIdx]
if (currentTickInitialized !== undefined) {
    activeTickProcessed.liquidityNet = JSBI.BigInt(currentTickInitialized.liquidityNet)
}
```

We now start iterating outwards from the active Tick and compute the active liquidity for each Tick we want to display. The processed Tick is then saved in an Array of `TickProcessed`.
We choose an arbitrary number of Ticks we want to display, for this example we calculate 100 Ticks in each direction.

```typescript
import { TickMath, tickToPrice } from '@uniswap/v3-sdk'

let previousTickProcessed = {
    ...activeTickProcessed
}

processedTicks: TickProcessed[] = []

for (let i = 0; i < 100; i++) {
    const currentTickIdx = previousTickProcessed.tickIdx + tickSpacing

    if (currentTickIdx > TickMath.MAX_TICK) {
        break
    }

    const currentTickProcessed = {
        liquidityActive: previousTickProcessed.liquidityActive,
        tickIdx: currentTickIdx,
        liquidityNet: JSBI.BigInt(0),
        price0: tickToPrice(token0, token1, currentTickIdx),
        price1: tickToPrice(token1, token0, currentTickIdx),
        isActive: false
    }
    
    ...
}
```

We calculate one Tick at a time, and we need to make sure our Tick stays inside the possible price range by checking against `TickMath.MAX_TICK`.
Again, we check if our current Tick is initialized and if so, recalculate the active liquidity:

```typescript
for (let i = 0; i < 100; i++) {

    ...

    const currentTickInitialized = tickIdxToTickDictionary[currentTickIdx]

    if (currentTickInitialized !== undefined) {
        currentTickProcessed.liquidityNet = JSBI.BigInt(currentTickInitialized.liquidityNet)
        currentTickProcessed.liquidityActive = JSBI.add(
            previousTickProcessed.liquidityActive,
            JSBI.BigInt(currentTickInitialized.liquidityNet)
        )
    }

    processedTicks.push(currentTickProcessed)
    previousTickProcessed = currentTickProcessed
}
```

After we are done calculating the next 100 Ticks after the current Tick, we iterate in the opposite direction for the previous Ticks. Iterating downwards, we need to subtract the net liquidity where we added it when iterating upwards.
You can find a full code example in the [Uniswap Example repository](https://github.com/Uniswap/examples/blob/main/v3-sdk/pool-data/src/libs/active-liquidity.ts).

We are finally able to combine the previous, active and subsequent Ticks:

```typescript
const allProcessedTicks = previousTicks.concat(activeTickProcessed).concat(subsequentTicks)
```

## Drawing the Chart

We are done with our calculations and move on to displaying the data. **Recharts** is not able to handle JSBI, so we need to convert the Array we created to a format it can handle:

```typescript
const chartTicks: TicksChart[] = allProcessedTicks.map((tickProcessed) => {
    return {...processedTick, liquidityActiveChart: parseFloat(tickProcessed.liquidityActive.toString())}
})
```

The loss of precision will not be visually noticeable in the chart and we are still able to display the exact number in a Tooltip if we wish to.
Liquidity is stored in a `uint128` format onchain, so the maximum loss of precision will be far smaller than the number of decimals of almost any ERC20 Token.

Finally, we draw the Chart:

```jsx
<ResponsiveContainer width="80%" height={400}>
    <BarChart>
        <XAxis />
        <YAxis />
        <Bar dataKey="liquidityActiveChart" fill="#2172E5">
            {chartTicks.map((entry, index) => {
                return (
                <Cell
                   key={`cell-${index}`}
                   fill={entry.isActive ? '#F51E87' : '#2172E5'}
                />
                )
            })}
        </Bar>
    </BarChart>
</ResponsiveContainer>
```

In a real application, you will probably want to format the chart properly and display additional information for users.
Check out the full [code example](https://github.com/Uniswap/examples/blob/main/v3-sdk/pool-data/src/libs/active-liquidity.ts) to this guide and the official recharts [documentation](https://recharts.org/).

You can also take a look at the [Uniswap Info](https://github.com/Uniswap/v3-info) repository to see a similar chart used in production.

## Locked Liquidity

If you run the example, you will notice that the chart also displays a custom tooltip with additional information that we didn't touch on in this example.
The total locked liqudity in the tooltip represents the sum of positions in the currency locked at the selected Tick.
It is calculated as the maximum token output of a swap when crossing to the next Tick.
The V3 pool here is initialized with only the liquidity of the current Tick.

Depending on your use case, it may make sense to display this value. You can find the full code in the [code example](https://github.com/Uniswap/examples/blob/main/v3-sdk/pool-data/src/libs/active-liquidity.ts).

## Next Steps

Now that you are familiar with liquidity data, consider checking out our [next guide](./04-price-oracle.md) on using Uniswap as a Price Oracle.
</file>

<file path="docs/sdk/v3/guides/advanced/04-price-oracle.md">
---
id: price-oracle
title: Uniswap as a Price Oracle
---

## Introduction

This guide will cover how to fetch price observations from a V3 pool to get onchain asset prices.
It is based on the [Price Oracle example](https://github.com/Uniswap/examples/tree/main/v3-sdk/oracle), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples).
To run this example, check out the guide's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/oracle/README.md) and follow the setup instructions.

:::info
If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](../01-background.md) page!
:::

In this example we will use **ethers JS** to observe the development of a Pool's current tick over several blocks.
We will then calculate the time weighted average price - **TWAP**, and time weighted average liquidity - **TWAL** over the observed time interval.

This guide will **cover**:

1. Understanding observations
2. Fetching observations
3. Computing TWAP
4. Computing TWAL
5. Why prefer observe over observations

Before diving into this guide, consider reading the theory behind using Uniswap V3 as an [Onchain Oracle](../../../../concepts/protocol/oracle.md).

For this guide, the following Uniswap packages are used:
  
- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)

The core code of this guide can be found in [`oracle.ts`](https://github.com/Uniswap/examples/tree/main/v3-sdk/oracle/src/libs/oracle.ts)

## Understanding Observations

First, we need to create a Pool contract to fetch data from the blockchain. Check out the [Pool data guide](./02-pool-data.md) to learn how to compute the address and create an **ethers Contract** to interact with.

```typescript
const poolContract = new ethers.Contract(
    poolAddress,
    IUniswapV3PoolABI.abi,
    provider
)
```

All V3 pools store observations of the current tick and the block timestamp. 
To minimize pool deployment costs, only one Observation is stored in the contract when the Pool is created.
Anyone who is willing to pay the gas costs can [increase](../../../../contracts/v3/reference/core/UniswapV3Pool.md#increaseobservationcardinalitynext) the number of stored observations to up to `65535`.
If the Pool cannot store an additional Observation, it overwrites the oldest one.

We create an interface to map our data to:

```typescript
interface Observation {
    secondsAgo: number
    tickCumulative: bigint
    secondsPerLiquidityCumulativeX128: bigint
}
```

To fetch the `Observations` from our pool contract, we will use the [`observe`](../../../../contracts/v3/reference/core/UniswapV3Pool.md#observe) function:

```solidity
function observe(
    uint32[] secondsAgos
) external view override noDelegateCall returns (
    int56[] tickCumulatives, 
    uint160[] secondsPerLiquidityCumulativeX128s
)
```

We first check how many observations are stored in the Pool by calling the `slot0` function.

```typescript
const slot0 = await poolContract.slot0()

const observationCount = slot0.observationCardinality
const maxObservationCount = slot0.observationCardinalityNext
```

The `observationCardinalityNext` is the maximum number of Observations the Pool **can store** at the moment.
The `observationCardinality` is the actual number of Observations the Pool **has currently stored**.

Observations are only stored when the `swap()` function is called on the Pool or when a **Position is modified**, so it can take some time to write the Observations after the `observationCardinalityNext` was increased.
If the number of Observations on the Pool is not sufficient, we need to call the `increaseObservationCardinalityNext()` function and set it to the value we desire.

This is a write function as the contract needs to store more data on the blockchain.
We will need a **wallet** or **signer** to pay the corresponding gas fee.

In this example, we want to fetch 10 observations.

```typescript
import { ethers } from 'ethers'

let provider = new ethers.providers.WebSocketProvider('rpcUrl...')
let wallet = new ethers.Wallet('private_key', provider)

const poolContract = new ethers.Contract(
    poolAddress,
    IUniswapV3PoolABI.abi,
    wallet
)

const txRes = await poolContract.increaseObservationCardinalityNext(10)
```

The Pool will now fill the open Observation Slots.
As someone has to pay for the gas to write the observations, writing to the array of observations is part of the `swap()` and the `modifyPosition()` function of the Pool.

:::note
Saving an Observation is a write operation on the blockchain and therefore costs gas.
This means that the pool will only be able to save observations for blocks where write calls are executed on the Pool contract.
If no Observation is stored for a block, it is calculated as the time weighted arithmetic mean between the two closest Observations.
Because of this, we can be sure the oldest Observation is **at least** 10 blocks old.
It is very likely that the number of blocks covered is bigger than 10.
:::

## Fetching Observations

We are now sure that at least 10 observations exist, and can safely fetch observations for the last 10 blocks.
We call the `observe` function with an array of numbers, representing the timestamps of the Observations in seconds ago from now.

In this example, we calculate averages over the last ten blocks so we fetch 2 observations with 9 times the blocktime in between.
Fetching an Observation `0s` ago will return the **most recent Observation** interpolated to the current timestamp as observations are written at most once a block.

```typescript
const timestamps = [
    0, 108
]

const [tickCumulatives, secondsPerLiquidityCumulatives] = await poolContract.observe(timestamps)

const observations: Observation[] = timestamps.map((time, i) => {
    return {
        secondsAgo: time
        tickCumulative: BigInt(tickCumulatives[i])
        secondsPerLiquidityCumulativeX128: BigInt(secondsPerLiquidityCumulatives[i]) 
    }
})
```

We map the response from the RPC provider to match our Observations interface.

## Calculating the average Price

To calculate the time weighted average price (TWAP) in the period we fetched, we first need to understand what the values we fetched mean.

The `tickCumulative` value is a snapshot of the `tick accumulator` at the timestamp we fetched. The Tick Accumulator stores the sum of all current ticks at every second since the Pool was initialised. Its value is therefore increasing with every second.

We cannot directly use the value of a single Observation for anything meaningful. Instead we need to compare the **difference** between two Observations and calculate the **time weighted arithmetic mean**.

```typescript
const diffTickCumulative = observations[0].tickCumulative - observations[1].tickCumulative
const secondsBetween = 108

const averageTick = diffTickCumulative / secondsBetween
```

Now that we know the average active Tick over the last 10 blocks, we can calculate the price with the `tickToPrice` function, which returns a [`Price`](../../../core/reference/classes/Price.md) Object. Check out the [Pool data](./02-pool-data.md) guide to understand how to construct a Pool Object and access its properties. We don't need the full Tick Data for this guide.

```typescript
import { tickToPrice, Pool } from '@uniswap/v3-sdk'

const pool = new Pool(...)

const TWAP = tickToPrice(pool.token0, pool.token1, averageTick)
```

We have now calculated the **time weighted average price** over the last 108 seconds.

Let's continue with the average liquidity.

## Calculating the average Liquidity

To understand the term **active Liquidity**, check out the [previous guide](./03-active-liquidity.md).
Similar to the `tick accumulator`, the `liquidity accumulator` stores a sum of values for every second since the Pool was initialized and increases with every second.
Because of the size of the active liquidity value, it is impractical to just add up the active liquidity. Instead the **seconds per liquidity** are summed up.

The `secondsPerLiquidityX128` value is calculated by shifting the seconds since the last Observation by 128 bits and dividing that value by the active liquidity. It is then added to the accumulator.

```solidity
uint32 delta = blockTimestamp - last.blockTimestamp;

uint128 secondsPerLiquidityX128 = (uint160(delta) << 128) / liquidity
uint160 secondsPerLiquidityCumulativeX128 = last.secondsPerLiquidityCumulativeX128 + secondsPerLiquidityX128
```

`last` is the most recent Observation in this illustrative code snippet. Consider taking a look at the [Solidity Oracle library](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/Oracle.sol) to see the actual implementation.

Let's invert this calculation and find the average active liquidity over our observed time period.

```typescript
const diffSecondsPerLiquidityX128 = observations[0].secondsPerLiquidityCumulativeX128 -
                    observations[1].secondsPerLiquidityCumulativeX128
const secondsBetweenX128 = BigInt(108) << 128

const TWAL =  secondsBetweenX128 / diffSecondsPerLiquidityX128
```

This **time weighted average liquidity** is the harmonic mean over the time period observed.

:::note
The costs associated with manipulating/ changing the liquidity of a Pool are **orders of magnitude smaller** than with manipulating the price of the assets, as **prices** will be arbitraged for assets **with more than one market**.
Adding massive amounts of liquidity to a Pool and withdrawing them after a block has passed more or less only costs gas fees.

Use the **TWAP** with care and consider handling outliers.
:::

## Why prefer observe over observations?

As touched on previously, the `observe` function calculates Observations for the timestamps requested from the nearest observations stored in the Pool.
It is also possible to directly fetch the stored observations by calling the `observations` function with the index of the Observation that we are interested in.

Let's fetch all observations stored in our Pool. We already made sure the observationCardinality is 10.
The solidity struct `Observation` looks like this:

```solidity
struct Observation {
    // the block timestamp of the observation
    uint32 blockTimestamp;
    // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized
    int56 tickCumulative;
    // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized
    uint160 secondsPerLiquidityCumulativeX128;
    // whether or not the observation is initialized
    bool initialized;
}
```

It is possible to request any Observation up to (excluding) index `65535`, but indices equal to or greater than the `observationCardinality` will return uninitialized Observations.

The full code to the following code snippets can be found in [`oracle.ts`](https://github.com/uniswap/examples/blob/main/v3-sdk/oracle/src/libs/oracle.ts)

```typescript
let requests = []
for (let i = 0; i < 10; i++) {
    requests.push(poolContract.observations(i))
}

const results = await Promise.all(requests)
```

We can only request one Observation at a time, so we create an Array of Promises to get an Array of Observations.

We already see one difference, to using the `observe` function here.
While `observe` creates an array onchain in the smart contract and returns it, calling `observations` requires us to make multiple RPC calls.

:::note
Depending on our setup and the Node we are using, either option can be faster, but making multiple RPC calls always has the danger of the blockchain state changing between our calls.
While it is extremely unlikely, it is still possible that our Node updates with a new block and new Observation in between our calls.
Because we access indices of an array, this would give us an unexpected result that we need to handle as an edge case in our implementation.
:::

One way to handle this behaviour is deploying or [using](https://github.com/mds1/multicall) a Contract with a [multicall](https://solidity-by-example.org/app/multi-call/) functionality to get all observations with one request.
You can also find an example of a JS multicall in the [Pool data guide](./02-pool-data.md).

We map the RPC result to the Typescript interface that we created:

```typescript
const utcNow = Math.floor(Date.now() / 1000)
const observations = results.map((result) => {
    const secondsAgo = utcNow - Number(result.blockTimeStamp)
    return {
        secondsAgo,
        tickCumulative: BigInt(result.tickCumulative),
        secondsPerLiquidityCumulativeX128: BigInt(result.secondsPerLiquidityCumulativeX128) 
    }
}).sort((a, b) => a.secondsAgo - b.secondsAgo)
```

We now have an Array of observations in the same format that we are used to.

:::note
Because Observations are stored in a **fixed size array** with always the oldest Observation overwritten if a new one is stored, they are **not sorted**.
We need to sort the result by the timestamp.
:::

The timestamps of the Observations we got are correspondent to blocks where **Swaps or Position changes** happened on the Pool.
Because of this, we would need to calculate Observations for specific intervals manually from the **surrounding Observations**.

In conclusion, it is much harder to work with `observations` than with `observe`, and we need to consider multiple edge cases.
For this reason, it is recommended to use the `observe` function.

## Next Steps

Now that you are familiar with the Oracle feature of Uniswap, consider checking out the [next guide](./05-range-orders.md) on **Range Orders**.
</file>

<file path="docs/sdk/v3/guides/advanced/05-range-orders.md">
---
id: range-orders
title: Range Orders
---

## Introduction

This guide will cover how single-side liquidity provisioning can be used to execute **Limit Orders** on Uniswap V3 Pools.
An example to showcase this concept can be found in the [Range Order example](https://github.com/Uniswap/examples/tree/main/v3-sdk/range-order), in the Uniswap code examples [repository](https://github.com/Uniswap/example).
To run this example, check out the guide's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/price-oracle/README.md) and follow the setup instructions.

:::info
This guide builds on top of the [Pooling Liquidity guides](../liquidity/01-position-data.md).
We recommend going through this section of the docs before imnplementing Range Orders.
:::

In this example we will create a single-side liquidity position with the [NonfungiblePositionManager](../../../../contracts/v3/reference/periphery/NonfungiblePositionManager.md) contract.
We will then use **ethers JS** to observe the price of the Pool on new blocks and withdraw the liquidity when our target is reached.

This guide will **cover**:

1. Understanding Range Orders
2. Calculating our Tick Range
3. Creating a single-side liquidity position
4. Observing the price of the Pool
5. Closing the Limit Order

Before working through this guide, consider checking out the Range Orders [concept page](../../../../concepts/protocol/range-orders.md) to understand how Limit orders can be executed with Uniswap V3.

For this guide, the following Uniswap packages are used:
  
- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

The core code of this guide can be found in [`range-order.ts`](https://github.com/Uniswap/examples/tree/main/v3-sdk/range-order/src/libs/range-order.ts).

## Understanding Range Orders

If you have read the [Range Order Concept page](../../../../concepts/protocol/range-orders.md), you can skip this section.

Positions on a V3 Pool are always created with a Tick range in which their liquidity is accessible to swaps on the Pool.
Lets look at the return value of the NonfungiblePositionManager contract when calling the `positions` function with a Position `tokenId`.

```solidity
function positions(
    uint256 tokenId
  ) external view returns (
    uint96 nonce, 
    address operator, 
    address token0, 
    address token1, 
    uint24 fee, 
    int24 tickLower,    // Lower Boundary of Position
    int24 tickUpper,    // Upper Boundary of Position
    uint128 liquidity,  // Liquidity
    uint256 feeGrowthInside0LastX128, 
    uint256 feeGrowthInside1LastX128, 
    uint128 tokensOwed0, 
    uint128 tokensOwed1
    )
```

We see that a position only stores a single `liquidity` value, and a `tickLower` and `tickUpper` value that define the range in which the liquidity of the Position can be utilised for Swaps.
The actual **amount** of `token0` and `token1` that a Pool owes the Position owner is calculated from the parts of the liquidity position that are to the left and right of the current Tick.
Liquidity left of the current Tick is denominated in `token0` and liquidity right of the current Tick is denominated in `token1`.

If a new Position is created and the Tick Range of the position does not include the current Tick of the Pool, only one of the two Tokens in the Pool can be provided.

We will call this a **Single Side Liquidity Position**.

<img src={require('./images/range-order.png').default} alt="RangeOrder" box-shadow="none"/>

When the current Tick of the Pool moves across the Position, the ratio of `token0` and `token1` will change, and ultimately inverse if the current Tick moves out of the position on the other side.

We will utilise this behaviour to provide liquidity with `token1` and withdraw the position when it has been converted to `token0`.

## Calculating the Tick Range

Our goal for this guide is to create a [Take Profit Order](../../../../concepts/protocol/range-orders.md#take-profit-orders) that trades `token0` for `token1` when the Price of `token0` increases by 5%.
To create our Position, we need to first decide the Tick Range that we want to provide liquidity in.

### Upper Tick

We [create a Pool](./02-pool-data.md) that represents the V3 Pool we are interacting with and get the `token0Price`.
We won't need full tick data in this example.

```typescript
import { Pool } from '@uniswap/v3-sdk'

... 
const pool = new Pool(token0, token1, fee, sqrtPriceX96, liquidity, tickCurrent)

const currentPrice = pool.token0Price
```

Next we increase the `Price` by 5%. We create a new Price with a numerator 5% higher than our current Price:

```typescript
import { Price, Fraction } from '@uniswap/sdk-core'

const targetFraction = Price.asFraction.multiply(new Fraction(100 + 5, 100))

const targetPrice = new Price(
    currentPrice.baseCurrency,
    currentPrice.quoteCurrency,
    targetFraction.denominator,
    targetFraction.numerator
)
```

Be aware that the `numerator` and `denominator` parameters are ordered differently in the `Fraction` and `Price` constructor.

We have calculated our target Price but we still need to find the **nearest usable tick** to create our Position.

:::info
As Positions can only start and end at initializable Ticks of the Pool, so we can only create a Range Order to a Price that exactly matches an initializable Tick.
:::

We use the `priceToClosestTick` function to find the closest tick to our targetPrice. 
We then use the `nearestUsableTick` function to find the closest initializable Tick for the `tickSpacing` of the `Pool`.

```typescript
import {priceToClosestTick, nearestUsableTick} from '@uniswap/v3-sdk'

let targetTick = nearestUsableTick(
    priceToClosestTick(targetPrice),
    pool.tickSpacing
)
```

This nearest Tick will most likely not **exactly** match our Price target.

Depending on our personal preferences we can either err on the higher or lower side of our target by adding or subtracting the `tickSpacing` if the initializable Tick is lower or higher than the theoretically closest Tick.

### Lower Tick

We now find the lower Tick by subtracting the tickSpacing from the upper Tick:

```typescript
let lowerTick = targetTick - pool.tickSpacing
```

If the price difference is too low, the lower tick may be left of the current Tick of the Pool.
In that case we would not be able to provide single side liquidity.
We can either throw an Error or increase our Position by one Tick.

```typescript
if (tickLower <= pool.tickCurrent) {
    tickLower += pool.tickSpacing
    targetTick += pool.tickSpacing
}
```

We now have a lower and upper Tick for our Position, next we need to construct and mint it.

## Creating the Single Side Liquidity Position

We will use the `NonfungiblePositionManager` and `Position` classes from the `v3-sdk` to construct our position. We then use an **etherJS** wallet to mint our Position onchain.

If you are not familiar with liquidity Positions, check out the [liquidity position guides](../liquidity/01-position-data.md).

### Minting the Position

We create a `Position` object with our ticks and the amount of tokens we want to deposit:

```typescript
import { Position } from '@uniswap/v3-sdk'

const position = Position.fromAmount0({
    pool: pool,
    tickLower: tickLower,
    tickUpper: targetTick,
    amount0: amount,
    useFullPrecision: true
})
```

Before we mint our position, we need to give the `NonfungiblePositionManager` Contract an approval to transfer our tokens.
We can find the Contract address on the official [Uniswap GitHub](https://github.com/Uniswap/v3-periphery/blob/main/deploys.md).
For local development, the contract address is the same as the network we are forking from.
So if we are using a local fork of mainnet like described in the [Local development guide](../02-local-development.md), the contract address would be the same as on mainnet.

```typescript
import ethers from 'ethers'

const provider = new ethers.providers.JsonRpcProvider(rpcUrl)
const wallet = new ethers.Wallet(privateKey, provider)

const tokenContract = new ethers.Contract(
    pool.token0.address,
    ERC20_ABI,
    wallet
)

await tokenContract['approve'](
    NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
    ethers.BigNumber.from(amount)
    )
```

Once we have our approval, we create the calldata for the **Mint** call using the `NonfungiblePositionManager`:

```typescript
import {MintOptions, NonfungiblePositionManager}
import { Percent } from '@uniswap/sdk-core'

const mintOptions: MintOptions = {
    recipient: wallet.address,
    deadline: Math.floor(Date.now() / 1000) + 60 * 20,
    slippageTolerance: new Percent(50, 10_000),
}

const { calldata, value } = NonfungiblePositionManager.addCallParameters(
    order.position,
    mintOptions
)
```

We can populate our mint transaction and send it with our wallet:

```typescript
 const transaction = {
    data: calldata,
    to: NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
    value: ethers.BigNumber.from(value),
    from: address,
    maxFeePerGas: MAX_FEE_PER_GAS,
    maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,
  }

const txRes = await wallet.sendTransaction(transaction)
```

You can find full code examples for these code snippets in [`range-order.ts`](https://github.com/uniswap/examples/blob/main/v3-sdk/range-order/src/libs/range-order.ts).

### Getting the tokenId

We want to read the response to our `Mint` function call to get **the position id**.
We will need the positionId to fetch the Position Info from the NFTPositionManager contract.
We wait for the transaction receipt and fetch the result using `trace_transaction`:

```typescript
let receipt = null
let mintCallOutput

while (receipt === null) {
    try {
        receipt = await provider.getTransactionReceipt(txRes.hash)

        if (receipt === null) {
            continue
        } else {
            const callTraces = await provider.send('trace_transaction', [
                txRes.hash
            ])
            mintCallOutput = callTraces[0].result.output
        }
    } catch (e) {
        break
    }
}
```

Your Node provider may not support this call. In that case you can also call the NonfungiblePositionManager Contract with the wallet address and identify the Range Order Position manually:

```typescript
const mintCallOutput = await wallet.call(transaction)
```

We get a raw byte string as a return value from this function and have to parse it ourselves.
We decode the result with the **ethers AbiCoder**. The solidity function has this signature:

```solidity
function mint(
    struct INonfungiblePositionManager.MintParams params
) external returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1)
```

So we need the first parameter to get the `tokenId`:

```typescript
const decodedOutput = ethers.utils.defaultAbiCoder.decode(
    ['tuple(uint256, uint128, uint256, uint256)'],
    mintCallOutput
  )[0]

const tokenId = decodedOutput.toString()
```

Ethers handles the string decoding of the byte string we got and parses it to its internal datatypes.
The decodedOutput we get from the AbiCoder is a `ethers.Bignumber` so we need to cast it to a string to use it with the SDK.

We have created our Range Order Position, now we need to monitor it.

In the [code example](https://github.com/uniswap/examples/blob/main/v3-sdk/range-order/src/libs/range-order.ts#L180) we use `wallet.call` to get the position id.
`call` and `trace_call` both simulate a transaction on the connected node and return the expected output, `trace_call` gives us a much more detailed output though.
Depending on the use case, either can be the better choice.
In a production environment you would prefer to wait for the `transactionReceipt` like described earlier to ensure the transaction was actaully included in the blockchain.

## Observing the Price

We need to observe the price of the Pool and withdraw our Position once the `tickCurrent` has moved across our Position.

We use **ethers JS** to watch for new blocks and fetch the latest Pool data:

```typescript

provider.on('block', refreshPool())

function refreshPool() {

    ... // construct Pool contract
    
    const slot0 = await poolContract.slot0()
    const tickCurrent = slot0.tick
}
```

It is not necessary to calculate the Price from the tick we fetched, as executing the limit order is dependent on the tick range we defined and not the Price from which we calculated it.

```typescript

if (tickCurrent > targetTick) {
    // Withdraw position
}
```

We check if the tick has crossed our position, and if so we withdraw the Position.

## Closing the Limit Order

We call the NonfungiblePositionManager Contract with the `tokenId` to get all info of our position as we may have gotten fees from trades on the Pool:

```typescript
import INON_FUNGIBLE_POSITION_MANAGER from '@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json'

const positionManagerContract = new ethers.Contract(
    NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
    INONFUNGIBLE_POSITION_MANAGER.abi,
    provider
)

const positionInfo = await positionManagerContract.positions(tokenId)
```

We use the `NonfungiblePositionManager`, the `pool`, `positionInfo` and `tokenId` to create call parameter for a `decreaseLiquidity` call.

We start with creating `CollectOptions`:

```typescript
import { Percent, CurrencyAmount } from '@uniswap/sdk-core'
import { CollectOptions, RemoveLiquidityOptions } from '@uniswap/v3-sdk'
import JSBI from 'jsbi'

const collectOptions: Omit<CollectOptions, 'tokenId'> = {
    expectedCurrencyOwed0: CurrencyAmount.fromRawAmount(
        pool.token0,
        JSBI.BigInt(positionInfo.tokensOwed0.toString())
    ),
    expectedCurrencyOwed1: CurrencyAmount.fromRawAmount(
        pool.token1,
        JSBI.BigInt(positionInfo.tokensOwed1.toString())
    ),
    recipient: wallet.address,
}
```

Next we create `RemoveLiquidityOptions`. We remove all our liquidity so we set liquidityPercentage to `1`:

```typescript
const removeLiquidityOptions: RemoveLiquidityOptions = {
      deadline: Math.floor(Date.now() / 1000) + 60 * 20,
      slippageTolerance: new Percent(50, 10_000),
      tokenId,
      // percentage of liquidity to remove
      liquidityPercentage: new Percent(1),
      collectOptions,
    }
```

We create a new `Position` object from the updated `positionInfo` info we fetched:

```typescript

const updatedPosition = new Position{
    pool,
    liquidity: JSBI.BigInt(currentPositionInfo.liquidity.toString()),
    tickLower: currentPositionInfo.tickLower,
    tickUpper: currentPositionInfo.tickUpper,
}
```

We have everything to create our calldata now and are ready to make our Contract call:

```typescript

const { calldata, value } = NonfungiblePositionManager.removeCallParameters(
      updatedPosition,
      removeLiquidityOptions
    )
const transaction = {
    data: calldata,
    to: NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
    value: value,
    from: address,
    maxFeePerGas: MAX_FEE_PER_GAS,
    maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,
}

const result = await wallet.sendTransaction(transaction)
```

Our liquidity position is removed and we receive `token1` at the Price we have specified.
We have successfully executed a range order.

## Caveats

Executing a range order has certain limitations that may have become obvious during the course of this guide.

- If the price of the Pool drops below `tickUpper` while we already decided to withdraw our liquidity our order may fail and we either receive `token0`, `token0` and `token1` or our transaction fails depending on our exact implementation.
- Range Orders can only be created between initializable ticks and may not exactly represent our limit order Price-Target.
- Depending on the price ratio of the tokens in the Pool the minimum price difference to the current price may be significant.
- The tokens received are the average between the Price of `tickUpper` and `tickLower` of the Range order. This can be a significant difference for Pools with a tickCurrent far from 0, for example tokens with different decimals (WETH/ USDT, WETH/USDC). The example showcases this behaviour well with the default configuration.

## Next Steps

This guide showcases everything you need to implement Range Orders on your own, but only demonstrates creating a Take Profit order in `token0` to `token1` direction.
Consider implementing Buy Limit orders as described in the [Range Orders concept page](../../../../concepts/protocol/range-orders.md#buy-limit-orders).

This is currently the last guide in the `v3-sdk` series. Consider joining the [Uniswap Discord](https://discord.com/invite/uniswap) or checkout the official [GitHub](https://github.com/Uniswap) to learn more about the Uniswap Protocol.
</file>

<file path="docs/sdk/v3/guides/liquidity/_category_.json">
{
  "label": "Pooling Liquidity",
  "position": 5,
  "collapsed": true
}
</file>

<file path="docs/sdk/v3/guides/liquidity/01-position-data.md">
---
id: position-data
title: Liquidity Positions
---

## Introduction

This guide will introduce us to **liquidity positions** in Uniswap V3 and present the `v3-sdk` classes and Contracts used to interact with the protocol.
The concepts and code snippets showcased here can be found across the **Pooling Liquidity** examples in the Uniswap code examples [repository](https://github.com/Uniswap/examples).

In this guide, we will take a look at the [Position](../../reference/classes/Position.md) and [NonfungiblePositionManager](../../reference/classes/NonfungiblePositionManager.md) classes, as well as the [NonfungiblePositionManager Contract](../../../../contracts/v3/reference/periphery/NonfungiblePositionManager.md).

At the end of the guide, we should be familiar with the most important classes used to interact with liquidity positions.
We should also understand how to fetch positions from the **NonfungiblePositionManager Contract**.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)
- [`@uniswap/v3-periphery`](https://www.npmjs.com/package/@uniswap/v3-periphery)

The code mentioned in this guide can be found across the [minting Position](https://github.com/Uniswap/examples/blob/main/v3-sdk/minting-position/src), [collecting Fees](https://github.com/Uniswap/examples/blob/main/v3-sdk/collecting-fees/src), [modifying positions](https://github.com/Uniswap/examples/blob/d34a53412dbf905802da2249391788a225719bb8/v3-sdk/modifying-position/src) and [swap and add liquidity](https://github.com/Uniswap/examples/blob/main/v3-sdk/swap-and-add-liquidity/src) examples.

## Prerequisites

To understand what Positions are, we need to understand some underlying concepts of the Uniswap protocol.

Consider checking out the [Concepts section](../../../../concepts/protocol/concentrated-liquidity.md) as well as the [Uniswap Book](https://uniswapv3book.com/docs/introduction/uniswap-v3/).

### Concentrated liquidity

Uniswap V3 Pools use concentrated liquidity to allow a denser concentration of liquidity at specific prices.
Compared to the full range liquidity model Uniswap V2 uses, this allows traders to make larger trades with less price impact.
Liquidity providers can choose a specific price range in which they want their liquidity to be used by trades.

To achieve this, Uniswap V3 Pools discriminate the price range with **Ticks**.

### Ticks

Ticks are the boundaries between discrete price ranges.
A change of 1 Tick always represents a price change of 0.01% from the current price.
Uniswap V3 Pools can have different `tickSpacings`, a constant that describes which ticks can be used by the Pool.
Only ticks at indices that are divisible by the tickSpacing can be initialized.
This value is dependant on the fee of the Pool, Pools with higher fees have higher tickSpacing.

For example, a Pool with **HIGH** fee (1%) has a tickSpacing of 200, meaning the price difference between initializable Ticks is:

$$1.0001^{200} = 1.0202$$ or $$2.02$$%

### Liquidity Positions

When someone provides liquidity to a Pool, they create a **Liquidity Position**.
This position is defined by the amount of liquidity provided and the start tick and the end tick, or price range, of the Position.

Because V3 Pools allow users to choose any price range in which they want to provide liquidity, it is possible to create positions that do not contain the current Price of the Pool.
In this case, the liquidity provider will pay only one type of Token into the Pool, creating a **single side liquidity position**.

To learn more about how Ticks and Liquidity positions work, consider reading the [whitepaper](https://uniswap.org/whitepaper-v3.pdf) or the other resources mentioned above.

Now that we have a rough understanding of liquidity positions in Uniswap V3, let's look at the correspondent classes the SDK offers us.

## Position class

The **sdk** provides a [`Position`](https://github.com/Uniswap/v3-sdk/blob/main/src/entities/position.ts) class used to create local representations of an onchain position.
It is used to create the calldata for onchain calls to mint or modify an onchain position.

There are four ways to construct a position.

Directly with the [constructor](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L40):

```typescript
import { Pool, Position } from '@uniswap/v3-sdk'
import JSBI from 'jsbi'

const pool = new Pool(...)
const tickLower: number = -100
const tickUpper: number = 200
const liquidity: JSBI = JSBI.BigInt('1000000000000000000')

const position = new Position({
    pool,
    liquidity,
    tickLower,
    tickUpper
})
```

Using the [`fromAmounts()`](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L312) function:

```typescript
import { BigIntish } from '@uniswap/sdk-core'

const pool = new Pool(...)
const tickLower: number = -100
const tickUpper: number = 200
const amount0: BigIntish = '1000000000000000000'
const amount1: BigIntish = JSBI.BigInt('1000000000000000000')
const useFullPrecision: boolean = true

const position = Position.fromAmounts({
    pool, 
    tickLower, 
    tickUpper, 
    amount0, 
    amount1, 
    useFullPrecision
})
```

Or using the [`fromAmount0()`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/entities/position.ts#L354) or [`fromAmount1()`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/entities/position.ts#L378) functions:

```typescript
import { BigIntish } from '@uniswap/sdk-core'
...

const pool = new Pool(...)
const tickLower: number = -200
const tickUpper: number = 100
const amount0: BigIntish = '1000000000000000000'
const useFullPrecision: boolean = true

const singleSidePositionToken0 = Position.fromAmount0({
    pool, 
    tickLower, 
    tickUpper, 
    amount0,
    useFullPrecision
})

const amount1: BigIntish = 100000000

const singleSidePositionToken1 = Position.fromAmount1({
    pool, 
    tickLower, 
    tickUpper, 
    amount1,
    useFullPrecision
})
```

These last two functions calculate a position at the given tick range given the amount of `token0` or `token1`. The amount of the second token is calculated from the ratio of the tokens inside the tick range and the amount of token one.

A create transaction would then fail if the wallet doesn't hold enough `token1` or the Contract is not given the necessary **Transfer Approval**.

All of these functions take an Object with **named values** as a call parameter. The amount and liquidity values are of type `BigIntish` which accepts `number`, `string` and `JSBI`.

The values of `tickLower` and `tickUpper` must match **initializable ticks** of the Pool.

## NonfungiblePositionManager

The `NonfungiblePositionManager` class is mainly used to create calldata for functions on the **NonfungiblePositionManager Contract**.

We will look at the **sdk** class and write functions on the Contract in this section.

### Creating a Position

To create a position on a Pool, the [`mint`](../../../../contracts/v3/reference/periphery/NonfungiblePositionManager.md#mint) function is called on the Contract.
The **sdk** class provides the `addCallParameters` function to create the calldata for the transaction:

```typescript
import { MintOptions, NonfungiblePositionManager } from '@uniswap/v3-sdk'

const mintOptions: MintOptions = {
  recipient: address,
  deadline: Math.floor(Date.now() / 1000) + 60 * 20,
  slippageTolerance: new Percent(50, 10_000),
}

// get calldata for minting a position
const { calldata, value } = NonfungiblePositionManager.addCallParameters(
  positionToMint,
  mintOptions
)
```

This call creates a position if it doesn't exist, but can also be used to increase an existing position.
Take a look at the [Mint Position guide](./02-minting-position.md) and [Modify Position guide](./04-modifying-position.md) to learn more.

### Decreasing and Increasing a Position

To decrease or increase the liquidity of a Position, the `decreaseLiquidity` or `increaseLiquidity` functions are called on the Contract.
To increase, `addCallParameters` is used as mentioned above, to decrease we use `removeCallParameters`:

```typescript
const { calldata, value } = NonfungiblePositionManager.removeCallParameters(
  currentPosition,
  removeLiquidityOptions
)
```

Take a look at the [Modify Positions guide](04-modifying-position.md) to learn how to create the `currentPosition` and `removeLiquidityOptions` parameters.

### Collecting Fees

To collect fees accrued, the `collect` function is called on the Contract.
The **sdk class** provides the `collectCallParameters` function to create the calldata for that:

```typescript
const { calldata, value } =
  NonfungiblePositionManager.collectCallParameters(collectOptions)
```


## Next steps

Now that you are familiar with the most important classes and Contract to interact with Liquidity Positions, continue with the next guide on [Minting Positions](./02-minting-position.md).
</file>

<file path="docs/sdk/v3/guides/liquidity/02-minting-position.md">
---
id: minting
title: Minting a Position
---

## Introduction

This guide will cover how to create (or mint) a liquidity position on the Uniswap V3 protocol.
It is based on the [minting a position code example](https://github.com/Uniswap/examples/tree/main/v3-sdk/minting-position), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples).
To run this example, check out the examples's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/minting-position/README.md) and follow the setup instructions.

:::info
If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](../01-background.md) page!
:::

In the Uniswap V3 protocol, liquidity positions are represented using non-fungible tokens. In this guide we will use the `NonfungiblePositionManager` class to help us mint a liquidity position for the  **USDC - DAI** pair. The inputs to our guide are the **two tokens** that we are pooling for, the **amount** of each token we are pooling for and the Pool **fee**.

The guide will **cover**:

1. Giving approval to transfer our tokens
2. Creating an instance of a `Pool`
3. Calculating our `Position` from our input tokens
4. Configuring and executing our minting transaction

At the end of the guide, given the inputs above, we should be able to mint a liquidity position with the press of a button and view the position on the UI of the web application.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)
- [`@uniswap/smart-order-router`](https://www.npmjs.com/package/@uniswap/smart-order-router)

The core code of this guide can be found in [`mintPosition()`](https://github.com/Uniswap/examples/blob/main/v3-sdk/minting-position/src/libs/positions.ts#L37)

## Giving approval to transfer our tokens

We want to use the `NonfungiblePositionManager` contract to create our liqudity position.
In situations where a smart contract is transfering tokens on our behalf, we need to give it approval to do so.
This is done by interacting with the Contract of the contract, considering ERC20 Tokens are smart contracts of their own.

Considering this, the first step to create our position is to give approval to the protocol's `NonfungiblePositionManager` to transfer our tokens:

```typescript
const token0Approval = await getTokenTransferApproval(
  token0Address,
  amount0
)
const token1Approval = await getTokenTransferApproval(
  token1Address,
  amount1
)
```

The logic to achieve that is wrapped in the `getTokenTransferApprovals` function. In short, since both **USDC** and **DAI** are ERC20 tokens, we setup a reference to their smart contracts and call the `approve` function:

```typescript
import { ethers, BigNumber } from 'ethers'

async function getTokenTransferApproval(address: string, amount: BigNumber) {
    const provider = new ethers.providers.JsonRpcProvider(rpcUrl)

    const tokenContract = new ethers.Contract(
        address,
        ERC20_ABI,
        provider
    )

    return tokenContract.approve(
        NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
        amount
    )
}
```

We can get the Contract address for the NonfungiblePositionManager from [GitHub](https://github.com/Uniswap/v3-periphery/blob/main/deploys.md).
For Ethereum mainnet or a local fork of mainnet, we see that the contract address is `0xC36442b4a4522E871399CD717aBDD847Ab11FE88`.
In our example, this is defined in the [`constants.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/minting-position/src/libs/constants.ts) file.

## Creating an instance of a `Pool`

Having approved the transfer of our tokens, we now need to get data about the pool for which we will provide liquidity, in order to instantiate a Pool class.

To start, we compute our Pool's address by using a helper function and passing in the unique identifiers of a Pool - the **two tokens** and the Pool **fee**.
The **fee** input parameter represents the swap fee that is distributed to all in range liquidity at the time of the swap.

```typescript
import { computePoolAddress, FeeAmount } from '@uniswap/v3-sdk'
import { Token } from '@uniswap/sdk-core'

const token0: Token = ...
const token1: Token = ...
const fee: FeeAmount = ...
const POOL_FACTORY_CONTRACT_ADDRESS: string = ...

const currentPoolAddress = computePoolAddress({
  factoryAddress: POOL_FACTORY_CONTRACT_ADDRESS,
  tokenA: token0,
  tokenB: token1,
  fee: poolFee,
})
```

Again, we can get the factory contract address from [GitHub](https://github.com/Uniswap/v3-periphery/blob/main/deploys.md). 
For Ethereum mainnet, or a local fork of mainnet, it is `0x1F98431c8aD98523631AE4a59f267346ea31F984`. 
In our example, it is defined in [`constants.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/minting-position/src/libs/constants.ts)

Then, we get the Pool's data by creating a reference to the Pool's smart contract and accessing its methods, very similar to what we did in the [Quoting guide](../swaps/01-quoting.md#referencing-the-pool-contract-and-fetching-metadata):

```typescript
import IUniswapV3PoolABI from '@uniswap/v3-core/artifacts/contracts/interfaces/IUniswapV3Pool.sol/IUniswapV3Pool.json'

const poolContract = new ethers.Contract(
  currentPoolAddress,
  IUniswapV3PoolABI.abi,
  provider
)

const [liquidity, slot0] =
  await Promise.all([
    poolContract.liquidity(),
    poolContract.slot0(),
  ])
```

Having collected the required data, we can now create an instance of the `Pool` class:

```typescript
import { Pool } from '@uniswap/v3-sdk'

const configuredPool = new Pool(
  token0,
  token1,
  poolFee,
  slot0.sqrtPriceX96.toString(),
  liquidity.toString(),
  slot0.tick
)
```

We need a Pool instance to create our Position as various parameters of liquidity positions depend on the state of the Pool where they are created.
An example is the current price (named *sqrtPriceX96* after the way it is encoded) to know the ratio of the two Tokens we need to send to the Pool.

Liquidity provided below the current Price will be provided in the first Token of the Pool, while liquidity provided above the current Price is made up by the second Token.

## Calculating our `Position` from our input tokens

Having created the instance of the `Pool` class, we can now use that to create an instance of a `Position` class, which represents the price range for a specific pool that LPs choose to provide in:

```typescript
import { Position } from '@uniswap/v3-sdk'
import { BigIntish } from '@uniswap/sdk-core'

// The maximum token amounts we want to provide. BigIntish accepts number, string or JSBI
const amount0: BigIntish = ...
const amount1: BigIntish = ...

const position = Position.fromAmounts({
  pool: configuredPool,
  tickLower:
    nearestUsableTick(configuredPool.tickCurrent, configuredPool.tickSpacing) -
    configuredPool.tickSpacing * 2,
  tickUpper:
    nearestUsableTick(configuredPool.tickCurrent, configuredPool.tickSpacing) +
    configuredPool.tickSpacing * 2,
  amount0: amount0,
  amount1: amount1,
  useFullPrecision: true,
})
```

We use the `fromAmounts` static function of the `Position` class to create an instance of it, which uses the following parameters:

- The **tickLower** and **tickUpper** parameters specify the price range at which to provide liquidity. This example calls **nearestUsableTick** to get the current useable tick and adjust the lower parameter to be below it by two **tickSpacing** and the upper to be above it by two tickSpacing. This guarantees that the provided liquidity is "in range", meaning it will be earning fees upon minting this position
- **amount0** and **amount1** define the maximum amount of currency the liquidity position can use. In this example, we supply these from our configuration parameters.

Given those parameters, `fromAmounts` will attempt to calculate the maximum amount of liquidity we can supply.

## Configuring and executing our minting transaction

The Position instance is then passed as input to the `NonfungiblePositionManager`'s `addCallParameters` function. The function also requires an [`AddLiquidityOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L77) object as its second parameter. This is either of type [`MintOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L74) for minting a new position or [`IncreaseOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L75) for adding liquidity to an existing position. For this example, we're using a `MintOptions` to create our position.

```typescript
import { MintOptions, NonfungiblePositionManager } from '@uniswap/v3-sdk'
import { Percent } from '@uniswap/sdk-core'

const mintOptions: MintOptions = {
  recipient: address,
  deadline: Math.floor(Date.now() / 1000) + 60 * 20,
  slippageTolerance: new Percent(50, 10_000),
}

// get calldata for minting a position
const { calldata, value } = NonfungiblePositionManager.addCallParameters(
  position,
  mintOptions
)
```

The `MintOptions` interface requires three keys:

- `recipient` defines the address of the Position owner, so in our case the address of our wallet.
- `deadline` defines the latest point in time at which we want our transaction to be included in the blockchain.
- `slippageTolerance` defines the maximum amount of **change of the ratio** of the Tokens we provide. The ratio can change if for example **trades** that change the price of the Pool are included before our transaction.

The `addCallParameters` function returns the calldata as well as the value required to execute the transaction:

```typescript
const transaction = {
  data: calldata,
  to: NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
  value: value,
  from: address,
  maxFeePerGas: MAX_FEE_PER_GAS,
  maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,
}
```

We use our wallet to send the transaction. As it is a write call, we need to sign the transaction with a valid private key.

```typescript
const wallet = new ethers.Wallet(privateKey, provider)

const txRes = await wallet.sendTransaction(transaction)
```

Write calls do not return the result of the transaction. If we want to read the result we would need to use for example `trace_transaction`.
You can find an example of that in the [Range Order guide](../advanced/05-range-orders.md).
In this example, we don't need the result of the transaction.

The effect of the transaction is to mint a new Position NFT. We should see a new position with liquidity in our list of positions.

## Next Steps

Once you have minted a position, our next guide [Adding and Removing Liquidity](./04-modifying-position.md) will demonstrate how you can add and remove liquidity from that minted position!
</file>

<file path="docs/sdk/v3/guides/liquidity/03-fetching-positions.md">
---
id: fetching-positions
title: Fetching Positions
---

## Introduction

This guide will cover how to create (or mint) a liquidity position on the Uniswap V3 protocol.
Like the [Liquidity Position guide](./01-position-data.md) it doesn't have an accompanying example, nevertheless the concepts and functions used here can be found among the various examples that interact with liquidity positions.

:::info
If you need an introduction to liquidity positions, check out the [Liquidity Position guide](./01-position-data.md)
:::

The [NonfungiblePositionManager Contract](../../../../contracts/v3/reference/periphery/NonfungiblePositionManager.md) can be used to create Positions, as well as get information on **existing Positions**.
In this guide, we will fetch **all Positions** an address has and fetch the **detailed Position Data** for those positions.

The guide will **cover**:

1. Creating an ethersJS contract to interact with the NonfungiblePositionManager.
2. Fetching all positions for an address.
3. Fetching the position info for the positions.

At the end of the guide, given the inputs above, we should be able to mint a liquidity position with the press of a button and view the position on the UI of the web application.

For this guide, we do not need to use the Uniswap SDKs, we will only import the contract ABI for the NonfungiblePositionManager Contract from [`@uniswap/v3-periphery`](https://www.npmjs.com/package/@uniswap/v3-periphery).

## Connecting to the NFTPositionManager Contract

We use **ethersJS** to interact with the NonfungiblePositionManager Contract. Let's create an ethers Contract:

```typescript
import { ethers } from 'ethers'
import INONFUNGIBLE_POSITION_MANAGER from '@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json'

const provider = new ethers.providers.JsonRpcProvider(rpcUrl)

const nfpmContract = new ethers.Contract(
    NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
    INONFUNGIBLE_POSITION_MANAGER.abi,
    provider
)
```

We get the Contract ABI from the 'v3-periphery` package and the contract address from [GitHub](https://github.com/Uniswap/v3-periphery/blob/main/deploys.md)

## Fetching the Position Ids

We want to fetch all Position Ids for our address. We first fetch the number of positions and then the ids by their indices.

We fetch the number of positions using the `balanceOf` read call:

```typescript

const numPositions = await nfpmContract.balanceOf(address)
```

Next we iterate over the number of positions and fetch the ids:

```typescript
const calls = []

for (let i = 0; i < numPositions; i++) {
    calls.push(
        nfpmContract.tokenOfOwnerByIndex(address, i)
    )
}

const positionIds = await Promise.all(calls)
```

## Fetching the Position Info

Now that we have the ids of the Positions associated with our address, we can fetch the position info using the `positions` function.

The solidity function returns a lot of values describing the Position:

```solidity
function positions(
    uint256 tokenId
  ) external view returns (
    uint96 nonce, 
    address operator, 
    address token0, 
    address token1, 
    uint24 fee, 
    int24 tickLower, 
    int24 tickUpper, 
    uint128 liquidity, 
    uint256 feeGrowthInside0LastX128, 
    uint256 feeGrowthInside1LastX128, 
    uint128 tokensOwed0, 
    uint128 tokensOwed1
    )
```

In this example we only care about values needed to interact with positions, so we create an Interface `PositionInfo`:

```typescript
interface PositionInfo {
  tickLower: number
  tickUpper: number
  liquidity: JSBI
  feeGrowthInside0LastX128: JSBI
  feeGrowthInside1LastX128: JSBI
  tokensOwed0: JSBI
  tokensOwed1: JSBI
}
```

We fetch the Position data with `positions`:

```typescript
const positionCalls = []

for (let id of positionIds) {
    positionCalls.push(
        nfpmContract.positions(id)
    )
}

const callResponses = await Promise.all(positionCalls)
```

Finally, we map the RPC response to our interface:

```typescript
const positionInfos = callResponses.map((position) => {
    return {
        tickLower: position.tickLower,
        tickUpper: position.tickUpper,
        liquidity: JSBI.BigInt(position.liquidity),
        feeGrowthInside0LastX128: JSBI.BigInt(position.feeGrowthInside0LastX128),
        feeGrowthInside1LastX128: JSBI.BigInt(position.feeGrowthInside1LastX128),
        tokensOwed0: JSBI.BigInt(position.tokensOwed0),
        tokensOwed1: JSBI.BigInt(position.tokensOwed1),
  }
})
```

We now have an array containing PositionInfo for all positions that our address holds.
</file>

<file path="docs/sdk/v3/guides/liquidity/04-modifying-position.md">
---
id: modifying-position
title: Adding & Removing Liquidity
---

## Introduction

This guide will cover how to modify a liquidity position by adding or removing liquidity on the Uniswap V3 protocol. It is based on the [modifying a position code example](https://github.com/Uniswap/examples/tree/main/v3-sdk/modifying-position), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/modifying-position/README.md) and follow the setup instructions.

:::info
If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](../01-background.md) page!
:::

In the Uniswap V3 protocol, liquidity positions are represented using non-fungible tokens. In this guide we will use the `NonfungiblePositionManager` class to help us mint a liquidity position and then modify the provided liquidity for the  **USDC - DAI** pair. The inputs to our guide are the **two tokens** that we are pooling for, the **amount** of each token we are pooling for, the Pool **fee** and the **fraction** by which to **add and remove** from our position.

The guide will **cover**:

1. Adding liquidity to our position
2. Removing liquidity from our position

At the end of the guide, given the inputs above, we should be able to add or remove liquidity from a minted position with the press of a button and see the change reflected in our position and the balance of our tokens.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

The core code of this guide can be found in [`addLiquidity()`](https://github.com/Uniswap/examples/blob/d34a53412dbf905802da2249391788a225719bb8/v3-sdk/modifying-position/src/example/Example.tsx#L33) and [`removeLiquidity()`](https://github.com/Uniswap/examples/blob/733d586070afe2c8cceb35d557a77eac7a19a656/v3-sdk/modifying-position/src/example/Example.tsx#L83)

:::note
This guide assumes you are familiar with our [Minting a Position](./02-minting-position.md) guide. A minted position is required to add or remove liquidity from, so the buttons will be disabled until a position is minted.

Also note that we do not need to give approval to the `NonfungiblePositionManager` to transfer our tokens as we will have already done that when minting our position.
:::

## Configuration and utils

The example can be configured in the [`config.ts`](https://github.com/Uniswap/examples/blob/d34a53412dbf905802da2249391788a225719bb8/v3-sdk/modifying-position/src/config.ts) file.
The `CurrentConfig` object has this structure:

```typescript
export const CurrentConfig: ExampleConfig = {
  env: Environment.LOCAL,
  rpc: {
    local: 'http://localhost:8545',
    mainnet: 'https://mainnet.infura.io/v3/0ac57a06f2994538829c14745750d721',
  },
  wallet: {
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    privateKey:
      '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
  },
  tokens: {
    token0: USDC_TOKEN,
    token0Amount: 1000,
    token1: DAI_TOKEN,
    token1Amount: 1000,
    poolFee: FeeAmount.LOW,
    fractionToRemove: 1,
    fractionToAdd: 0.5,
  },
}
```

You should already be familiar with the `rpc`, `wallet` and token parameters, they are used in the same way as in the guides earlier in our v3-sdk series.
The `fractionToAdd` variable is the multiplicator by which we will increase the Position. A fraction of **0.5** means we increase the liquidity by **50%**.
The `fractionToRemove` variable is the fraction of the Position that we want to remove later in the guide. A fraction of **1** means we remove **100%** of the liquidity.

## Adding liquidity to our position

Assuming we have already minted a position, our first step is to construct the modified position using our original position to calculate the amount by which we want to increase our current position:

```typescript
const fractionToAdd: number = ...

const amount0Increased: JSBI = fromReadableAmount(
    readableAmount0 * fractionToAdd, 
    token0.decimals
)
const amount1Increase: JSBI = fromReadableAmount(
    readableAmount1 * fractionToAdd, 
    token1.decimals
)

const positionToIncreaseBy = constructPosition(
    amount0Increased,
    amount1Increase
  )
)
```

The `fromReadableAmount()` function calculates the amount of tokens in their smallest unit, so for example 1 ETH would be `1000000000000000000` Wei as ETH has 18 decimals.

A better way to get the amounts might be to fetch them with the positionId directly from the blockchain.
We demonstrated how to do that in the [first guide](./01-position-data.md#fetching-positions) of this series.

```typescript
import { Pool, Position } from '@uniswap/v3-sdk'
import JSBI from 'jsbi'

function constructPosition(
    amount0: JSBI,
    amount1: JSBI
): Position {
    // create Pool same as in the previous guide
    const pool = new Pool(...)

    // create position using the maximum liquidity from input amounts
    return Position.fromAmounts({
        pool,
        tickLower:
            nearestUsableTick(pool.tickCurrent, pool.tickSpacing) -
            pool.tickSpacing * 2,
        tickUpper:
            nearestUsableTick(pool.tickCurrent, pool.tickSpacing) +
            pool.tickSpacing * 2,
        amount0,
        amount1,
        useFullPrecision: true,
    })
}
```

The function receives two arguments, which are the amounts that are used to construct the Position instance. In this example, both of the arguments follow the same logic: we multiply the parameterized `tokenAmount` by the parameterized `fractionToAdd` since the new liquidity position will be added on top of the already minted liquidity position.

We then need to construct an options object of type [`AddLiquidityOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L77) similar to how we did in the minting case. In this case, we will use [`IncreaseOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L75):

```typescript
import { AddLiquidityOptions } from '@uniswap/v3-sdk'

const addLiquidityOptions: AddLiquidityOptions = {
  deadline: Math.floor(Date.now() / 1000) + 60 * 20,
  slippageTolerance: new Percent(50, 10_000),
  tokenId,
}
```

Compared to minting, we have omitted the `recipient` parameter and instead passed in the `tokenId` of the position we previously minted.
As the Position already exists, the recipient doesn't change, instead the NonfungiblePositionManager contract can modify the existing Position by accessing it with its id.

The tokenId can be fetched with the tokenOfOwnerByIndex function of the NonfungiblePositionManager Contract as described [here](./01-position-data.md#fetching-positions).

The newly created position along with the options object are then passed to the `NonfungiblePositionManager`'s `addCallParameters`:

```typescript
import { NonfungiblePositionManager } from '@uniswap/v3-sdk'

const positionToIncreaseBy = constructPosition(CurrentConfig.tokens.amount0, CurrentConfig.tokens.amount1)

const { calldata, value } = NonfungiblePositionManager.addCallParameters(
  positionToIncreaseBy,
  addLiquidityOptions
)
```

The return values of `addCallParameters` are the calldata and value of the transaction we need to submit to increase our position's liquidity. We can now build and execute the transaction:

```typescript
import { ethers } from 'ethers'

const transaction = {
  data: calldata,
  to: NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
  value: value,
  from: address,
  maxFeePerGas: MAX_FEE_PER_GAS,
  maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,
}

const wallet = new ethers.Wallet(privateKey, provider)

const txRes = await wallet.sendTransaction(transaction)
```

We can get the Contract address for the NonfungiblePositionManager from [GitHub](https://github.com/Uniswap/v3-periphery/blob/main/deploys.md).

After pressing the button, note how the balance of USDC and DAI drops and our position's liquidity increases.

## Removing liquidity from our position

The `removeLiquidity` function is the mirror action of adding liquidity and will be somewhat similar as a result, requiring a position to already be minted.

To start, we create a position identical to the one we minted:

```typescript
const amount0: JSBI = fromReadableAmount(
    readableAmount0 * fractionToAdd, 
    token0.decimals
)
const amount1: JSBI = fromReadableAmount(
    readableAmount1 * fractionToAdd, 
    token1.decimals
)

const currentPosition = constructPosition(
  amount0,
  amount1
)
```

We then need to construct an options object of type [`RemoveLiquidityOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L138):

```typescript
import { RemoveLiquidityOptions } from '@uniswap/v3-sdk'
import { Percent } from '@uniswap/sdk-core'

const removeLiquidityOptions: RemoveLiquidityOptions = {
  deadline: Math.floor(Date.now() / 1000) + 60 * 20,
  slippageTolerance: new Percent(50, 10_000),
  tokenId: positionId,
  // percentage of liquidity to remove
  liquidityPercentage: new Percent(0.5),
  collectOptions,
}
```

Just as with adding liquidity, we have we have omitted the `recipient` parameter and instead passed in the `tokenId` of the position we previously minted.

We have also provide two additional parameters:

- `liquidityPercentage` determines how much liquidity is removed from our initial position (as a `Percentage`), and transfers the removed liquidity back to our address. We set this percentage from our guide configuration ranging from 0 (0%) to 1 (100%). In this example we would remove 50% of the liquidity.
- [`collectOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L105) gives us the option to collect the fees, if any, that we have accrued for this position. In this example, we won't collect any fees, so we provide zero values. If you'd like to see how to collect fees without modifying your position, check out our [collecting fees](./05-collecting-fees.md) guide!

```typescript
import { CurrencyAmount } from '@uniswap/sdk-core'
import { CollectOptions } from '@uniswap/v3-sdk'

const collectOptions: Omit<CollectOptions, 'tokenId'> = {
  expectedCurrencyOwed0: CurrencyAmount.fromRawAmount(
    token0,
    0
  ),
  expectedCurrencyOwed1: CurrencyAmount.fromRawAmount(
    token1,
    0
  ),
  recipient: address,
}
```

The position object along with the options object is passed to the `NonfungiblePositionManager`'s `removeCallParameters`, similar to how we did in the adding liquidity case:

```typescript
const { calldata, value } = NonfungiblePositionManager.removeCallParameters(
  currentPosition,
  removeLiquidityOptions
)
```

The return values `removeCallParameters` are the calldata and value that are needed to construct the transaction to remove liquidity from our position. We can build the transaction and send it for execution:

```typescript
const transaction = {
  data: calldata,
  to: NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
  value: value,
  from: address,
  maxFeePerGas: MAX_FEE_PER_GAS,
  maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,
}

const txRes = await wallet.sendTransaction(transaction)
```

After pressing the button, note how the balance of USDC and DAI increases and our position's liquidity drops.

## Next Steps

Now that you can mint and modify a position, check out how to [collect fees](./04-collecting-fees.md) from the position!
</file>

<file path="docs/sdk/v3/guides/liquidity/05-collecting-fees.md">
---
id: liquidity-fees
title: Collecting Fees
---

## Introduction

This guide will cover how to collect fees from a liquidity position on the Uniswap V3 protocol. It is based on the [collecting fees code example](https://github.com/Uniswap/examples/tree/main/v3-sdk/collecting-fees), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/collecting-fees/README.md) and follow the setup instructions.

:::info
If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](../01-background.md) page!
:::

In the Uniswap V3 protocol, liquidity positions are represented using non-fungible tokens. In this guide we will use the `NonfungiblePositionManager` class to help us mint a liquidity position for the  **USDC - DAI** pair. We will then attempt to collect any fees that the position has accrued from those trading against our provisioned liquidity. The inputs to our guide are the **two tokens** that we are pooling for, the **amount** of each token we are pooling for, the Pool **fee** and the **max amount of accrued fees** we want to collect for each token.

The guide will **cover**:

1. Setting up our fee collection
2. Submitting our fee collection transaction

At the end of the guide, given the inputs above, we should be able to collect the accrued fees (if any) of a minted position with the press of a button and see the change reflected in our position and the balance of our tokens.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

The core code of this guide can be found in [`collectFees()`](https://github.com/Uniswap/examples/blob/main/v3-sdk/collecting-fees/src/libs/liquidity.ts#L35).

:::note
This guide assumes you are familiar with our [Minting a Position](./01-minting-position.md) guide. A minted position is required to add or remove liquidity from, so the buttons will be disabled until a position is minted.

Also note that we do not need to give approval to the `NonfungiblePositionManager` to transfer our tokens as we will have already done that when minting our position.
:::

## Setting up our fee collection

All of the fee collecting logic can be found in the [`collectFees`](https://github.com/Uniswap/examples/blob/be67e7df220b0a270c9d18bbaab529e017213adf/v3-sdk/collecting-fees/src/example/Example.tsx#L24) function. Notice how the **Collect Fees** button is disabled until a position is minted. This happens because there will be no fees to collect unless there is a position whose liquidity has been traded against.

To start, we fetch the position from the NonfungiblePositionManager Contract to get the fees we are owed:

```typescript
import { ethers } from 'ethers'
import JSBI from 'jsbi'
...

const nfpmContract = new ethers.Contract(NONFUNGIBLE_POSITION_MANAGER_ADDRESS, provider)
const position = nfpmContract.positions(positionId)
```

Next, we construct an options object of type  [`CollectOptions`](https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/nonfungiblePositionManager.ts#L105) that holds the data about the fees we want to collect:

```typescript
import { CurrencyAmount } from '@uniswap/sdk-core'

const collectOptions: CollectOptions = {
  tokenId: positionId,
  expectedCurrencyOwed0: CurrencyAmount.fromRawAmount(
    CurrentConfig.tokens.token0,
    JSBI.BigInt(position.tokensOwed0)
  ),
  expectedCurrencyOwed1: CurrencyAmount.fromRawAmount(
    CurrentConfig.tokens.token1,
    JSBI.BigInt(position.tokensOwed1)
  ),
  recipient: address,
}
```

Read more about fetching position info [here](./01-position-data.md#fetching-positions).

Similar to the other functions exposed by the `NonfungiblePositionManager`, we pass the `tokenId` and the `recipient` of the fees, which in this case is our function's input position id and our wallet's address.

The other two `CurrencyAmount` parameters (`expectedCurrencyOwed0` and `expectedCurrencyOwed1`) define the **maximum** amount of currency we expect to get collect through accrued fees of each token in the pool. We set these through our guide's configuration.

In a real world scenario, we can fetch the amount of fees that are owed to the Position through the `positions()` function of the NonfungiblePositionManager Contract.
We fetch the position info like in this code snippet taken from the [Fetching Positions guide](./03-fetching-positions.md):

```typescript
const positionInfos = callResponses.map((position) => {
    return {
        tickLower: position.tickLower,
        tickUpper: position.tickUpper,
        liquidity: JSBI.BigInt(position.liquidity),
        feeGrowthInside0LastX128: JSBI.BigInt(position.feeGrowthInside0LastX128),
        feeGrowthInside1LastX128: JSBI.BigInt(position.feeGrowthInside1LastX128),
        tokensOwed0: JSBI.BigInt(position.tokensOwed0),
        tokensOwed1: JSBI.BigInt(position.tokensOwed1),
  }
})
```

The `tokensOwed0` and `tokensOwed1` values are the fees owed.

In this example, we have the values hardcoded in the [`config.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/collecting-fees/src/config.ts) file.

## Submitting our fee collection transaction

Next, we get the call parameters for collecting our fees from our `NonfungiblePositionManager` using the constructed `CollectOptions`:

```typescript
const { calldata, value } =
  NonfungiblePositionManager.collectCallParameters(collectOptions)
```

The function above returns the calldata and value required to construct the transaction for collecting accrued fees. Now that we have both the calldata and value we needed for the transaction, we can build and execute the it:

```typescript
const transaction = {
  data: calldata,
  to: NONFUNGIBLE_POSITION_MANAGER_CONTRACT_ADDRESS,
  value: value,
  from: address,
  maxFeePerGas: MAX_FEE_PER_GAS,
  maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,
}

const txRes = await wallet.sendTransaction(transaction)
```

After pressing the button, if someone has traded against our position, we should be able to note how the balance of USDC and DAI increases as we collect fees.

## Next Steps

The previous guides detail all the atomic steps needed to create and manage positions. However, these approaches may not use all of your desired currency. To ensure you are using your full funds while minimizing gas prices, check out our guide on [Swapping and Adding Liquidity](./06-swap-and-add-liquidity.md) in a single transaction!
</file>

<file path="docs/sdk/v3/guides/liquidity/06-swap-and-add-liquidity.md">
---
id: swap-and-add
title: Swapping and Adding Liquidity
---

## Introduction

This guide will cover how to execute a swap-and-add operation in a single atomic transaction. It is based on the [swap-and-add example](https://github.com/Uniswap/examples/tree/main/v3-sdk/swap-and-add-liquidity), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/tree/main/v3-sdk/swap-and-add-liquidity) and follow the setup instructions.

:::info
If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](../01-background.md) page!
:::

When adding liquidity to a Uniswap v3 pool, you must provide two assets in a particular ratio. In many cases, your contract or the user's wallet hold a different ratio of those two assets. In order to deposit 100% of your assets, you must first swap your assets to the optimal ratio and then add liquidity.

However, the swap may shift the balance of the pool and thus change the optimal ratio. To avoid that, we can execute this swap-and-add liquidity operation in an atomic fashion, using a router. The inputs to our guide are the **two tokens** that we are pooling for, the **amount** of each token we are pooling for, the **amount** of each token to swap-and-add, and the Pool **fee**.

The guide will **cover**:

1. Setup a router instance
2. Configuring our ratio calculation
3. Calculating our currency ratio
4. Constructing and executing our swap-and-add transaction

At the end of the guide, given the inputs above, we should be able swap-and-add liquidity using 100% of the input assets with the press of a button and see the change reflected in our position and the balance of our tokens.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)
- [`@uniswap/smart-order-router`](https://www.npmjs.com/package/@uniswap/smart-order-router)

The core code of this guide can be found in [`swapAndAddLiquidity()`](https://github.com/Uniswap/examples/blob/main/v3-sdk/swap-and-add-liquidity/src/libs/liquidity.ts#L48).

:::note
This guide assumes you are familiar with our [Minting a Position](./01-minting-position.md) guide. A minted position is required to add or remove liquidity from, so the buttons will be disabled until a position is minted.

Also note that we do not need to give approval to the `NonfungiblePositionManager` to transfer our tokens as we will have already done that when minting our position.
:::

## Setup a router instance

The first step is to approve the `SwapRouter` smart contract to spend our tokens for us in order for us to add liquidity to our position:

```typescript
const tokenInApproval = await getTokenTransferApproval(
  token0,
  V3_SWAP_ROUTER_ADDRESS
)

const tokenOutApproval = await getTokenTransferApproval(
  token1,
  V3_SWAP_ROUTER_ADDRESS
)
```

We described the `getTokenTransferApproval` function [here](./02-minting-position.md#giving-approval-to-transfer-our-tokens).

Then we can setup our router, the [`AlphaRouter`](https://github.com/Uniswap/smart-order-router/blob/97c1bb7cb64b22ebf3509acda8de60c0445cf250/src/routers/alpha-router/alpha-router.ts#L333), which is part of the [smart-order-router package](https://www.npmjs.com/package/@uniswap/smart-order-router). The router requires a `chainId` and a `provider` to be initialized. Note that routing is not supported for local forks, so we will use a mainnet provider even when swapping on a local fork:

```typescript
import { ethers } from 'ethers'
import { AlphaRouter } from '@uniswap/smart-order-router'

const provider = new ethers.providers.JsonRpcProvider(rpcUrl)

const router = new AlphaRouter({ chainId: 1, provider })
```

For a more detailed example, check out our [routing guide](../trading/03-routing.md).

## Configuring our ratio calculation

Having created the router, we now need to construct the parameters required to make a call to its `routeToRatio` function, which will ensure the ratio of currency used matches the pool's required ratio to add our total liquidity. This will require the following parameters:

The first two parameters are the currency amounts we use as input to the `routeToRatio` algorithm:

```typescript
import { CurrencyAmount } from '@uniswap/sdk-core'

const token0CurrencyAmount = CurrencyAmount.fromRawAmount(
  token0,
  fromReadableAmount(
    token0AmountToAdd,
    token0.decimals
  )
)

const token1CurrencyAmount = CurrencyAmount.fromRawAmount(
  token1,
  fromReadableAmount(
    token1AmountToAdd,
    token1.decimals
  )
)
```

Next, we will create a placeholder position with a liquidity of `1` since liquidity is still unknown and will be set inside the call to `routeToRatio`:

```typescript
import { Pool, Position, nearestUsableTick } from '@uniswap/v3-sdk'

const placeholderPosition = new Position{
    pool,
    liquidity: 1,
    tickLower:
      nearestUsableTick(pool.tickCurrent, pool.tickSpacing) -
      pool.tickSpacing * 2,
    tickUpper:
      nearestUsableTick(pool.tickCurrent, pool.tickSpacing) +
      poolInfo.tickSpacing * 2
}
```

We then need to create an instance of `SwapAndAddConfig` which will set additional configuration parameters for the `routeToRatio` algorithm:

- `ratioErrorTolerance` determines the margin of error the resulting ratio can have from the optimal ratio.
- `maxIterations` determines the maximum times the algorithm will iterate to find a ratio within error tolerance. If max iterations is exceeded, an error is returned. The benefit of running the algorithm more times is that we have more chances to find a route, but more iterations will longer to execute. We've used a default of 6 in our example.

```typescript
import { Fraction } from '@uniswap/sdk-core'
import { SwapAndAddConfig } from '@uniswap/smart-order-router'

const swapAndAddConfig: SwapAndAddConfig = {
  ratioErrorTolerance: new Fraction(1, 100),
  maxIterations: 6,
}
```

Finally, we will create an instance of `SwapAndAddOptions` to configure which position we are adding liquidity to and our defined swapping parameters in two different objects:

- **`swapConfig`** configures the `recipient` of leftover dust from swap, `slippageTolerance` and a `deadline` for the swap.
- **`addLiquidityOptions`** must contain a `tokenId` to add to an existing position

```typescript
import { SwapAndAddOptions } from '@uniswap/smart-order-router'

const swapAndAddOptions: SwapAndAddOptions = {
  swapOptions: {
    type: SwapType.SWAP_ROUTER_02,
    recipient: address,
    slippageTolerance: new Percent(50, 10_000),
    deadline: Math.floor(Date.now() / 1000) + 60 * 20,
  },
  addLiquidityOptions: {
    tokenId: positionId,
  },
}
```

## Calculating our currency ratio

Having constructed all the parameters we need to call `routeToRatio`, we can now make the call to the function:

```typescript
import { SwapToRatioResponse } from '@uniswap/smart-order-router'

const routeToRatioResponse: SwapToRatioResponse = await router.routeToRatio(
  token0CurrencyAmount,
  token1CurrencyAmount,
  currentPosition,
  swapAndAddConfig,
  swapAndAddOptions
)
```

The return type of the function call is [SwapToRatioResponse](https://github.com/Uniswap/smart-order-router/blob/97c1bb7cb64b22ebf3509acda8de60c0445cf250/src/routers/router.ts#L121). If a route was found successfully, this object will have two fields: the status (success) and the `SwapToRatioRoute` object. We check to make sure that both of those conditions hold true before we construct and submit the transaction:

```typescript
import { SwapToRatioStatus } from '@uniswap/smart-order-router'

if (
  !routeToRatioResponse ||
  routeToRatioResponse.status !== SwapToRatioStatus.SUCCESS
) {
  // Handle Failed Transaction
}
```

In case a route was not found, we return from the function a `Failed` state for the transaction.

## Constructing and executing our swap-and-add transaction

After making sure that a route was successfully found, we can now construct and send the transaction. The response (`SwapToRatioRoute`) will have the properties we need to construct our transaction object:

```typescript
import { SwapToRatioRoute } from '@uniswap/smart-order-router'

const route: SwapToRatioRoute = routeToRatioResponse.result
const transaction = {
  data: route.methodParameters?.calldata,
  to: V3_SWAP_ROUTER_ADDRESS,
  value: route.methodParameters?.value,
  from: address,
}

const txRes = await wallet.sendTransaction(transaction)
```

If the transaction was successful, our swap-and-add will be completed! We should see our input token balances decrease and our position balance should be increased accordingly.
</file>

<file path="docs/sdk/v3/guides/swaps/_category_.json">
{
  "label": "Swaps",
  "position": 4,
  "collapsed": true
}
</file>

<file path="docs/sdk/v3/guides/swaps/01-quoting.md">
---
id: quoting
title: Getting a Quote
---     

## Introduction

This guide will cover how to get the current quotes for any token pair on the Uniswap protocol. It is based on the [Quoting code example](https://github.com/Uniswap/examples/tree/main/v3-sdk/quoting), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/quoting/README.md) and follow the setup instructions.

:::info
If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](../01-background.md) page!
:::

In this example we will use `quoteExactInputSingle` to get a quote for the pair **USDC - WETH**.
The inputs are the **token in**, the **token out**, the **amount in** and the **fee**.

The **fee** input parameter represents the swap fee that is distributed to all in-range liquidity at the time of the swap. It is one of the identifiers of a Pool, along with **tokenIn** and **tokenOut**.
  
The guide will **cover**:

1. Computing the Pool's deployment address
2. Referencing the Pool contract and fetching metadata
3. Referencing the Quoter contract and getting a quote

At the end of the guide, we should be able to fetch a quote for the given input token pair and the input token amount with the press of a button on the web application.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

The core code of this guide can be found in [`quote.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/quoting/src/libs/quote.ts)

## Example configuration

We will use the example configuration `CurrentConfig` in most code snippets of this guide. It has the format:

```typescript
import { Token } from '@uniswap/sdk-core'

interface ExampleConfig {
  rpc: {
    local: string
    mainnet: string
  }
  tokens: {
    in: Token
    amountIn: number
    out: Token
    poolFee: number
  }
}

export const CurrentConfig: ExampleConfig = {...}
```

The default config of the example uses a local fork of mainnet. If you haven't already, check out our [local development guide](../02-local-development.md).
To change the rpc endpoint or the Pool used, edit the [`Currentconfig`](https://github.com/Uniswap/examples/blob/main/v3-sdk/quoting/src/config.ts#L21).
To connect to mainnet directly, set the `mainnet` field in the config:

```typescript
export const CurrentConfig: ExampleConfig = {
  rpc: {
    local: 'http://localhost:8545',
    mainnet: 'https://mainnet.infura.io/v3/0ac57a06f2994538829c14745750d721',
  },
  tokens: {
    in: USDC_TOKEN,
    amountIn: 1000,
    out: WETH_TOKEN,
    poolFee: FeeAmount.MEDIUM,
  },
}
```

The pool used is defined by a pair of tokens in [`constants.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/quoting/src/libs/constants.ts#L14). 
You can also change these two tokens and the fee of the pool in the config, just make sure a Pool actually exists for your configuration.
Check out the top pools on [Uniswap info](https://info.uniswap.org/#/pools).

## Computing the Pool's deployment address

To interact with the **USDC - WETH** Pool contract, we first need to compute its deployment address.
If you haven't worked directly with smart contracts yet, check out this [guide](https://docs.alchemy.com/docs/smart-contract-basics) from Alchemy.
The SDK provides a utility method for that:

```typescript
import { computePoolAddress } from '@uniswap/v3-sdk' 

const currentPoolAddress = computePoolAddress({
  factoryAddress: POOL_FACTORY_CONTRACT_ADDRESS,
  tokenA: CurrentConfig.tokens.in,
  tokenB: CurrentConfig.tokens.out,
  fee: CurrentConfig.tokens.poolFee,
})
```

Since each *Uniswap V3 Pool* is uniquely identified by 3 characteristics (token in, token out, fee), we use those
in combination with the address of the *PoolFactory* contract to compute the address of the **USDC - ETH** Pool.
These parameters have already been defined in our [constants.ts](https://github.com/Uniswap/examples/blob/main/v3-sdk/quoting/src/libs/constants.ts#L14) file:

```typescript
const WETH_TOKEN = new Token(
  1,
  '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
  18,
  'WETH',
  'Wrapped Ether'
)

const USDC_TOKEN = new Token(
  1,
  '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  6,
  'USDC',
  'USD//C'
)
```

These constants are used in the `config.ts` file, as mentioned in the Introduction.

We can find the Pool Factory Contract address for our chain [here](../../../../contracts/v3/reference/deployments/deployments.md).

## Referencing the Pool contract and fetching metadata

Now that we have the deployment address of the **USDC - ETH** Pool, we can construct an instance of an **ethers** `Contract` to interact with it:

```typescript
import { ethers } from 'ethers'

const provider = new ethers.providers.JsonRpcProvider(rpcUrl)
const poolContract = new ethers.Contract(
  currentPoolAddress,
  IUniswapV3PoolABI.abi,
  provider
)
```

To construct the *Contract* we need to provide the address of the contract, its ABI and the provider that will carry out the RPC call for us.
We get access to the contract's ABI through the [@uniswap/v3-core](https://www.npmjs.com/package/@uniswap/v3-core) package, which holds the core smart contracts of the Uniswap V3 protocol:

```typescript
import IUniswapV3PoolABI from '@uniswap/v3-core/artifacts/contracts/interfaces/IUniswapV3Pool.sol/IUniswapV3Pool.json'
```

Having constructed our reference to the contract, we can now access its methods through our provider.
We use a batch `Promise` call. This approach queries state data concurrently, rather than sequentially, to minimize the chance of fetching out of sync data that may be returned if sequential queries are executed over the span of two blocks:

```typescript
const [token0, token1, fee, liquidity, slot0] = await Promise.all([
  poolContract.token0(),
  poolContract.token1(),
  poolContract.fee(),
  poolContract.liquidity(),
  poolContract.slot0(),
])
```

The return values of these methods will become inputs to the quote fetching function.
The `token0` and `token1` variables are the addresses of the tokens in the Pool and should not be mistaken for `Token` objects from the sdk.
For the full code, check out [`getPoolConstants()`](https://github.com/Uniswap/examples/blob/main/v3-sdk/quoting/src/libs/quote.ts#L35) in `quote.ts`.

:::note
In this example, the metadata we fetch is already present in our inputs. This guide fetches this information first in order to show how to fetch any metadata, which will be expanded on in future guides.
:::

## Referencing the Quoter contract and getting a quote

To get quotes for trades, Uniswap has deployed a **Quoter Contract**. We will use this contract to fetch the output amount we can expect for our trade, without actually executing the trade.
Check out the full code for the following snippets in [quote.ts](https://github.com/Uniswap/examples/blob/main/v3-sdk/quoting/src/libs/quote.ts)

Like we did for the Pool contract, we need to construct an instance of an **ethers** `Contract` for our Quoter contract in order to interact with it:

```typescript
const quoterContract = new ethers.Contract(
  QUOTER_CONTRACT_ADDRESS,
  Quoter.abi,
  getProvider()
)
```

We get access to the contract's ABI through the [@uniswap/v3-periphery](https://www.npmjs.com/package/@uniswap/v3-periphery) package, which holds the periphery smart contracts of the Uniswap V3 protocol:

```typescript
import Quoter from '@uniswap/v3-periphery/artifacts/contracts/lens/Quoter.sol/Quoter.json'
```

We get the QUOTE_CONTRACT_ADDRESS for our chain from [GitHub](https://github.com/Uniswap/v3-periphery/blob/main/deploys.md).

We can now use our Quoter contract to obtain the quote.

In an ideal world, the quoter functions would be `view` functions, which would make them very easy to query on-chain with minimal gas costs. However, the Uniswap V3 Quoter contracts rely on state-changing calls designed to be reverted to return the desired data. This means calling the quoter will be very expensive and should not be called on-chain.

To get around this difficulty, we can use the `callStatic` method provided by the **ethers.js** `Contract` instances.
This is a useful method that submits a state-changing transaction to an Ethereum node, but asks the node to simulate the state change, rather than to execute it. Our script can then return the result of the simulated state change:

```typescript
const quotedAmountOut = await quoterContract.callStatic.quoteExactInputSingle(
  token0,
  token1,
  fee,
  fromReadableAmount(
    CurrentConfig.tokens.amountIn,
    CurrentConfig.tokens.in.decimals
  ).toString(),
  0
)
```

The `fromReadableAmount()` function creates the amount of the smallest unit of a token from the full unit amount and the decimals.

The result of the call is the number of output tokens you'd receive for the quoted swap.

It should be noted that `quoteExactInputSingle` is only 1 of 4 different methods that the quoter offers:

1. `quoteExactInputSingle` - given the amount you want to swap, produces a quote for the amount out for a swap of a single pool
2. `quoteExactInput` - given the amount you want to swap, produces a quote for the amount out for a swap over multiple pools
3. `quoteExactOutputSingle` - given the amount you want to get out, produces a quote for the amount in for a swap over a single pool
4. `quoteExactOutput`  - given the amount you want to get out, produces a quote for the amount in for a swap over multiple pools

If we want to trade two tokens that do not share a pool with each other, we will need to make swaps over multiple pools.
This is where the `quoteExactInput` and `quoteExactOutput` methods come in.
We will dive deeper into routing in the [routing guide](03-routing.md).

For the `exactOutput` and `exactOutputSingle` methods, we need to keep in mind that a pool can not give us more than the amount of Tokens it holds.
If we try to get a quote on an output of 100 WETH from a Pool that only holds 50 WETH, the function call will fail.

## Referencing the QuoterV2 contract and getting a quote

```typescript
const quoterV2Contract = new ethers.Contract(
  QUOTER_V2_CONTRACT_ADDRESS,
  QuoterV2.abi,
  getProvider()
)
```

We get the QUOTE_V2_CONTRACT_ADDRESS for our chain from [V3 reference deployments](../../../../contracts/v3/reference/deployments/deployments.md).

We get access to the contract's ABI through the [@uniswap/v3-periphery](https://www.npmjs.com/package/@uniswap/v3-periphery) package, which holds the periphery smart contracts of the Uniswap V3 protocol:

```typescript
import Quoter as QuoterV2 from '@uniswap/v3-periphery/artifacts/contracts/lens/QuoterV2.sol/QuoterV2.json'
```
Let's get the quote for our tokens, where "Quoter" takes multiple arguments in quoteExactInputSingle(), QuoterV2 takes only one argument in the form of an object

```typescript
const quote = await quoterContract.callStatic.quoteExactInputSingle(
  {
    tokenIn: tokenIn.address, // tokenIn is of type Token
    tokenOut: tokenOut.address, // tokenOut is of type Token
    fee: fee, // eg. 3000
    amountIn: fromReadableAmount(amountIn, tokenIn.decimals).toString(),
    sqrtPriceLimitX96: 0,
  }
);
console.log(quote.amountOut);
```

This will return "amountOut" , "gasEstimate", "initializedTicksCrossed" and "sqrtPriceX96After"
1. **AmountOut**: The tokens or cryptocurrency received in a Uniswap swap transaction.

2. **Gas Estimate**: Estimated amount of gas required for executing a Uniswap transaction on the Ethereum network.

3. **InitializedTicksCrossed**: In Uniswap V3, indicates whether liquidity has crossed certain price thresholds within a liquidity range.

4. **SqrtPriceX96After**: Square root of the price after a Uniswap V3 transaction, essential for determining pricing accuracy.


## Next Steps

Now that you're able to make a quote, check out our next guide on [trading](./02-trading.md) using this quote!
</file>

<file path="docs/sdk/v3/guides/swaps/02-trading.md">
---
id: trading
title: Executing a Trade
---   

## Introduction

This guide will build off our [quoting guide](./01-quoting.md) and show how to use a quote to construct and execute a trade on the Uniswap V3 protocol. It is based on the [Trading code example](https://github.com/Uniswap/examples/tree/main/v3-sdk/trading), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the guide's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/trading/README.md) and follow the setup instructions.

:::info
If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](../01-background.md) page!

To get started with local development, also check out the [local development guide](../02-local-development.md).
:::

In this example we will trade between two ERC20 tokens: **WETH and USDC**. The tokens, amount of input token, and the fee level can be configured as inputs.

The guide will **cover**:

1. Constructing a route from pool information
2. Constructing an unchecked trade
3. Executing a trade

At the end of the guide, we should be able to create and execute a trade between any two ERC20 tokens using the example's included UI.

:::note
Included in the example application is functionality to wrap/unwrap ETH as needed to fund the example `WETH` to `USDC` swap directly from an `ETH` balance.
:::

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

The core code of this guide can be found in [`trading.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/trading/src/libs/trading.ts)

## Using a wallet extension

Like in the previous guide, our [example](https://github.com/Uniswap/examples/blob/main/v3-sdk/trading) uses a [config file ](https://github.com/Uniswap/examples/blob/main/v3-sdk/trading/src/config.ts) to configurate the inputs used.
The strucuture is similar to the quoting config, but we also have the option to select an environment:

```typescript
export interface ExampleConfig {
  env: Environment
  rpc: {
    local: string
    mainnet: string
  }
  wallet: {
    address: string
    privateKey: string
  }
  tokens: {
    in: Token
    amountIn: number
    out: Token
    poolFee: number
  }
}
```

Per default, the env field is set to `Environment.LOCAL`:

```typescript
export const CurrentConfig: ExampleConfig = {
  env: Environment.LOCAL,
  rpc: {
    local: 'http://localhost:8545',
    mainnet: '',
  },
  wallet: {
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
    privateKey:
      '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
  },
  tokens: {
    in: WETH_TOKEN,
    amountIn: 1,
    out: USDC_TOKEN,
    poolFee: FeeAmount.MEDIUM,
  },
}
```

In this example, we have the option to use a Wallet Extension like Metamask to sign the transactions we are sending. To do so, let's change the Environment to `Environment.WALLET_EXTENSION`:

```typescript
export const CurrentConfig: ExampleConfig = {
  env: Environment.WALLET_EXTENSION,
  rpc: {
    local: 'http://localhost:8545',
  },
  wallet: {
    ...
  },
  tokens: {
    ...
  },
}
```

Run the example and then add the local network to your wallet browser extension, if you are using Metamask for example, follow [this guide](https://support.metamask.io/hc/en-us/articles/360043227612-How-to-add-a-custom-network-RPC).
You should also import a private key to use on your local network, for example `0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80` from Foundry's example wallets.

Consider checking out the [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/trading/README.md) of the example.

If you cannot see the Tokens traded in your wallet, you possibly have to [import them](https://support.metamask.io/hc/en-us/articles/360015489031-How-to-display-tokens-in-MetaMask).

## Constructing a route from pool information

To construct our trade, we will first create an model instance of a `Pool`. We create an **ethers** contract like in the [previous guide](./01-quoting.md#referencing-the-pool-contract-and-fetching-metadata).
We will first extract the needed metadata from the relevant pool contract. Metadata includes both constant information about the pool as well as information about its current state stored in its first slot:

```typescript
async function getPoolInfo() {
    const [token0, token1, fee, liquidity, slot0] =
    await Promise.all([
        poolContract.fee(),
        poolContract.liquidity(),
        poolContract.slot0(),
    ])

    return {
        fee,
        liquidity,
        sqrtPriceX96: slot0[0],
        tick: slot0[1],
    } 
}
```

Before continuing, let's talk about the values we fetched here and what they represent:

- `fee` is the fee that is taken from every swap that is executed on the pool in 1 per million - if the `fee` value of a pool is 500, ```500/ 1000000``` (or 0.05%) of the trade amount is taken as a fee. This fee goes to the liquidity providers of the Pool.
- `liquidity` is the amount of liquidity the Pool can use for trades at the current price.
- `sqrtPriceX96` is the current Price of the pool, encoded as a ratio between `token0` and `token1`.
- `tick` is the tick at the current price of the pool.

Check out the [whitepaper](https://uniswap.org/whitepaper-v3.pdf) to learn more on how liquidity and ticks work in Uniswap V3.
  
You can find the full code in [`pool.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/trading/src/libs/pool.ts).

Using this metadata along with our inputs, we will then construct a `Pool`:

```typescript
const poolInfo = await getPoolInfo()

const pool = new Pool(
  CurrentConfig.tokens.in,
  CurrentConfig.tokens.out,
  CurrentConfig.tokens.poolFee,
  poolInfo.sqrtPriceX96.toString(),
  poolInfo.liquidity.toString(),
  poolInfo.tick
)
```

## Creating a Route

With this `Pool`, we can now construct a route to use in our trade. Routes represent a route over one or more pools from one Token to another. Let's imagine we have three pools:

```
- PoolA: USDC/ WETH
- PoolB: USDT/ WETH
- PoolC: USDT/ DAI
```

We would like to trade from USDC to DAI, so we create a route through our 3 pools:

```
PoolA -> PoolB -> PoolC
```

The `Route` object can find this route from an array of given pools and an input and output Token.

To keep it simple for this guide, we only swap over one Pool:

```typescript
import { Route } from '@uniswap/v3-sdk'

const swapRoute = new Route(
  [pool],
  CurrentConfig.tokens.in,
  CurrentConfig.tokens.out
)
```

Our `Route` understands that `CurrentConfig.tokens.in` should be traded for `CurrentConfig.tokens.out` over the Array of pools `[pool]`.


## Constructing an unchecked trade

Once we have constructed the route object, we now need to obtain a quote for the given `inputAmount` of the example:

```typescript
const amountOut = await getOutputQuote(swapRoute)
```

As shown below, the quote is obtained using the `v3-sdk`'s `SwapQuoter`, in contrast to the [previous quoting guide](./01-quoting.md), where we directly accessed the smart contact:

```typescript
import { SwapQuoter } from '@uniswap/v3-sdk'
import { CurrencyAmount, TradeType } from '@uniswap/sdk-core'

const { calldata } = await SwapQuoter.quoteCallParameters(
  swapRoute,
  CurrencyAmount.fromRawAmount(
    CurrentConfig.tokens.in,
    fromReadableAmount(
      CurrentConfig.tokens.amountIn,
      CurrentConfig.tokens.in.decimals
    )
  ),
  TradeType.EXACT_INPUT,
  {
    useQuoterV2: true,
  }
)
```

The `SwapQuoter`'s `quoteCallParameters` function, gives us the calldata needed to make the call to the `Quoter`, and we then decode the returned quote:

```typescript
const quoteCallReturnData = await provider.call({
  to: QUOTER_CONTRACT_ADDRESS,
  data: calldata,
})

return ethers.utils.defaultAbiCoder.decode(['uint256'], quoteCallReturnData)
```

With the quote and the route, we can now construct a trade using the route in addition to the output amount from a quote based on our input.
Because we already know the expected output of our Trade, we do not have to check it again. We can use the `uncheckedTrade` function to create our Trade:

```typescript
import { Trade } from 'uniswap/v3-sdk'
import { CurrencyAmount, TradeType } from '@uniswap/sdk-core'
import JSBI from 'jsbi'

const uncheckedTrade = Trade.createUncheckedTrade({
  route: swapRoute,
  inputAmount: CurrencyAmount.fromRawAmount(
    CurrentConfig.tokens.in,
    fromReadableAmount(
      CurrentConfig.tokens.amountIn,
      CurrentConfig.tokens.in.decimals
    )
  ),
  outputAmount: CurrencyAmount.fromRawAmount(
    CurrentConfig.tokens.out,
    JSBI.BigInt(amountOut)
  ),
  tradeType: TradeType.EXACT_INPUT,
})
```

This example uses an exact input trade, but we can also construct a trade using exact output assuming we adapt our quoting code accordingly.

## Executing a trade

Once we have created a trade, we can now execute this trade with our provider. First, we must give the `SwapRouter` approval to spend our tokens for us:

```typescript
const tokenApproval = await getTokenTransferApproval(CurrentConfig.tokens.in)
```

You can find the approval function [here](https://github.com/Uniswap/examples/blob/main/v3-sdk/trading/src/libs/trading.ts#L151). 
We will use this function or similar implementations in most guides.

Then, we set our options that define how much time and slippage can occur in our execution as well as the address to use for our wallet:

```typescript
import { SwapOptions } from '@uniswap/v3-sdk'
import { Percent } from '@uniswap/sdk-core'

const options: SwapOptions = {
  slippageTolerance: new Percent(50, 10_000), // 50 bips, or 0.50%
  deadline: Math.floor(Date.now() / 1000) + 60 * 20, // 20 minutes from the current Unix time
  recipient: walletAddress,
}
```

The slippage of our trade is the maximum decrease from our calculated output amount that we are willing to accept for this trade.
The deadline is the latest point in time when we want the transaction to go through. 
If we set this value too high, the transaction could be left waiting for days and we would need to pay gas fees to cancel it.

Next, we use the `SwapRouter` class, a representation of the Uniswap [SwapRouter Contract](https://github.com/Uniswap/v3-periphery/blob/v1.0.0/contracts/SwapRouter.sol), to get the associated call parameters for our trade and options:

```typescript
import { SwapRouter } from '@uniswap/v3-sdk'

const methodParameters = SwapRouter.swapCallParameters([uncheckedTrade], options)
```

Finally, we can construct a transaction from the method parameters and send the transaction:

```typescript
const tx = {
  data: methodParameters.calldata,
  to: SWAP_ROUTER_ADDRESS,
  value: methodParameters.value,
  from: walletAddress,
  maxFeePerGas: MAX_FEE_PER_GAS,
  maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,
}

const res = await wallet.sendTransaction(tx)
```

## Next Steps

The resulting example allows for trading between any two ERC20 tokens, but this can be suboptimal for the best pricing and fees. To achieve the best possible price, we use the Uniswap auto router to route through pools to get an optimal cost. Our [routing](./03-routing.md) guide will show you how to use this router and execute optimal swaps.
</file>

<file path="docs/sdk/v3/guides/swaps/03-routing.md">
---
id: routing
title: Routing a Swap
---

## Introduction

This guide will cover how to use Uniswap's smart order router to compute optimal routes and execute swaps. Rather than trading between a single pool, smart routing may use multiple hops (as many as needed) to ensure that the end result of the swap is the optimal price. It is based on the [routing code example](https://github.com/Uniswap/examples/tree/main/v3-sdk/routing), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the guide's [README](https://github.com/Uniswap/examples/blob/main/v3-sdk/routing/README.md) and follow the setup instructions.

:::info
If you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our [background](../01-background.md) page!
:::

In this example we will trade between **WETH and USDC**, but you can configure your example to use any two currencies and amount of input currency.

The guide will **cover**:

1. Creating a router instance
2. Creating a route
3. Swapping using a route

At the end of the guide, we should be able to create a route and execute a swap between any two currencies tokens using the example's included UI.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)
- [`@uniswap/smart-order-router`](https://www.npmjs.com/package/@uniswap/smart-order-router)

The core code of this guide can be found in [`routing.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/routing/src/libs/routing.ts)

The config, which we will use in some code snippets in this guides has this structure:

```typescript
import { Token } from '@uniswap/sdk-core'

interface ExampleConfig {
  env: Environment
  rpc: {
    local: string
    mainnet: string
  }
  wallet: {
    address: string
    privateKey: string
  }
  tokens: {
    in: Token
    amountIn: number
    out: Token
  }
}

export const CurrentConfig: ExampleConfig = {...}
```

## Creating a router instance

To compute our route, we will use the `@uniswap/smart-order-router` package, specifically the `AlphaRouter` class which requires a `chainId` and a `provider`. Note that routing is not supported for local forks, so we will use a mainnet provider even when swapping on a local fork:

```typescript
import { AlphaRouter, ChainId } from '@uniswap/smart-order-router'

const provider = new ethers.providers.JsonRpcProvider(rpcUrl)

const router = new AlphaRouter({
  chainId: ChainId.MAINNET,
  provider,
})
```

## Creating a route

We will use the [SwapRouter02](https://github.com/Uniswap/v3-periphery/blob/v1.0.0/contracts/SwapRouter.sol) for our trade.
The `smart-order-router` package provides us with a `SwapOptionsSwapRouter02` interface, defining the wallet to use, slippage tolerance, and deadline for the transaction that we need to interact with the contract:

```typescript
import { SwapOptionsSwapRouter02, SwapType } from '@uniswap/smart-order-router'
import { Percent } from '@uniswap/sdk-core'

const options: SwapOptionsSwapRouter02 = {
  recipient: CurrentConfig.wallet.address,
  slippageTolerance: new Percent(50, 10_000),
  deadline: Math.floor(Date.now() / 1000 + 1800),
  type: SwapType.SWAP_ROUTER_02,
}
```

Like explained in the [previous guide](./02-trading.md#executing-a-trade), it is important to set the parameters to sensible values.

Using these options, we can now create a trade (`TradeType.EXACT_INPUT` or `TradeType.EXACT_OUTPUT`) with the currency and the input amount to use to get a quote. For this example, we'll use an `EXACT_INPUT` trade to get a quote outputted in the quote currency.

```typescript
import { CurrencyAmount, TradeType } from '@uniswap/sdk-core'

const rawTokenAmountIn: JSBI = fromReadableAmount(
      CurrentConfig.tokens.amountIn,
      CurrentConfig.tokens.in.decimals
    )

const route = await router.route(
  CurrencyAmount.fromRawAmount(
    CurrentConfig.tokens.in,
    rawTokenAmountIn
  ),
  CurrentConfig.tokens.out,
  TradeType.EXACT_INPUT,
  options
)
```

The `fromReadableAmount` function calculates the amount of tokens in the Token's smallest unit from the full unit and the Token's decimals:

```typescript title="src/libs/conversion.ts"
export function fromReadableAmount(amount: number, decimals: number): JSBI {
  const extraDigits = Math.pow(10, countDecimals(amount))
  const adjustedAmount = amount * extraDigits
  return JSBI.divide(
    JSBI.multiply(
      JSBI.BigInt(adjustedAmount),
      JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimals))
    ),
    JSBI.BigInt(extraDigits)
  )
}
```

`route` and `route.methodParameters` are *optional* as the request can fail, for example if **no route exists** between the two Tokens or because of networking issues.
We check if the call was succesful:

```typescript
if (!route || !route.methodParameters) {
    // Handle failed request
}
```

Depending on our preferences and reason for the issue we could retry the request or throw an Error.

## Swapping using a route

First, we need to give approval to the `SwapRouter` smart contract to spend our tokens for us:

```typescript
import { ethers } from 'ethers'
...

const wallet = new ethers.Wallet(privateKey, provider)
const tokenContract = new ethers.Contract(
    CurrentConfig.tokens.in.address, 
    ERC20ABI, 
    wallet
)
const tokenApproval = await tokenContract.approve(
    V3_SWAP_ROUTER_ADDRESS, 
    ethers.BigNumber.from(rawTokenAmountIn.toString())
)
```

To be able to spend the tokens of a wallet, a smart contract first needs to get an approval from that wallet. 
ERC20 tokens have an `approve` function that accepts the address of the smart contract that we want to allow spending our tokens and the amount the smart contract should be allowed to spend.

We can get the **V3_SWAP_ROUTER_ADDRESS** for our chain from the `SwapRouter02` field in [Deployments](../../../../contracts/v3/reference/deployments/deployments.md). 
Keep in mind that different chains might have **different deployment addresses** for the same contracts.
The deployment address for local forks of a network are the same as in the network you forked, so for a **fork of mainnet** it would be the address for **Mainnet**.

We need to wait one block for the approval transaction to be included by the blockchain.

Once the approval has been granted, we can now execute the trade using the route's computed calldata, values, and gas values:

```typescript
const txRes = await wallet.sendTransaction({
  data: route.methodParameters.calldata,
  to: V3_SWAP_ROUTER_ADDRESS,
  value: route.methodParameters.value,
  from: wallet.address,
  maxFeePerGas: MAX_FEE_PER_GAS,
  maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,
})
```

After swapping, you should see the currency balances update in the UI shortly after the block is confirmed.

You can find the full code in [`routing.ts`](https://github.com/Uniswap/examples/blob/main/v3-sdk/routing/src/libs/routing.ts).

## Next Steps

Now that you're familiar with trading, consider checking out our next guides on [pooling liquidity](../liquidity/01-position-data.md) to Uniswap!
</file>

<file path="docs/sdk/v3/guides/_category_.json">
{
  "label": "Guides",
  "position": 2,
  "collapsed": false
}
</file>

<file path="docs/sdk/v3/guides/01-background.md">
---
id: background
title: Background
position: 1
---

Before integrating with Uniswap, it may be helpful for newcomers to review the following background information on some important developer web3 concepts, the structure of our examples, and SDK concepts.

:::info
Already familiar with web3 development and/or the basics of our SDK and want to get right to the code? Start with our first guide, [Getting a Quote](./swaps/01-quoting.md)!
:::

## Providers

Communication with the blockchain is typically done through a provider and local models of smart contracts and their [ABIs](#abis).

To achieve this, our examples use the [ethers.js](https://docs.ethers.io/v5/) library. To instantiate a provider you will need a data source. Our examples offer two options:

- **JSON RPC URL**: If you are working directly with the Ethereum mainnet or a local fork, products such as [Infura](https://infura.io/) offer JSON RPC URLs for a wide variety of chains and testnets. For our examples, we'll only be using the Ethereum mainnet.

- **Wallet Extension**: If you are connecting to a wallet browser extension, these wallets embed a source directly into the Javascript window object as `window.ethereum`. This object surfaces information about the user's wallets and provides the ability to communicate with the connected chain. Importantly for our examples, it can be used with `ethers.js` to construct a provider.

## Uniswap's Runnable Examples

Each guide is accompanied and driven by [runnable examples](https://github.com/Uniswap/examples/tree/main/v3-sdk) using React to provide a basic UI for interacting with the example. Each examples provides relevant options such as running against a local blockchain or connecting to the Ethereum mainnet directly. You also have the option of using a wallet extension which can be connected to either environment.

Inputs and environment settings are configured in each example's `config.ts` and allows for simple setup and configuration.

### Developing and Testing

To test your code, we recommend utilizing a local fork of the Ethereum mainnet. To help facilitate easy testing, each example includes a quickstart for running the local chain with a test wallet. To further test, we also recommend using a wallet extension and connecting to the local chain. Finally, each example can be run against the Ethereum mainnet if desired. Full development instructs can be found in the `README.md` of each code example.

### Utility Libraries

Each example is concentrated into a single file within the `libs/` folder of the example, with the entry points noted in each guide and README.

To allow the guides to focus on the SDK's core functionality, additional basic building blocks can be found in each example's `libs` folder. The exported functionality from these files is intended to be the minimum needed for each example and not a complete library for production usage. These also include storing core constants such as definitions for tokens, ABI's, and blockchain addresses that can distract from the core concepts. Below are summaries of the helping libraries you will encounter.

#### Provider Utilities

`provider.ts` wraps the basics of `ethers.js` and connecting to wallet extensions into an abstracted view of a provider, a wallet address, and the ability to send transactions. It also helps abstract the configured environment you wish to run against in your example without making code changes outside of your configuration.

#### Wallet Utilities

`wallet.ts` offers the ability to query a wallet (whether connected via an extension or defined in code/config) for its balances and other essential information.

#### Pool Information

`pool.ts` contains the basic querying of pool information when not essential / core to the relevant guide

#### Display Utilities

`conversion.ts` provides display and light math wrappers to help show human readable prices when dealing with currency amounts (typically stored as raw numbers and the decimal placement separate for precision reasons) in the form of two functions: `fromReadableAmount` and `toReadableAmount`

## Notable SDK Structures and Concepts

When working with the SDK it can be helpful to understand some of the design choices and why they are needed. Below you can find a few important concepts.

### ABI's

To allow others to interact with a smart contract, each contract exposes an ABI (Application Binary Interface). As these are defined on the blockchain, we must ensure the correct definitions are provided to our Javascript functions. ABI's are provided from various SDK's and imported in as needed. Some examples will define an ABI directly as needed.

### CurrencyAmount and JSBI

Cryptocurrency applications often work with very small fractions of tokens. As a result, high precision is very important. To ensure precision is upheld, the `CurrencyAmount` class helps store exact values as fractions and utilizes [JSBI](https://github.com/GoogleChromeLabs/jsbi) for compatibility across the web. To display these amounts nicely to users, additional work is sometimes required.

### Currency

The `Currency` class can represent both native currency (ETH) and an ERC20 `Token`. Currencies vary in their relative value, so the `Token` class allows your application to define the number of decimals needed for each currency along with the currency's address, symbol, and name.
</file>

<file path="docs/sdk/v3/guides/02-local-development.md">
---
id: local-development
title: Local Development
position: 2
---

## Introduction

Developing your dApps or smart contracts requires some tinkering to get a proper setup that is both a good simulation of how Mainnet will behave,
but also customizable enough to suit the needs of a development environment.

One very common approach is to create your own custom chain offline and develop on top of it.
The issue with this approach is that if you are integrating with protocols like Uniswap or others that are on Mainnet, it's
difficult to simulate on your local chain as the smart contracts from Mainnet are not there.

Another approach is to use a testnet like Ethereum Goerli. While most protocols (including Uniswap) have versions of their smart contracts
deployed on common testnets, there are certain behavioural differences. Not all pools that are on Mainnet are on Goerli for example.
Also, it's difficult to get enough testnet ETH to account for real testing. And without lots of testnet ETH it's even more difficult
to swap to other coins on Uniswap, if that's what you need to do in your development environment.

This guide focuses on yet another approach to local development: Mainnet Forks.

A Mainnet Fork is a local chain that copies the state of Ethereum Mainnet at a given block number. It then gives you access to cheat codes
like wallets with thousands of ETH and RPC URLs that you can use as drop-in replacements of real Mainnet RPCs.

This approach combines the best of all other approaches. You have a local chain that you can manipulate to your liking
and you have real deployments of all the protocols you need to test and develop your dApp or smart contracts.

:::info
This guide focuses on Ethereum Mainnet. But you can easily fork any other chain by simply replacing the RPC URL with
one of the network you want to use.
:::

For this guide, the following packages are used:
  
- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)
- [`ethers@5`](https://www.npmjs.com/package/ethers)

Please note that we use ethers version 5, as this is still the most commonly used version of ethers.js.
If you use version 6, you will need to slightly change the syntax in the examples below.

:::info
Forking a chain requires archival data and trace calls. Infura and normal geth instances are by default not archival.
You can get a free archival RPC that you can use to follow this guide and fork Mainnet you can visit [Chainnodes](https://www.chainnodes.org/).
:::

## Using Foundry and Anvil

There are several developer tools to fork Mainnet.
[Anvil](https://github.com/foundry-rs/foundry/tree/master/crates/anvil) by foundry is a newcomer that's fast and easy to setup.
This guide focuses on Anvil.

As a first step, follow the [installation guide](https://book.getfoundry.sh/getting-started/installation) in the foundry book.

Once you have done that, you will be able to fork Mainnet straight away. Run the below command in your terminal:

Make sure that you:

- Replace your API Key (get one by heading to [Chainnodes](https://app.chainnodes.org/))
- Replace the block number with a recent one, check [Etherscan](https://etherscan.io/) for that
- If you fork a non-Ethereum Mainnet chain, check [Chainlist](https://chainlist.org/) for the correct chain id and replace both occurrences in the command below

```bash
anvil --fork-url https://mainnet.chainnodes.org/api_key --fork-block-number 17480237 --fork-chain-id 1 --chain-id 1
```

Run `anvil --help` to see all available options.

Once you have done that, you should see something like the below:

<img src={require('./images/anvil-result.png').default} alt="anvil result after calling" box-shadow="none"/>

Your local fork of Mainnet is now running!

And as you can see on the screenshot above, anvil prints a bunch of private keys that are loaded with 10k ETH each.
We will use them going forward to send transactions, including swaps on Uniswap pools.

:::warning
Security consideration: This is a fork of Mainnet and the same chain id is used. You have no replay protection to Ethereum Mainnet. So you need to 1: Never use the anvil private keys on a real chain or send funds to it
(they are leaked everywhere) and 2: Not send any transactions to your local fork chain with accounts that you use on Ethereum Mainnet or other real chains.
:::

If you scroll down in your terminal, near the bottom of the anvil logs you will find your RPC URL.
If you haven't changed any configs, it should be `127.0.0.1:8545`.
This is the RPC URL that you can now use as a drop-in replacement everywhere in your development environment, and interact with it
as if it was real Ethereum Mainnet. You can use the http provider `http://127.0.0.1:8545` as well as the Websocket provider `ws://127.0.0.1:8545`.

You can now make a sample RPC request to your http provider using [Postman](https://www.postman.com/) using the below:

POST `http://127.0.0.1:8545`

Body:

```json
{
    "jsonrpc": "2.0",
    "method": "eth_chainId",
    "params": [],
    "id": 1
}
```

The result should look like the below (see image below as well):

```json
{
    "jsonrpc": "2.0",
    "id": 1,
    "result": "0x1"
}
```

<img src={require('./images/postman-chainid-result.png').default} alt="anvil result after calling" box-shadow="none"/>

As you can see, the chain id is `1`, just like on Mainnet!

You can find the above example and more in [this Postman workspace](https://www.postman.com/chainnodes/workspace/uniswap-examples) under "Local Development".

## Using your Mainnet Fork

Now that you have a running Mainnet Fork, you will be able to use it everywhere in your development setup.
Using one of the private keys provided by anvil, you have access to enough ETH to do endless swaps and smart contract calls.

If you need any other token, you now have the flexibility of swapping your ETH to any token that has a pool deployed on Mainnet.
You basically take your fake ETH and swap it to the token you need.

Check out one of the [guides about swapping](./swaps/02-trading.md) and replace the RPC URL with your local anvil HTTP link as above.

## Next Steps

Using the above you are fully equipped to continue following the guides about how to use Uniswap while testing everything locally before
going on Mainnet. You will also be able to reuse what you have learned when you develop your own protocols or dApps.

You can also continue tapping into other developer tools that make smart contract development easier like [forge](https://github.com/foundry-rs/foundry/tree/master/crates/forge) from foundry.
To read more about foundry and their developer tooling, visit their [GitHub](https://github.com/foundry-rs/foundry) or the [foundry book](https://book.getfoundry.sh/).
</file>

<file path="docs/sdk/v3/guides/03-web3-development-basics.md">
---
id: web3-development-basics
title: Web3 Development Basics
position: 3
---

## Introduction

Developing dApps and interacting with Smart Contracts is quite different from Web2, and at times challenging due to little information
on this topic compared to other areas of software development.

This developer guide is a quick overview of the space, including references to libraries and guides that are great starting points.
Reading this guide should help you identify areas that you might need to learn a bit more about and prepare you for the following Uniswap-specific guides.

It is assumed that you know the basics about Ethereum and the blockchain, including some terminology.
If you already know how to build dApps and interact with ethersJS etc. you can safely skip this guide.

## RPCs

The access point to the blockchain are RPC nodes. They are the [standardized interface](https://ethereum.org/en/developers/docs/apis/json-rpc/)
to read data from smart contracts, send transactions and interact with on-chain protocols.

RPCs are either [full or archival nodes](https://ethereum.org/en/developers/docs/nodes-and-clients/archive-nodes/)
with a ([JSON-RPC](https://www.jsonrpc.org/)) interface.

To support Ethereum's decentralization, one can host a node themselves, for example by using one of the implementations listed below:

* [geth](https://github.com/ethereum/go-ethereum) - The original (reference) implementation of the Ethereum protocol
* [erigon](https://github.com/ledgerwatch/erigon) - A very efficient archival node implementation
* [Nethermind](https://github.com/NethermindEth/nethermind) - An Ethereum implementation focused on stability

As achieving high availability and making sure your node is synced all the time turns out to be quite challenging,
there are nodes as a service (RPC) providers that you can use, especially in production environments.
When choosing an RPC provider, we suggest you look for an RPC service that supports websockets as they provide far superior performance than HTTP connections.
To ensure interoperability, you should also ensure that your RPC provider adheres strictly to the JSON-RPC standard and doesn't require custom requests.

[Chainnodes](https://www.chainnodes.org/) is a robust RPC provider with generous free tier that you can use in both development and production environments.
For testing purposes you could also use a free public RPC endpoint, for example from [Chainlist](https://chainlist.org/).

### JSON-RPC Standard

RPCs communicate over the [JSON-RPC](https://www.jsonrpc.org/) standard. To send requests, you take the RPC URL and
make a POST request with a JSON body. See the below example:

`POST https://mainnet.chainnodes.org/API_KEY`

Body:

```json
{
    "jsonrpc": "2.0",
    "method": "eth_blockNumber",
    "params": [],
    "id": 1
}
```

At the time of writing, this request would respond with the following:

```json
{
    "id": 1,
    "result": "0x11527c0",
    "jsonrpc": "2.0"
}
```

Examining the result, we see that the result is an encoded hex string.
After decoding it, we see it returns the current blocknumber of our network, `18163648`.

You can find the above examples, including more, in [this Postman collection](https://www.postman.com/chainnodes/workspace/uniswap-examples).

To check out all possible RPC requests, head over to the [Chainnodes Docs](https://www.chainnodes.org/docs).

### Client implementations

As communicating over HTTP with POST requests directly can be quite difficult, especially if you want to properly
encode and decode responses and handle failures and exponential backoffs, there are client implementations that
can do the heavy lifting for you. These SDKs have developer friendly APIs and internally handle
creating the proper RPC requests, sending them to the endpoint you choose and decoding the response for you.

Some of the major implementations are listed below:

* [ethers.js](https://github.com/ethers-io/ethers.js) - Javascript/Typescript SDK for NodeJS and the Browser. Used throughout the Uniswap Docs.
* [wagmi](https://github.com/wagmi-dev/wagmi) and [viem](https://github.com/wagmi-dev/viem) - Javascript/Typescript, great duo for modern Web3 development in the Browser.
* [web3js](https://github.com/web3/web3.js) - Javascript/Typescript SDK for NodeJS and the Browser by ChainSafe.

Web3 development is not limited to JS. Web3 libraries for various languages include:

* [Web3.swift](https://github.com/Boilertalk/Web3.swift) - Swift SDK for iOS apps and Backends.
* [KEthereum](https://github.com/komputing/KEthereum) - Kotlin SDK for Android development.
* [ethers-rs](https://github.com/gakonst/ethers-rs) - Rust SDK.
* [ethclient](https://github.com/ethereum/go-ethereum/tree/master/ethclient) - Go SDK, part of geth, the reference Ethereum node implementation.
* [web3.py](https://github.com/ethereum/web3.py) - Python SDK.

At the moment, Uniswap only offers Typescript sdks.

As you can see there are lots of SDKs to make it easier to communicate via RPC with the blockchain.

### Local Development

To simulate RPCs and transactions locally, you can check [this guide](./02-local-development).

## Indexers

As RPCs are only a slim abstraction of the data stored in the blockchain, there are certain things that are hard
or expensive to access with regular RPC requests.

A common example are transactions of a specific Wallet address. Imagine you want to get a list of all transactions that originated from (or to) a
specific Wallet. One could think there should be an RPC method called `eth_getTransactionsForWallet` or something similar.
But due to the nature of how the data is stored, this RPC method is not feasible, and hence not implemented.

Now, instead of accessing those kind of things by iterating through every block in the blockchain, you can use Indexers, that are
designed to index data like that on the go and provide easy access to it.

### TheGraph

A well-known, standardized implementation of indexers is [TheGraph](https://thegraph.com/). It is used by most major protocols,
including Uniswap, to index data and make it accessible to users and dashboards.

Using TheGraph, you can either access open [subgraphs](https://thegraph.com/explorer) via the GraphQL querying language, or [create your own](https://thegraph.com/docs/en/developing/creating-a-subgraph/) and deploy it.

Throughout the docs you will see how to interact with the Uniswap subgraph to fetch tick data and more without ever touching RPCs.

An important note about Indexers though:

While they can be helpful, you need to be aware that the ultimate source of truth comes from the RPCs. As reorgs happen and
certain issues on indexers arise, there might be certain datapoints that are either not fully up-to-date or even
completely wrong on Indexers. If you have a use-case that requires perfectly correct data all the time, use RPCs directly.
If you are just doing data visualization or dashboards, use Indexers if they fit your use-case.

Some popular subgraphs that you can try to fetch data from the blockchain easily (click on playground to give it a try):

* [Uniswap Messari subgraph](https://thegraph.com/explorer/subgraphs/ELUcwgpm14LKPLrBRuVvPvNKHQ9HvwmtKgKSH6123cr7?view=Overview&chain=mainnet)
* [Snapshot Subgraph](https://thegraph.com/explorer/subgraphs/3Q4vnuSqemXnSNHoiLD7wdBbGCXszUYnUbTz191kDMNn?view=Overview&chain=mainnet)
* [Aave V3 Messari subgraph](https://thegraph.com/explorer/subgraphs/HB1Z2EAw4rtPRYVb2Nz8QGFLHCpym6ByBX6vbCViuE9F?view=Overview&chain=mainnet)

## Smart Contract Development

Smart contracts are typically developed using the [Solidity language](https://soliditylang.org/).

There are VSCode plugins that make the development with Solidity easier. One of them is Juan Blanco's "Solidity" that you can find
over [here](https://marketplace.visualstudio.com/items?itemName=JuanBlanco.solidity).

You would typically also go for a developer suite with testing, compilation and deployment capabilities:

* [Foundry](https://github.com/foundry-rs/foundry) - Fast and modern developer tools for smart contract engineers.
* [Hardhat](https://github.com/NomicFoundation/hardhat) - Scriptable, easy and battle-tested JS developer suite for smart contracts.

To read data from smart contracts, or interact with them, use the [client SDKs](#client-implementations) mentioned above.
They help you generate the necessary RPC calls to fetch data from / send transactions to the blockchain and interact with your
smart contracts.
You can read more about it in the [ethers.js docs](https://docs.ethers.org/v5/api/contract/contract/).

## Blockchain Explorers

Manually gathering information and inspecting data stored in a blockchain is a tedious task.
Almost all chains have at least one accompanying block explorer to help visualize addresses, transactions, contracts and more.

For Ethereum mainnet, we suggest using [Etherscan](https://etherscan.io/).
You can use Etherscan to inspect [contracts](https://etherscan.io/address/0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45#code), transactions, blocks, and much more.

If you are looking to debug a transaction, [Tenderly](https://dashboard.tenderly.co/tx/mainnet/0xa4affe1abfaf28d1763d6c3ccda33e717462a928abca89415fc6e661dd7e0c55) can also be a very helpful tool.
In this example of a failed transaction on the Uniswap V2 Router you can easily see why the execution failed and where.

## The Uniswap development suite

Uniswap offers several SDKs that work together and enable you to easily interact with the Uniswap protocol
The most important SDKs are:

* [sdk-core](https://github.com/Uniswap/sdk-core): The core of the Uniswap SDKs, defines classes and types shared across all the SDKs
* [v2-sdk](https://github.com/Uniswap/v2-sdk): An SDK to interact with the Uniswap V2 protocol.
* [v3-sdk](https://github.com/Uniswap/v3-sdk): An SDK to interact with the Uniswap V3 protocol.
* [router-sdk](https://github.com/Uniswap/router-sdk): Provides abstractions to interact with the (older) SwapRouter contracts.
* [universal-router-sdk](https://github.com/Uniswap/universal-router-sdk): Abstracts interactions with the Universal Router.
* [smart-order-router](https://github.com/Uniswap/smart-order-router): Searches for the most efficient routes for a trade.
* [permit2-sdk](https://github.com/Uniswap/permit2-sdk): Simplifies interactions with Permit2 in JS.
* [uniswapx-sdk](https://github.com/Uniswap/uniswapx-sdk): SDK for the UniswapX protocol.

As you know already, all interactions with the blockchain happens through RPCs. So the Uniswap SDKs, as you will see throughout the guides,
requires you to have access to an RPC endpoint like [Chainnodes](https://www.chainnodes.org).
When reading data, the data is read from the given RPC endpoint. When actually swapping, you will need to sign a transaction
using a private key.

We are continuously working on improving the Uniswap development suite, so stay tuned for more updates.

## Next Steps

Go through the basic guides first and try to fetch some data and interact with the Uniswap ecosystem a little bit. You can even
[send your first swap transaction](./swaps/02-trading) on a local fork!

While some concepts in Web3 require thinking outside of the box, this guide should give you a good overview on where to start.
You should now be fully equipped to follow our other guides.
</file>

<file path="docs/sdk/v3/reference/classes/FullMath.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / FullMath

# Class: FullMath

## Table of contents

### Constructors

- [constructor](FullMath.md#constructor)

### Methods

- [mulDivRoundingUp](FullMath.md#muldivroundingup)

## Constructors

### constructor

• `Private` **new FullMath**()

Cannot be constructed.

#### Defined in

[utils/fullMath.ts:8](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/fullMath.ts#L8)

## Methods

### mulDivRoundingUp

▸ `Static` **mulDivRoundingUp**(`a`, `b`, `denominator`): `default`

#### Parameters

| Name | Type |
| :------ | :------ |
| `a` | `default` |
| `b` | `default` |
| `denominator` | `default` |

#### Returns

`default`

#### Defined in

[utils/fullMath.ts:10](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/fullMath.ts#L10)
</file>

<file path="docs/sdk/v3/reference/classes/LiquidityMath.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / LiquidityMath

# Class: LiquidityMath

## Table of contents

### Constructors

- [constructor](LiquidityMath.md#constructor)

### Methods

- [addDelta](LiquidityMath.md#adddelta)

## Constructors

### constructor

• `Private` **new LiquidityMath**()

Cannot be constructed.

#### Defined in

[utils/liquidityMath.ts:8](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/liquidityMath.ts#L8)

## Methods

### addDelta

▸ `Static` **addDelta**(`x`, `y`): `default`

#### Parameters

| Name | Type |
| :------ | :------ |
| `x` | `default` |
| `y` | `default` |

#### Returns

`default`

#### Defined in

[utils/liquidityMath.ts:10](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/liquidityMath.ts#L10)
</file>

<file path="docs/sdk/v3/reference/classes/Multicall.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / Multicall

# Class: Multicall

## Table of contents

### Constructors

- [constructor](Multicall.md#constructor)

### Properties

- [INTERFACE](Multicall.md#interface)

### Methods

- [encodeMulticall](Multicall.md#encodemulticall)

## Constructors

### constructor

• `Private` **new Multicall**()

Cannot be constructed.

#### Defined in

[multicall.ts:10](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/multicall.ts#L10)

## Properties

### INTERFACE

▪ `Static` **INTERFACE**: `Interface`

#### Defined in

[multicall.ts:5](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/multicall.ts#L5)

## Methods

### encodeMulticall

▸ `Static` **encodeMulticall**(`calldatas`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `calldatas` | `string` \| `string`[] |

#### Returns

`string`

#### Defined in

[multicall.ts:12](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/multicall.ts#L12)
</file>

<file path="docs/sdk/v3/reference/classes/NonfungiblePositionManager.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / NonfungiblePositionManager

# Class: NonfungiblePositionManager

## Table of contents

### Constructors

- [constructor](NonfungiblePositionManager.md#constructor)

### Properties

- [INTERFACE](NonfungiblePositionManager.md#interface)

### Methods

- [addCallParameters](NonfungiblePositionManager.md#addcallparameters)
- [collectCallParameters](NonfungiblePositionManager.md#collectcallparameters)
- [createCallParameters](NonfungiblePositionManager.md#createcallparameters)
- [encodeCollect](NonfungiblePositionManager.md#encodecollect)
- [encodeCreate](NonfungiblePositionManager.md#encodecreate)
- [removeCallParameters](NonfungiblePositionManager.md#removecallparameters)
- [safeTransferFromParameters](NonfungiblePositionManager.md#safetransferfromparameters)

## Constructors

### constructor

• `Private` **new NonfungiblePositionManager**()

Cannot be constructed.

#### Defined in

[nonfungiblePositionManager.ts:181](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L181)

## Properties

### INTERFACE

▪ `Static` **INTERFACE**: `Interface`

#### Defined in

[nonfungiblePositionManager.ts:176](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L176)

## Methods

### addCallParameters

▸ `Static` **addCallParameters**(`position`, `options`): [`MethodParameters`](../interfaces/MethodParameters.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `position` | [`Position`](Position.md) |
| `options` | [`AddLiquidityOptions`](../modules.md#addliquidityoptions) |

#### Returns

[`MethodParameters`](../interfaces/MethodParameters.md)

#### Defined in

[nonfungiblePositionManager.ts:199](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L199)

___

### collectCallParameters

▸ `Static` **collectCallParameters**(`options`): [`MethodParameters`](../interfaces/MethodParameters.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `options` | [`CollectOptions`](../interfaces/CollectOptions.md) |

#### Returns

[`MethodParameters`](../interfaces/MethodParameters.md)

#### Defined in

[nonfungiblePositionManager.ts:326](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L326)

___

### createCallParameters

▸ `Static` **createCallParameters**(`pool`): [`MethodParameters`](../interfaces/MethodParameters.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `pool` | [`Pool`](Pool.md) |

#### Returns

[`MethodParameters`](../interfaces/MethodParameters.md)

#### Defined in

[nonfungiblePositionManager.ts:192](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L192)

___

### encodeCollect

▸ `Static` `Private` **encodeCollect**(`options`): `string`[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `options` | [`CollectOptions`](../interfaces/CollectOptions.md) |

#### Returns

`string`[]

#### Defined in

[nonfungiblePositionManager.ts:286](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L286)

___

### encodeCreate

▸ `Static` `Private` **encodeCreate**(`pool`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `pool` | [`Pool`](Pool.md) |

#### Returns

`string`

#### Defined in

[nonfungiblePositionManager.ts:183](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L183)

___

### removeCallParameters

▸ `Static` **removeCallParameters**(`position`, `options`): [`MethodParameters`](../interfaces/MethodParameters.md)

Produces the calldata for completely or partially exiting a position

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `position` | [`Position`](Position.md) | The position to exit |
| `options` | [`RemoveLiquidityOptions`](../interfaces/RemoveLiquidityOptions.md) | Additional information necessary for generating the calldata |

#### Returns

[`MethodParameters`](../interfaces/MethodParameters.md)

The call parameters

#### Defined in

[nonfungiblePositionManager.ts:341](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L341)

___

### safeTransferFromParameters

▸ `Static` **safeTransferFromParameters**(`options`): [`MethodParameters`](../interfaces/MethodParameters.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `options` | [`SafeTransferOptions`](../interfaces/SafeTransferOptions.md) |

#### Returns

[`MethodParameters`](../interfaces/MethodParameters.md)

#### Defined in

[nonfungiblePositionManager.ts:416](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L416)
</file>

<file path="docs/sdk/v3/reference/classes/NoTickDataProvider.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / NoTickDataProvider

# Class: NoTickDataProvider

This tick data provider does not know how to fetch any tick data. It throws whenever it is required. Useful if you
do not need to load tick data for your use case.

## Implements

- [`TickDataProvider`](../interfaces/TickDataProvider.md)

## Table of contents

### Constructors

- [constructor](NoTickDataProvider.md#constructor)

### Properties

- [ERROR\_MESSAGE](NoTickDataProvider.md#error_message)

### Methods

- [getTick](NoTickDataProvider.md#gettick)
- [nextInitializedTickWithinOneWord](NoTickDataProvider.md#nextinitializedtickwithinoneword)

## Constructors

### constructor

• **new NoTickDataProvider**()

## Properties

### ERROR\_MESSAGE

▪ `Static` `Private` **ERROR\_MESSAGE**: `string` = `'No tick data provider was given'`

#### Defined in

[entities/tickDataProvider.ts:27](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickDataProvider.ts#L27)

## Methods

### getTick

▸ **getTick**(`_tick`): `Promise`\<\{ `liquidityNet`: `BigintIsh`  \\}\>

Return information corresponding to a specific tick

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `_tick` | `number` | the tick to load |

#### Returns

`Promise`\<\{ `liquidityNet`: `BigintIsh`  \}\>

#### Implementation of

[TickDataProvider](../interfaces/TickDataProvider.md).[getTick](../interfaces/TickDataProvider.md#gettick)

#### Defined in

[entities/tickDataProvider.ts:28](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickDataProvider.ts#L28)

___

### nextInitializedTickWithinOneWord

▸ **nextInitializedTickWithinOneWord**(`_tick`, `_lte`, `_tickSpacing`): `Promise`\<[`number`, `boolean`]\>

Return the next tick that is initialized within a single word

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `_tick` | `number` | The current tick |
| `_lte` | `boolean` | Whether the next tick should be lte the current tick |
| `_tickSpacing` | `number` | The tick spacing of the pool |

#### Returns

`Promise`\<[`number`, `boolean`]\>

#### Implementation of

[TickDataProvider](../interfaces/TickDataProvider.md).[nextInitializedTickWithinOneWord](../interfaces/TickDataProvider.md#nextinitializedtickwithinoneword)

#### Defined in

[entities/tickDataProvider.ts:32](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickDataProvider.ts#L32)
</file>

<file path="docs/sdk/v3/reference/classes/Payments.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / Payments

# Class: Payments

## Table of contents

### Constructors

- [constructor](Payments.md#constructor)

### Properties

- [INTERFACE](Payments.md#interface)

### Methods

- [encodeFeeBips](Payments.md#encodefeebips)
- [encodeRefundETH](Payments.md#encoderefundeth)
- [encodeSweepToken](Payments.md#encodesweeptoken)
- [encodeUnwrapWETH9](Payments.md#encodeunwrapweth9)

## Constructors

### constructor

• `Private` **new Payments**()

Cannot be constructed.

#### Defined in

[payments.ts:25](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L25)

## Properties

### INTERFACE

▪ `Static` **INTERFACE**: `Interface`

#### Defined in

[payments.ts:20](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L20)

## Methods

### encodeFeeBips

▸ `Static` `Private` **encodeFeeBips**(`fee`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `fee` | `Percent` |

#### Returns

`string`

#### Defined in

[payments.ts:27](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L27)

___

### encodeRefundETH

▸ `Static` **encodeRefundETH**(): `string`

#### Returns

`string`

#### Defined in

[payments.ts:73](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L73)

___

### encodeSweepToken

▸ `Static` **encodeSweepToken**(`token`, `amountMinimum`, `recipient`, `feeOptions?`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `token` | `Token` |
| `amountMinimum` | `default` |
| `recipient` | `string` |
| `feeOptions?` | [`FeeOptions`](../interfaces/FeeOptions.md) |

#### Returns

`string`

#### Defined in

[payments.ts:49](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L49)

___

### encodeUnwrapWETH9

▸ `Static` **encodeUnwrapWETH9**(`amountMinimum`, `recipient`, `feeOptions?`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `amountMinimum` | `default` |
| `recipient` | `string` |
| `feeOptions?` | [`FeeOptions`](../interfaces/FeeOptions.md) |

#### Returns

`string`

#### Defined in

[payments.ts:31](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L31)
</file>

<file path="docs/sdk/v3/reference/classes/Pool.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / Pool

# Class: Pool

Represents a V3 pool

## Table of contents

### Constructors

- [constructor](Pool.md#constructor)

### Properties

- [\_token0Price](Pool.md#_token0price)
- [\_token1Price](Pool.md#_token1price)
- [fee](Pool.md#fee)
- [liquidity](Pool.md#liquidity)
- [sqrtRatioX96](Pool.md#sqrtratiox96)
- [tickCurrent](Pool.md#tickcurrent)
- [tickDataProvider](Pool.md#tickdataprovider)
- [token0](Pool.md#token0)
- [token1](Pool.md#token1)

### Accessors

- [chainId](Pool.md#chainid)
- [tickSpacing](Pool.md#tickspacing)
- [token0Price](Pool.md#token0price)
- [token1Price](Pool.md#token1price)

### Methods

- [getInputAmount](Pool.md#getinputamount)
- [getOutputAmount](Pool.md#getoutputamount)
- [involvesToken](Pool.md#involvestoken)
- [priceOf](Pool.md#priceof)
- [swap](Pool.md#swap)
- [getAddress](Pool.md#getaddress)

## Constructors

### constructor

• **new Pool**(`tokenA`, `tokenB`, `fee`, `sqrtRatioX96`, `liquidity`, `tickCurrent`, `ticks?`)

Construct a pool

#### Parameters

| Name | Type | Default value | Description |
| :------ | :------ | :------ | :------ |
| `tokenA` | `Token` | `undefined` | One of the tokens in the pool |
| `tokenB` | `Token` | `undefined` | The other token in the pool |
| `fee` | [`FeeAmount`](../enums/FeeAmount.md) | `undefined` | The fee in hundredths of a bips of the input amount of every swap that is collected by the pool |
| `sqrtRatioX96` | `BigintIsh` | `undefined` | The sqrt of the current ratio of amounts of token1 to token0 |
| `liquidity` | `BigintIsh` | `undefined` | The current value of in range liquidity |
| `tickCurrent` | `number` | `undefined` | The current tick of the pool |
| `ticks` | [`TickDataProvider`](../interfaces/TickDataProvider.md) \| ([`Tick`](Tick.md) \| [`TickConstructorArgs`](../interfaces/TickConstructorArgs.md))[] | `NO_TICK_DATA_PROVIDER_DEFAULT` | The current state of the pool ticks or a data provider that can return tick data |

#### Defined in

[entities/pool.ts:70](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L70)

## Properties

### \_token0Price

• `Private` `Optional` **\_token0Price**: `Price`\<`Token`, `Token`\>

#### Defined in

[entities/pool.ts:41](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L41)

___

### \_token1Price

• `Private` `Optional` **\_token1Price**: `Price`\<`Token`, `Token`\>

#### Defined in

[entities/pool.ts:42](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L42)

___

### fee

• `Readonly` **fee**: [`FeeAmount`](../enums/FeeAmount.md)

#### Defined in

[entities/pool.ts:35](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L35)

___

### liquidity

• `Readonly` **liquidity**: `default`

#### Defined in

[entities/pool.ts:37](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L37)

___

### sqrtRatioX96

• `Readonly` **sqrtRatioX96**: `default`

#### Defined in

[entities/pool.ts:36](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L36)

___

### tickCurrent

• `Readonly` **tickCurrent**: `number`

#### Defined in

[entities/pool.ts:38](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L38)

___

### tickDataProvider

• `Readonly` **tickDataProvider**: [`TickDataProvider`](../interfaces/TickDataProvider.md)

#### Defined in

[entities/pool.ts:39](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L39)

___

### token0

• `Readonly` **token0**: `Token`

#### Defined in

[entities/pool.ts:33](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L33)

___

### token1

• `Readonly` **token1**: `Token`

#### Defined in

[entities/pool.ts:34](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L34)

## Accessors

### chainId

• `get` **chainId**(): `number`

Returns the chain ID of the tokens in the pool.

#### Returns

`number`

#### Defined in

[entities/pool.ts:149](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L149)

___

### tickSpacing

• `get` **tickSpacing**(): `number`

#### Returns

`number`

#### Defined in

[entities/pool.ts:317](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L317)

___

### token0Price

• `get` **token0Price**(): `Price`\<`Token`, `Token`\>

Returns the current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0

#### Returns

`Price`\<`Token`, `Token`\>

#### Defined in

[entities/pool.ts:109](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L109)

___

### token1Price

• `get` **token1Price**(): `Price`\<`Token`, `Token`\>

Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1

#### Returns

`Price`\<`Token`, `Token`\>

#### Defined in

[entities/pool.ts:124](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L124)

## Methods

### getInputAmount

▸ **getInputAmount**(`outputAmount`, `sqrtPriceLimitX96?`): `Promise`\<[`CurrencyAmount`\<`Token`\>, [`Pool`](Pool.md)]\>

Given a desired output amount of a token, return the computed input amount and a pool with state updated after the trade

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `outputAmount` | `CurrencyAmount`\<`Token`\> | the output amount for which to quote the input amount |
| `sqrtPriceLimitX96?` | `default` | The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap |

#### Returns

`Promise`\<[`CurrencyAmount`\<`Token`\>, [`Pool`](Pool.md)]\>

The input amount and the pool with updated state

#### Defined in

[entities/pool.ts:185](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L185)

___

### getOutputAmount

▸ **getOutputAmount**(`inputAmount`, `sqrtPriceLimitX96?`): `Promise`\<[`CurrencyAmount`\<`Token`\>, [`Pool`](Pool.md)]\>

Given an input amount of a token, return the computed output amount, and a pool with state updated after the trade

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `inputAmount` | `CurrencyAmount`\<`Token`\> | The input amount for which to quote the output amount |
| `sqrtPriceLimitX96?` | `default` | The Q64.96 sqrt price limit |

#### Returns

`Promise`\<[`CurrencyAmount`\<`Token`\>, [`Pool`](Pool.md)]\>

The output amount and the pool with updated state

#### Defined in

[entities/pool.ts:159](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L159)

___

### involvesToken

▸ **involvesToken**(`token`): `boolean`

Returns true if the token is either token0 or token1

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `token` | `Token` | The token to check |

#### Returns

`boolean`

True if token is either token0 or token

#### Defined in

[entities/pool.ts:102](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L102)

___

### priceOf

▸ **priceOf**(`token`): `Price`\<`Token`, `Token`\>

Return the price of the given token in terms of the other token in the pool.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `token` | `Token` | The token to return price of |

#### Returns

`Price`\<`Token`, `Token`\>

The price of the given token, in terms of the other.

#### Defined in

[entities/pool.ts:141](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L141)

___

### swap

▸ `Private` **swap**(`zeroForOne`, `amountSpecified`, `sqrtPriceLimitX96?`): `Promise`\<\{ `amountCalculated`: `default` ; `liquidity`: `default` ; `sqrtRatioX96`: `default` ; `tickCurrent`: `number`  \\}\>

Executes a swap

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `zeroForOne` | `boolean` | Whether the amount in is token0 or token1 |
| `amountSpecified` | `default` | The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative) |
| `sqrtPriceLimitX96?` | `default` | The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap |

#### Returns

`Promise`\<\{ `amountCalculated`: `default` ; `liquidity`: `default` ; `sqrtRatioX96`: `default` ; `tickCurrent`: `number`  \}\>

amountCalculated

sqrtRatioX96

liquidity

tickCurrent

#### Defined in

[entities/pool.ts:215](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L215)

___

### getAddress

▸ `Static` **getAddress**(`tokenA`, `tokenB`, `fee`, `initCodeHashManualOverride?`, `factoryAddressOverride?`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `tokenA` | `Token` |
| `tokenB` | `Token` |
| `fee` | [`FeeAmount`](../enums/FeeAmount.md) |
| `initCodeHashManualOverride?` | `string` |
| `factoryAddressOverride?` | `string` |

#### Returns

`string`

#### Defined in

[entities/pool.ts:44](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/pool.ts#L44)
</file>

<file path="docs/sdk/v3/reference/classes/Position.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / Position

# Class: Position

Represents a position on a Uniswap V3 Pool

## Table of contents

### Constructors

- [constructor](Position.md#constructor)

### Properties

- [\_mintAmounts](Position.md#_mintamounts)
- [\_token0Amount](Position.md#_token0amount)
- [\_token1Amount](Position.md#_token1amount)
- [liquidity](Position.md#liquidity)
- [pool](Position.md#pool)
- [tickLower](Position.md#ticklower)
- [tickUpper](Position.md#tickupper)

### Accessors

- [amount0](Position.md#amount0)
- [amount1](Position.md#amount1)
- [mintAmounts](Position.md#mintamounts)
- [token0PriceLower](Position.md#token0pricelower)
- [token0PriceUpper](Position.md#token0priceupper)

### Methods

- [burnAmountsWithSlippage](Position.md#burnamountswithslippage)
- [mintAmountsWithSlippage](Position.md#mintamountswithslippage)
- [ratiosAfterSlippage](Position.md#ratiosafterslippage)
- [fromAmount0](Position.md#fromamount0)
- [fromAmount1](Position.md#fromamount1)
- [fromAmounts](Position.md#fromamounts)

## Constructors

### constructor

• **new Position**(`__namedParameters`)

Constructs a position for a given pool with the given liquidity

#### Parameters

| Name | Type |
| :------ | :------ |
| `__namedParameters` | `PositionConstructorArgs` |

#### Defined in

[entities/position.ts:40](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L40)

## Properties

### \_mintAmounts

• `Private` **\_mintAmounts**: ``null`` \| `Readonly`\<\{ `amount0`: `default` ; `amount1`: `default`  \\\}\> = `null`

#### Defined in

[entities/position.ts:31](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L31)

___

### \_token0Amount

• `Private` **\_token0Amount**: ``null`` \| `CurrencyAmount`\<`Token`\> = `null`

#### Defined in

[entities/position.ts:29](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L29)

___

### \_token1Amount

• `Private` **\_token1Amount**: ``null`` \| `CurrencyAmount`\<`Token`\> = `null`

#### Defined in

[entities/position.ts:30](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L30)

___

### liquidity

• `Readonly` **liquidity**: `default`

#### Defined in

[entities/position.ts:26](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L26)

___

### pool

• `Readonly` **pool**: [`Pool`](Pool.md)

#### Defined in

[entities/position.ts:23](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L23)

___

### tickLower

• `Readonly` **tickLower**: `number`

#### Defined in

[entities/position.ts:24](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L24)

___

### tickUpper

• `Readonly` **tickUpper**: `number`

#### Defined in

[entities/position.ts:25](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L25)

## Accessors

### amount0

• `get` **amount0**(): `CurrencyAmount`\<`Token`\>

Returns the amount of token0 that this position's liquidity could be burned for at the current pool price

#### Returns

`CurrencyAmount`\<`Token`\>

#### Defined in

[entities/position.ts:68](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L68)

___

### amount1

• `get` **amount1**(): `CurrencyAmount`\<`Token`\>

Returns the amount of token1 that this position's liquidity could be burned for at the current pool price

#### Returns

`CurrencyAmount`\<`Token`\>

#### Defined in

[entities/position.ts:100](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L100)

___

### mintAmounts

• `get` **mintAmounts**(): `Readonly`\<\{ `amount0`: `default` ; `amount1`: `default`  \\}\>

Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at
the current price for the pool

#### Returns

`Readonly`\<\{ `amount0`: `default` ; `amount1`: `default`  \\}\>

#### Defined in

[entities/position.ts:258](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L258)

___

### token0PriceLower

• `get` **token0PriceLower**(): `Price`\<`Token`, `Token`\>

Returns the price of token0 at the lower tick

#### Returns

`Price`\<`Token`, `Token`\>

#### Defined in

[entities/position.ts:54](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L54)

___

### token0PriceUpper

• `get` **token0PriceUpper**(): `Price`\<`Token`, `Token`\>

Returns the price of token0 at the upper tick

#### Returns

`Price`\<`Token`, `Token`\>

#### Defined in

[entities/position.ts:61](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L61)

## Methods

### burnAmountsWithSlippage

▸ **burnAmountsWithSlippage**(`slippageTolerance`): `Readonly`\<\{ `amount0`: `default` ; `amount1`: `default`  \\}\>

Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the
position with the given slippage tolerance

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `slippageTolerance` | `Percent` | tolerance of unfavorable slippage from the current price |

#### Returns

`Readonly`\<\{ `amount0`: `default` ; `amount1`: `default`  \\}\>

The amounts, with slippage

#### Defined in

[entities/position.ts:213](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L213)

___

### mintAmountsWithSlippage

▸ **mintAmountsWithSlippage**(`slippageTolerance`): `Readonly`\<\{ `amount0`: `default` ; `amount1`: `default`  \\}\>

Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position
with the given slippage tolerance

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `slippageTolerance` | `Percent` | Tolerance of unfavorable slippage from the current price |

#### Returns

`Readonly`\<\{ `amount0`: `default` ; `amount1`: `default`  \\}\>

The amounts, with slippage

#### Defined in

[entities/position.ts:157](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L157)

___

### ratiosAfterSlippage

▸ `Private` **ratiosAfterSlippage**(`slippageTolerance`): `Object`

Returns the lower and upper sqrt ratios if the price 'slips' up to slippage tolerance percentage

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `slippageTolerance` | `Percent` | The amount by which the price can 'slip' before the transaction will revert |

#### Returns

`Object`

The sqrt ratios after slippage

| Name | Type |
| :------ | :------ |
| `sqrtRatioX96Lower` | `default` |
| `sqrtRatioX96Upper` | `default` |

#### Defined in

[entities/position.ts:134](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L134)

___

### fromAmount0

▸ `Static` **fromAmount0**(`__namedParameters`): [`Position`](Position.md)

Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1

#### Parameters

| Name | Type |
| :------ | :------ |
| `__namedParameters` | `Object` |
| `__namedParameters.amount0` | `BigintIsh` |
| `__namedParameters.pool` | [`Pool`](Pool.md) |
| `__namedParameters.tickLower` | `number` |
| `__namedParameters.tickUpper` | `number` |
| `__namedParameters.useFullPrecision` | `boolean` |

#### Returns

[`Position`](Position.md)

The position

#### Defined in

[entities/position.ts:354](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L354)

___

### fromAmount1

▸ `Static` **fromAmount1**(`__namedParameters`): [`Position`](Position.md)

Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0

#### Parameters

| Name | Type |
| :------ | :------ |
| `__namedParameters` | `Object` |
| `__namedParameters.amount1` | `BigintIsh` |
| `__namedParameters.pool` | [`Pool`](Pool.md) |
| `__namedParameters.tickLower` | `number` |
| `__namedParameters.tickUpper` | `number` |

#### Returns

[`Position`](Position.md)

The position

#### Defined in

[entities/position.ts:378](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L378)

___

### fromAmounts

▸ `Static` **fromAmounts**(`__namedParameters`): [`Position`](Position.md)

Computes the maximum amount of liquidity received for a given amount of token0, token1,
and the prices at the tick boundaries.

#### Parameters

| Name | Type |
| :------ | :------ |
| `__namedParameters` | `Object` |
| `__namedParameters.amount0` | `BigintIsh` |
| `__namedParameters.amount1` | `BigintIsh` |
| `__namedParameters.pool` | [`Pool`](Pool.md) |
| `__namedParameters.tickLower` | `number` |
| `__namedParameters.tickUpper` | `number` |
| `__namedParameters.useFullPrecision` | `boolean` |

#### Returns

[`Position`](Position.md)

The amount of liquidity for the position

#### Defined in

[entities/position.ts:312](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/position.ts#L312)
</file>

<file path="docs/sdk/v3/reference/classes/PositionLibrary.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / PositionLibrary

# Class: PositionLibrary

## Table of contents

### Constructors

- [constructor](PositionLibrary.md#constructor)

### Methods

- [getTokensOwed](PositionLibrary.md#gettokensowed)

## Constructors

### constructor

• `Private` **new PositionLibrary**()

Cannot be constructed.

#### Defined in

[utils/position.ts:10](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/position.ts#L10)

## Methods

### getTokensOwed

▸ `Static` **getTokensOwed**(`feeGrowthInside0LastX128`, `feeGrowthInside1LastX128`, `liquidity`, `feeGrowthInside0X128`, `feeGrowthInside1X128`): `default`[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `feeGrowthInside0LastX128` | `default` |
| `feeGrowthInside1LastX128` | `default` |
| `liquidity` | `default` |
| `feeGrowthInside0X128` | `default` |
| `feeGrowthInside1X128` | `default` |

#### Returns

`default`[]

#### Defined in

[utils/position.ts:13](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/position.ts#L13)
</file>

<file path="docs/sdk/v3/reference/classes/Route.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / Route

# Class: Route\<TInput, TOutput\>

Represents a list of pools through which a swap can occur

## Type parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `TInput` | extends `Currency` | The input token |
| `TOutput` | extends `Currency` | The output token |

## Table of contents

### Constructors

- [constructor](Route.md#constructor)

### Properties

- [\_midPrice](Route.md#_midprice)
- [input](Route.md#input)
- [output](Route.md#output)
- [pools](Route.md#pools)
- [tokenPath](Route.md#tokenpath)

### Accessors

- [chainId](Route.md#chainid)
- [midPrice](Route.md#midprice)

## Constructors

### constructor

• **new Route**\<`TInput`, `TOutput`\>(`pools`, `input`, `output`)

Creates an instance of route.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TInput` | extends `Currency` |
| `TOutput` | extends `Currency` |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `pools` | [`Pool`](Pool.md)[] | An array of `Pool` objects, ordered by the route the swap will take |
| `input` | `TInput` | The input token |
| `output` | `TOutput` | The output token |

#### Defined in

[entities/route.ts:25](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L25)

## Properties

### \_midPrice

• `Private` **\_midPrice**: ``null`` \| `Price`\<`TInput`, `TOutput`\> = `null`

#### Defined in

[entities/route.ts:17](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L17)

___

### input

• `Readonly` **input**: `TInput`

#### Defined in

[entities/route.ts:14](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L14)

___

### output

• `Readonly` **output**: `TOutput`

#### Defined in

[entities/route.ts:15](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L15)

___

### pools

• `Readonly` **pools**: [`Pool`](Pool.md)[]

#### Defined in

[entities/route.ts:12](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L12)

___

### tokenPath

• `Readonly` **tokenPath**: `Token`[]

#### Defined in

[entities/route.ts:13](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L13)

## Accessors

### chainId

• `get` **chainId**(): `number`

#### Returns

`number`

#### Defined in

[entities/route.ts:54](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L54)

___

### midPrice

• `get` **midPrice**(): `Price`\<`TInput`, `TOutput`\>

Returns the mid price of the route

#### Returns

`Price`\<`TInput`, `TOutput`\>

#### Defined in

[entities/route.ts:61](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/route.ts#L61)
</file>

<file path="docs/sdk/v3/reference/classes/SelfPermit.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / SelfPermit

# Class: SelfPermit

## Table of contents

### Constructors

- [constructor](SelfPermit.md#constructor)

### Properties

- [INTERFACE](SelfPermit.md#interface)

### Methods

- [encodePermit](SelfPermit.md#encodepermit)

## Constructors

### constructor

• `Private` **new SelfPermit**()

Cannot be constructed.

#### Defined in

[selfPermit.ts:34](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L34)

## Properties

### INTERFACE

▪ `Static` **INTERFACE**: `Interface`

#### Defined in

[selfPermit.ts:29](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L29)

## Methods

### encodePermit

▸ `Static` **encodePermit**(`token`, `options`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `token` | `Token` |
| `options` | [`PermitOptions`](../modules.md#permitoptions) |

#### Returns

`string`

#### Defined in

[selfPermit.ts:36](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L36)
</file>

<file path="docs/sdk/v3/reference/classes/SqrtPriceMath.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / SqrtPriceMath

# Class: SqrtPriceMath

## Table of contents

### Constructors

- [constructor](SqrtPriceMath.md#constructor)

### Methods

- [getAmount0Delta](SqrtPriceMath.md#getamount0delta)
- [getAmount1Delta](SqrtPriceMath.md#getamount1delta)
- [getNextSqrtPriceFromAmount0RoundingUp](SqrtPriceMath.md#getnextsqrtpricefromamount0roundingup)
- [getNextSqrtPriceFromAmount1RoundingDown](SqrtPriceMath.md#getnextsqrtpricefromamount1roundingdown)
- [getNextSqrtPriceFromInput](SqrtPriceMath.md#getnextsqrtpricefrominput)
- [getNextSqrtPriceFromOutput](SqrtPriceMath.md#getnextsqrtpricefromoutput)

## Constructors

### constructor

• `Private` **new SqrtPriceMath**()

Cannot be constructed.

#### Defined in

[utils/sqrtPriceMath.ts:23](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/sqrtPriceMath.ts#L23)

## Methods

### getAmount0Delta

▸ `Static` **getAmount0Delta**(`sqrtRatioAX96`, `sqrtRatioBX96`, `liquidity`, `roundUp`): `default`

#### Parameters

| Name | Type |
| :------ | :------ |
| `sqrtRatioAX96` | `default` |
| `sqrtRatioBX96` | `default` |
| `liquidity` | `default` |
| `roundUp` | `boolean` |

#### Returns

`default`

#### Defined in

[utils/sqrtPriceMath.ts:25](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/sqrtPriceMath.ts#L25)

___

### getAmount1Delta

▸ `Static` **getAmount1Delta**(`sqrtRatioAX96`, `sqrtRatioBX96`, `liquidity`, `roundUp`): `default`

#### Parameters

| Name | Type |
| :------ | :------ |
| `sqrtRatioAX96` | `default` |
| `sqrtRatioBX96` | `default` |
| `liquidity` | `default` |
| `roundUp` | `boolean` |

#### Returns

`default`

#### Defined in

[utils/sqrtPriceMath.ts:38](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/sqrtPriceMath.ts#L38)

___

### getNextSqrtPriceFromAmount0RoundingUp

▸ `Static` `Private` **getNextSqrtPriceFromAmount0RoundingUp**(`sqrtPX96`, `liquidity`, `amount`, `add`): `default`

#### Parameters

| Name | Type |
| :------ | :------ |
| `sqrtPX96` | `default` |
| `liquidity` | `default` |
| `amount` | `default` |
| `add` | `boolean` |

#### Returns

`default`

#### Defined in

[utils/sqrtPriceMath.ts:71](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/sqrtPriceMath.ts#L71)

___

### getNextSqrtPriceFromAmount1RoundingDown

▸ `Static` `Private` **getNextSqrtPriceFromAmount1RoundingDown**(`sqrtPX96`, `liquidity`, `amount`, `add`): `default`

#### Parameters

| Name | Type |
| :------ | :------ |
| `sqrtPX96` | `default` |
| `liquidity` | `default` |
| `amount` | `default` |
| `add` | `boolean` |

#### Returns

`default`

#### Defined in

[utils/sqrtPriceMath.ts:100](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/sqrtPriceMath.ts#L100)

___

### getNextSqrtPriceFromInput

▸ `Static` **getNextSqrtPriceFromInput**(`sqrtPX96`, `liquidity`, `amountIn`, `zeroForOne`): `default`

#### Parameters

| Name | Type |
| :------ | :------ |
| `sqrtPX96` | `default` |
| `liquidity` | `default` |
| `amountIn` | `default` |
| `zeroForOne` | `boolean` |

#### Returns

`default`

#### Defined in

[utils/sqrtPriceMath.ts:48](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/sqrtPriceMath.ts#L48)

___

### getNextSqrtPriceFromOutput

▸ `Static` **getNextSqrtPriceFromOutput**(`sqrtPX96`, `liquidity`, `amountOut`, `zeroForOne`): `default`

#### Parameters

| Name | Type |
| :------ | :------ |
| `sqrtPX96` | `default` |
| `liquidity` | `default` |
| `amountOut` | `default` |
| `zeroForOne` | `boolean` |

#### Returns

`default`

#### Defined in

[utils/sqrtPriceMath.ts:57](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/sqrtPriceMath.ts#L57)
</file>

<file path="docs/sdk/v3/reference/classes/Staker.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / Staker

# Class: Staker

## Table of contents

### Constructors

- [constructor](Staker.md#constructor)

### Properties

- [INCENTIVE\_KEY\_ABI](Staker.md#incentive_key_abi)
- [INTERFACE](Staker.md#interface)

### Methods

- [\_encodeIncentiveKey](Staker.md#_encodeincentivekey)
- [collectRewards](Staker.md#collectrewards)
- [encodeClaim](Staker.md#encodeclaim)
- [encodeDeposit](Staker.md#encodedeposit)
- [withdrawToken](Staker.md#withdrawtoken)

## Constructors

### constructor

• `Protected` **new Staker**()

#### Defined in

[staker.ts:72](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L72)

## Properties

### INCENTIVE\_KEY\_ABI

▪ `Static` `Private` **INCENTIVE\_KEY\_ABI**: `string` = `'tuple(address rewardToken, address pool, uint256 startTime, uint256 endTime, address refundee)'`

#### Defined in

[staker.ts:73](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L73)

___

### INTERFACE

▪ `Static` **INTERFACE**: `Interface`

#### Defined in

[staker.ts:70](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L70)

## Methods

### \_encodeIncentiveKey

▸ `Static` `Private` **_encodeIncentiveKey**(`incentiveKey`): `Object`

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `incentiveKey` | [`IncentiveKey`](../interfaces/IncentiveKey.md) | An `IncentiveKey` which represents a unique staking program. |

#### Returns

`Object`

An encoded IncentiveKey to be read by ethers

#### Defined in

[staker.ts:194](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L194)

___

### collectRewards

▸ `Static` **collectRewards**(`incentiveKeys`, `options`): [`MethodParameters`](../interfaces/MethodParameters.md)

Note:  A `tokenId` can be staked in many programs but to claim rewards and continue the program you must unstake, claim, and then restake.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `incentiveKeys` | [`IncentiveKey`](../interfaces/IncentiveKey.md) \| [`IncentiveKey`](../interfaces/IncentiveKey.md)[] | An IncentiveKey or array of IncentiveKeys that `tokenId` is staked in. Input an array of IncentiveKeys to claim rewards for each program. |
| `options` | [`ClaimOptions`](../interfaces/ClaimOptions.md) | ClaimOptions to specify tokenId, recipient, and amount wanting to collect. Note that you can only specify one amount and one recipient across the various programs if you are collecting from multiple programs at once. |

#### Returns

[`MethodParameters`](../interfaces/MethodParameters.md)

#### Defined in

[staker.ts:107](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L107)

___

### encodeClaim

▸ `Static` `Private` **encodeClaim**(`incentiveKey`, `options`): `string`[]

To claim rewards, must unstake and then claim.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `incentiveKey` | [`IncentiveKey`](../interfaces/IncentiveKey.md) | The unique identifier of a staking program. |
| `options` | [`ClaimOptions`](../interfaces/ClaimOptions.md) | Options for producing the calldata to claim. Can't claim unless you unstake. |

#### Returns

`string`[]

The calldatas for 'unstakeToken' and 'claimReward'.

#### Defined in

[staker.ts:82](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L82)

___

### encodeDeposit

▸ `Static` **encodeDeposit**(`incentiveKeys`): `string`

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `incentiveKeys` | [`IncentiveKey`](../interfaces/IncentiveKey.md) \| [`IncentiveKey`](../interfaces/IncentiveKey.md)[] | A single IncentiveKey or array of IncentiveKeys to be encoded and used in the data parameter in `safeTransferFrom` |

#### Returns

`string`

An IncentiveKey as a string

#### Defined in

[staker.ts:173](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L173)

___

### withdrawToken

▸ `Static` **withdrawToken**(`incentiveKeys`, `withdrawOptions`): [`MethodParameters`](../interfaces/MethodParameters.md)

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `incentiveKeys` | [`IncentiveKey`](../interfaces/IncentiveKey.md) \| [`IncentiveKey`](../interfaces/IncentiveKey.md)[] | A list of incentiveKeys to unstake from. Should include all incentiveKeys (unique staking programs) that `options.tokenId` is staked in. |
| `withdrawOptions` | [`FullWithdrawOptions`](../modules.md#fullwithdrawoptions) | Options for producing claim calldata and withdraw calldata. Can't withdraw without unstaking all programs for `tokenId`. |

#### Returns

[`MethodParameters`](../interfaces/MethodParameters.md)

Calldata for unstaking, claiming, and withdrawing.

#### Defined in

[staker.ts:136](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L136)
</file>

<file path="docs/sdk/v3/reference/classes/SwapMath.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / SwapMath

# Class: SwapMath

## Table of contents

### Constructors

- [constructor](SwapMath.md#constructor)

### Methods

- [computeSwapStep](SwapMath.md#computeswapstep)

## Constructors

### constructor

• `Private` **new SwapMath**()

Cannot be constructed.

#### Defined in

[utils/swapMath.ts:13](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/swapMath.ts#L13)

## Methods

### computeSwapStep

▸ `Static` **computeSwapStep**(`sqrtRatioCurrentX96`, `sqrtRatioTargetX96`, `liquidity`, `amountRemaining`, `feePips`): [`default`, `default`, `default`, `default`]

#### Parameters

| Name | Type |
| :------ | :------ |
| `sqrtRatioCurrentX96` | `default` |
| `sqrtRatioTargetX96` | `default` |
| `liquidity` | `default` |
| `amountRemaining` | `default` |
| `feePips` | [`FeeAmount`](../enums/FeeAmount.md) |

#### Returns

[`default`, `default`, `default`, `default`]

#### Defined in

[utils/swapMath.ts:15](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/swapMath.ts#L15)
</file>

<file path="docs/sdk/v3/reference/classes/SwapQuoter.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / SwapQuoter

# Class: SwapQuoter

Represents the Uniswap V3 QuoterV1 contract with a method for returning the formatted
calldata needed to call the quoter contract.

## Table of contents

### Constructors

- [constructor](SwapQuoter.md#constructor)

### Properties

- [V1INTERFACE](SwapQuoter.md#v1interface)
- [V2INTERFACE](SwapQuoter.md#v2interface)

### Methods

- [quoteCallParameters](SwapQuoter.md#quotecallparameters)

## Constructors

### constructor

• **new SwapQuoter**()

## Properties

### V1INTERFACE

▪ `Static` **V1INTERFACE**: `Interface`

#### Defined in

[quoter.ts:37](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/quoter.ts#L37)

___

### V2INTERFACE

▪ `Static` **V2INTERFACE**: `Interface`

#### Defined in

[quoter.ts:38](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/quoter.ts#L38)

## Methods

### quoteCallParameters

▸ `Static` **quoteCallParameters**\<`TInput`, `TOutput`\>(`route`, `amount`, `tradeType`, `options?`): [`MethodParameters`](../interfaces/MethodParameters.md)

Produces the on-chain method name of the appropriate function within QuoterV2,
and the relevant hex encoded parameters.

#### Type parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `TInput` | extends `Currency` | The input token, either Ether or an ERC-20 |
| `TOutput` | extends `Currency` | The output token, either Ether or an ERC-20 |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `route` | [`Route`](Route.md)\<`TInput`, `TOutput`\> | The swap route, a list of pools through which a swap can occur |
| `amount` | `CurrencyAmount`\<`TInput` \| `TOutput`\> | The amount of the quote, either an amount in, or an amount out |
| `tradeType` | `TradeType` | The trade type, either exact input or exact output |
| `options` | [`QuoteOptions`](../interfaces/QuoteOptions.md) | The optional params including price limit and Quoter contract switch |

#### Returns

[`MethodParameters`](../interfaces/MethodParameters.md)

The formatted calldata

#### Defined in

[quoter.ts:51](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/quoter.ts#L51)
</file>

<file path="docs/sdk/v3/reference/classes/SwapRouter.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / SwapRouter

# Class: SwapRouter

Represents the Uniswap V3 SwapRouter, and has static methods for helping execute trades.

## Table of contents

### Constructors

- [constructor](SwapRouter.md#constructor)

### Properties

- [INTERFACE](SwapRouter.md#interface)

### Methods

- [swapCallParameters](SwapRouter.md#swapcallparameters)

## Constructors

### constructor

• `Private` **new SwapRouter**()

Cannot be constructed.

#### Defined in

[swapRouter.ts:57](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L57)

## Properties

### INTERFACE

▪ `Static` **INTERFACE**: `Interface`

#### Defined in

[swapRouter.ts:52](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L52)

## Methods

### swapCallParameters

▸ `Static` **swapCallParameters**(`trades`, `options`): [`MethodParameters`](../interfaces/MethodParameters.md)

Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `trades` | [`Trade`](Trade.md)\<`Currency`, `Currency`, `TradeType`\> \| [`Trade`](Trade.md)\<`Currency`, `Currency`, `TradeType`\>[] | - |
| `options` | [`SwapOptions`](../interfaces/SwapOptions.md) | options for the call parameters |

#### Returns

[`MethodParameters`](../interfaces/MethodParameters.md)

#### Defined in

[swapRouter.ts:64](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L64)
</file>

<file path="docs/sdk/v3/reference/classes/Tick.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / Tick

# Class: Tick

## Table of contents

### Constructors

- [constructor](Tick.md#constructor)

### Properties

- [index](Tick.md#index)
- [liquidityGross](Tick.md#liquiditygross)
- [liquidityNet](Tick.md#liquiditynet)

## Constructors

### constructor

• **new Tick**(`__namedParameters`)

#### Parameters

| Name | Type |
| :------ | :------ |
| `__namedParameters` | [`TickConstructorArgs`](../interfaces/TickConstructorArgs.md) |

#### Defined in

[entities/tick.ts:17](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tick.ts#L17)

## Properties

### index

• `Readonly` **index**: `number`

#### Defined in

[entities/tick.ts:13](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tick.ts#L13)

___

### liquidityGross

• `Readonly` **liquidityGross**: `default`

#### Defined in

[entities/tick.ts:14](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tick.ts#L14)

___

### liquidityNet

• `Readonly` **liquidityNet**: `default`

#### Defined in

[entities/tick.ts:15](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tick.ts#L15)
</file>

<file path="docs/sdk/v3/reference/classes/TickLibrary.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / TickLibrary

# Class: TickLibrary

## Table of contents

### Constructors

- [constructor](TickLibrary.md#constructor)

### Methods

- [getFeeGrowthInside](TickLibrary.md#getfeegrowthinside)

## Constructors

### constructor

• `Private` **new TickLibrary**()

Cannot be constructed.

#### Defined in

[utils/tickLibrary.ts:25](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickLibrary.ts#L25)

## Methods

### getFeeGrowthInside

▸ `Static` **getFeeGrowthInside**(`feeGrowthOutsideLower`, `feeGrowthOutsideUpper`, `tickLower`, `tickUpper`, `tickCurrent`, `feeGrowthGlobal0X128`, `feeGrowthGlobal1X128`): `default`[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `feeGrowthOutsideLower` | `FeeGrowthOutside` |
| `feeGrowthOutsideUpper` | `FeeGrowthOutside` |
| `tickLower` | `number` |
| `tickUpper` | `number` |
| `tickCurrent` | `number` |
| `feeGrowthGlobal0X128` | `default` |
| `feeGrowthGlobal1X128` | `default` |

#### Returns

`default`[]

#### Defined in

[utils/tickLibrary.ts:27](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickLibrary.ts#L27)
</file>

<file path="docs/sdk/v3/reference/classes/TickList.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / TickList

# Class: TickList

Utility methods for interacting with sorted lists of ticks

## Table of contents

### Constructors

- [constructor](TickList.md#constructor)

### Methods

- [binarySearch](TickList.md#binarysearch)
- [getTick](TickList.md#gettick)
- [isAtOrAboveLargest](TickList.md#isatorabovelargest)
- [isBelowSmallest](TickList.md#isbelowsmallest)
- [nextInitializedTick](TickList.md#nextinitializedtick)
- [nextInitializedTickWithinOneWord](TickList.md#nextinitializedtickwithinoneword)
- [validateList](TickList.md#validatelist)

## Constructors

### constructor

• `Private` **new TickList**()

Cannot be constructed

#### Defined in

[utils/tickList.ts:18](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L18)

## Methods

### binarySearch

▸ `Static` `Private` **binarySearch**(`ticks`, `tick`): `number`

Finds the largest tick in the list of ticks that is less than or equal to tick

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `ticks` | readonly [`Tick`](Tick.md)[] | list of ticks |
| `tick` | `number` | tick to find the largest tick that is less than or equal to tick |

#### Returns

`number`

#### Defined in

[utils/tickList.ts:62](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L62)

___

### getTick

▸ `Static` **getTick**(`ticks`, `index`): [`Tick`](Tick.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `ticks` | readonly [`Tick`](Tick.md)[] |
| `index` | `number` |

#### Returns

[`Tick`](Tick.md)

#### Defined in

[utils/tickList.ts:50](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L50)

___

### isAtOrAboveLargest

▸ `Static` **isAtOrAboveLargest**(`ticks`, `tick`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `ticks` | readonly [`Tick`](Tick.md)[] |
| `tick` | `number` |

#### Returns

`boolean`

#### Defined in

[utils/tickList.ts:45](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L45)

___

### isBelowSmallest

▸ `Static` **isBelowSmallest**(`ticks`, `tick`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `ticks` | readonly [`Tick`](Tick.md)[] |
| `tick` | `number` |

#### Returns

`boolean`

#### Defined in

[utils/tickList.ts:40](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L40)

___

### nextInitializedTick

▸ `Static` **nextInitializedTick**(`ticks`, `tick`, `lte`): [`Tick`](Tick.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `ticks` | readonly [`Tick`](Tick.md)[] |
| `tick` | `number` |
| `lte` | `boolean` |

#### Returns

[`Tick`](Tick.md)

#### Defined in

[utils/tickList.ts:83](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L83)

___

### nextInitializedTickWithinOneWord

▸ `Static` **nextInitializedTickWithinOneWord**(`ticks`, `tick`, `lte`, `tickSpacing`): [`number`, `boolean`]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ticks` | readonly [`Tick`](Tick.md)[] |
| `tick` | `number` |
| `lte` | `boolean` |
| `tickSpacing` | `number` |

#### Returns

[`number`, `boolean`]

#### Defined in

[utils/tickList.ts:101](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L101)

___

### validateList

▸ `Static` **validateList**(`ticks`, `tickSpacing`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `ticks` | [`Tick`](Tick.md)[] |
| `tickSpacing` | `number` |

#### Returns

`void`

#### Defined in

[utils/tickList.ts:20](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickList.ts#L20)
</file>

<file path="docs/sdk/v3/reference/classes/TickListDataProvider.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / TickListDataProvider

# Class: TickListDataProvider

A data provider for ticks that is backed by an in-memory array of ticks.

## Implements

- [`TickDataProvider`](../interfaces/TickDataProvider.md)

## Table of contents

### Constructors

- [constructor](TickListDataProvider.md#constructor)

### Properties

- [ticks](TickListDataProvider.md#ticks)

### Methods

- [getTick](TickListDataProvider.md#gettick)
- [nextInitializedTickWithinOneWord](TickListDataProvider.md#nextinitializedtickwithinoneword)

## Constructors

### constructor

• **new TickListDataProvider**(`ticks`, `tickSpacing`)

#### Parameters

| Name | Type |
| :------ | :------ |
| `ticks` | ([`Tick`](Tick.md) \| [`TickConstructorArgs`](../interfaces/TickConstructorArgs.md))[] |
| `tickSpacing` | `number` |

#### Defined in

[entities/tickListDataProvider.ts:12](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickListDataProvider.ts#L12)

## Properties

### ticks

• `Private` **ticks**: readonly [`Tick`](Tick.md)[]

#### Defined in

[entities/tickListDataProvider.ts:10](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickListDataProvider.ts#L10)

## Methods

### getTick

▸ **getTick**(`tick`): `Promise`\<\{ `liquidityGross`: `BigintIsh` ; `liquidityNet`: `BigintIsh`  \}\>

Return information corresponding to a specific tick

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `tick` | `number` | the tick to load |

#### Returns

`Promise`\<\{ `liquidityGross`: `BigintIsh` ; `liquidityNet`: `BigintIsh`  \}\>

#### Implementation of

[TickDataProvider](../interfaces/TickDataProvider.md).[getTick](../interfaces/TickDataProvider.md#gettick)

#### Defined in

[entities/tickListDataProvider.ts:18](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickListDataProvider.ts#L18)

___

### nextInitializedTickWithinOneWord

▸ **nextInitializedTickWithinOneWord**(`tick`, `lte`, `tickSpacing`): `Promise`\<[`number`, `boolean`]\>

Return the next tick that is initialized within a single word

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `tick` | `number` | The current tick |
| `lte` | `boolean` | Whether the next tick should be lte the current tick |
| `tickSpacing` | `number` | The tick spacing of the pool |

#### Returns

`Promise`\<[`number`, `boolean`]\>

#### Implementation of

[TickDataProvider](../interfaces/TickDataProvider.md).[nextInitializedTickWithinOneWord](../interfaces/TickDataProvider.md#nextinitializedtickwithinoneword)

#### Defined in

[entities/tickListDataProvider.ts:22](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickListDataProvider.ts#L22)
</file>

<file path="docs/sdk/v3/reference/classes/TickMath.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / TickMath

# Class: TickMath

## Table of contents

### Constructors

- [constructor](TickMath.md#constructor)

### Properties

- [MAX\_SQRT\_RATIO](TickMath.md#max_sqrt_ratio)
- [MAX\_TICK](TickMath.md#max_tick)
- [MIN\_SQRT\_RATIO](TickMath.md#min_sqrt_ratio)
- [MIN\_TICK](TickMath.md#min_tick)

### Methods

- [getSqrtRatioAtTick](TickMath.md#getsqrtratioattick)
- [getTickAtSqrtRatio](TickMath.md#gettickatsqrtratio)

## Constructors

### constructor

• `Private` **new TickMath**()

Cannot be constructed.

#### Defined in

[utils/tickMath.ts:17](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickMath.ts#L17)

## Properties

### MAX\_SQRT\_RATIO

▪ `Static` **MAX\_SQRT\_RATIO**: `default`

The sqrt ratio corresponding to the maximum tick that could be used on any pool.

#### Defined in

[utils/tickMath.ts:35](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickMath.ts#L35)

___

### MAX\_TICK

▪ `Static` **MAX\_TICK**: `number` = `-TickMath.MIN_TICK`

The maximum tick that can be used on any pool.

#### Defined in

[utils/tickMath.ts:26](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickMath.ts#L26)

___

### MIN\_SQRT\_RATIO

▪ `Static` **MIN\_SQRT\_RATIO**: `default`

The sqrt ratio corresponding to the minimum tick that could be used on any pool.

#### Defined in

[utils/tickMath.ts:31](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickMath.ts#L31)

___

### MIN\_TICK

▪ `Static` **MIN\_TICK**: `number` = `-887272`

The minimum tick that can be used on any pool.

#### Defined in

[utils/tickMath.ts:22](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickMath.ts#L22)

## Methods

### getSqrtRatioAtTick

▸ `Static` **getSqrtRatioAtTick**(`tick`): `default`

Returns the sqrt ratio as a Q64.96 for the given tick. The sqrt ratio is computed as sqrt(1.0001)^tick

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `tick` | `number` | the tick for which to compute the sqrt ratio |

#### Returns

`default`

#### Defined in

[utils/tickMath.ts:41](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickMath.ts#L41)

___

### getTickAtSqrtRatio

▸ `Static` **getTickAtSqrtRatio**(`sqrtRatioX96`): `number`

Returns the tick corresponding to a given sqrt ratio, s.t. #getSqrtRatioAtTick(tick) \<= sqrtRatioX96
and #getSqrtRatioAtTick(tick + 1) > sqrtRatioX96

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `sqrtRatioX96` | `default` | the sqrt ratio as a Q64.96 for which to compute the tick |

#### Returns

`number`

#### Defined in

[utils/tickMath.ts:82](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickMath.ts#L82)
</file>

<file path="docs/sdk/v3/reference/classes/Trade.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / Trade

# Class: Trade\<TInput, TOutput, TTradeType\>

Represents a trade executed against a set of routes where some percentage of the input is
split across each route.

Each route has its own set of pools. Pools can not be re-used across routes.

Does not account for slippage, i.e., changes in price environment that can occur between
the time the trade is submitted and when it is executed.

## Type parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `TInput` | extends `Currency` | The input token, either Ether or an ERC-20 |
| `TOutput` | extends `Currency` | The output token, either Ether or an ERC-20 |
| `TTradeType` | extends `TradeType` | The trade type, either exact input or exact output |

## Table of contents

### Constructors

- [constructor](Trade.md#constructor)

### Properties

- [\_executionPrice](Trade.md#_executionprice)
- [\_inputAmount](Trade.md#_inputamount)
- [\_outputAmount](Trade.md#_outputamount)
- [\_priceImpact](Trade.md#_priceimpact)
- [swaps](Trade.md#swaps)
- [tradeType](Trade.md#tradetype)

### Accessors

- [executionPrice](Trade.md#executionprice)
- [inputAmount](Trade.md#inputamount)
- [outputAmount](Trade.md#outputamount)
- [priceImpact](Trade.md#priceimpact)
- [route](Trade.md#route)

### Methods

- [maximumAmountIn](Trade.md#maximumamountin)
- [minimumAmountOut](Trade.md#minimumamountout)
- [worstExecutionPrice](Trade.md#worstexecutionprice)
- [bestTradeExactIn](Trade.md#besttradeexactin)
- [bestTradeExactOut](Trade.md#besttradeexactout)
- [createUncheckedTrade](Trade.md#createuncheckedtrade)
- [createUncheckedTradeWithMultipleRoutes](Trade.md#createuncheckedtradewithmultipleroutes)
- [exactIn](Trade.md#exactin)
- [exactOut](Trade.md#exactout)
- [fromRoute](Trade.md#fromroute)
- [fromRoutes](Trade.md#fromroutes)

## Constructors

### constructor

• `Private` **new Trade**\<`TInput`, `TOutput`, `TTradeType`\>(`__namedParameters`)

Construct a trade by passing in the pre-computed property values

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TInput` | extends `Currency` |
| `TOutput` | extends `Currency` |
| `TTradeType` | extends `TradeType` |

#### Parameters

| Name | Type |
| :------ | :------ |
| `__namedParameters` | `Object` |
| `__namedParameters.routes` | \{ `inputAmount`: `CurrencyAmount`\<`TInput`\> ; `outputAmount`: `CurrencyAmount`\<`TOutput`\> ; `route`: [`Route`](Route.md)\<`TInput`, `TOutput`\>  \}[] |
| `__namedParameters.tradeType` | `TTradeType` |

#### Defined in

[entities/trade.ts:397](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L397)

## Properties

### \_executionPrice

• `Private` **\_executionPrice**: `undefined` \| `Price`\<`TInput`, `TOutput`\>

The cached result of the computed execution price

#### Defined in

[entities/trade.ts:143](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L143)

___

### \_inputAmount

• `Private` **\_inputAmount**: `undefined` \| `CurrencyAmount`\<`TInput`\>

The cached result of the input amount computation

#### Defined in

[entities/trade.ts:97](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L97)

___

### \_outputAmount

• `Private` **\_outputAmount**: `undefined` \| `CurrencyAmount`\<`TOutput`\>

The cached result of the output amount computation

#### Defined in

[entities/trade.ts:120](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L120)

___

### \_priceImpact

• `Private` **\_priceImpact**: `undefined` \| `Percent`

The cached result of the price impact computation

#### Defined in

[entities/trade.ts:164](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L164)

___

### swaps

• `Readonly` **swaps**: \{ `inputAmount`: `CurrencyAmount`\<`TInput`\> ; `outputAmount`: `CurrencyAmount`\<`TOutput`\> ; `route`: [`Route`](Route.md)\<`TInput`, `TOutput`\>  \}[]

The swaps of the trade, i.e. which routes and how much is swapped in each that
make up the trade.

#### Defined in

[entities/trade.ts:82](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L82)

___

### tradeType

• `Readonly` **tradeType**: `TTradeType`

The type of the trade, either exact in or exact out.

#### Defined in

[entities/trade.ts:91](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L91)

## Accessors

### executionPrice

• `get` **executionPrice**(): `Price`\<`TInput`, `TOutput`\>

The price expressed in terms of output amount/input amount.

#### Returns

`Price`\<`TInput`, `TOutput`\>

#### Defined in

[entities/trade.ts:148](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L148)

___

### inputAmount

• `get` **inputAmount**(): `CurrencyAmount`\<`TInput`\>

The input amount for the trade assuming no slippage.

#### Returns

`CurrencyAmount`\<`TInput`\>

#### Defined in

[entities/trade.ts:102](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L102)

___

### outputAmount

• `get` **outputAmount**(): `CurrencyAmount`\<`TOutput`\>

The output amount for the trade assuming no slippage.

#### Returns

`CurrencyAmount`\<`TOutput`\>

#### Defined in

[entities/trade.ts:125](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L125)

___

### priceImpact

• `get` **priceImpact**(): `Percent`

Returns the percent difference between the route's mid price and the price impact

#### Returns

`Percent`

#### Defined in

[entities/trade.ts:169](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L169)

___

### route

• `get` **route**(): [`Route`](Route.md)\<`TInput`, `TOutput`\>

**`Deprecated`**

Deprecated in favor of 'swaps' property. If the trade consists of multiple routes
this will return an error.

When the trade consists of just a single route, this returns the route of the trade,
i.e. which pools the trade goes through.

#### Returns

[`Route`](Route.md)\<`TInput`, `TOutput`\>

#### Defined in

[entities/trade.ts:73](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L73)

## Methods

### maximumAmountIn

▸ **maximumAmountIn**(`slippageTolerance`, `amountIn?`): `CurrencyAmount`\<`TInput`\>

Get the maximum amount in that can be spent via this trade for the given slippage tolerance

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `slippageTolerance` | `Percent` | The tolerance of unfavorable slippage from the execution price of this trade |
| `amountIn` | `CurrencyAmount`\<`TInput`\> | - |

#### Returns

`CurrencyAmount`\<`TInput`\>

The amount in

#### Defined in

[entities/trade.ts:456](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L456)

___

### minimumAmountOut

▸ **minimumAmountOut**(`slippageTolerance`, `amountOut?`): `CurrencyAmount`\<`TOutput`\>

Get the minimum amount that must be received from this trade for the given slippage tolerance

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `slippageTolerance` | `Percent` | The tolerance of unfavorable slippage from the execution price of this trade |
| `amountOut` | `CurrencyAmount`\<`TOutput`\> | - |

#### Returns

`CurrencyAmount`\<`TOutput`\>

The amount out

#### Defined in

[entities/trade.ts:438](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L438)

___

### worstExecutionPrice

▸ **worstExecutionPrice**(`slippageTolerance`): `Price`\<`TInput`, `TOutput`\>

Return the execution price after accounting for slippage tolerance

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `slippageTolerance` | `Percent` | the allowed tolerated slippage |

#### Returns

`Price`\<`TInput`, `TOutput`\>

The execution price

#### Defined in

[entities/trade.ts:471](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L471)

___

### bestTradeExactIn

▸ `Static` **bestTradeExactIn**\<`TInput`, `TOutput`\>(`pools`, `currencyAmountIn`, `currencyOut`, `__namedParameters?`, `currentPools?`, `nextAmountIn?`, `bestTrades?`): `Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_INPUT`\>[]\>

Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token
amount to an output token, making at most `maxHops` hops.
Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting
the amount in among multiple routes.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TInput` | extends `Currency` |
| `TOutput` | extends `Currency` |

#### Parameters

| Name | Type | Default value | Description |
| :------ | :------ | :------ | :------ |
| `pools` | [`Pool`](Pool.md)[] | `undefined` | the pools to consider in finding the best trade |
| `currencyAmountIn` | `CurrencyAmount`\<`TInput`\> | `undefined` | used in recursion; the original value of the currencyAmountIn parameter |
| `currencyOut` | `TOutput` | `undefined` | the desired currency out |
| `__namedParameters` | [`BestTradeOptions`](../interfaces/BestTradeOptions.md) | `{}` | - |
| `currentPools` | [`Pool`](Pool.md)[] | `[]` | used in recursion; the current list of pools |
| `nextAmountIn` | `CurrencyAmount`\<`Currency`\> | `currencyAmountIn` | exact amount of input currency to spend |
| `bestTrades` | [`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_INPUT`\>[] | `[]` | used in recursion; the current list of best trades |

#### Returns

`Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_INPUT`\>[]\>

The exact in trade

#### Defined in

[entities/trade.ts:495](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L495)

___

### bestTradeExactOut

▸ `Static` **bestTradeExactOut**\<`TInput`, `TOutput`\>(`pools`, `currencyIn`, `currencyAmountOut`, `__namedParameters?`, `currentPools?`, `nextAmountOut?`, `bestTrades?`): `Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_OUTPUT`\>[]\>

similar to the above method but instead targets a fixed output amount
given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token
to an output token amount, making at most `maxHops` hops
note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting
the amount in among multiple routes.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TInput` | extends `Currency` |
| `TOutput` | extends `Currency` |

#### Parameters

| Name | Type | Default value | Description |
| :------ | :------ | :------ | :------ |
| `pools` | [`Pool`](Pool.md)[] | `undefined` | the pools to consider in finding the best trade |
| `currencyIn` | `TInput` | `undefined` | the currency to spend |
| `currencyAmountOut` | `CurrencyAmount`\<`TOutput`\> | `undefined` | the desired currency amount out |
| `__namedParameters` | [`BestTradeOptions`](../interfaces/BestTradeOptions.md) | `{}` | - |
| `currentPools` | [`Pool`](Pool.md)[] | `[]` | used in recursion; the current list of pools |
| `nextAmountOut` | `CurrencyAmount`\<`Currency`\> | `currencyAmountOut` | the exact amount of currency out |
| `bestTrades` | [`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_OUTPUT`\>[] | `[]` | used in recursion; the current list of best trades |

#### Returns

`Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_OUTPUT`\>[]\>

The exact out trade

#### Defined in

[entities/trade.ts:576](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L576)

___

### createUncheckedTrade

▸ `Static` **createUncheckedTrade**\<`TInput`, `TOutput`, `TTradeType`\>(`constructorArguments`): [`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>

Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade
elsewhere and do not have any tick data

#### Type parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `TInput` | extends `Currency` | The input token, either Ether or an ERC-20 |
| `TOutput` | extends `Currency` | The output token, either Ether or an ERC-20 |
| `TTradeType` | extends `TradeType` | The type of the trade, either exact in or exact out |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `constructorArguments` | `Object` | The arguments passed to the trade constructor |
| `constructorArguments.inputAmount` | `CurrencyAmount`\<`TInput`\> | - |
| `constructorArguments.outputAmount` | `CurrencyAmount`\<`TOutput`\> | - |
| `constructorArguments.route` | [`Route`](Route.md)\<`TInput`, `TOutput`\> | - |
| `constructorArguments.tradeType` | `TTradeType` | - |

#### Returns

[`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>

The unchecked trade

#### Defined in

[entities/trade.ts:346](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L346)

___

### createUncheckedTradeWithMultipleRoutes

▸ `Static` **createUncheckedTradeWithMultipleRoutes**\<`TInput`, `TOutput`, `TTradeType`\>(`constructorArguments`): [`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>

Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade
elsewhere and do not have any tick data

#### Type parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `TInput` | extends `Currency` | The input token, either Ether or an ERC-20 |
| `TOutput` | extends `Currency` | The output token, either Ether or an ERC-20 |
| `TTradeType` | extends `TradeType` | The type of the trade, either exact in or exact out |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `constructorArguments` | `Object` | The arguments passed to the trade constructor |
| `constructorArguments.routes` | \{ `inputAmount`: `CurrencyAmount`\<`TInput`\> ; `outputAmount`: `CurrencyAmount`\<`TOutput`\> ; `route`: [`Route`](Route.md)\<`TInput`, `TOutput`\>  \}[] | - |
| `constructorArguments.tradeType` | `TTradeType` | - |

#### Returns

[`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>

The unchecked trade

#### Defined in

[entities/trade.ts:377](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L377)

___

### exactIn

▸ `Static` **exactIn**\<`TInput`, `TOutput`\>(`route`, `amountIn`): `Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_INPUT`\>\>

Constructs an exact in trade with the given amount in and route

#### Type parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `TInput` | extends `Currency` | The input token, either Ether or an ERC-20 |
| `TOutput` | extends `Currency` | The output token, either Ether or an ERC-20 |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `route` | [`Route`](Route.md)\<`TInput`, `TOutput`\> | The route of the exact in trade |
| `amountIn` | `CurrencyAmount`\<`TInput`\> | The amount being passed in |

#### Returns

`Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_INPUT`\>\>

The exact in trade

#### Defined in

[entities/trade.ts:194](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L194)

___

### exactOut

▸ `Static` **exactOut**\<`TInput`, `TOutput`\>(`route`, `amountOut`): `Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_OUTPUT`\>\>

Constructs an exact out trade with the given amount out and route

#### Type parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `TInput` | extends `Currency` | The input token, either Ether or an ERC-20 |
| `TOutput` | extends `Currency` | The output token, either Ether or an ERC-20 |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `route` | [`Route`](Route.md)\<`TInput`, `TOutput`\> | The route of the exact out trade |
| `amountOut` | `CurrencyAmount`\<`TOutput`\> | The amount returned by the trade |

#### Returns

`Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_OUTPUT`\>\>

The exact out trade

#### Defined in

[entities/trade.ts:209](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L209)

___

### fromRoute

▸ `Static` **fromRoute**\<`TInput`, `TOutput`, `TTradeType`\>(`route`, `amount`, `tradeType`): `Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>\>

Constructs a trade by simulating swaps through the given route

#### Type parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `TInput` | extends `Currency` | The input token, either Ether or an ERC-20. |
| `TOutput` | extends `Currency` | The output token, either Ether or an ERC-20. |
| `TTradeType` | extends `TradeType` | The type of the trade, either exact in or exact out. |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `route` | [`Route`](Route.md)\<`TInput`, `TOutput`\> | route to swap through |
| `amount` | `TTradeType` extends `EXACT_INPUT` ? `CurrencyAmount`\<`TInput`\> : `CurrencyAmount`\<`TOutput`\> | the amount specified, either input or output, depending on tradeType |
| `tradeType` | `TTradeType` | whether the trade is an exact input or exact output swap |

#### Returns

`Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>\>

The route

#### Defined in

[entities/trade.ts:226](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L226)

___

### fromRoutes

▸ `Static` **fromRoutes**\<`TInput`, `TOutput`, `TTradeType`\>(`routes`, `tradeType`): `Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>\>

Constructs a trade from routes by simulating swaps

#### Type parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `TInput` | extends `Currency` | The input token, either Ether or an ERC-20. |
| `TOutput` | extends `Currency` | The output token, either Ether or an ERC-20. |
| `TTradeType` | extends `TradeType` | The type of the trade, either exact in or exact out. |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `routes` | \{ `amount`: `TTradeType` extends `EXACT_INPUT` ? `CurrencyAmount`\<`TInput`\> : `CurrencyAmount`\<`TOutput`\> ; `route`: [`Route`](Route.md)\<`TInput`, `TOutput`\>  \}[] | the routes to swap through and how much of the amount should be routed through each |
| `tradeType` | `TTradeType` | whether the trade is an exact input or exact output swap |

#### Returns

`Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>\>

The trade

#### Defined in

[entities/trade.ts:276](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L276)
</file>

<file path="docs/sdk/v3/reference/enums/FeeAmount.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / FeeAmount

# Enumeration: FeeAmount

The default factory enabled fee amounts, denominated in hundredths of bips.

## Table of contents

### Enumeration Members

- [HIGH](FeeAmount.md#high)
- [LOW](FeeAmount.md#low)
- [LOWEST](FeeAmount.md#lowest)
- [MEDIUM](FeeAmount.md#medium)

## Enumeration Members

### HIGH

• **HIGH** = ``10000``

#### Defined in

[constants.ts:14](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L14)

___

### LOW

• **LOW** = ``500``

#### Defined in

[constants.ts:12](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L12)

___

### LOWEST

• **LOWEST** = ``100``

#### Defined in

[constants.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L11)

___

### MEDIUM

• **MEDIUM** = ``3000``

#### Defined in

[constants.ts:13](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L13)
</file>

<file path="docs/sdk/v3/reference/interfaces/AllowedPermitArguments.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / AllowedPermitArguments

# Interface: AllowedPermitArguments

## Table of contents

### Properties

- [expiry](AllowedPermitArguments.md#expiry)
- [nonce](AllowedPermitArguments.md#nonce)
- [r](AllowedPermitArguments.md#r)
- [s](AllowedPermitArguments.md#s)
- [v](AllowedPermitArguments.md#v)

## Properties

### expiry

• **expiry**: `BigintIsh`

#### Defined in

[selfPermit.ts:19](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L19)

___

### nonce

• **nonce**: `BigintIsh`

#### Defined in

[selfPermit.ts:18](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L18)

___

### r

• **r**: `string`

#### Defined in

[selfPermit.ts:16](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L16)

___

### s

• **s**: `string`

#### Defined in

[selfPermit.ts:17](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L17)

___

### v

• **v**: ``0`` \| ``1`` \| ``27`` \| ``28``

#### Defined in

[selfPermit.ts:15](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L15)
</file>

<file path="docs/sdk/v3/reference/interfaces/BestTradeOptions.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / BestTradeOptions

# Interface: BestTradeOptions

## Table of contents

### Properties

- [maxHops](BestTradeOptions.md#maxhops)
- [maxNumResults](BestTradeOptions.md#maxnumresults)

## Properties

### maxHops

• `Optional` **maxHops**: `number`

#### Defined in

[entities/trade.ts:50](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L50)

___

### maxNumResults

• `Optional` **maxNumResults**: `number`

#### Defined in

[entities/trade.ts:48](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L48)
</file>

<file path="docs/sdk/v3/reference/interfaces/ClaimOptions.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / ClaimOptions

# Interface: ClaimOptions

Options to specify when claiming rewards.

## Table of contents

### Properties

- [amount](ClaimOptions.md#amount)
- [recipient](ClaimOptions.md#recipient)
- [tokenId](ClaimOptions.md#tokenid)

## Properties

### amount

• `Optional` **amount**: `BigintIsh`

The amount of `rewardToken` to claim. 0 claims all.

#### Defined in

[staker.ts:52](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L52)

___

### recipient

• **recipient**: `string`

Address to send rewards to.

#### Defined in

[staker.ts:47](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L47)

___

### tokenId

• **tokenId**: `BigintIsh`

The id of the NFT

#### Defined in

[staker.ts:42](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L42)
</file>

<file path="docs/sdk/v3/reference/interfaces/CollectOptions.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / CollectOptions

# Interface: CollectOptions

## Table of contents

### Properties

- [expectedCurrencyOwed0](CollectOptions.md#expectedcurrencyowed0)
- [expectedCurrencyOwed1](CollectOptions.md#expectedcurrencyowed1)
- [recipient](CollectOptions.md#recipient)
- [tokenId](CollectOptions.md#tokenid)

## Properties

### expectedCurrencyOwed0

• **expectedCurrencyOwed0**: `CurrencyAmount`\<`Currency`\>

Expected value of tokensOwed0, including as-of-yet-unaccounted-for fees/liquidity value to be burned

#### Defined in

[nonfungiblePositionManager.ts:114](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L114)

___

### expectedCurrencyOwed1

• **expectedCurrencyOwed1**: `CurrencyAmount`\<`Currency`\>

Expected value of tokensOwed1, including as-of-yet-unaccounted-for fees/liquidity value to be burned

#### Defined in

[nonfungiblePositionManager.ts:119](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L119)

___

### recipient

• **recipient**: `string`

The account that should receive the tokens.

#### Defined in

[nonfungiblePositionManager.ts:124](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L124)

___

### tokenId

• **tokenId**: `BigintIsh`

Indicates the ID of the position to collect for.

#### Defined in

[nonfungiblePositionManager.ts:109](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L109)
</file>

<file path="docs/sdk/v3/reference/interfaces/CommonAddLiquidityOptions.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / CommonAddLiquidityOptions

# Interface: CommonAddLiquidityOptions

Options for producing the calldata to add liquidity.

## Table of contents

### Properties

- [deadline](CommonAddLiquidityOptions.md#deadline)
- [slippageTolerance](CommonAddLiquidityOptions.md#slippagetolerance)
- [token0Permit](CommonAddLiquidityOptions.md#token0permit)
- [token1Permit](CommonAddLiquidityOptions.md#token1permit)
- [useNative](CommonAddLiquidityOptions.md#usenative)

## Properties

### deadline

• **deadline**: `BigintIsh`

When the transaction expires, in epoch seconds.

#### Defined in

[nonfungiblePositionManager.ts:56](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L56)

___

### slippageTolerance

• **slippageTolerance**: `Percent`

How much the pool price is allowed to move.

#### Defined in

[nonfungiblePositionManager.ts:51](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L51)

___

### token0Permit

• `Optional` **token0Permit**: [`PermitOptions`](../modules.md#permitoptions)

The optional permit parameters for spending token0

#### Defined in

[nonfungiblePositionManager.ts:66](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L66)

___

### token1Permit

• `Optional` **token1Permit**: [`PermitOptions`](../modules.md#permitoptions)

The optional permit parameters for spending token1

#### Defined in

[nonfungiblePositionManager.ts:71](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L71)

___

### useNative

• `Optional` **useNative**: `NativeCurrency`

Whether to spend ether. If true, one of the pool tokens must be WETH, by default false

#### Defined in

[nonfungiblePositionManager.ts:61](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L61)
</file>

<file path="docs/sdk/v3/reference/interfaces/FeeOptions.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / FeeOptions

# Interface: FeeOptions

## Table of contents

### Properties

- [fee](FeeOptions.md#fee)
- [recipient](FeeOptions.md#recipient)

## Properties

### fee

• **fee**: `Percent`

The percent of the output that will be taken as a fee.

#### Defined in

[payments.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L11)

___

### recipient

• **recipient**: `string`

The recipient of the fee.

#### Defined in

[payments.ts:16](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/payments.ts#L16)
</file>

<file path="docs/sdk/v3/reference/interfaces/IncentiveKey.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / IncentiveKey

# Interface: IncentiveKey

Represents a unique staking program.

## Table of contents

### Properties

- [endTime](IncentiveKey.md#endtime)
- [pool](IncentiveKey.md#pool)
- [refundee](IncentiveKey.md#refundee)
- [rewardToken](IncentiveKey.md#rewardtoken)
- [startTime](IncentiveKey.md#starttime)

## Properties

### endTime

• **endTime**: `BigintIsh`

The time that the incentive program ends.

#### Defined in

[staker.ts:28](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L28)

___

### pool

• **pool**: [`Pool`](../classes/Pool.md)

The pool that the staked positions must provide in.

#### Defined in

[staker.ts:20](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L20)

___

### refundee

• **refundee**: `string`

The address which receives any remaining reward tokens at `endTime`.

#### Defined in

[staker.ts:32](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L32)

___

### rewardToken

• **rewardToken**: `Token`

The token rewarded for participating in the staking program.

#### Defined in

[staker.ts:16](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L16)

___

### startTime

• **startTime**: `BigintIsh`

The time when the incentive program begins.

#### Defined in

[staker.ts:24](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L24)
</file>

<file path="docs/sdk/v3/reference/interfaces/IncreaseSpecificOptions.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / IncreaseSpecificOptions

# Interface: IncreaseSpecificOptions

## Table of contents

### Properties

- [tokenId](IncreaseSpecificOptions.md#tokenid)

## Properties

### tokenId

• **tokenId**: `BigintIsh`

Indicates the ID of the position to increase liquidity for.

#### Defined in

[nonfungiblePositionManager.ts:41](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L41)
</file>

<file path="docs/sdk/v3/reference/interfaces/MethodParameters.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / MethodParameters

# Interface: MethodParameters

Generated method parameters for executing a call.

## Table of contents

### Properties

- [calldata](MethodParameters.md#calldata)
- [value](MethodParameters.md#value)

## Properties

### calldata

• **calldata**: `string`

The hex encoded calldata to perform the given operation

#### Defined in

[utils/calldata.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/calldata.ts#L11)

___

### value

• **value**: `string`

The amount of ether (wei) to send in hex.

#### Defined in

[utils/calldata.ts:15](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/calldata.ts#L15)
</file>

<file path="docs/sdk/v3/reference/interfaces/MintSpecificOptions.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / MintSpecificOptions

# Interface: MintSpecificOptions

## Table of contents

### Properties

- [createPool](MintSpecificOptions.md#createpool)
- [recipient](MintSpecificOptions.md#recipient)

## Properties

### createPool

• `Optional` **createPool**: `boolean`

Creates pool if not initialized before mint.

#### Defined in

[nonfungiblePositionManager.ts:34](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L34)

___

### recipient

• **recipient**: `string`

The account that should receive the minted NFT.

#### Defined in

[nonfungiblePositionManager.ts:29](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L29)
</file>

<file path="docs/sdk/v3/reference/interfaces/NFTPermitOptions.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / NFTPermitOptions

# Interface: NFTPermitOptions

## Table of contents

### Properties

- [deadline](NFTPermitOptions.md#deadline)
- [r](NFTPermitOptions.md#r)
- [s](NFTPermitOptions.md#s)
- [spender](NFTPermitOptions.md#spender)
- [v](NFTPermitOptions.md#v)

## Properties

### deadline

• **deadline**: `BigintIsh`

#### Defined in

[nonfungiblePositionManager.ts:131](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L131)

___

### r

• **r**: `string`

#### Defined in

[nonfungiblePositionManager.ts:129](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L129)

___

### s

• **s**: `string`

#### Defined in

[nonfungiblePositionManager.ts:130](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L130)

___

### spender

• **spender**: `string`

#### Defined in

[nonfungiblePositionManager.ts:132](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L132)

___

### v

• **v**: ``0`` \| ``1`` \| ``27`` \| ``28``

#### Defined in

[nonfungiblePositionManager.ts:128](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L128)
</file>

<file path="docs/sdk/v3/reference/interfaces/QuoteOptions.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / QuoteOptions

# Interface: QuoteOptions

Optional arguments to send to the quoter.

## Table of contents

### Properties

- [sqrtPriceLimitX96](QuoteOptions.md#sqrtpricelimitx96)
- [useQuoterV2](QuoteOptions.md#usequoterv2)

## Properties

### sqrtPriceLimitX96

• `Optional` **sqrtPriceLimitX96**: `BigintIsh`

The optional price limit for the trade.

#### Defined in

[quoter.ts:17](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/quoter.ts#L17)

___

### useQuoterV2

• `Optional` **useQuoterV2**: `boolean`

The optional quoter interface to use

#### Defined in

[quoter.ts:22](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/quoter.ts#L22)
</file>

<file path="docs/sdk/v3/reference/interfaces/RemoveLiquidityOptions.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / RemoveLiquidityOptions

# Interface: RemoveLiquidityOptions

Options for producing the calldata to exit a position.

## Table of contents

### Properties

- [burnToken](RemoveLiquidityOptions.md#burntoken)
- [collectOptions](RemoveLiquidityOptions.md#collectoptions)
- [deadline](RemoveLiquidityOptions.md#deadline)
- [liquidityPercentage](RemoveLiquidityOptions.md#liquiditypercentage)
- [permit](RemoveLiquidityOptions.md#permit)
- [slippageTolerance](RemoveLiquidityOptions.md#slippagetolerance)
- [tokenId](RemoveLiquidityOptions.md#tokenid)

## Properties

### burnToken

• `Optional` **burnToken**: `boolean`

Whether the NFT should be burned if the entire position is being exited, by default false.

#### Defined in

[nonfungiblePositionManager.ts:162](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L162)

___

### collectOptions

• **collectOptions**: `Omit`\<[`CollectOptions`](CollectOptions.md), ``"tokenId"``\>

Parameters to be passed on to collect

#### Defined in

[nonfungiblePositionManager.ts:172](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L172)

___

### deadline

• **deadline**: `BigintIsh`

When the transaction expires, in epoch seconds.

#### Defined in

[nonfungiblePositionManager.ts:157](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L157)

___

### liquidityPercentage

• **liquidityPercentage**: `Percent`

The percentage of position liquidity to exit.

#### Defined in

[nonfungiblePositionManager.ts:147](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L147)

___

### permit

• `Optional` **permit**: [`NFTPermitOptions`](NFTPermitOptions.md)

The optional permit of the token ID being exited, in case the exit transaction is being sent by an account that does not own the NFT

#### Defined in

[nonfungiblePositionManager.ts:167](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L167)

___

### slippageTolerance

• **slippageTolerance**: `Percent`

How much the pool price is allowed to move.

#### Defined in

[nonfungiblePositionManager.ts:152](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L152)

___

### tokenId

• **tokenId**: `BigintIsh`

The ID of the token to exit

#### Defined in

[nonfungiblePositionManager.ts:142](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L142)
</file>

<file path="docs/sdk/v3/reference/interfaces/SafeTransferOptions.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / SafeTransferOptions

# Interface: SafeTransferOptions

## Table of contents

### Properties

- [data](SafeTransferOptions.md#data)
- [recipient](SafeTransferOptions.md#recipient)
- [sender](SafeTransferOptions.md#sender)
- [tokenId](SafeTransferOptions.md#tokenid)

## Properties

### data

• `Optional` **data**: `string`

The optional parameter that passes data to the `onERC721Received` call for the staker

#### Defined in

[nonfungiblePositionManager.ts:97](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L97)

___

### recipient

• **recipient**: `string`

The account that should receive the NFT.

#### Defined in

[nonfungiblePositionManager.ts:88](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L88)

___

### sender

• **sender**: `string`

The account sending the NFT.

#### Defined in

[nonfungiblePositionManager.ts:83](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L83)

___

### tokenId

• **tokenId**: `BigintIsh`

The id of the token being sent.

#### Defined in

[nonfungiblePositionManager.ts:93](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L93)
</file>

<file path="docs/sdk/v3/reference/interfaces/StandardPermitArguments.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / StandardPermitArguments

# Interface: StandardPermitArguments

## Table of contents

### Properties

- [amount](StandardPermitArguments.md#amount)
- [deadline](StandardPermitArguments.md#deadline)
- [r](StandardPermitArguments.md#r)
- [s](StandardPermitArguments.md#s)
- [v](StandardPermitArguments.md#v)

## Properties

### amount

• **amount**: `BigintIsh`

#### Defined in

[selfPermit.ts:10](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L10)

___

### deadline

• **deadline**: `BigintIsh`

#### Defined in

[selfPermit.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L11)

___

### r

• **r**: `string`

#### Defined in

[selfPermit.ts:8](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L8)

___

### s

• **s**: `string`

#### Defined in

[selfPermit.ts:9](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L9)

___

### v

• **v**: ``0`` \| ``1`` \| ``27`` \| ``28``

#### Defined in

[selfPermit.ts:7](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L7)
</file>

<file path="docs/sdk/v3/reference/interfaces/SwapOptions.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / SwapOptions

# Interface: SwapOptions

Options for producing the arguments to send calls to the router.

## Table of contents

### Properties

- [deadline](SwapOptions.md#deadline)
- [fee](SwapOptions.md#fee)
- [inputTokenPermit](SwapOptions.md#inputtokenpermit)
- [recipient](SwapOptions.md#recipient)
- [slippageTolerance](SwapOptions.md#slippagetolerance)
- [sqrtPriceLimitX96](SwapOptions.md#sqrtpricelimitx96)

## Properties

### deadline

• **deadline**: `BigintIsh`

When the transaction expires, in epoch seconds.

#### Defined in

[swapRouter.ts:30](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L30)

___

### fee

• `Optional` **fee**: [`FeeOptions`](FeeOptions.md)

Optional information for taking a fee on output.

#### Defined in

[swapRouter.ts:45](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L45)

___

### inputTokenPermit

• `Optional` **inputTokenPermit**: [`PermitOptions`](../modules.md#permitoptions)

The optional permit parameters for spending the input.

#### Defined in

[swapRouter.ts:35](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L35)

___

### recipient

• **recipient**: `string`

The account that should receive the output.

#### Defined in

[swapRouter.ts:25](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L25)

___

### slippageTolerance

• **slippageTolerance**: `Percent`

How much the execution price is allowed to move unfavorably from the trade execution price.

#### Defined in

[swapRouter.ts:20](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L20)

___

### sqrtPriceLimitX96

• `Optional` **sqrtPriceLimitX96**: `BigintIsh`

The optional price limit for the trade.

#### Defined in

[swapRouter.ts:40](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/swapRouter.ts#L40)
</file>

<file path="docs/sdk/v3/reference/interfaces/TickConstructorArgs.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / TickConstructorArgs

# Interface: TickConstructorArgs

## Table of contents

### Properties

- [index](TickConstructorArgs.md#index)
- [liquidityGross](TickConstructorArgs.md#liquiditygross)
- [liquidityNet](TickConstructorArgs.md#liquiditynet)

## Properties

### index

• **index**: `number`

#### Defined in

[entities/tick.ts:7](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tick.ts#L7)

___

### liquidityGross

• **liquidityGross**: `BigintIsh`

#### Defined in

[entities/tick.ts:8](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tick.ts#L8)

___

### liquidityNet

• **liquidityNet**: `BigintIsh`

#### Defined in

[entities/tick.ts:9](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tick.ts#L9)
</file>

<file path="docs/sdk/v3/reference/interfaces/TickDataProvider.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / TickDataProvider

# Interface: TickDataProvider

Provides information about ticks

## Implemented by

- [`NoTickDataProvider`](../classes/NoTickDataProvider.md)
- [`TickListDataProvider`](../classes/TickListDataProvider.md)

## Table of contents

### Methods

- [getTick](TickDataProvider.md#gettick)
- [nextInitializedTickWithinOneWord](TickDataProvider.md#nextinitializedtickwithinoneword)

## Methods

### getTick

▸ **getTick**(`tick`): `Promise`\<\{ `liquidityNet`: `BigintIsh`  \}\>

Return information corresponding to a specific tick

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `tick` | `number` | the tick to load |

#### Returns

`Promise`\<\{ `liquidityNet`: `BigintIsh`  \}\>

#### Defined in

[entities/tickDataProvider.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickDataProvider.ts#L11)

___

### nextInitializedTickWithinOneWord

▸ **nextInitializedTickWithinOneWord**(`tick`, `lte`, `tickSpacing`): `Promise`\<[`number`, `boolean`]\>

Return the next tick that is initialized within a single word

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `tick` | `number` | The current tick |
| `lte` | `boolean` | Whether the next tick should be lte the current tick |
| `tickSpacing` | `number` | The tick spacing of the pool |

#### Returns

`Promise`\<[`number`, `boolean`]\>

#### Defined in

[entities/tickDataProvider.ts:19](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/tickDataProvider.ts#L19)
</file>

<file path="docs/sdk/v3/reference/interfaces/WithdrawOptions.md">
[@uniswap/v3-sdk](../README.md) / [Exports](../modules.md) / WithdrawOptions

# Interface: WithdrawOptions

Options to specify when withdrawing a position.

## Table of contents

### Properties

- [data](WithdrawOptions.md#data)
- [owner](WithdrawOptions.md#owner)

## Properties

### data

• `Optional` **data**: `string`

Set when withdrawing. `data` is passed to `safeTransferFrom` when transferring the position from contract back to owner.

#### Defined in

[staker.ts:66](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L66)

___

### owner

• **owner**: `string`

Set when withdrawing. The position will be sent to `owner` on withdraw.

#### Defined in

[staker.ts:61](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L61)
</file>

<file path="docs/sdk/v3/reference/_category_.json">
{
  "label": "Technical Reference",
  "position": 3,
  "collapsed": true
}
</file>

<file path="docs/sdk/v3/reference/overview.md">
---
id: overview
sidebar_position: 1
title: Overview
---

## Table of contents

### Enumerations

- [FeeAmount](enums/FeeAmount.md)

### Classes

- [FullMath](classes/FullMath.md)
- [LiquidityMath](classes/LiquidityMath.md)
- [Multicall](classes/Multicall.md)
- [NoTickDataProvider](classes/NoTickDataProvider.md)
- [NonfungiblePositionManager](classes/NonfungiblePositionManager.md)
- [Payments](classes/Payments.md)
- [Pool](classes/Pool.md)
- [Position](classes/Position.md)
- [PositionLibrary](classes/PositionLibrary.md)
- [Route](classes/Route.md)
- [SelfPermit](classes/SelfPermit.md)
- [SqrtPriceMath](classes/SqrtPriceMath.md)
- [Staker](classes/Staker.md)
- [SwapMath](classes/SwapMath.md)
- [SwapQuoter](classes/SwapQuoter.md)
- [SwapRouter](classes/SwapRouter.md)
- [Tick](classes/Tick.md)
- [TickLibrary](classes/TickLibrary.md)
- [TickList](classes/TickList.md)
- [TickListDataProvider](classes/TickListDataProvider.md)
- [TickMath](classes/TickMath.md)
- [Trade](classes/Trade.md)

### Interfaces

- [AllowedPermitArguments](interfaces/AllowedPermitArguments.md)
- [BestTradeOptions](interfaces/BestTradeOptions.md)
- [ClaimOptions](interfaces/ClaimOptions.md)
- [CollectOptions](interfaces/CollectOptions.md)
- [CommonAddLiquidityOptions](interfaces/CommonAddLiquidityOptions.md)
- [FeeOptions](interfaces/FeeOptions.md)
- [IncentiveKey](interfaces/IncentiveKey.md)
- [IncreaseSpecificOptions](interfaces/IncreaseSpecificOptions.md)
- [MethodParameters](interfaces/MethodParameters.md)
- [MintSpecificOptions](interfaces/MintSpecificOptions.md)
- [NFTPermitOptions](interfaces/NFTPermitOptions.md)
- [QuoteOptions](interfaces/QuoteOptions.md)
- [RemoveLiquidityOptions](interfaces/RemoveLiquidityOptions.md)
- [SafeTransferOptions](interfaces/SafeTransferOptions.md)
- [StandardPermitArguments](interfaces/StandardPermitArguments.md)
- [SwapOptions](interfaces/SwapOptions.md)
- [TickConstructorArgs](interfaces/TickConstructorArgs.md)
- [TickDataProvider](interfaces/TickDataProvider.md)
- [WithdrawOptions](interfaces/WithdrawOptions.md)

### Type Aliases

- [AddLiquidityOptions](modules.md#addliquidityoptions)
- [FullWithdrawOptions](modules.md#fullwithdrawoptions)
- [IncreaseOptions](modules.md#increaseoptions)
- [MintOptions](modules.md#mintoptions)
- [PermitOptions](modules.md#permitoptions)

### Variables

- [ADDRESS\_ZERO](modules.md#address_zero)
- [FACTORY\_ADDRESS](modules.md#factory_address)
- [POOL\_INIT\_CODE\_HASH](modules.md#pool_init_code_hash)
- [TICK\_SPACINGS](modules.md#tick_spacings)

### Functions

- [computePoolAddress](modules.md#computepooladdress)
- [encodeRouteToPath](modules.md#encoderoutetopath)
- [encodeSqrtRatioX96](modules.md#encodesqrtratiox96)
- [isSorted](modules.md#issorted)
- [maxLiquidityForAmounts](modules.md#maxliquidityforamounts)
- [mostSignificantBit](modules.md#mostsignificantbit)
- [nearestUsableTick](modules.md#nearestusabletick)
- [priceToClosestTick](modules.md#pricetoclosesttick)
- [subIn256](modules.md#subin256)
- [tickToPrice](modules.md#ticktoprice)
- [toHex](modules.md#tohex)
- [tradeComparator](modules.md#tradecomparator)

## Type Aliases

### AddLiquidityOptions

Ƭ **AddLiquidityOptions**: [`MintOptions`](modules.md#mintoptions) \| [`IncreaseOptions`](modules.md#increaseoptions)

#### Defined in

[nonfungiblePositionManager.ts:77](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L77)

___

### FullWithdrawOptions

Ƭ **FullWithdrawOptions**: [`ClaimOptions`](interfaces/ClaimOptions.md) & [`WithdrawOptions`](interfaces/WithdrawOptions.md)

#### Defined in

[staker.ts:8](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/staker.ts#L8)

___

### IncreaseOptions

Ƭ **IncreaseOptions**: [`CommonAddLiquidityOptions`](interfaces/CommonAddLiquidityOptions.md) & [`IncreaseSpecificOptions`](interfaces/IncreaseSpecificOptions.md)

#### Defined in

[nonfungiblePositionManager.ts:75](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L75)

___

### MintOptions

Ƭ **MintOptions**: [`CommonAddLiquidityOptions`](interfaces/CommonAddLiquidityOptions.md) & [`MintSpecificOptions`](interfaces/MintSpecificOptions.md)

#### Defined in

[nonfungiblePositionManager.ts:74](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/nonfungiblePositionManager.ts#L74)

___

### PermitOptions

Ƭ **PermitOptions**: [`StandardPermitArguments`](interfaces/StandardPermitArguments.md) \| [`AllowedPermitArguments`](interfaces/AllowedPermitArguments.md)

#### Defined in

[selfPermit.ts:22](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/selfPermit.ts#L22)

## Variables

### ADDRESS\_ZERO

• `Const` **ADDRESS\_ZERO**: ``"0x0000000000000000000000000000000000000000"``

#### Defined in

[constants.ts:3](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L3)

___

### FACTORY\_ADDRESS

• `Const` **FACTORY\_ADDRESS**: ``"0x1F98431c8aD98523631AE4a59f267346ea31F984"``

#### Defined in

[constants.ts:1](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L1)

___

### POOL\_INIT\_CODE\_HASH

• `Const` **POOL\_INIT\_CODE\_HASH**: ``"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54"``

#### Defined in

[constants.ts:5](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L5)

___

### TICK\_SPACINGS

• `Const` **TICK\_SPACINGS**: \{ [amount in FeeAmount]: number \}

The default factory tick spacings by fee amount.

#### Defined in

[constants.ts:20](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/constants.ts#L20)

## Functions

### computePoolAddress

▸ **computePoolAddress**(`__namedParameters`): `string`

Computes a pool address

#### Parameters

| Name | Type |
| :------ | :------ |
| `__namedParameters` | `Object` |
| `__namedParameters.factoryAddress` | `string` |
| `__namedParameters.fee` | [`FeeAmount`](enums/FeeAmount.md) |
| `__namedParameters.initCodeHashManualOverride?` | `string` |
| `__namedParameters.tokenA` | `Token` |
| `__namedParameters.tokenB` | `Token` |

#### Returns

`string`

The pool address

#### Defined in

[utils/computePoolAddress.ts:16](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/computePoolAddress.ts#L16)

___

### encodeRouteToPath

▸ **encodeRouteToPath**(`route`, `exactOutput`): `string`

Converts a route to a hex encoded path

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `route` | [`Route`](classes/Route.md)\<`Currency`, `Currency`\> | the v3 path to convert to an encoded path |
| `exactOutput` | `boolean` | whether the route should be encoded in reverse, for making exact output swaps |

#### Returns

`string`

#### Defined in

[utils/encodeRouteToPath.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/encodeRouteToPath.ts#L11)

___

### encodeSqrtRatioX96

▸ **encodeSqrtRatioX96**(`amount1`, `amount0`): `JSBI`

Returns the sqrt ratio as a Q64.96 corresponding to a given ratio of amount1 and amount0

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `amount1` | `BigintIsh` | The numerator amount i.e., the amount of token1 |
| `amount0` | `BigintIsh` | The denominator amount i.e., the amount of token0 |

#### Returns

`JSBI`

The sqrt ratio

#### Defined in

[utils/encodeSqrtRatioX96.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/encodeSqrtRatioX96.ts#L11)

___

### isSorted

▸ **isSorted**\<`T`\>(`list`, `comparator`): `boolean`

Determines if a tick list is sorted

#### Type parameters

| Name |
| :------ |
| `T` |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `list` | `T`[] | The tick list |
| `comparator` | (`a`: `T`, `b`: `T`) => `number` | The comparator |

#### Returns

`boolean`

true if sorted

#### Defined in

[utils/isSorted.ts:7](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/isSorted.ts#L7)

___

### maxLiquidityForAmounts

▸ **maxLiquidityForAmounts**(`sqrtRatioCurrentX96`, `sqrtRatioAX96`, `sqrtRatioBX96`, `amount0`, `amount1`, `useFullPrecision`): `JSBI`

Computes the maximum amount of liquidity received for a given amount of token0, token1,
and the prices at the tick boundaries.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `sqrtRatioCurrentX96` | `default` | the current price |
| `sqrtRatioAX96` | `default` | price at lower boundary |
| `sqrtRatioBX96` | `default` | price at upper boundary |
| `amount0` | `BigintIsh` | token0 amount |
| `amount1` | `BigintIsh` | token1 amount |
| `useFullPrecision` | `boolean` | if false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support |

#### Returns

`JSBI`

#### Defined in

[utils/maxLiquidityForAmounts.ts:68](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/maxLiquidityForAmounts.ts#L68)

___

### mostSignificantBit

▸ **mostSignificantBit**(`x`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `x` | `default` |

#### Returns

`number`

#### Defined in

[utils/mostSignificantBit.ts:12](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/mostSignificantBit.ts#L12)

___

### nearestUsableTick

▸ **nearestUsableTick**(`tick`, `tickSpacing`): `number`

Returns the closest tick that is nearest a given tick and usable for the given tick spacing

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `tick` | `number` | the target tick |
| `tickSpacing` | `number` | the spacing of the pool |

#### Returns

`number`

#### Defined in

[utils/nearestUsableTick.ts:9](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/nearestUsableTick.ts#L9)

___

### priceToClosestTick

▸ **priceToClosestTick**(`price`): `number`

Returns the first tick for which the given price is greater than or equal to the tick price

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `price` | `Price`\<`Token`, `Token`\> | for which to return the closest tick that represents a price less than or equal to the input price, i.e. the price of the returned tick is less than or equal to the input price |

#### Returns

`number`

#### Defined in

[utils/priceTickConversions.ts:29](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/priceTickConversions.ts#L29)

___

### subIn256

▸ **subIn256**(`x`, `y`): `JSBI`

#### Parameters

| Name | Type |
| :------ | :------ |
| `x` | `default` |
| `y` | `default` |

#### Returns

`JSBI`

#### Defined in

[utils/tickLibrary.ts:11](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/tickLibrary.ts#L11)

___

### tickToPrice

▸ **tickToPrice**(`baseToken`, `quoteToken`, `tick`): `Price`\<`Token`, `Token`\>

Returns a price object corresponding to the input tick and the base/quote token
Inputs must be tokens because the address order is used to interpret the price represented by the tick

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `baseToken` | `Token` | the base token of the price |
| `quoteToken` | `Token` | the quote token of the price |
| `tick` | `number` | the tick for which to return the price |

#### Returns

`Price`\<`Token`, `Token`\>

#### Defined in

[utils/priceTickConversions.ts:14](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/priceTickConversions.ts#L14)

___

### toHex

▸ **toHex**(`bigintIsh`): `string`

Converts a big int to a hex string

#### Parameters

| Name | Type |
| :------ | :------ |
| `bigintIsh` | `BigintIsh` |

#### Returns

`string`

The hex encoded calldata

#### Defined in

[utils/calldata.ts:23](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/utils/calldata.ts#L23)

___

### tradeComparator

▸ **tradeComparator**\<`TInput`, `TOutput`, `TTradeType`\>(`a`, `b`): `number`

Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them

#### Type parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `TInput` | extends `Currency` | The input token, either Ether or an ERC-20 |
| `TOutput` | extends `Currency` | The output token, either Ether or an ERC-20 |
| `TTradeType` | extends `TradeType` | The trade type, either exact input or exact output |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `a` | [`Trade`](classes/Trade.md)\<`TInput`, `TOutput`, `TTradeType`\> | The first trade to compare |
| `b` | [`Trade`](classes/Trade.md)\<`TInput`, `TOutput`, `TTradeType`\> | The second trade to compare |

#### Returns

`number`

A sorted ordering for two neighboring elements in a trade array

#### Defined in

[entities/trade.ts:16](https://github.com/Uniswap/v3-sdk/blob/08a7c05/src/entities/trade.ts#L16)
</file>

<file path="docs/sdk/v3/_category_.json">
{
  "label": "v3 SDK",
  "position": 2,
  "collapsed": true
}
</file>

<file path="docs/sdk/v3/overview.md">
---
id: overview
sidebar_position: 1
title: Overview
---

The Uniswap v3 SDK provides abstractions to assist you with interacting with the Uniswap v3 smart contracts in a Typescript/Javascript environment (e.g. websites, node scripts). It makes uses of the [**Core SDK**](../core/overview.md) to gain access to abstractions that are common amongst the Uniswap SDKs. With the SDK, you can manipulate data that has been queried from the [EVM](https://ethereum.org/en/developers/docs/evm/) using libraries that assist with needs such as data modeling, protection from rounding errors, and compile time enforced typing.

To begin, we recommend looking at our [**Guides**](./guides/01-background.md) which include [runnable examples](https://github.com/Uniswap/examples/tree/main/v3-sdk) and walkthroughs of core usages. These guides will help you better understand how to use the SDK and integrate it into your application.

For complete documentation of the SDK's offerings, see the [**Technical Reference**](./reference/overview.md).

## Installation

To interact with the v3 SDK we recommend installing though npm:

```bash
npm i --save @uniswap/v3-sdk
npm i --save @uniswap/sdk-core
```

## Developer Links

- [**v3 SDK GitHub Repo**](https://github.com/Uniswap/v3-sdk)
- [**Core SDK GitHub Repo**](https://github.com/Uniswap/sdk-core)
- [**v3 SDK NPM Package**](https://www.npmjs.com/package/@uniswap/v3-sdk)

[![Unit Tests](https://github.com/Uniswap/uniswap-v3-sdk/workflows/Unit%20Tests/badge.svg)](https://github.com/Uniswap/uniswap-v3-sdk/actions?query=workflow%3A%22Unit+Tests%22)
[![Lint](https://github.com/Uniswap/uniswap-v3-sdk/workflows/Lint/badge.svg)](https://github.com/Uniswap/uniswap-v3-sdk/actions?query=workflow%3ALint)
[![npm version](https://img.shields.io/npm/v/@uniswap/v3-sdk/latest.svg)](https://www.npmjs.com/package/@uniswap/v3-sdk/v/latest)
[![npm bundle size (scoped version)](https://img.shields.io/bundlephobia/minzip/@uniswap/v3-sdk/latest.svg)](https://bundlephobia.com/result?p=@uniswap/v3-sdk@latest)
[![Discord](https://img.shields.io/badge/discord-join%20chat-blue.svg)](https://discord.com/channels/597638925346930701/607978109089611786)
</file>

<file path="docs/sdk/v4/guides/advanced/_category_.json">
{
  "label": "Advanced",
  "position": 6,
  "collapsed": true
}
</file>

<file path="docs/sdk/v4/guides/advanced/create-pool.md">
---
id: create-pool
title: Create Pool
sidebar_position: 2
---

## Introduction

In this example we will use **ethers.js** and the **Uniswap v4 SDK** to create pools on Uniswap v4. Uniswap v4 is a popular destination for creating markets due to its:

- Proven track record and battle-tested codebase
- Concentrated liquidity, unlocks capital efficiency
- Flexible pool design through dynamic fees and hooks
- Gas-efficient architecture
- Integrations with alternative trading venues

For more information, developers should see [Uniswap v4 Overview](/contracts/v4/overview)

For this guide, the following Uniswap packages are used:
  
- [`@uniswap/v4-sdk`](https://www.npmjs.com/package/@uniswap/v4-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

## Configuration

To initialize a Uniswap v4 Pool _without initial liquidity_, developers should call [`PoolManager.initialize()`](/contracts/v4/concepts/PoolManager)

Creating a pool without liquidity may be useful for "reserving" a pool for future use, when initial liquidity is not available, or when external market makers would provide the starting liquidity.

### Configure the Pool

We will first create an example configuration `CurrentConfig` in `config.ts`. It has the format:

```typescript
export const CurrentConfig: ExampleConfig = {
  env: Environment.MAINNET,
  rpc: {
    local: 'http://localhost:8545',
    mainnet: 'https://mainnet.infura.io/v3/YOUR_API_KEY',
  },
  ...
  poolKey: {
    currency0: currency0,
    currency1: currency1,
    fee: lpFee,
    tickSpacing: tickSpacing,
    hooks: HOOK_CONTRACT_ADDRESS,
  },
}
```

> For native token pairs (Ether), use `ADDRESS_ZERO` as `currency0`

[PoolKey](/contracts/v4/reference/core/types/PoolKey) uniquely identifies a pool

- _Currencies_ should be sorted, `uint160(currency0) < uint160(currency1)`
- _lpFee_ is the fee expressed in pips, i.e. 3000 = 0.30%
- _tickSpacing_ is the granularity of the pool. Lower values are more precise but may be more expensive to trade on
- _hookContract_ is the address of the hook contract

A note on `tickSpacing`:

Lower tick spacing provides improved price precision; however, smaller tick spaces will cause swaps to cross ticks more often, incurring higher gas costs.

## Call `initialize` of Pool Manager contract

Now to initialize the `Pool` we need to call the `initialize` function of the Pool Manager Contract.
To construct the Pool Manager Contract we need to provide the address of the contract, its ABI and a provider connected to an RPC endpoint.

```typescript
import { ethers } from 'ethers'
const POOL_MANAGER_ADDRESS = '0x000000000004444c5dc75cB358380D2e3dE08A90' // Replace with actual StateView contract address
const POOL_MANAGER_ABI = [...]; // Import or define the ABI for PoolManager contract

const provider = getProvider() // Provide the right RPC address for the chain
const signer = new ethers.Wallet(PRIVATE_KEY, provider)
const poolManager = new ethers.Contract(
    POOL_MANAGER_ADDRESS,
    POOL_MANAGER_ABI,
    signer
)
```

We get the `POOL_MANAGER_ADDRESS` for our chain from [Uniswap Deployments](/contracts/v4/deployments).

Pools are initialized with a starting price

```typescript
const result = await poolManager.initialize(
    CurrentConfig.poolKey,
    startingPrice
)
```

- the _startingPrice_ is expressed as sqrtPriceX96: `floor(sqrt(token1 / token0) * 2^96)`
  - i.e. `79228162514264337593543950336` is the starting price for a 1:1 pool

Now the pool is initialized and you can add liquidity to it.

## Important Note on Initial Liquidity

When creating a new pool, it's critical to understand that initializing a pool without liquidity can be dangerous. An empty pool's spot price is freely manipulatable since there is no liquidity to resist price movements.

This means that on the first liquidity provision, if proper slippage parameters are not set:

1. Malicious actors can manipulate the price before the first position is minted
2. The first position can be mispriced and have incorrect asset ratios

To safely add the first liquidity to a new pool:

- Always use appropriate slippage parameters when minting the first position
- Consider adding liquidity immediately after pool creation in the same transaction. Reference our [Mint Position guide](/sdk/v4/guides/liquidity/position-minting) for proper liquidity addition practices.
</file>

<file path="docs/sdk/v4/guides/advanced/pool-data.md">
---
id: pool-data
title: Fetching Pool Data
sidebar_position: 1
---

## Introduction

In this example we will use **ethers JS** and **ethers-multicall** to construct a `Pool` object that we can use in the following guides.

This guide will **cover**:

1. Computing the PoolId out of PoolKey
2. Referencing the StateView contract and fetching metadata
3. Fetching the positions of all initialized Ticks with multicall
4. Fetching all ticks by their indices with a multicall
5. Constructing the Pool object

At the end of the guide, we will have created a `Pool` Object that accurately represents the state of a v4 pool at the time we fetched it.

For this guide, the following Uniswap packages are used:
  
- [`@uniswap/v4-sdk`](https://www.npmjs.com/package/@uniswap/v4-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

We will also use the `ethers-multicall` npm package:

- [`ethers-multicall`](https://www.npmjs.com/package/ethers-multicall)

## Configuration

We will first create an example configuration `CurrentConfig` in `config.ts`. It has the format:

```typescript
export const CurrentConfig: ExampleConfig = {
  env: Environment.MAINNET,
  rpc: {
    local: 'http://localhost:8545',
    mainnet: 'https://mainnet.infura.io/v3/YOUR_API_KEY',
  },
  ...
  poolKey: {
    currency0: USDC_TOKEN.address,
    currency1: ETH_TOKEN.address,
    fee: FEE_AMOUNT_LOW,
    tickSpacing: TICK_SPACING_TEN,
    hooks: EMPTY_HOOK,
  },
}
```

The pool used is defined by a pair of tokens in `constants.ts`.
You can also change these two tokens and the other pool parameters in the config, just make sure a pool actually exists for your configuration.
Check out the top pools on [Uniswap](https://app.uniswap.org/explore/pools).

```typescript
export const ETH_TOKEN = new Token(
  SupportedChainId.MAINNET,
  '0x0000000000000000000000000000000000000000',
  18,
  'ETH',
  'Ether'
)

export const USDC_TOKEN = new Token(
  SupportedChainId.MAINNET,
  '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  6,
  'USDC',
  'USDC'
)
```

## Computing the PoolId out of PoolKey

In this example, we will construct the **USDC - ETH** Pool with **LOW** fees and without hooks. The SDK provides a method to compute the `PoolId` for this pool:

```typescript
import { Pool } from '@uniswap/v4-sdk';

const {currency0, currency1, fee, tickSpacing, hooks} = CurrentConfig.poolKey;
const poolId = Pool.getPoolId(currency0, currency1, fee, tickSpacing, hooks);

```

## Referencing the StateView contract and fetching metadata

Now that we have the `PoolId` of a **USDC - ETH** Pool, we need to call [StateView](/contracts/v4/guides/state-view) contract to get the pool state. In v4 you need to use `StateLibrary` to read pool state, but offchain systems—such as frontends or analytics services—require a deployed contract with view functions. This is where `StateView` comes in.
To construct the Contract we need to provide the address of the contract, its ABI and a provider connected to an RPC endpoint.

```typescript
import { ethers } from 'ethers'
const STATE_VIEW_ADDRESS = '0x7ffe42c4a5deea5b0fec41c94c136cf115597227'; // Replace with actual StateView contract address
const STATE_VIEW_ABI = [...]; // Import or define the ABI for StateView contract

const provider = getProvider() // Provide the right RPC address for the chain
const stateViewContract = new ethers.Contract(
    STATE_VIEW_ADDRESS,
    STATE_VIEW_ABI,
    provider
)
```

We get the `STATE_VIEW_ADDRESS` for our chain from [Uniswap Deployments](/contracts/v4/deployments).
Once we have set up our reference to the contract, we can proceed to access its methods. To construct our offchain representation of the Pool, we need to fetch its liquidity, sqrtPrice, currently active tick and the full Tick data.
We get the **liquidity**, **sqrtPrice** and **tick** directly from the blockchain by calling `getLiquidity()`and `getSlot0()` on the StateView contract:

```typescript
  const [slot0, liquidity] = await Promise.all([
    stateViewContract.getSlot0(poolId, {
      blockTag: blockNum,
    }),
    stateViewContract.getLiquidity(poolId, {
      blockTag: blockNum,
    }),
  ])
```

The [getSlot0 function](/contracts/v4/guides/state-view#getting-pool-state) represents the first (0th) storage slot of the pool and exposes multiple useful values in a single function:

- `sqrtPriceX96`: The current pool price in Q64.96 fixed-point format.
- `tick`: The current tick in which the pool is operating.
- `protocolFee` and `lpFee`: Fee parameters for protocol and LP fee tiers.

For our use case, we only need the `sqrtPriceX96` and the currently active `tick`.

## Fetching all Ticks

v4 pools use ticks to [concentrate liquidity](/concepts/protocol/concentrated-liquidity) in price ranges and allow for better pricing of trades.
Even though most Pools only have a couple of **initialized ticks**, it is possible that a pools liquidity is defined by thousands of **initialized ticks**.
In that case, it can be very expensive or slow to get all of them with normal RPC calls.

If you are not familiar with the concept of ticks, check out the [`introduction`](/concepts/protocol/concentrated-liquidity#ticks).

To access tick data, we will use the `getTickInfo` function of the State View contract:

```solidity
  function getTickInfo(PoolId poolId, int24 tick)
    external
    view
    returns (
        uint128 liquidityGross,
        int128 liquidityNet,
        uint256 feeGrowthOutside0X128,
        uint256 feeGrowthOutside1X128
    )
```

The `tick` parameter that we provide the function with is the **index** (memory position) of the Tick we are trying to fetch.
To get the indices of all initialized Ticks of the Pool, we can calculate them from the **tickBitmaps**.
To fetch a `tickBitmap` we use a `getTickBitmap` function of the State View contract:

```solidity
  function getTickBitmap(
      PoolId poolId,
      int16 wordPosition
  ) external view returns (uint256 tickBitmap)
```

A pool stores lots of bitmaps, each of which contain the status of 256 Ticks.
The parameter `int16 wordPosition` the function accepts is the position of the bitMap we want to fetch.
We can calculate all the position of bitMaps (or words as they are sometimes called) from the `tickSpacing` of the Pool, which is in turn dependant on the Fee tier.

So to summarise we need 4 steps to fetch all initialized ticks:

1. Calculate all bitMap positions from the tickSpacing of the Pool.
2. Fetch all bitMaps using their positions.
3. Calculate the memory positions of all Ticks from the bitMaps.
4. Fetch all Ticks by their memory position.

We will use multicalls for the fetch calls.

## Multicall

Multicall contracts **aggregate results** from multiple contract calls and therefore allow sending multiple contract calls in **one RPC request**.
This can improve the **speed** of fetching large amounts of data significantly and ensures that the data fetched is all from the **same block**.

We will use the Multicall2 contract by MakerDAO.
We use the `ethers-muticall` npm package to easily interact with the Contract.

## Calculating all bitMap positions

As mentioned, Uniswap v4 Pools store **bitmaps**, also called *words*, that represent the state of **256 initializable ticks** at a time.
The value at a bit of a word is 1 if the tick at this index is initialized and 0 if it isn't.
We can calculate the positions of initialized ticks from the **words** of the Pool.

All ticks of Uniswap v4 pools are between the indices `-887272` and `887272`.
We can calculate the minimum and maximum word from these indices and the Pool's tickSpacing:

```typescript
function tickToWord(tick: number): number {
  let compressed = Math.floor(tick / tickSpacing)
  if (tick < 0 && tick % tickSpacing !== 0) {
    compressed -= 1
  }
  return compressed >> 8
}

const minWord = tickToWord(-887272)
const maxWord = tickToWord(887272)
```

Ticks can only be initialized at indices that are **divisible by the tickSpacing**.
One word contains 256 ticks, so we can compress the ticks by right shifting 8 bit.

## Fetching bitMaps from their position

Knowing the positions of words, we can now fetch them using multicall.

First we initialize our multicall providers and State View Contract:

```typescript
import { ethers } from 'ethers'
import { Contract, Provider } from 'ethers-multicall'

const ethersProvider = new ethers.providers.JsonRpcProvider("YOUR_RPC_URL")
const multicallProvider = new Provider(ethersProvider)
await multicallProvider.init()

const stateViewContract = new Contract(STATE_VIEW_ADDRESS, STATE_VIEW_ABI)
```

The `multicallProvider` creates the multicall request and sends it via the ethers Provider.

Next we loop through all possible word positions and add a `getTickBitmap` call for each:

```typescript
let calls: any[] = []
let wordPosIndices: number[] = []
for (let i = minWord; i <= maxWord; i++) {
  wordPosIndices.push(i)
  calls.push(stateViewContract.getTickBitmap(poolId, i))
}
```

We also keep track of the word position indices to be able to loop through them in the same order we added the calls to the array.

We use the `multicallProvider.all()` function to send a multicall and map the results:

```typescript
const results: bigint[] = (await multicallProvider.all(calls)).map(
    (ethersResponse) => {
      return BigInt(ethersResponse.toString())
    }
  )
```

A great visualization of what the bitMaps look like can be found in the [Uniswap v3 development book](https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/](https://uniswapv3book.com/milestone_2/tick-bitmap-index.html):

<img src={require('./images/tickBitmap_cut.png').default} alt="TickBitmap" box-shadow="none"/>

We encourage anyone trying to get a deeper understanding of the Uniswap protocol to read the Book.

## Calculating the memory positions of all Ticks

Now that we fetched all **bitMaps**, we check which ticks are initialized and calculate the **tick position** from the **word index** and the **tickSpacing** of the pool.

We check if a tick is **initialized** inside the word by shifting a bit by the index we are looking at and performing a bitwise AND operation:

```typescript
const bit = 1n
const initialized = (bitmap & (bit << BigInt(i))) !== 0n
```

If the tick is **initialized**, we revert the compression from tick to word we made earlier by multiplying the word index with 256, which is the same as left shifting by 8 bit, adding the position we are currently at, and multiplying with the tickSpacing:

```typescript
const tickIndex = (ind * 256 + i) * tickSpacing
```

The whole loop looks like this:

```typescript
const tickIndices: number[] = []

  for (let j = 0; j < wordPosIndices.length; j++) {
    const ind = wordPosIndices[j]
    const bitmap = results[j]

    if (bitmap !== 0n) {
      for (let i = 0; i < 256; i++) {
        const bit = 1n
        const initialized = (bitmap & (bit << BigInt(i))) !== 0n
        if (initialized) {
          const tickIndex = (ind * 256 + i) * tickSpacing
          tickIndices.push(tickIndex)
        }
      }
    }
  }
```

We now have an array containing the indices of all initialized Ticks.

## Fetching all Ticks by their indices

We use the multicallProvider again to execute an aggregated read call for all tick indices.
We create an array of call Promises again and use `.all()` to make our multicall:

```typescript
const calls: any[] = []

for (const index of tickIndices) {
  calls.push(stateViewContract.getTickInfo(poolId, index))
}

const results = await multicallProvider.all(calls)
```

Again, the order of the results array is the same as the elements in **tickIndices**.

We are able to combine the **tickIndices** and **results** array to create an array of `Tick` objects:

```typescript
const allTicks: Tick[] = []

  for (let i = 0; i < tickIndices.length; i++) {
    const index = tickIndices[i]
    const ethersResponse = results[i]
    const tick = new Tick({
      index,
      liquidityGross: JSBI.BigInt(ethersResponse.liquidityGross.toString()),
      liquidityNet: JSBI.BigInt(ethersResponse.liquidityNet.toString()),
    })
    allTicks.push(tick)
  }
```

We need to parse the response from our RPC provider to JSBI values that the v4-sdk can work with.

## Constructing the Pool

We have everything to construct our `Pool` now:

```typescript
const usdcWethPool = new Pool(
    USDC,
    WETH,
    feeAmount,
    slot0.sqrtPriceX96,
    liquidity,
    slot0.tick,
    allTicks
)
```

With this fully initialized Pool, we can make accurate offchain calculations.
</file>

<file path="docs/sdk/v4/guides/liquidity/_category_.json">
{
  "label": "Position Management",
  "position": 5,
  "collapsed": true
}
</file>

<file path="docs/sdk/v4/guides/liquidity/add-remove-liquidity.md">
---
id: add-remove-liquidity
title: Adding and Removing Liquidity
sidebar_position: 4
---

## Introduction

This guide will cover:

1. **Setting up liquidity operations** – Preparing to add/remove liquidity from v4 positions, including fetching position details, handling native ETH vs ERC20 tokens, and configuring Permit2 for ERC20 token approvals.
2. **Adding liquidity to existing positions** – Using the v4 SDK to increase liquidity with `addCallParameters`, handling native ETH positions, and executing transactions via PositionManager multicall.
3. **Removing liquidity from positions** – Using `removeCallParameters` to decrease or fully exit positions, handling proportional withdrawals, and token collection.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v4-sdk`](https://www.npmjs.com/package/@uniswap/v4-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

## v4 Architecture and Key Changes

### Native ETH Handling

Unlike v3, Uniswap v4 has native support for ETH without wrapping to WETH. This requires special handling in the SDK:

```typescript
// ✅ Correct: Using Ether.onChain() for native ETH
const token0 = Ether.onChain(chainId)
```

### Position Manager Multicall

All v4 position operations use the `PositionManager` contract's `multicall` function with encoded action sequences:

```typescript
const { calldata, value } = V4PositionManager.addCallParameters(position, options)

await walletClient.writeContract({
  address: POSITION_MANAGER_ADDRESS,
  functionName: 'multicall',
  args: [[calldata]],
  value: BigInt(value),
})
```

## Adding Liquidity to Existing Positions

### Theory: IncreaseLiquidityOptions

When adding liquidity to existing positions, we use `IncreaseLiquidityOptions` which combines:

- `CommonOptions`: slippage, deadline, hookData
- `ModifyPositionSpecificOptions`: tokenId
- `CommonAddLiquidityOptions`: useNative, batchPermit

### Step 1: Fetch Position Details

```typescript
interface PositionDetails {
  tokenId: bigint
  tickLower: number
  tickUpper: number
  liquidity: bigint
  poolKey: {
    currency0: Address
    currency1: Address
    fee: number
    tickSpacing: number
    hooks: Address
  }
  token0: Currency // Can be Ether or Token
  token1: Token // Always Token in current implementation
  currentTick: number
  sqrtPriceX96: string
  poolLiquidity: string
}

async function getPositionDetails(tokenId: bigint): Promise<PositionDetails> {
  // Fetch position info from PositionManager
  const [poolKey, infoValue] = await publicClient.readContract({
    address: POSITION_MANAGER_ADDRESS,
    abi: POSITION_MANAGER_ABI,
    functionName: 'getPoolAndPositionInfo',
    args: [tokenId],
  })

  // Create proper Currency instances
  let token0: Currency
  if (isNativeETH(poolKey.currency0)) {
    token0 = Ether.onChain(chainId)
  } else {
    const decimals0 = await fetchTokenDecimals(poolKey.currency0)
    const symbol0 = await getTokenSymbol(poolKey.currency0)
    token0 = new Token(chainId, poolKey.currency0, decimals0, symbol0)
  }

  const token1 = new Token(chainId, poolKey.currency1, decimals1, symbol1)

  return {
    tokenId,
    tickLower: infoValue.tickLower,
    tickUpper: infoValue.tickUpper,
    liquidity: infoValue.liquidity,
    poolKey,
    token0,
    token1,
    // ... other fields
  }
}
```

### Step 2: Configure Permit2 (Recommended)

```typescript
const PERMIT2_TYPES = {
  PermitDetails: [
    { name: 'token', type: 'address' },
    { name: 'amount', type: 'uint160' },
    { name: 'expiration', type: 'uint48' },
    { name: 'nonce', type: 'uint48' },
  ],
  PermitBatch: [
    { name: 'details', type: 'PermitDetails[]' },
    { name: 'spender', type: 'address' },
    { name: 'sigDeadline', type: 'uint256' },
  ],
}

async function configurePermit2(positionDetails: EnhancedPositionDetails, deadline: number) {
  const permitDetails = []

  // Add token1 (always ERC20)
  const [, , nonce1] = await publicClient.readContract({
    address: PERMIT2_ADDRESS,
    abi: PERMIT2_ABI,
    functionName: 'allowance',
    args: [userAddress, positionDetails.token1.address, POSITION_MANAGER_ADDRESS],
  })

  permitDetails.push({
    token: positionDetails.token1.address,
    amount: (2n ** 160n - 1n).toString(),
    expiration: deadline.toString(),
    nonce: nonce1.toString(),
  })

  // Add token0 only if it's not native ETH
  if (!positionDetails.token0.isNative) {
    const [, , nonce0] = await publicClient.readContract({
      address: PERMIT2_ADDRESS,
      abi: PERMIT2_ABI,
      functionName: 'allowance',
      args: [userAddress, (positionDetails.token0 as Token).address, POSITION_MANAGER_ADDRESS],
    })

    permitDetails.push({
      token: (positionDetails.token0 as Token).address,
      amount: (2n ** 160n - 1n).toString(),
      expiration: deadline.toString(),
      nonce: nonce0.toString(),
    })
  }

  const permitData = {
    details: permitDetails,
    spender: POSITION_MANAGER_ADDRESS,
    sigDeadline: deadline.toString(),
  }

  // Sign Permit2 data
  const signature = await walletClient.signTypedData({
    account,
    domain: {
      name: 'Permit2',
      chainId,
      verifyingContract: PERMIT2_ADDRESS,
    },
    types: PERMIT2_TYPES,
    primaryType: 'PermitBatch',
    message: permitData,
  })

  return {
    owner: userAddress,
    permitBatch: permitData,
    signature,
  }
}
```

### Step 3: Create Position and Add Liquidity

```typescript
async function addLiquidityToPosition(
  positionDetails: EnhancedPositionDetails,
  amount0: string,
  amount1: string,
  slippageTolerance: number = 0.05
) {
  // Create Pool instance
  const pool = new Pool(
    positionDetails.token0,
    positionDetails.token1,
    positionDetails.poolKey.fee,
    positionDetails.poolKey.tickSpacing,
    positionDetails.poolKey.hooks,
    positionDetails.sqrtPriceX96,
    positionDetails.poolLiquidity,
    positionDetails.currentTick
  )

  // Create currency amounts
  const amount0Currency = CurrencyAmount.fromRawAmount(positionDetails.token0, amount0)
  const amount1Currency = CurrencyAmount.fromRawAmount(positionDetails.token1, amount1)

  // Create Position from amounts
  const position = Position.fromAmounts({
    pool,
    tickLower: positionDetails.tickLower,
    tickUpper: positionDetails.tickUpper,
    amount0: amount0Currency.quotient,
    amount1: amount1Currency.quotient,
    useFullPrecision: true,
  })

  // Configure options
  const slippagePct = new Percent(Math.floor(slippageTolerance * 100), 10_000)
  const deadline = Math.floor(Date.now() / 1000) + 1200 // 20 minutes

  const addOptions: AddLiquidityOptions = {
    // CommonOptions
    slippageTolerance: slippagePct,
    deadline: deadline.toString(),
    hookData: '0x',

    // ModifyPositionSpecificOptions
    tokenId: positionDetails.tokenId.toString(),

    // CommonAddLiquidityOptions
    ...(positionDetails.token0.isNative && { useNative: Ether.onChain(chainId) }),
    batchPermit: await configurePermit2(positionDetails, deadline),
  }

  // Generate calldata and execute
  const { calldata, value } = V4PositionManager.addCallParameters(position, addOptions)

  const txHash = await walletClient.writeContract({
    account,
    address: POSITION_MANAGER_ADDRESS,
    chain: unichain,
    abi: POSITION_MANAGER_ABI,
    functionName: 'multicall',
    args: [[calldata]],
    value: BigInt(value.toString()),
  })

  return { txHash, addedAmounts: { amount0, amount1 } }
}
```

## Removing Liquidity from Positions

### Theory: RemoveLiquidityOptions

When removing liquidity, we use `RemoveLiquidityOptions` which includes:

- `CommonOptions`: slippage, deadline, hookData
- `ModifyPositionSpecificOptions`: tokenId
- `RemoveLiquiditySpecificOptions`: liquidityPercentage, burnToken, permit

### Step 1: Calculate Liquidity to Remove

```typescript
function calculateLiquidityToRemove(
  currentLiquidity: bigint,
  percentageToRemove: number // 0.25 = 25%, 1.0 = 100%
): {
  liquidityToRemove: bigint
  liquidityPercentage: Percent
} {
  const liquidityToRemove = (currentLiquidity * BigInt(Math.floor(percentageToRemove * 10000))) / 10000n
  const liquidityPercentage = new Percent(Math.floor(percentageToRemove * 100), 100)

  return { liquidityToRemove, liquidityPercentage }
}
```

### Step 2: Remove Liquidity Implementation

```typescript
async function removeLiquidityFromPosition(
  positionDetails: EnhancedPositionDetails,
  percentageToRemove: number, // 0.25 = 25%, 1.0 = 100%
  slippageTolerance: number = 0.05,
  burnTokenIfEmpty: boolean = false
) {
  const { liquidityToRemove, liquidityPercentage } = calculateLiquidityToRemove(
    positionDetails.liquidity,
    percentageToRemove
  )

  // Create Pool instance
  const pool = new Pool(
    positionDetails.token0,
    positionDetails.token1,
    positionDetails.poolKey.fee,
    positionDetails.poolKey.tickSpacing,
    positionDetails.poolKey.hooks,
    positionDetails.sqrtPriceX96,
    positionDetails.poolLiquidity,
    positionDetails.currentTick
  )

  // Create Position instance with current liquidity
  const position = new Position({
    pool,
    tickLower: positionDetails.tickLower,
    tickUpper: positionDetails.tickUpper,
    liquidity: positionDetails.liquidity.toString(),
  })

  // Configure remove options
  const slippagePct = new Percent(Math.floor(slippageTolerance * 100), 10_000)
  const deadline = Math.floor(Date.now() / 1000) + 1200

  const removeOptions: RemoveLiquidityOptions = {
    // CommonOptions
    slippageTolerance: slippagePct,
    deadline: deadline.toString(),
    hookData: '0x',

    // ModifyPositionSpecificOptions
    tokenId: positionDetails.tokenId.toString(),

    // RemoveLiquiditySpecificOptions
    liquidityPercentage,
    burnToken: burnTokenIfEmpty && percentageToRemove === 1.0,
    // permit: optional NFT permit if transaction sender doesn't own the NFT
  }

  // Generate calldata and execute
  const { calldata, value } = V4PositionManager.removeCallParameters(position, removeOptions)

  const txHash = await walletClient.writeContract({
    account,
    address: POSITION_MANAGER_ADDRESS,
    chain: unichain,
    abi: POSITION_MANAGER_ABI,
    functionName: 'multicall',
    args: [[calldata]],
    value: BigInt(value.toString()),
  })

  return {
    txHash,
    removedLiquidity: liquidityToRemove,
    percentageRemoved: percentageToRemove,
    tokenBurned: burnTokenIfEmpty && percentageToRemove === 1.0,
  }
}
```

## Complete Example: Add/Remove Workflow

```typescript
async function completeAddRemoveWorkflow() {
  const tokenId = 123456n

  // 1. Fetch position details
  const positionDetails = await getPositionDetails(tokenId)
  console.log(`Position: ${positionDetails.token0.symbol}/${positionDetails.token1.symbol}`)

  // 2. Add liquidity
  const addResult = await addLiquidityToPosition(
    positionDetails,
    '1000000000000000', // 0.001 ETH
    '1000000', // 1 USDC
    0.05 // 5% slippage
  )
  console.log(`Added liquidity: ${addResult.txHash}`)

  // 3. Wait and verify
  await new Promise((resolve) => setTimeout(resolve, 5000))
  const updatedPosition = await getPositionDetails(tokenId)

  // 4. Remove 50% of liquidity
  const removeResult = await removeLiquidityFromPosition(
    updatedPosition,
    0.5, // 50%
    0.05, // 5% slippage
    false // don't burn token
  )
  console.log(`Removed 50% liquidity: ${removeResult.txHash}`)

  return { addResult, removeResult }
}
```
</file>

<file path="docs/sdk/v4/guides/liquidity/collecting-fees.md">
---
id: collect-fees
title: Collecting Fee
sidebar_position: 3
---

## Introduction

This guide will cover:

1. **Setting up our fee collection** – Preparing to collect fees from a v4 position, including fetching position details, computing the `poolId`, using `StateView` to read fee growth data, and calculating the unclaimed fees off-chain.
2. **Submitting our fee collection transaction** – Using the v4 SDK to create the transaction calldata (with `collectCallParameters`), executing the call (via a multicall on the PositionManager).

For this guide, the following Uniswap packages are used:

- [`@uniswap/v4-sdk`](https://www.npmjs.com/package/@uniswap/v4-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

## Fee Calculation Theory

In Uniswap v4, fees are not stored directly. Instead, fees must be calculated using **differential calculation** from cumulative values called `feeGrowthInside`.

### feeGrowthInside Concept

```text
feeGrowthInside = Cumulative fees generated in pool ÷ Active liquidity at that time
```

### Unclaimed Fees (Currently Collectible Fees)

```typescript
const Q128 = 2n ** 128n
unclaimedFees = ((feeGrowthCurrent - feeGrowthLast) * liquidity) / Q128
```

**Compute unclaimed fees off-chain using the v4 formula:**

- `feeGrowthInsideCurrentX128` (for token0 and token1): the total fee growth inside the range as of now.
- `feeGrowthInsideLastX128` (for token0 and token1): the fee growth inside the range at the last time the position's state was updated (recorded in the position info).
- `liquidity`: the amount of liquidity in the position.

**Implementation**:

```typescript
function calculateUnclaimedFeesV4(
  liquidity: bigint,
  feeGrowthInside0Current: bigint,
  feeGrowthInside1Current: bigint,
  feeGrowthInside0Last: bigint,
  feeGrowthInside1Last: bigint
): UnclaimedFees {
  const Q128 = 2n ** 128n

  // Overflow protection: return 0 if current is less than last
  const feeGrowthDelta0 =
    feeGrowthInside0Current >= feeGrowthInside0Last ? feeGrowthInside0Current - feeGrowthInside0Last : 0n

  const feeGrowthDelta1 =
    feeGrowthInside1Current >= feeGrowthInside1Last ? feeGrowthInside1Current - feeGrowthInside1Last : 0n

  return {
    token0Fees: (feeGrowthDelta0 * liquidity) / Q128,
    token1Fees: (feeGrowthDelta1 * liquidity) / Q128,
  }
}
```

### Lifetime Fees (Total Fees Since Position Creation)

```typescript
lifetimeFees = (feeGrowthCurrent * liquidity) / Q128
```

**Implementation**:

```typescript
function calculateLifetimeFeesV4(
  liquidity: bigint,
  feeGrowthInside0Current: bigint,
  feeGrowthInside1Current: bigint
): LifetimeFees {
  const Q128 = 2n ** 128n

  return {
    token0LifetimeFees: (feeGrowthInside0Current * liquidity) / Q128,
    token1LifetimeFees: (feeGrowthInside1Current * liquidity) / Q128,
  }
}
```

### 3. Collected Fees Estimate

**Calculation basis**:

```text
Total fees = Collected + Unclaimed
∴ Collected = Total fees - Unclaimed
```

## v4 Architecture and Required Changes

### Fee Accrual and Credit Changes

**Fee Accrual and Credit:** Uniswap v4 changes how fee accrual is handled when modifying liquidity. In v3, adding or removing liquidity didn't automatically claim fees – you had to call a separate `collect` function to pull out accrued fees. In v4, **accrued fees act like a credit** that is automatically applied or required depending on liquidity changes. Increasing a position's liquidity will **roll any unclaimed fees into the position's liquidity**, and decreasing liquidity will **automatically withdraw** the proportional unclaimed fees for that position. This means that partially removing liquidity in v4 will force-claim the fees earned by that liquidity portion. However, if you want to claim fees without changing liquidity, you can perform a liquidity change of zero (as we'll do in this guide).

### Why StateView is Required

In v4, all pools are managed by a single `PoolManager`, so direct access to pool contracts is not possible. Instead, data must be read through the `StateView` contract.

```typescript
// v4 approach (required)
await StateView.getPositionInfo(poolId, owner, tickLower, tickUpper, salt)
```

### salt

In v4, the same owner can have multiple positions in the same tick range. `salt` is used to identify them individually.

**Derive the salt for the position:** As noted, v4 positions include a `salt` to distinguish positions with identical range by the same owner. For positions created via the `PositionManager` (which holds ownership in the pool), the salt **is the NFT token ID, encoded as a 32-byte value**.

```typescript
// Use tokenId as salt (PositionManager standard)
const salt = `0x${tokenId.toString(16).padStart(64, '0')}`
```

## Code Implementation Flow

### Phase 1: Position Information Retrieval

### Step 1: Position List Retrieval

Retrieves the tokenIds for v4 positions owned by a specific address from a Subgraph.

### Step 2: Position Details Retrieval

```typescript
async function getPositionDetails(tokenId: bigint): Promise<PositionDetails> {
  const [poolKey, infoValue] = await publicClient.readContract({
    address: POSITION_MANAGER_ADDRESS,
    functionName: 'getPoolAndPositionInfo',
    args: [tokenId],
  })

  // poolId calculation
  const poolId = Pool.getPoolId(currency0, currency1, poolKey.fee, poolKey.tickSpacing, poolKey.hooks)
}
```

### Step 3: Stored Fee State Retrieval

```typescript
async function getStoredPositionInfoV4(positionDetails, tokenId, owner) {
  const salt = `0x${tokenId.toString(16).padStart(64, '0')}`
  const [liquidity, feeGrowthInside0Last, feeGrowthInside1Last] = await publicClient.readContract({
    address: STATE_VIEW_ADDRESS,
    functionName: 'getPositionInfo',
    args: [poolId, POSITION_MANAGER_ADDRESS, tickLower, tickUpper, salt],
  })
}
```

### Step 4: Current Fee Growth Values Retrieval

**Read the current fee growth in the pool for the position's range:** To compute how much fees are unclaimed, we need the **current** fee growth inside the range and compare it to the last snapshot. We could manually fetch global fee growth and subtract out-of-range values, but `StateView` provides a convenience: [`getFeeGrowthInside(poolId, tickLower, tickUpper)`](/contracts/v4/reference/periphery/interfaces/IStateView) will calculate the up-to-date fee growth inside that tick range for each token. This function reads the latest pool state (including global fee growth) and subtracts the parts outside the range. It accounts for any new trades that happened since the last snapshot.

```typescript
async function getCurrentFeeGrowthV4(positionDetails) {
  const [feeGrowthInside0X128, feeGrowthInside1X128] = await publicClient.readContract({
    address: STATE_VIEW_ADDRESS,
    functionName: 'getFeeGrowthInside',
    args: [poolId, tickLower, tickUpper],
  })
}
```

### Phase 2: Submitting Our Fee Collection Transaction

Collecting fees in v4 is done via the `PositionManager` contract's `modifyLiquidities` function with a specific sequence of actions. We will use the Uniswap v4 SDK to construct the required calldata and then send the transaction.

### Build the fee-collection calldata with collectCallParameters

The Uniswap v4 SDK provides a helper `V4PositionManager.collectCallParameters(...)` that produces the calldata for the necessary multicall to collect fees. Under the hood, this will encode two actions: a `DECREASE_LIQUIDITY` with `liquidity = 0` (and min amounts = 0) and a `TAKE_PAIR` to sweep both tokens to a recipient. We need to supply the SDK with our position details and our desired options. First, create a `Position` object for the position (this requires the pool info and position info we fetched):

```typescript
async function collectFeesViaMulticall(tokenId, userAddress) {
  // Create Position object using pool and position parameters
  const position = new Position({
    pool,
    tickLower: positionDetails.tickLower,
    tickUpper: positionDetails.tickUpper,
    liquidity: positionDetails.liquidity.toString(),
  })

  // Specify collect options
  const collectOptions = {
    tokenId: tokenId,
    recipient: userAddress,
    slippageTolerance,
    deadline,
    hookData,
  }

  // Generate command with v4 SDK
  const { calldata, value } = V4PositionManager.collectCallParameters(position, collectOptions)

  // Execute with multicall
  const txHash = await walletClient.writeContract({
    account,
    chain: unichain,
    address: POSITION_MANAGER_ADDRESS,
    abi: POSITION_MANAGER_ABI,
    functionName: 'multicall',
    args: [[calldata]],
    value: BigInt(value),
  })
}
```

Let's break this down: we created a `Position` object using the pool and position parameters. We then specify `collectOptions` including the NFT `tokenId`, a `recipient` address (fees will be sent to this address), and a `deadline`. Because fee collection is not really subject to price slippage, we can set slippage tolerance to 0 and simply expect whatever fees are available. The SDK's `collectCallParameters` returns an object with `calldata` (the encoded bytes to send to the PositionManager) and `value` (the ETH value to send with the transaction, if needed). In our case, `value` will typically be `0` because we are not providing any additional ETH; we are only withdrawing. (The `value` would be non-zero if one of the actions required sending ETH to the contract, e.g. if adding liquidity to an ETH pair.)

**Under the hood:** The `calldata` produced encodes exactly two actions in `modifyLiquidities`: `Actions.DECREASE_LIQUIDITY` followed by `Actions.TAKE_PAIR`. The first action includes our `tokenId` and zeros for liquidity and min amounts, and the second action includes the two token currencies and the recipient address. Using a zero liquidity decrease is a trick to trigger the pool to calculate fees owed without actually changing the liquidity. The `TAKE_PAIR` then instructs the contract to transfer both token0 and token1 fee amounts out to us. (If our pool involved native ETH, one of the `Currency` entries in this param will be `Currency.wrap(0)` as shown, which signals the contract to send ETH. No manual WETH unwrap is needed – v4 handles it natively.)

### Phase 3: Verify the Fees Were Collected

Once the transaction is mined, you'll want to confirm that the fees made it to the `recipient`. There are a few ways to verify:

### Check the Transaction Receipt Logs

For ERC-20 tokens, the fee amounts taken will appear as `Transfer` events from the pool or PositionManager contract to your address. Token contracts will emit these events when the PositionManager transfers the fees to you. You can parse the receipt for `Transfer` logs of `token0` and `token1`. The amounts in those events should match the fees we calculated (or be very close, allowing for rounding).

```typescript
async function verifyFeeCollection(receipt, userAddress, positionDetails, ethBalanceBefore) {
  // Search for ERC-20 Transfer events
  const transferSignature = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'
  const erc20Transfers = receipt.logs
    .filter(
      (log) =>
        log.topics[0] === transferSignature && log.topics[2]?.toLowerCase().includes(userAddress.slice(2).toLowerCase())
    )
    .map((log) => ({
      token: log.address as Address,
      amount: BigInt(log.data),
    }))
}
```

### Check Your Token Balances

You can simply measuring the balance change in your wallet before vs. after the call. For example, read your token balances (and ETH balance) prior to calling, then after the transaction confirm the increases. Because v4 might auto-wrap or unwrap ETH, if one of the tokens was ETH you should check your ETH balance difference. In ETH pools, no ERC-20 transfer event will fire for the ETH – the ETH will be sent directly to you (as an internal transfer), which is why checking the balance or the transaction's internal traces is necessary to confirm the amount.

```typescript
// Check native ETH balance changes
const hasNativeETH = isNativeETH(positionDetails.poolKey.currency0)

if (hasNativeETH) {
  const ethBalanceAfter = await publicClient.getBalance({ address: userAddress })
  const ethChange = ethBalanceAfter - ethBalanceBefore

  if (ethChange > 0n) {
    collectedFees.push({
      token: '0x0000000000000000000000000000000000000000',
      amount: ethChange,
    })
  }
}
```
</file>

<file path="docs/sdk/v4/guides/liquidity/fetching-positions.md">
---
id: position-fetching
title: Fetching Positions
sidebar_position: 2
---

## Introduction

This guide covers how to fetch and analyze liquidity positions in Uniswap v4 using the v4-sdk.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v4-sdk`](https://www.npmjs.com/package/@uniswap/v4-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

## Key Differences from v3

The v4 PositionManager does not implement ERC721Enumerable, so `tokenOfOwnerByIndex` is not available. This requires using the subgraph to discover position IDs. Additionally, v4 uses a packed data format for position information.

## Setup

```typescript
import { createPublicClient, http, Address, zeroAddress } from 'viem'
import { unichain } from 'viem/chains'
import request from 'graphql-request'

const POSITION_MANAGER_ADDRESS = '0x4529a01c7a0410167c5740c487a8de60232617bf' //unichain

const publicClient = createPublicClient({
  chain: unichain,
  transport: http(),
})
```

## Fetching Position IDs

```typescript
interface SubgraphPosition {
  id: string
  tokenId: string
  owner: string
}

const GET_POSITIONS_QUERY = `
  query GetPositions($owner: String!) {
    positions(where: { owner: $owner }) {
      tokenId
      owner
      id
    }
  }
`

const UNICHAIN_SUBGRAPH_URL =
  'https://gateway.thegraph.com/api/subgraphs/id/EoCvJ5tyMLMJcTnLQwWpjAtPdn74PcrZgzfcT5bYxNBH'

async function getPositionIds(owner: Address): Promise<bigint[]> {
  // You can explore queries at: https://thegraph.com/explorer/subgraphs/EoCvJ5tyMLMJcTnLQwWpjAtPdn74PcrZgzfcT5bYxNBH?view=Query&chain=arbitrum-one

  const headers = {
    Authorization: 'Bearer ' + process.env.GRAPH_KEY, // Get your API key from https://thegraph.com/studio/apikeys/
  }

  const response = await request<{ positions: SubgraphPosition[] }>(
    UNICHAIN_SUBGRAPH_URL,
    GET_POSITIONS_QUERY,
    { owner: owner.toLowerCase() },
    headers
  )

  return response.positions.map((p) => BigInt(p.tokenId))
}
```

## Decoding Packed Position Data

v4 stores position information in a packed format. Here's how to decode it:

```typescript
interface PackedPositionInfo {
  getTickUpper(): number
  getTickLower(): number
  hasSubscriber(): boolean
}

function decodePositionInfo(value: bigint): PackedPositionInfo {
  return {
    getTickUpper: () => {
      const raw = Number((value >> 32n) & 0xffffffn)
      return raw >= 0x800000 ? raw - 0x1000000 : raw
    },

    getTickLower: () => {
      const raw = Number((value >> 8n) & 0xffffffn)
      return raw >= 0x800000 ? raw - 0x1000000 : raw
    },

    hasSubscriber: () => (value & 0xffn) !== 0n,
  }
}
```

## Position Details Interface

```typescript
interface PositionDetails {
  tokenId: bigint
  tickLower: number
  tickUpper: number
  liquidity: bigint
  poolKey: {
    currency0: Address
    currency1: Address
    fee: number
    tickSpacing: number
    hooks: Address
  }
}
```

## Contract ABI

```typescript
const POSITION_MANAGER_ABI = [
  {
    name: 'getPoolAndPositionInfo',
    type: 'function',
    inputs: [{ name: 'tokenId', type: 'uint256' }],
    outputs: [
      {
        name: 'poolKey',
        type: 'tuple',
        components: [
          { name: 'currency0', type: 'address' },
          { name: 'currency1', type: 'address' },
          { name: 'fee', type: 'uint24' },
          { name: 'tickSpacing', type: 'int24' },
          { name: 'hooks', type: 'address' },
        ],
      },
      { name: 'info', type: 'uint256' },
    ],
  },
  {
    name: 'getPositionLiquidity',
    type: 'function',
    inputs: [{ name: 'tokenId', type: 'uint256' }],
    outputs: [{ name: 'liquidity', type: 'uint128' }],
  },
] as const
```

## Fetching Position Details

```typescript
async function getPositionDetails(tokenId: bigint): Promise<PositionDetails> {
  // Get pool key and packed position info
  // Get pool key and packed position info
  const [poolKey, infoValue] = (await publicClient.readContract({
    address: POSITION_MANAGER_ADDRESS,
    abi: POSITION_MANAGER_ABI,
    functionName: 'getPoolAndPositionInfo',
    args: [tokenId],
  })) as readonly [
    {
      currency0: Address
      currency1: Address
      fee: number
      tickSpacing: number
      hooks: Address
    },
    bigint
  ]

  // Get current liquidity
  const liquidity = (await publicClient.readContract({
    address: POSITION_MANAGER_ADDRESS,
    abi: POSITION_MANAGER_ABI,
    functionName: 'getPositionLiquidity',
    args: [tokenId],
  })) as bigint

  // Decode packed position info
  const positionInfo = decodePositionInfo(infoValue)

  return {
    tokenId,
    tickLower: positionInfo.getTickLower(),
    tickUpper: positionInfo.getTickUpper(),
    liquidity,
    poolKey,
  }
}
```

## Usage Example

```typescript
async function fetchUserPositions(userAddress: Address) {
  try {
    // Get position IDs from subgraph
    const tokenIds = await getPositionIds(userAddress)
    console.log(`Found ${tokenIds.length} positions on Unichain`)

    // Fetch details for each position
    for (const tokenId of tokenIds) {
      const details = await getPositionDetails(tokenId)

      console.log(`Position ${tokenId}:`)
      console.log(`  Token0: ${details.poolKey.currency0}`)
      console.log(`  Token1: ${details.poolKey.currency1}`)
      console.log(`  Fee: ${details.poolKey.fee / 10000}%`)
      console.log(`  Range: ${details.tickLower} to ${details.tickUpper}`)
      console.log(`  Liquidity: ${details.liquidity.toString()}`)
      console.log(`  Hooks: ${details.poolKey.hooks}`)
      console.log('---')
    }
  } catch (error) {
    console.error('Error:', error)
  }
}

// Example usage
fetchUserPositions('0xYourAddress' as Address)
```

## Resources

- [Uniswap v4 SDK](https://github.com/Uniswap/sdks/tree/main/sdks/v4-sdk)
- [Unichain Documentation](https://docs.unichain.org/)
</file>

<file path="docs/sdk/v4/guides/liquidity/minting-position.md">
---
id: position-minting
title: Minting a position
sidebar_position: 1
---

## Introduction

This guide will introduce us to liquidity positions in Uniswap v4 and present the v4-sdk classes and contracts used to interact with the protocol.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v3-sdk`](https://www.npmjs.com/package/@uniswap/v3-sdk)
- [`@uniswap/v4-sdk`](https://www.npmjs.com/package/@uniswap/v4-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

## Overview of Uniswap v4 Position Minting

Uniswap v4 introduces a new PositionManager contract and a corresponding v4 SDK to manage liquidity positions. Like v3, liquidity positions are represented as NFTs, but v4 uses a command-based interface for bundling actions (e.g., minting liquidity and transferring tokens) into a single transaction.

The v4 SDK provides high-level classes – Pool, Position, and v4PositionManager – to help construct these transactions in JavaScript/TypeScript. This guide explains how to create (mint) a new liquidity position using the Uniswap v4 SDK.

We will cover:

- Setting up a Pool and Position for minting
- Configuring MintOptions (all parameters, types, and defaults)
- Using v4PositionManager.addCallParameters to get transaction data

## Preparing Pool and Position Objects

Before minting, you need a Pool instance reflecting the current on-chain state and a Position defining your desired liquidity parameters:

### Step 1: Define Token Information

```typescript
import { Token, ChainId, Ether } from '@uniswap/sdk-core'

const ETH_NATIVE = Ether.onChain(ChainId.Mainnet)

const ETH_TOKEN = new Token(
  ChainId.MAINNET,
  '0x0000000000000000000000000000000000000000',
  18,
  'ETH',
  'Ether'
)

const USDC_TOKEN = new Token(
  ChainId.MAINNET,
  '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  6,
  'USDC',
  'USDC'
)
```

> **Note**: In v4, pools are identified by a PoolKey (which includes token0, token1, fee, tick spacing, and hook address). The SDK's Pool class helps manage these details. Ensure that the token order (token0 vs token1) and the hook address match the actual pool.

### Step 2: Fetch Pool State

Before creating a Pool instance, you need to fetch the current state from the blockchain:

```typescript
import { createPublicClient, http } from 'viem';
import { Pool } from '@uniswap/v4-sdk';

// Define constants for the function
// The STATE_VIEW_ADDRESS should be imported from your constants file
// or defined at the top of your file
const STATE_VIEW_ADDRESS = '0x86e8631a016f9068c3f085faf484ee3f5fdee8f2'; // Replace with actual StateView contract address
const STATE_VIEW_ABI = [...]; // Import or define the ABI for StateView contract
const CHAIN_ID = xxx; // Replace Chain id

// Create a viem client for reading blockchain data
const client = createPublicClient({
  chain: CHAIN_ID,
  transport: http()
});

// Define pool parameters
const fee = 500; // Fee tier (e.g., 500 = 0.05%)
const tickSpacing = 10; // Tick spacing for this fee tier
const hookAddress = '0x0000...'; // Hook address, if any (or zero address)

// Get the pool ID using SDK helper
const poolId = Pool.getPoolId(token0, token1, fee, tickSpacing, hookAddress);

// Fetch current pool state from the blockchain
const [slot0, liquidity] = await Promise.all([
  client.readContract({
    address: STATE_VIEW_ADDRESS,
    abi: STATE_VIEW_ABI,
    functionName: 'getSlot0',
    args: [poolId as `0x${string}`],
  }),
  client.readContract({
    address: STATE_VIEW_ADDRESS,
    abi: STATE_VIEW_ABI,
    functionName: 'getLiquidity',
    args: [poolId as `0x${string}`],
  }),
]);

// Extract relevant data
const sqrtPriceX96Current = slot0[0] as bigint;
const currentTick = slot0[1] as number;
const currentLiquidity = liquidity as bigint;

// Create Pool instance with the fetched data
const pool = new Pool(
  token0,
  token1,
  fee,
  tickSpacing,
  hookAddress, // Pass the hook address from above
  sqrtPriceX96Current.toString(), // Convert bigint to string for SDK
  currentLiquidity.toString(), // Convert bigint to string for SDK
  currentTick, // Current tick from slot0
);
```

### Step 3: Define Position Parameters

Now define the parameters for your liquidity position:

```typescript
import { nearestUsableTick } from "@uniswap/v3-sdk";

// Define position parameters
// These typically come from user input in your interface
const fullRange = false // Whether to create a full-range position
const tickRange = 500 // Tick range around current price (e.g., 5%)
const amountA = 1.0 // Amount of token A to deposit
const amountB = 1000.0 // Amount of token B to deposit

// Calculate tick boundaries based on user preferences
let tickLower: number
let tickUpper: number

if (fullRange) {
  // For full-range positions, use Uniswap's minimum and maximum allowed ticks
  const MIN_TICK = -887272
  const MAX_TICK = 887272

  // Get tick spacing from the pool (already fetched from blockchain)
  const poolTickSpacing = pool.tickSpacing

  // Round tickLower up (closer to the center)
  // The nearestUsableTick ensures the tick is aligned with tick spacing
  tickLower = nearestUsableTick(MIN_TICK, poolTickSpacing)

  // Round tickUpper down (closer to the center)
  tickUpper = nearestUsableTick(MAX_TICK, poolTickSpacing)
} else {
  // Calculate lower and upper ticks, ensuring they align with tick spacing
  tickLower = nearestUsableTick(currentTick - tickRangeAmount, tickSpacing)
  tickUpper = nearestUsableTick(currentTick + tickRangeAmount, tickSpacing)
}

// Convert human-readable amounts to token amounts with proper decimals
const amountADesired = BigInt(Math.floor(amountA * 10 ** ETH_TOKEN.decimals))
const amountBDesired = BigInt(Math.floor(amountB * 10 ** USDC_TOKEN.decimals))

// Ensure token amounts are in the correct order (token0, token1)
const amount0Desired = token0IsA ? amountADesired.toString() : amountBDesired.toString()
const amount1Desired = token0IsA ? amountBDesired.toString() : amountADesired.toString()
```

### Step 5: Create a Position

Use the SDK to create a Position object that represents your liquidity position:

```typescript
import { Position } from '@uniswap/v4-sdk'

// Create a position from the desired token amounts
// The SDK will calculate the maximum liquidity possible with these amounts
const position = Position.fromAmounts({
  pool,
  tickLower,
  tickUpper,
  amount0: amount0Desired,
  amount1: amount1Desired,
  useFullPrecision: true, // Use full precision for maximum accuracy
})

// You can now access useful information from the position:
// position.mintAmounts - The actual amounts needed to mint this position
// position.amount0 - The amount of token0 in the position
// position.amount1 - The amount of token1 in the position
// position.liquidity - The liquidity value of the position
console.log('Position liquidity:', position.liquidity.toString())
console.log('Token0 amount:', position.amount0.toExact())
console.log('Token1 amount:', position.amount1.toExact())
```

> **Alternative**: If you have a specific liquidity amount instead of token amounts, you could use:
>
> ```typescript
> const position = new Position({
>   pool,
>   tickLower,
>   tickUpper,
>   liquidity: '1000000000000000000', // Example liquidity amount
> })
> ```

## Understanding MintOptions and Its Parameters

Once the Position is defined, the next step is to prepare the MintOptions object. In Uniswap v4 SDK, MintOptions is a type alias that combines three sets of options: CommonOptions, CommonAddLiquidityOptions, and MintSpecificOptions. This structure covers generic transaction settings, options common to any "add liquidity" action, and options unique to minting a new position.

### MintOptions Parameters Explained

```typescript
// Import necessary types
import { Percent } from '@uniswap/sdk-core'
import { MintOptions } from '@uniswap/v4-sdk'

// Example code showing how to set up MintOptions
// These parameters typically come from user input or application state

// 1. slippageTolerance (required): Maximum allowed price movement
// Convert from a percentage (e.g., 0.5%) to a Percent object
// Here, 50 out of 10000 = 0.5%
const slippageTolerance = 0.5 // 0.5% slippage tolerance
const slippagePct = new Percent(Math.floor(slippageTolerance * 100), 10_000)

// 2. deadline (required): Transaction expiry timestamp in seconds
// Usually current time + some buffer (e.g., 20 minutes)
const deadlineSeconds = 20 * 60 // 20 minutes
const currentBlock = await publicClient.getBlock()
const currentBlockTimestamp = Number(currentBlock.timestamp)
const deadline = currentBlockTimestamp + deadlineSeconds

// 3. recipient (required): Address to receive the position NFT
// Typically the user's wallet address
const userAddress = '0xYourAddressHere' // Replace with actual user address

// Create the basic MintOptions object with required fields
const mintOptions: MintOptions = {
  recipient: userAddress,
  slippageTolerance: slippagePct,
  deadline: deadline.toString(),

  // 4. useNative (optional): Use native ETH
  useNative: ETH_TOKEN.isNative
    ? Ether.onChain(ETH_TOKEN.chainId)
    : USDC_TOKEN.isNative
    ? Ether.onChain(USDC_TOKEN.chainId)
    : undefined,

  // 5. batchPermit (optional): For gasless approvals via Permit2
  // We'll set this later if needed

  // 6. hookData (optional): Data for pool hooks
  // Only needed for pools with custom hooks
  hookData: '0x', // Default empty bytes

  // 7-8. For new pools only:
  // createPool: true, // Uncomment if creating a new pool
  // sqrtPriceX96: '1234567890123456789', // Initial price, required if createPool is true

  // 9. For migrations only:
  // migrate: false, // Normally omitted unless migrating from v3
}
```

| Parameter         | Type               | Description                                                 | Required           |
| ----------------- | ------------------ | ----------------------------------------------------------- | ------------------ |
| slippageTolerance | Percent            | Max price movement allowed (for min amount calc)            | Yes                |
| deadline          | BigintIsh          | Tx expiry timestamp (seconds)                               | Yes                |
| recipient         | string             | Address to receive the position NFT                         | Yes                |
| hookData          | string (bytes)     | Data for pool hook (if applicable)                          | No                 |
| useNative         | NativeCurrency     | Use native ETH instead of wrapped token if one is WETH      | No                 |
| batchPermit       | BatchPermitOptions | Permit2 parameters for gasless token approval               | No                 |
| createPool        | boolean            | Create & initialize pool if not existent                    | No (default false) |
| sqrtPriceX96      | BigintIsh          | Initial price (sqrtP) for new pool (required if createPool) | No                 |
| migrate           | boolean            | Mark as part of v3→v4 migration flow                        | No                 |

### Using Permit2 for Gasless Approvals (Optional)

The `batchPermit` option allows users to sign a message off-chain to grant token approval, avoiding separate approve transactions. Here's how to implement it:

```typescript
// Constants and imports needed for Permit2
import { getWalletAccount } from './your-wallet-helpers';

// Define necessary constants
const CONTRACTS = {
  PERMIT2: '0x000000000022D473030F116dDEE9F6B43aC78BA3', // Permit2 contract address
  POSITION_MANAGER: '0x4529a01c7a0410167c5740c487a8de60232617bf.', // Position Manager address (unichain)
};

const PERMIT2_ABI = [...]; // Import or define Permit2 ABI
const PERMIT2_TYPES = {
  PermitBatch: [
    { name: 'details', type: 'PermitDetails[]' },
    { name: 'spender', type: 'address' },
    { name: 'sigDeadline', type: 'uint256' }
  ],
  PermitDetails: [
    { name: 'token', type: 'address' },
    { name: 'amount', type: 'uint160' },
    { name: 'expiration', type: 'uint48' },
    { name: 'nonce', type: 'uint48' }
  ]
};

// Check if we should use Permit2 (application setting or user preference)
const usePermit2 = true; // This could be a user setting

if (usePermit2) {
  // Generate Permit2 data only for ERC20 tokens (not needed for native ETH)
  const permitDetails = [];

  // Process tokenA if it's not native
  if (!ETH_TOKEN.isNative) {
    // Get current nonce from Permit2 contract
    const [, , nonce] = (await publicClient.readContract({
      account: getWalletAccount(), // Your function to get the current wallet
      address: PERMIT2_ADDRESS,
      abi: PERMIT2_ABI,
      functionName: 'allowance',
      args: [userAddress, ETH_TOKEN.address, POSITION_MANAGER_ADDRESS],
    })) as [bigint, bigint, bigint];

    // Add permit details for this token
    // Max uint160 value is used as the amount for an unlimited allowance
    permitDetails.push({
      token: ETH_TOKEN.address,
      amount: (2n ** 160n - 1n).toString(), // Max uint160
      expiration: deadline.toString(),
      nonce: nonce.toString(),
    });
  }

  // Do the same for tokenB if it's not native
  if (!USDC_TOKEN.isNative) {
    const [, , nonce] = (await publicClient.readContract({
      account: getWalletAccount(),
      address: PERMIT2_ADDRESS,
      abi: PERMIT2_ABI,
      functionName: 'allowance',
      args: [userAddress, USDC_TOKEN.address, POSITION_MANAGER_ADDRESS],
    })) as [bigint, bigint, bigint];

    permitDetails.push({
      token: USDC_TOKEN.address,
      amount: (2n ** 160n - 1n).toString(),
      expiration: deadline.toString(),
      nonce: nonce.toString(),
    });
  }

  // If we have any tokens to permit, create and sign the permit message
  if (permitDetails.length > 0) {
    // Create permit data
    const permitData = {
      details: permitDetails,
      spender: POSITION_MANAGER_ADDRESS,
      sigDeadline: deadline.toString(),
    };

    // Sign the permit data with the user's wallet
    // This requires user interaction to approve the signature
    const signature = await walletClient.signTypedData({
      account,
      domain: {
        name: 'Permit2',
        chainId,
        verifyingContract: PERMIT2_ADDRESS,
      },
      types: PERMIT2_TYPES,
      primaryType: 'PermitBatch',
      message: permitData,
    });

    // Add the permit data and signature to our mint options
    mintOptions.batchPermit = {
      owner: userAddress,
      permitBatch: permitData,
      signature,
    };
  }
}
```

## Using v4PositionManager to Generate Mint Transaction

With a Position object and MintOptions prepared, we can now use the SDK to compute the calldata and value needed for the transaction:

```typescript
import { V4PositionManager } from '@uniswap/v4-sdk'

// Generate transaction parameters
// This produces the calldata and value needed for the blockchain transaction
const { calldata, value } = V4PositionManager.addCallParameters(position, mintOptions)

// Log the results (for debugging)
console.log('Calldata:', calldata)
console.log('Value:', value)
```

Under the hood, `addCallParameters` builds the necessary function calls to the PositionManager contract:

- It encodes a MINT_POSITION command with your position parameters (pool key, tickLower, tickUpper, liquidity) and a SETTLE_PAIR command to pull in the tokens.
- The slippageTolerance is applied to calculate amount0Max and amount1Max – these are the maximum token amounts the contract is allowed to take.
- If useNative was true, it would also append a SWEEP command for the native token. In case of solidity, please read this [report](https://reports.electisec.com/reports/04-2025-Sickle#2-high---uniswapv4connectoraddliquidity-does-not-reclaim-excess-eth) carefully.
- If batchPermit is provided, the SDK will prepend the permit call using the contract's multicall capability.

## Executing the Transaction with Viem

After obtaining calldata and value, you need to send the transaction to the blockchain:

```typescript
import { createWalletClient } from 'viem'

// Function to execute the mint transaction
async function executeTransaction() {
  try {
    // Send the transaction
    const txHash = await walletClient.writeContract({
      account,
      chain: chainId,
      address: POSITION_MANAGER_ADDRESS,
      abi: POSITION_MANAGER_ABI,
      functionName: 'multicall',
      args: [[calldata]],
      value: BigInt(value),
    })

    // Wait for transaction confirmation
    const receipt = await publicClient.waitForTransactionReceipt({
      hash: txHash,
    })
  } catch (error) {
    console.error('Transaction failed:', error)
  }
}
```

## Further Resources

- [Uniswap v4 SDK Repository](https://github.com/Uniswap/sdks/tree/main/sdks/v4-sdk)
- [Permit2 Documentation](/contracts/permit2/overview)
</file>

<file path="docs/sdk/v4/guides/swaps/_category_.json">
{
  "label": "Swaps",
  "position": 1,
  "collapsed": true
}
</file>

<file path="docs/sdk/v4/guides/swaps/multi-hop-swapping.md">
---
id: multi-hop-swapping
title: Executing Multi-Hop Swaps
sidebar_position: 3
---

## Introduction

This guide demonstrates how to execute multi-hop swaps on Uniswap V4, allowing you to trade between tokens that might not share a direct pool. Multi-hop swaps route through multiple pools to achieve the desired token exchange, often providing better pricing than attempting direct swaps through less liquid pools.

Building on our [single-hop swap guide](./single-hop-swapping.md), this guide will show you how to construct routing paths and execute them efficiently.

The guide will cover:

1. Constructing swap paths through multiple pools
2. Executing the multi-hop swap

At the end of this guide, you should be able to execute swaps between any two tokens using optimal routing through multiple pools.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v4-sdk`](https://www.npmjs.com/package/@uniswap/v4-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)
- [`@uniswap/universal-router-sdk`](https://www.npmjs.com/package/@uniswap/universal-router-sdk)

## Constructing swap paths through multiple pools

Let's first define a multi-hop swap configuration. In this example, we'll swap ETH → USDC → USDT. The configuration follows closely from the quoting and single-hop swapping guides.

```typescript
import { SwapExactIn, PoolKey } from '@uniswap/v4-sdk'
import { ETH_TOKEN, USDC_TOKEN, USDT_TOKEN } from './constants'

const ETH_USDC_POOL_KEY: PoolKey = {
    currency0: ETH_TOKEN.address,
    currency1: USDC_TOKEN.address,
    fee: 3000,
    tickSpacing: 60,
    hooks: "0x0000000000000000000000000000000000000000",
};

const USDC_USDT_POOL_KEY: PoolKey = {
    currency0: USDC_TOKEN.address,
    currency1: USDT_TOKEN.address,
    fee: 10,
    tickSpacing: 1,
    hooks: "0x0000000000000000000000000000000000000000",
};

export const CurrentConfig: SwapExactIn = {
    currencyIn: ETH_TOKEN.address,
    path: encodeMultihopExactInPath(
        [ETH_USDC_POOL_KEY, USDC_USDT_POOL_KEY],
        ETH_TOKEN.address
    ),
    amountIn: ethers.utils.parseUnits('1', ETH_TOKEN.decimals).toString(), 
    amountOutMinimum: "minAmountOut", // Change according to the slippage desired
}
```

Uniswap V4 uses a specific format for encoding multi-hop paths. Each hop in the path requires:

```typescript
type PathKey = {
    intermediateCurrency: string;
    fee: number;
    tickSpacing: number;
    hooks: string;
    hookData: string;
};
```

We can encode the path using a function like:

```typescript
export function encodeMultihopExactInPath(
  poolKeys: PoolKey[],
  currencyIn: string
): PathKey[] {
  const pathKeys: PathKey[] = []
  let currentCurrencyIn = currencyIn
  
  for (let i = 0; i < poolKeys.length; i++) {
    // Determine the output currency for this hop
    const currencyOut = currentCurrencyIn === poolKeys[i].currency0
      ? poolKeys[i].currency1
      : poolKeys[i].currency0
    
    // Create path key for this hop
    const pathKey: PathKey = {
      intermediateCurrency: currencyOut,
      fee: poolKeys[i].fee,
      tickSpacing: poolKeys[i].tickSpacing,
      hooks: poolKeys[i].hooks,
      hookData: '0x'
    }
    
    pathKeys.push(pathKey)
    currentCurrencyIn = currencyOut // Output becomes input for next hop
  }
  
  return pathKeys
}
```

## Executing the multi-hop swap

We'll use the same contract addresses and ABIs from the single-hop guide and construct the **ethers** `Contract` for them:

```typescript
const UNIVERSAL_ROUTER_ADDRESS = "0x66a9893cC07D91D95644AEDD05D03f95e1dBA8Af"
const PERMIT2_ADDRESS = "0x000000000022D473030F116dDEE9F6B43aC78BA3"

// ABIs remain the same as in single-hop guide
const UNIVERSAL_ROUTER_ABI = [/* ... */]
const ERC20_ABI = [/* ... */]
const PERMIT2_ABI = [/* ... */]
```

The main function for executing multi-hop swaps is very similar to the single-hop guide as well. The only difference is that the first action to the Universal Router is `SWAP_EXACT_IN` instead of `SWAP_EXACT_IN_SINGLE`.

```typescript
import { Actions, V4Planner } from '@uniswap/v4-sdk'
import { CommandType, RoutePlanner } from '@uniswap/universal-router-sdk'

const v4Planner = new V4Planner()
const routePlanner = new RoutePlanner()

const deadline = Math.floor(Date.now() / 1000) + 3600

v4Planner.addAction(Actions.SWAP_EXACT_IN, [CurrentConfig]);
v4Planner.addAction(Actions.SETTLE_ALL, [ETH_USDC_POOL_KEY.currency0, CurrentConfig.amountIn]);
v4Planner.addAction(Actions.TAKE_ALL, [USDC_USDT_POOL_KEY.currency1, CurrentConfig.amountOutMinimum]);

const encodedActions = v4Planner.finalize()

routePlanner.addCommand(CommandType.V4_SWAP, [v4Planner.actions, v4Planner.params])

// Only needed for native ETH as input currency swaps
const txOptions: any = {
    value: CurrentConfig.amountIn
}

const tx = await universalRouter.execute(
  routePlanner.commands,
  [encodedActions],
  deadline,
  txOptions
)

const receipt = await tx.wait()
console.log('Multi-hop swap completed! Transaction hash:', receipt.transactionHash)
```

The token approvals for ERC20 token swaps remain the same as the [single-hop swapping guide](./02-single-hop-swapping.md).

## Next Steps

Now that you're familiar with trading, consider checking out our next guides on [pooling liquidity](../liquidity/01-pool-data.md) to Uniswap!
</file>

<file path="docs/sdk/v4/guides/swaps/quoting.md">
---
id: quoting
title: Getting a Quote
sidebar_position: 1
---

## Introduction

This guide will cover how to get the current quotes for any token pair on the Uniswap protocol.

In this example we will use `quoteExactInputSingle` to get a quote for the pair **ETH - USDC**. The inputs are **poolKey**, **zeroForOne**, **exactAmount** and **hookData**.

The guide will cover:

1. Constructing the `PoolKey` and swap parameters
2. Referencing the `Quoter` contract and getting a quote

At the end of the guide, we should be able to fetch the output for the given token pair and input amount.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v4-sdk`](https://www.npmjs.com/package/@uniswap/v4-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)

## Constructing the PoolKey and Swap parameters

We will first create an example configuration `CurrentConfig` in `config.ts`. For this example, we are using the [0.05% ETH - USDC pool](https://app.uniswap.org/explore/pools/ethereum/0x21c67e77068de97969ba93d4aab21826d33ca12bb9f565d8496e8fda8a82ca27) which has the format:

```typescript
import { SwapExactInSingle } from '@uniswap/v4-sdk'
import { USDC_TOKEN, ETH_TOKEN } from './constants'
import { parseUnits, JsonRpcProvider, formatUnits } from 'ethers'

export const CurrentConfig: SwapExactInSingle = {
    poolKey: {
        currency0: ETH_TOKEN.address,
        currency1: USDC_TOKEN.address,
        fee: 500,
        tickSpacing: 10,
        hooks: "0x0000000000000000000000000000000000000000",
    },
    zeroForOne: true,
    amountIn: parseUnits('1', ETH_TOKEN.decimals).toString(), 
    amountOutMinimum: "0",
    hookData: '0x00'
}
```

The pool used is defined by a pair of tokens in `constants.ts`.
You can also change these two tokens and the other pool parameters in the config, just make sure a pool actually exists for your configuration.
Check out the top pools on [Uniswap](https://app.uniswap.org/#/pools).

```typescript
import { Token, ChainId } from '@uniswap/sdk-core'

export const ETH_TOKEN = new Token(
  ChainId.MAINNET,
  '0x0000000000000000000000000000000000000000',
  18,
  'ETH',
  'Ether'
)

export const USDC_TOKEN = new Token(
  ChainId.MAINNET,
  '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  6,
  'USDC',
  'USDC'
)
```

## Referencing the Quoter contract and getting a quote

To get quotes for trades, Uniswap has deployed a **Quoter Contract**. We will use this contract to fetch the output amount we can expect for our trade, without actually executing the trade.

Now, we need to construct an instance of an **ethers** `Contract` for our Quoter contract in order to interact with it:

```typescript
const quoterContract = new ethers.Contract(
  QUOTER_CONTRACT_ADDRESS,
  QUOTER_ABI, // Import or define the ABI for Quoter contract
  new JsonRpcProvider("RPC") // Provide the right RPC address for the chain
)
```

We get the `QUOTE_CONTRACT_ADDRESS` for our chain from [Uniswap Deployments](https://docs.uniswap.org/contracts/v4/deployments).

We can now use our Quoter contract to obtain the quote.

In an ideal world, the quoter functions would be `view` functions, which would make them very easy to query on-chain with minimal gas costs. However, the Uniswap V4 Quoter contracts rely on state-changing calls designed to be reverted to return the desired data. This means calling the quoter will be very expensive and **should not be called on-chain.**

To get around this difficulty, we can use the `callStatic` method provided by the **ethers.js** `Contract` instances.
This is a useful method that submits a state-changing transaction to an Ethereum node, but asks the node to simulate the state change, rather than to execute it. Our script can then return the result of the simulated state change:

```typescript
const quotedAmountOut = await quoterContract.callStatic.quoteExactInputSingle({
    poolKey: CurrentConfig.poolKey,
    zeroForOne: CurrentConfig.zeroForOne,
    exactAmount: CurrentConfig.amountIn, 
    hookData: CurrentConfig.hookData,
})

console.log(formatUnits(quotedAmountOut.amountOut, USDC_TOKEN.decimals));
```

The result of the call is the number of output tokens you would receive for the quoted swap.

It should be noted that `quoteExactInputSingle` is only 1 of 4 different methods that the quoter offers:

1. `quoteExactInputSingle` - given an input amount, produce a quote of the output amount for a swap on a single pool
2. `quoteExactInput` - given an input amount, produce a quote for the output amount a swap over multiple pools
3. `quoteExactOutputSingle` - given a desired output amount, produce a quote for the input amount on a swap over a single pool
4. `quoteExactOutput`  - given a desired output amount, produce a quote for the input amount in for a swap over multiple pools

If we want to trade two tokens that do not share a pool with each other, we will need to make swaps over multiple pools.
This is where the `quoteExactInput` and `quoteExactOutput` methods come in.

For the `exactOutput` and `exactOutputSingle` methods, we need to keep in mind that a pool can not give us more than the amount of Tokens it holds.
If we try to get a quote on an output of 100 ETH from a pool that only holds 50 ETH, the function call will fail.
</file>

<file path="docs/sdk/v4/guides/swaps/single-hop-swapping.md">
---
id: single-hop-swapping
title: Executing a Single-Hop Swap
sidebar_position: 2
---

## Introduction

This guide will build off our [quoting guide](./quoting.md) and show how to use a quote to construct and execute a trade on the Uniswap v4 protocol. In this example we will trade between two tokens: **ETH and USDC**.

The guide will cover:

1. Setting up swap parameters and pool configuration
2. Using Universal Router and executing a single-hop swap

At the end of this guide, you should be able to execute swaps between any two tokens using a single pool on Uniswap V4.

For this guide, the following Uniswap packages are used:

- [`@uniswap/v4-sdk`](https://www.npmjs.com/package/@uniswap/v4-sdk)
- [`@uniswap/sdk-core`](https://www.npmjs.com/package/@uniswap/sdk-core)
- [`@uniswap/universal-router-sdk`](https://www.npmjs.com/package/@uniswap/universal-router-sdk)

## Setting up Swap Configuration

First, let's define our swap configuration. We will use the same pool structure from the quoting guide:

```typescript
import { SwapExactInSingle } from '@uniswap/v4-sdk'
import { USDC_TOKEN, ETH_TOKEN } from './constants'

export const CurrentConfig: SwapExactInSingle = {
    poolKey: {
        currency0: ETH_TOKEN.address,
        currency1: USDC_TOKEN.address,
        fee: 500,
        tickSpacing: 10,
        hooks: "0x0000000000000000000000000000000000000000",
    },
    zeroForOne: true, // The direction of swap is ETH to USDC. Change it to 'false' for the reverse direction
    amountIn: ethers.utils.parseUnits('1', ETH_TOKEN.decimals).toString(), 
    amountOutMinimum: "minAmountOut", // Change according to the slippage desired
    hookData: '0x00'
}
```

Like the quoting guide, the pool used is defined by a pair of tokens in `constants.ts`. You can change these two tokens and the other pool parameters in the config as long as a pool actually exists for that configuration.

## Using Universal Router and executing a single-hop swap

The Universal Router is a flexible, gas-efficient contract designed to execute complex swap operations across various protocols, including Uniswap v4. It serves as an intermediary between users and the Uniswap v4 PoolManager, handling the intricacies of swap execution.

So, we construct an instance of an **ethers** `Contract` for the Universal Router contract in order to interact with it:

```typescript
const UNIVERSAL_ROUTER_ADDRESS = "0x66a9893cc07d91d95644aedd05d03f95e1dba8af" // Change the Universal Router address as per the chain

const UNIVERSAL_ROUTER_ABI = [
  {
    inputs: [
      { internalType: "bytes", name: "commands", type: "bytes" },
      { internalType: "bytes[]", name: "inputs", type: "bytes[]" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
    ],
    name: "execute",
    outputs: [],
    stateMutability: "payable",
    type: "function",
  },
]

const universalRouter = new ethers.Contract(
    UNIVERSAL_ROUTER_ADDRESS,
    UNIVERSAL_ROUTER_ABI,
    signer
)
```

We can get the `UNIVERSAL_ROUTER_ADDRESS` for our chain from [Uniswap Deployments](/contracts/v4/deployments).

A signer object can be created like this:

```typescript
const provider = new ethers.providers.JsonRpcProvider("RPC");
const signer = new ethers.Wallet(
  "YOUR PRIVATE KEY",
  provider
);
```

Now, let's implement the main function that handles the swap. When encoding a swap command for the Universal Router, we need to choose between two types of swaps:

- Exact Input Swaps: Use this swap-type when you know the exact amount of tokens you want to swap in, and you're willing to accept any amount of output tokens above your minimum. This is common when you want to sell a specific amount of tokens.
- Exact Output Swaps: Use this swap-type when you need a specific amount of output tokens, and you're willing to spend up to a maximum amount of input tokens. This is useful when you need to acquire a precise amount of tokens, for example, to repay a loan or meet a specific requirement.

We will be doing an Exact Input swap in this example.

```typescript
import { Actions, V4Planner } from '@uniswap/v4-sdk'
import { CommandType, RoutePlanner } from '@uniswap/universal-router-sdk'

const v4Planner = new V4Planner()
const routePlanner = new RoutePlanner()

// Set deadline (1 hour from now)
const deadline = Math.floor(Date.now() / 1000) + 3600

v4Planner.addAction(Actions.SWAP_EXACT_IN_SINGLE, [CurrentConfig]);
v4Planner.addAction(Actions.SETTLE_ALL, [CurrentConfig.poolKey.currency0, CurrentConfig.amountIn]);
v4Planner.addAction(Actions.TAKE_ALL, [CurrentConfig.poolKey.currency1, CurrentConfig.amountOutMinimum]);

const encodedActions = v4Planner.finalize()

routePlanner.addCommand(CommandType.V4_SWAP, [v4Planner.actions, v4Planner.params])

// Only needed for native ETH as input currency swaps
const txOptions: any = {
    value: CurrentConfig.amountIn
}

const tx = await universalRouter.execute(
    routePlanner.commands,
    [encodedActions],
    deadline,
    txOptions
)

const receipt = await tx.wait()
console.log('Swap completed! Transaction hash:', receipt.transactionHash)
```

The actions in the planner define the sequence of operations that will be performed in our v4 swap:

- `SWAP_EXACT_IN_SINGLE`: This action specifies that we want to perform an exact input swap using a single pool.
- `SETTLE_ALL`: This action ensures all input tokens involved in the swap are properly paid. This is part of v4's settlement pattern for handling token transfers.
- `TAKE_ALL`: This final action collects all output tokens after the swap is complete.

The sequence of these actions is important as they define the complete flow of our swap operation from start to finish. The input and output currencies should be exchanged for the `SETTLE_ALL` and `TAKE_ALL` actions if the direction of the swap is reversed.

The `V4_SWAP` command tells the Universal Router that we want to perform a swap on a Uniswap v4 pool.

## Handling Token Approvals for ERC20 Swaps

When swapping ERC20 tokens, we need to set up approvals through Permit2. So, we construct an instance of an **ethers** `Contract` for the Permit2 contract in order to interact with it:

```typescript
const permit2Contract = new ethers.Contract(
    PERMIT2_ADDRESS, 
    PERMIT2_ABI, 
    signer
)
```

Create a similar one for the ERC20 token contract. If enough allowances have not been provided or the deadline has expired, we first need to approve Permit2 as a spender on the ERC20 token and then approve the Universal Router on Permit2.

```typescript
const tx1 = await erc20Contract.approve(PERMIT2_ADDRESS, ethers.constants.MaxUint256)
const tx2 = await permit2Contract.approve(
  tokenAddress,
  UNIVERSAL_ROUTER_ADDRESS,
  ethers.BigNumber.from(2).pow(160).sub(1), // MAX_UINT160
  deadline
)
```

The rest of the swap process remains the same.

## Next Steps

Now that you understand single-hop swaps, you might want to explore [multi-hop swaps](./03-multi-hop-swapping.md) for trading between tokens without direct pools or enough liquidity.
</file>

<file path="docs/sdk/v4/guides/_category_.json">
{
  "label": "Guides",
  "position": 2,
  "collapsed": false
}
</file>

<file path="docs/sdk/v4/reference/classes/Hook.md">
[@uniswap/v4-sdk](../overview.md) / Hook

Defined in: [utils/hook.ts:40](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L40)

## Constructors

### new Hook()

> **new Hook**(): [`Hook`](Hook.md)

#### Returns

[`Hook`](Hook.md)

## Methods

### hasDonatePermissions()

> `static` **hasDonatePermissions**(`address`): `boolean`

Defined in: [utils/hook.ts:91](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L91)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `address` | `string` |

#### Returns

`boolean`

***

### hasInitializePermissions()

> `static` **hasInitializePermissions**(`address`): `boolean`

Defined in: [utils/hook.ts:66](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L66)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `address` | `string` |

#### Returns

`boolean`

***

### hasLiquidityPermissions()

> `static` **hasLiquidityPermissions**(`address`): `boolean`

Defined in: [utils/hook.ts:74](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L74)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `address` | `string` |

#### Returns

`boolean`

***

### hasPermission()

> `static` **hasPermission**(`address`, `hookOption`): `boolean`

Defined in: [utils/hook.ts:61](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L61)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `address` | `string` |
| `hookOption` | [`HookOptions`](../enumerations/HookOptions.md) |

#### Returns

`boolean`

***

### hasSwapPermissions()

> `static` **hasSwapPermissions**(`address`): `boolean`

Defined in: [utils/hook.ts:85](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L85)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `address` | `string` |

#### Returns

`boolean`

***

### permissions()

> `static` **permissions**(`address`): [`HookPermissions`](../overview.md#hookpermissions)

Defined in: [utils/hook.ts:41](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L41)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `address` | `string` |

#### Returns

[`HookPermissions`](../overview.md#hookpermissions)
</file>

<file path="docs/sdk/v4/reference/classes/Pool.md">
[@uniswap/v4-sdk](../overview.md) / Pool

Defined in: [entities/pool.ts:33](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L33)

Represents a V4 pool

## Constructors

### new Pool()

> **new Pool**(`currencyA`, `currencyB`, `fee`, `tickSpacing`, `hooks`, `sqrtRatioX96`, `liquidity`, `tickCurrent`, `ticks`): [`Pool`](Pool.md)

Defined in: [entities/pool.ts:103](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L103)

Construct a pool

#### Parameters

| Parameter | Type | Default value | Description |
| ------ | ------ | ------ | ------ |
| `currencyA` | `Currency` | `undefined` | One of the currencys in the pool |
| `currencyB` | `Currency` | `undefined` | The other currency in the pool |
| `fee` | `number` | `undefined` | The fee in hundredths of a bips of the input amount of every swap that is collected by the pool |
| `tickSpacing` | `number` | `undefined` | The tickSpacing of the pool |
| `hooks` | `string` | `undefined` | The address of the hook contract |
| `sqrtRatioX96` | `BigintIsh` | `undefined` | The sqrt of the current ratio of amounts of currency1 to currency0 |
| `liquidity` | `BigintIsh` | `undefined` | The current value of in range liquidity |
| `tickCurrent` | `number` | `undefined` | The current tick of the pool |
| `ticks` | `TickDataProvider` | (`Tick` | `TickConstructorArgs`)[] | `NO_TICK_DATA_PROVIDER_DEFAULT` | - |

#### Returns

[`Pool`](Pool.md)

## Properties

### currency0

> `readonly` **currency0**: `Currency`

Defined in: [entities/pool.ts:34](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L34)

***

### currency1

> `readonly` **currency1**: `Currency`

Defined in: [entities/pool.ts:35](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L35)

***

### fee

> `readonly` **fee**: `number`

Defined in: [entities/pool.ts:36](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L36)

***

### hooks

> `readonly` **hooks**: `string`

Defined in: [entities/pool.ts:39](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L39)

***

### liquidity

> `readonly` **liquidity**: `JSBI`

Defined in: [entities/pool.ts:40](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L40)

***

### poolId

> `readonly` **poolId**: `string`

Defined in: [entities/pool.ts:44](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L44)

***

### poolKey

> `readonly` **poolKey**: [`PoolKey`](../overview.md#poolkey)

Defined in: [entities/pool.ts:43](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L43)

***

### sqrtRatioX96

> `readonly` **sqrtRatioX96**: `JSBI`

Defined in: [entities/pool.ts:38](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L38)

***

### tickCurrent

> `readonly` **tickCurrent**: `number`

Defined in: [entities/pool.ts:41](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L41)

***

### tickDataProvider

> `readonly` **tickDataProvider**: `TickDataProvider`

Defined in: [entities/pool.ts:42](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L42)

***

### tickSpacing

> `readonly` **tickSpacing**: `number`

Defined in: [entities/pool.ts:37](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L37)

## Accessors

### chainId

#### Get Signature

> **get** **chainId**(): `number`

Defined in: [entities/pool.ts:214](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L214)

Returns the chain ID of the currencies in the pool.

##### Returns

`number`

***

### currency0Price

#### Get Signature

> **get** **currency0Price**(): `Price`\<`Currency`, `Currency`\>

Defined in: [entities/pool.ts:166](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L166)

Returns the current mid price of the pool in terms of currency0, i.e. the ratio of currency1 over currency0

##### Returns

`Price`\<`Currency`, `Currency`\>

***

### currency1Price

#### Get Signature

> **get** **currency1Price**(): `Price`\<`Currency`, `Currency`\>

Defined in: [entities/pool.ts:185](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L185)

Returns the current mid price of the pool in terms of currency1, i.e. the ratio of currency0 over currency1

##### Returns

`Price`\<`Currency`, `Currency`\>

***

### token0

#### Get Signature

> **get** **token0**(): `Currency`

Defined in: [entities/pool.ts:143](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L143)

backwards compatibility with v2/3 sdks

##### Returns

`Currency`

***

### token0Price

#### Get Signature

> **get** **token0Price**(): `Price`\<`Currency`, `Currency`\>

Defined in: [entities/pool.ts:178](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L178)

backwards compatibility with v2/3 sdks

##### Returns

`Price`\<`Currency`, `Currency`\>

***

### token1

#### Get Signature

> **get** **token1**(): `Currency`

Defined in: [entities/pool.ts:146](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L146)

##### Returns

`Currency`

***

### token1Price

#### Get Signature

> **get** **token1Price**(): `Price`\<`Currency`, `Currency`\>

Defined in: [entities/pool.ts:197](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L197)

backwards compatibility with v2/3 sdks

##### Returns

`Price`\<`Currency`, `Currency`\>

## Methods

### getInputAmount()

> **getInputAmount**(`outputAmount`, `sqrtPriceLimitX96`?): `Promise`\<[`CurrencyAmount`\<`Currency`\>, [`Pool`](Pool.md)]>

Defined in: [entities/pool.ts:257](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L257)

Given a desired output amount of a currency, return the computed input amount and a pool with state updated after the trade
Works only for vanilla hookless v3 pools, otherwise throws an error

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `outputAmount` | `CurrencyAmount`\<`Currency`\> | the output amount for which to quote the input amount |
| `sqrtPriceLimitX96`? | `JSBI` | The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap |

#### Returns

`Promise`\<[`CurrencyAmount`\<`Currency`\>, [`Pool`](Pool.md)]>

The input amount and the pool with updated state

***

### getOutputAmount()

> **getOutputAmount**(`inputAmount`, `sqrtPriceLimitX96`?): `Promise`\<[`CurrencyAmount`\<`Currency`\>, [`Pool`](Pool.md)]>

Defined in: [entities/pool.ts:219](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L219)

Works only for vanilla hookless v3 pools, otherwise throws an error

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `inputAmount` | `CurrencyAmount`\<`Currency`\> |
| `sqrtPriceLimitX96`? | `JSBI` |

#### Returns

`Promise`\<[`CurrencyAmount`\<`Currency`\>, [`Pool`](Pool.md)]>

***

### getPoolId()

> `static` **getPoolId**(`currencyA`, `currencyB`, `fee`, `tickSpacing`, `hooks`): `string`

Defined in: [entities/pool.ts:71](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L71)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `currencyA` | `Currency` |
| `currencyB` | `Currency` |
| `fee` | `number` |
| `tickSpacing` | `number` |
| `hooks` | `string` |

#### Returns

`string`

***

### getPoolKey()

> `static` **getPoolKey**(`currencyA`, `currencyB`, `fee`, `tickSpacing`, `hooks`): [`PoolKey`](../overview.md#poolkey)

Defined in: [entities/pool.ts:49](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L49)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `currencyA` | `Currency` |
| `currencyB` | `Currency` |
| `fee` | `number` |
| `tickSpacing` | `number` |
| `hooks` | `string` |

#### Returns

[`PoolKey`](../overview.md#poolkey)

***

### involvesCurrency()

> **involvesCurrency**(`currency`): `boolean`

Defined in: [entities/pool.ts:155](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L155)

Returns true if the currency is either currency0 or currency1

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `currency` | `Currency` | The currency to check |

#### Returns

`boolean`

True if currency is either currency0 or currency1

***

### involvesToken()

> **involvesToken**(`currency`): `boolean`

Defined in: [entities/pool.ts:159](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L159)

backwards compatibility with v2/3 sdks

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `currency` | `Currency` |

#### Returns

`boolean`

***

### priceOf()

> **priceOf**(`currency`): `Price`\<`Currency`, `Currency`\>

Defined in: [entities/pool.ts:206](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L206)

Return the price of the given currency in terms of the other currency in the pool.

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `currency` | `Currency` | The currency to return price of |

#### Returns

`Price`\<`Currency`, `Currency`\>

The price of the given currency, in terms of the other.
</file>

<file path="docs/sdk/v4/reference/classes/Position.md">
[@uniswap/v4-sdk](../overview.md) / Position

Defined in: [entities/position.ts:23](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L23)

Represents a position on a Uniswap V4 Pool

## Dev

Similar to the V3 implementation
- using Currency instead of Token
- keep in mind that Pool and liquidity must be fetched from the pool manager

## Constructors

### new Position()

> **new Position**(`__namedParameters`): [`Position`](Position.md)

Defined in: [entities/position.ts:41](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L41)

Constructs a position for a given pool with the given liquidity

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `__namedParameters` | `PositionConstructorArgs` |

#### Returns

[`Position`](Position.md)

## Properties

### liquidity

> `readonly` **liquidity**: `JSBI`

Defined in: [entities/position.ts:27](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L27)

***

### pool

> `readonly` **pool**: [`Pool`](Pool.md)

Defined in: [entities/position.ts:24](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L24)

***

### tickLower

> `readonly` **tickLower**: `number`

Defined in: [entities/position.ts:25](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L25)

***

### tickUpper

> `readonly` **tickUpper**: `number`

Defined in: [entities/position.ts:26](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L26)

## Accessors

### amount0

#### Get Signature

> **get** **amount0**(): `CurrencyAmount`\<`Currency`\>

Defined in: [entities/position.ts:69](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L69)

Returns the amount of token0 that this position's liquidity could be burned for at the current pool price

##### Returns

`CurrencyAmount`\<`Currency`\>

***

### amount1

#### Get Signature

> **get** **amount1**(): `CurrencyAmount`\<`Currency`\>

Defined in: [entities/position.ts:101](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L101)

Returns the amount of token1 that this position's liquidity could be burned for at the current pool price

##### Returns

`CurrencyAmount`\<`Currency`\>

***

### mintAmounts

#### Get Signature

> **get** **mintAmounts**(): `Readonly`\<\{ `amount0`: `JSBI`; `amount1`: `JSBI`; \}\>

Defined in: [entities/position.ts:272](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L272)

Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at
the current price for the pool

##### Returns

`Readonly`\<\{ `amount0`: `JSBI`; `amount1`: `JSBI`; \}\>

***

### token0PriceLower

#### Get Signature

> **get** **token0PriceLower**(): `Price`\<`Currency`, `Currency`\>

Defined in: [entities/position.ts:55](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L55)

Returns the price of token0 at the lower tick

##### Returns

`Price`\<`Currency`, `Currency`\>

***

### token0PriceUpper

#### Get Signature

> **get** **token0PriceUpper**(): `Price`\<`Currency`, `Currency`\>

Defined in: [entities/position.ts:62](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L62)

Returns the price of token0 at the upper tick

##### Returns

`Price`\<`Currency`, `Currency`\>

## Methods

### burnAmountsWithSlippage()

> **burnAmountsWithSlippage**(`slippageTolerance`): `Readonly`\<\{ `amount0`: `JSBI`; `amount1`: `JSBI`; \}\>

Defined in: [entities/position.ts:223](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L223)

Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the
position with the given slippage tolerance

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `slippageTolerance` | `Percent` | tolerance of unfavorable slippage from the current price |

#### Returns

`Readonly`\<\{ `amount0`: `JSBI`; `amount1`: `JSBI`; \}\>

The amounts, with slippage

***

### fromAmount0()

> `static` **fromAmount0**(`__namedParameters`): [`Position`](Position.md)

Defined in: [entities/position.ts:402](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L402)

Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `__namedParameters` | \{ `amount0`: `BigintIsh`; `pool`: [`Pool`](Pool.md); `tickLower`: `number`; `tickUpper`: `number`; `useFullPrecision`: `boolean`; \} |
| `__namedParameters.amount0` | `BigintIsh` |
| `__namedParameters.pool` | [`Pool`](Pool.md) |
| `__namedParameters.tickLower` | `number` |
| `__namedParameters.tickUpper` | `number` |
| `__namedParameters.useFullPrecision` | `boolean` |

#### Returns

[`Position`](Position.md)

The position

***

### fromAmount1()

> `static` **fromAmount1**(`__namedParameters`): [`Position`](Position.md)

Defined in: [entities/position.ts:426](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L426)

Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `__namedParameters` | \{ `amount1`: `BigintIsh`; `pool`: [`Pool`](Pool.md); `tickLower`: `number`; `tickUpper`: `number`; \} |
| `__namedParameters.amount1` | `BigintIsh` |
| `__namedParameters.pool` | [`Pool`](Pool.md) |
| `__namedParameters.tickLower` | `number` |
| `__namedParameters.tickUpper` | `number` |

#### Returns

[`Position`](Position.md)

The position

***

### fromAmounts()

> `static` **fromAmounts**(`__namedParameters`): [`Position`](Position.md)

Defined in: [entities/position.ts:360](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L360)

Computes the maximum amount of liquidity received for a given amount of token0, token1,
and the prices at the tick boundaries.

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `__namedParameters` | \{ `amount0`: `BigintIsh`; `amount1`: `BigintIsh`; `pool`: [`Pool`](Pool.md); `tickLower`: `number`; `tickUpper`: `number`; `useFullPrecision`: `boolean`; \} |
| `__namedParameters.amount0` | `BigintIsh` |
| `__namedParameters.amount1` | `BigintIsh` |
| `__namedParameters.pool` | [`Pool`](Pool.md) |
| `__namedParameters.tickLower` | `number` |
| `__namedParameters.tickUpper` | `number` |
| `__namedParameters.useFullPrecision` | `boolean` |

#### Returns

[`Position`](Position.md)

The amount of liquidity for the position

***

### mintAmountsWithSlippage()

> **mintAmountsWithSlippage**(`slippageTolerance`): `Readonly`\<\{ `amount0`: `JSBI`; `amount1`: `JSBI`; \}\>

Defined in: [entities/position.ts:159](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L159)

Returns the maximum amount of token0 and token1 that must be sent in order to safely mint the amount of liquidity held by the position
with the given slippage tolerance

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `slippageTolerance` | `Percent` | Tolerance of unfavorable slippage from the current price |

#### Returns

`Readonly`\<\{ `amount0`: `JSBI`; `amount1`: `JSBI`; \}\>

The amounts, with slippage

#### Dev

In v4, minting and increasing is protected by maximum amounts of token0 and token1.

***

### permitBatchData()

> **permitBatchData**(`slippageTolerance`, `spender`, `nonce`, `deadline`): [`AllowanceTransferPermitBatch`](../interfaces/AllowanceTransferPermitBatch.md)

Defined in: [entities/position.ts:321](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/position.ts#L321)

Returns the AllowanceTransferPermitBatch for adding liquidity to a position

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `slippageTolerance` | `Percent` | The amount by which the price can 'slip' before the transaction will revert |
| `spender` | `string` | The spender of the permit (should usually be the PositionManager) |
| `nonce` | `BigintIsh` | A valid permit2 nonce |
| `deadline` | `BigintIsh` | The deadline for the permit |

#### Returns

[`AllowanceTransferPermitBatch`](../interfaces/AllowanceTransferPermitBatch.md)
</file>

<file path="docs/sdk/v4/reference/classes/Route.md">
[@uniswap/v4-sdk](../overview.md) / Route

Defined in: [entities/route.ts:12](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/route.ts#L12)

Represents a list of pools through which a swap can occur

## Type Parameters

| Type Parameter | Description |
| ------ | ------ |
| `TInput` *extends* `Currency` | The input currency |
| `TOutput` *extends* `Currency` | The output currency |

## Constructors

### new Route()

> **new Route**\<`TInput`, `TOutput`\>(`pools`, `input`, `output`): [`Route`](Route.md)\<`TInput`, `TOutput`\>

Defined in: [entities/route.ts:28](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/route.ts#L28)

Creates an instance of route.

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `pools` | [`Pool`](Pool.md)[] | An array of `Pool` objects, ordered by the route the swap will take |
| `input` | `TInput` | The input currency |
| `output` | `TOutput` | The output currency |

#### Returns

[`Route`](Route.md)\<`TInput`, `TOutput`\>

## Properties

### currencyPath

> `readonly` **currencyPath**: `Currency`[]

Defined in: [entities/route.ts:14](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/route.ts#L14)

***

### input

> `readonly` **input**: `TInput`

Defined in: [entities/route.ts:15](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/route.ts#L15)

***

### output

> `readonly` **output**: `TOutput`

Defined in: [entities/route.ts:16](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/route.ts#L16)

***

### pathInput

> `readonly` **pathInput**: `Currency`

Defined in: [entities/route.ts:17](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/route.ts#L17)

***

### pathOutput

> `readonly` **pathOutput**: `Currency`

Defined in: [entities/route.ts:18](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/route.ts#L18)

***

### pools

> `readonly` **pools**: [`Pool`](Pool.md)[]

Defined in: [entities/route.ts:13](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/route.ts#L13)

## Accessors

### chainId

#### Get Signature

> **get** **chainId**(): `number`

Defined in: [entities/route.ts:58](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/route.ts#L58)

##### Returns

`number`

***

### midPrice

#### Get Signature

> **get** **midPrice**(): `Price`\<`TInput`, `TOutput`\>

Defined in: [entities/route.ts:65](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/route.ts#L65)

Returns the mid price of the route

##### Returns

`Price`\<`TInput`, `TOutput`\>
</file>

<file path="docs/sdk/v4/reference/classes/Trade.md">
[@uniswap/v4-sdk](../overview.md) / Trade

Defined in: [entities/trade.ts:66](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L66)

Represents a trade executed against a set of routes where some percentage of the input is
split across each route.

Each route has its own set of pools. Pools can not be re-used across routes.

Does not account for slippage, i.e., changes in price environment that can occur between
the time the trade is submitted and when it is executed.

## Type Parameters

| Type Parameter | Description |
| ------ | ------ |
| `TInput` *extends* `Currency` | The input currency, either Ether or an ERC-20 |
| `TOutput` *extends* `Currency` | The output currency, either Ether or an ERC-20 |
| `TTradeType` *extends* `TradeType` | The trade type, either exact input or exact output |

## Properties

### swaps

> `readonly` **swaps**: `object`[]

Defined in: [entities/trade.ts:83](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L83)

The swaps of the trade, i.e. which routes and how much is swapped in each that
make up the trade.

#### inputAmount

> **inputAmount**: `CurrencyAmount`\<`TInput`\>

#### outputAmount

> **outputAmount**: `CurrencyAmount`\<`TOutput`\>

#### route

> **route**: [`Route`](Route.md)\<`TInput`, `TOutput`\>

***

### tradeType

> `readonly` **tradeType**: `TTradeType`

Defined in: [entities/trade.ts:92](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L92)

The type of the trade, either exact in or exact out.

## Accessors

### executionPrice

#### Get Signature

> **get** **executionPrice**(): `Price`\<`TInput`, `TOutput`\>

Defined in: [entities/trade.ts:149](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L149)

The price expressed in terms of output amount/input amount.

##### Returns

`Price`\<`TInput`, `TOutput`\>

***

### inputAmount

#### Get Signature

> **get** **inputAmount**(): `CurrencyAmount`\<`TInput`\>

Defined in: [entities/trade.ts:103](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L103)

The input amount for the trade assuming no slippage.

##### Returns

`CurrencyAmount`\<`TInput`\>

***

### outputAmount

#### Get Signature

> **get** **outputAmount**(): `CurrencyAmount`\<`TOutput`\>

Defined in: [entities/trade.ts:126](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L126)

The output amount for the trade assuming no slippage.

##### Returns

`CurrencyAmount`\<`TOutput`\>

***

### priceImpact

#### Get Signature

> **get** **priceImpact**(): `Percent`

Defined in: [entities/trade.ts:170](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L170)

Returns the percent difference between the route's mid price and the price impact

##### Returns

`Percent`

***

### route

#### Get Signature

> **get** **route**(): [`Route`](Route.md)\<`TInput`, `TOutput`\>

Defined in: [entities/trade.ts:74](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L74)

##### Deprecated

Deprecated in favor of 'swaps' property. If the trade consists of multiple routes
this will return an error.

When the trade consists of just a single route, this returns the route of the trade,
i.e. which pools the trade goes through.

##### Returns

[`Route`](Route.md)\<`TInput`, `TOutput`\>

## Methods

### bestTradeExactIn()

> `static` **bestTradeExactIn**\<`TInput`, `TOutput`\>(`pools`, `currencyAmountIn`, `currencyOut`, `__namedParameters`, `currentPools`, `nextAmountIn`, `bestTrades`): `Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_INPUT`\>[]>

Defined in: [entities/trade.ts:454](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L454)

Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input currency
amount to an output currency, making at most `maxHops` hops.
Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting
the amount in among multiple routes.

#### Type Parameters

| Type Parameter |
| ------ |
| `TInput` *extends* `Currency` |
| `TOutput` *extends* `Currency` |

#### Parameters

| Parameter | Type | Default value | Description |
| ------ | ------ | ------ | ------ |
| `pools` | [`Pool`](Pool.md)[] | `undefined` | the pools to consider in finding the best trade |
| `currencyAmountIn` | `CurrencyAmount`\<`TInput`\> | `undefined` | used in recursion; the original value of the currencyAmountIn parameter |
| `currencyOut` | `TOutput` | `undefined` | the desired currency out |
| `__namedParameters` | [`BestTradeOptions`](../interfaces/BestTradeOptions.md) | `{}` | - |
| `currentPools` | [`Pool`](Pool.md)[] | `[]` | used in recursion; the current list of pools |
| `nextAmountIn` | `CurrencyAmount`\<`Currency`\> | `currencyAmountIn` | exact amount of input currency to spend |
| `bestTrades` | [`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_INPUT`\>[] | `[]` | used in recursion; the current list of best trades |

#### Returns

`Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_INPUT`\>[]>

The exact in trade

***

### bestTradeExactOut()

> `static` **bestTradeExactOut**\<`TInput`, `TOutput`\>(`pools`, `currencyIn`, `currencyAmountOut`, `__namedParameters`, `currentPools`, `nextAmountOut`, `bestTrades`): `Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_OUTPUT`\>[]>

Defined in: [entities/trade.ts:533](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L533)

similar to the above method but instead targets a fixed output amount
given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input currency
to an output currency amount, making at most `maxHops` hops
note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting
the amount in among multiple routes.

#### Type Parameters

| Type Parameter |
| ------ |
| `TInput` *extends* `Currency` |
| `TOutput` *extends* `Currency` |

#### Parameters

| Parameter | Type | Default value | Description |
| ------ | ------ | ------ | ------ |
| `pools` | [`Pool`](Pool.md)[] | `undefined` | the pools to consider in finding the best trade |
| `currencyIn` | `TInput` | `undefined` | the currency to spend |
| `currencyAmountOut` | `CurrencyAmount`\<`TOutput`\> | `undefined` | the desired currency amount out |
| `__namedParameters` | [`BestTradeOptions`](../interfaces/BestTradeOptions.md) | `{}` | - |
| `currentPools` | [`Pool`](Pool.md)[] | `[]` | used in recursion; the current list of pools |
| `nextAmountOut` | `CurrencyAmount`\<`Currency`\> | `currencyAmountOut` | the exact amount of currency out |
| `bestTrades` | [`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_OUTPUT`\>[] | `[]` | used in recursion; the current list of best trades |

#### Returns

`Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_OUTPUT`\>[]>

The exact out trade

***

### createUncheckedTrade()

> `static` **createUncheckedTrade**\<`TInput`, `TOutput`, `TTradeType`\>(`constructorArguments`): [`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>

Defined in: [entities/trade.ts:305](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L305)

Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade
elsewhere and do not have any tick data

#### Type Parameters

| Type Parameter | Description |
| ------ | ------ |
| `TInput` *extends* `Currency` | The input currency, either Ether or an ERC-20 |
| `TOutput` *extends* `Currency` | The output currency, either Ether or an ERC-20 |
| `TTradeType` *extends* `TradeType` | The type of the trade, either exact in or exact out |

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `constructorArguments` | \{ `inputAmount`: `CurrencyAmount`\<`TInput`\>; `outputAmount`: `CurrencyAmount`\<`TOutput`\>; `route`: [`Route`](Route.md)\<`TInput`, `TOutput`\>; `tradeType`: `TTradeType`; \} | The arguments passed to the trade constructor |
| `constructorArguments.inputAmount` | `CurrencyAmount`\<`TInput`\> | - |
| `constructorArguments.outputAmount` | `CurrencyAmount`\<`TOutput`\> | - |
| `constructorArguments.route` | [`Route`](Route.md)\<`TInput`, `TOutput`\> | - |
| `constructorArguments.tradeType` | `TTradeType` | - |

#### Returns

[`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>

The unchecked trade

***

### createUncheckedTradeWithMultipleRoutes()

> `static` **createUncheckedTradeWithMultipleRoutes**\<`TInput`, `TOutput`, `TTradeType`\>(`constructorArguments`): [`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>

Defined in: [entities/trade.ts:336](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L336)

Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade
elsewhere and do not have any tick data

#### Type Parameters

| Type Parameter | Description |
| ------ | ------ |
| `TInput` *extends* `Currency` | The input currency, either Ether or an ERC-20 |
| `TOutput` *extends* `Currency` | The output currency, either Ether or an ERC-20 |
| `TTradeType` *extends* `TradeType` | The type of the trade, either exact in or exact out |

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `constructorArguments` | \{ `routes`: `object`[]; `tradeType`: `TTradeType`; \} | The arguments passed to the trade constructor |
| `constructorArguments.routes` | `object`[] | - |
| `constructorArguments.tradeType` | `TTradeType` | - |

#### Returns

[`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>

The unchecked trade

***

### exactIn()

> `static` **exactIn**\<`TInput`, `TOutput`\>(`route`, `amountIn`): `Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_INPUT`\>>

Defined in: [entities/trade.ts:195](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L195)

Constructs an exact in trade with the given amount in and route

#### Type Parameters

| Type Parameter | Description |
| ------ | ------ |
| `TInput` *extends* `Currency` | The input currency, either Ether or an ERC-20 |
| `TOutput` *extends* `Currency` | The output currency, either Ether or an ERC-20 |

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `route` | [`Route`](Route.md)\<`TInput`, `TOutput`\> | The route of the exact in trade |
| `amountIn` | `CurrencyAmount`\<`TInput`\> | The amount being passed in |

#### Returns

`Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_INPUT`\>>

The exact in trade

***

### exactOut()

> `static` **exactOut**\<`TInput`, `TOutput`\>(`route`, `amountOut`): `Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_OUTPUT`\>>

Defined in: [entities/trade.ts:210](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L210)

Constructs an exact out trade with the given amount out and route

#### Type Parameters

| Type Parameter | Description |
| ------ | ------ |
| `TInput` *extends* `Currency` | The input currency, either Ether or an ERC-20 |
| `TOutput` *extends* `Currency` | The output currency, either Ether or an ERC-20 |

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `route` | [`Route`](Route.md)\<`TInput`, `TOutput`\> | The route of the exact out trade |
| `amountOut` | `CurrencyAmount`\<`TOutput`\> | The amount returned by the trade |

#### Returns

`Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `EXACT_OUTPUT`\>>

The exact out trade

***

### fromRoute()

> `static` **fromRoute**\<`TInput`, `TOutput`, `TTradeType`\>(`route`, `amount`, `tradeType`): `Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>>

Defined in: [entities/trade.ts:227](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L227)

Constructs a trade by simulating swaps through the given route

#### Type Parameters

| Type Parameter | Description |
| ------ | ------ |
| `TInput` *extends* `Currency` | The input currency, either Ether or an ERC-20. |
| `TOutput` *extends* `Currency` | The output currency, either Ether or an ERC-20. |
| `TTradeType` *extends* `TradeType` | The type of the trade, either exact in or exact out. |

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `route` | [`Route`](Route.md)\<`TInput`, `TOutput`\> | route to swap through |
| `amount` | `TTradeType` *extends* `EXACT_INPUT` ? `CurrencyAmount`\<`TInput`\> : `CurrencyAmount`\<`TOutput`\> | the amount specified, either input or output, depending on tradeType |
| `tradeType` | `TTradeType` | whether the trade is an exact input or exact output swap |

#### Returns

`Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>>

The route

***

### fromRoutes()

> `static` **fromRoutes**\<`TInput`, `TOutput`, `TTradeType`\>(`routes`, `tradeType`): `Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>>

Defined in: [entities/trade.ts:272](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L272)

Constructs a trade from routes by simulating swaps

#### Type Parameters

| Type Parameter | Description |
| ------ | ------ |
| `TInput` *extends* `Currency` | The input currency, either Ether or an ERC-20. |
| `TOutput` *extends* `Currency` | The output currency, either Ether or an ERC-20. |
| `TTradeType` *extends* `TradeType` | The type of the trade, either exact in or exact out. |

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `routes` | `object`[] | the routes to swap through and how much of the amount should be routed through each |
| `tradeType` | `TTradeType` | whether the trade is an exact input or exact output swap |

#### Returns

`Promise`\<[`Trade`](Trade.md)\<`TInput`, `TOutput`, `TTradeType`\>>

The trade

***

### maximumAmountIn()

> **maximumAmountIn**(`slippageTolerance`, `amountIn`): `CurrencyAmount`\<`TInput`\>

Defined in: [entities/trade.ts:415](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L415)

Get the maximum amount in that can be spent via this trade for the given slippage tolerance

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `slippageTolerance` | `Percent` | The tolerance of unfavorable slippage from the execution price of this trade |
| `amountIn` | `CurrencyAmount`\<`TInput`\> | - |

#### Returns

`CurrencyAmount`\<`TInput`\>

The amount in

***

### minimumAmountOut()

> **minimumAmountOut**(`slippageTolerance`, `amountOut`): `CurrencyAmount`\<`TOutput`\>

Defined in: [entities/trade.ts:397](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L397)

Get the minimum amount that must be received from this trade for the given slippage tolerance

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `slippageTolerance` | `Percent` | The tolerance of unfavorable slippage from the execution price of this trade |
| `amountOut` | `CurrencyAmount`\<`TOutput`\> | - |

#### Returns

`CurrencyAmount`\<`TOutput`\>

The amount out

***

### worstExecutionPrice()

> **worstExecutionPrice**(`slippageTolerance`): `Price`\<`TInput`, `TOutput`\>

Defined in: [entities/trade.ts:430](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L430)

Return the execution price after accounting for slippage tolerance

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `slippageTolerance` | `Percent` | the allowed tolerated slippage |

#### Returns

`Price`\<`TInput`, `TOutput`\>

The execution price
</file>

<file path="docs/sdk/v4/reference/classes/V4BaseActionsParser.md">
[@uniswap/v4-sdk](../overview.md) / V4BaseActionsParser

Defined in: [utils/v4BaseActionsParser.ts:52](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4BaseActionsParser.ts#L52)

## Constructors

### new V4BaseActionsParser()

> **new V4BaseActionsParser**(): [`V4BaseActionsParser`](V4BaseActionsParser.md)

#### Returns

[`V4BaseActionsParser`](V4BaseActionsParser.md)

## Methods

### parseCalldata()

> `static` **parseCalldata**(`calldata`): [`V4RouterCall`](../overview.md#v4routercall)

Defined in: [utils/v4BaseActionsParser.ts:53](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4BaseActionsParser.ts#L53)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `calldata` | `string` |

#### Returns

[`V4RouterCall`](../overview.md#v4routercall)
</file>

<file path="docs/sdk/v4/reference/classes/V4Planner.md">
[@uniswap/v4-sdk](../overview.md) / V4Planner

Defined in: [utils/v4Planner.ts:167](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L167)

## Extended by

- [`V4PositionPlanner`](V4PositionPlanner.md)

## Constructors

### new V4Planner()

> **new V4Planner**(): [`V4Planner`](V4Planner.md)

Defined in: [utils/v4Planner.ts:171](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L171)

#### Returns

[`V4Planner`](V4Planner.md)

## Properties

### actions

> **actions**: `string`

Defined in: [utils/v4Planner.ts:168](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L168)

***

### params

> **params**: `string`[]

Defined in: [utils/v4Planner.ts:169](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L169)

## Methods

### addAction()

> **addAction**(`type`, `parameters`): [`V4Planner`](V4Planner.md)

Defined in: [utils/v4Planner.ts:176](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L176)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `type` | [`Actions`](../enumerations/Actions.md) |
| `parameters` | `any`[] |

#### Returns

[`V4Planner`](V4Planner.md)

***

### addSettle()

> **addSettle**(`currency`, `payerIsUser`, `amount`?): [`V4Planner`](V4Planner.md)

Defined in: [utils/v4Planner.ts:213](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L213)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `currency` | `Currency` |
| `payerIsUser` | `boolean` |
| `amount`? | `BigNumber` |

#### Returns

[`V4Planner`](V4Planner.md)

***

### addTake()

> **addTake**(`currency`, `recipient`, `amount`?): [`V4Planner`](V4Planner.md)

Defined in: [utils/v4Planner.ts:218](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L218)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `currency` | `Currency` |
| `recipient` | `string` |
| `amount`? | `BigNumber` |

#### Returns

[`V4Planner`](V4Planner.md)

***

### addTrade()

> **addTrade**(`trade`, `slippageTolerance`?): [`V4Planner`](V4Planner.md)

Defined in: [utils/v4Planner.ts:183](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L183)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `trade` | [`Trade`](Trade.md)\<`Currency`, `Currency`, `TradeType`\> |
| `slippageTolerance`? | `Percent` |

#### Returns

[`V4Planner`](V4Planner.md)

***

### finalize()

> **finalize**(): `string`

Defined in: [utils/v4Planner.ts:224](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L224)

#### Returns

`string`
</file>

<file path="docs/sdk/v4/reference/classes/V4PositionManager.md">
[@uniswap/v4-sdk](../overview.md) / V4PositionManager

Defined in: [PositionManager.ts:206](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L206)

## Properties

### INTERFACE

> `static` **INTERFACE**: `Interface`

Defined in: [PositionManager.ts:207](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L207)

## Methods

### addCallParameters()

> `static` **addCallParameters**(`position`, `options`): [`MethodParameters`](../interfaces/MethodParameters.md)

Defined in: [PositionManager.ts:224](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L224)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `position` | [`Position`](Position.md) |
| `options` | [`AddLiquidityOptions`](../overview.md#addliquidityoptions) |

#### Returns

[`MethodParameters`](../interfaces/MethodParameters.md)

***

### collectCallParameters()

> `static` **collectCallParameters**(`position`, `options`): [`MethodParameters`](../interfaces/MethodParameters.md)

Defined in: [PositionManager.ts:387](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L387)

Produces the calldata for collecting fees from a position

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `position` | [`Position`](Position.md) | The position to collect fees from |
| `options` | [`CollectOptions`](../overview.md#collectoptions) | Additional information necessary for generating the calldata |

#### Returns

[`MethodParameters`](../interfaces/MethodParameters.md)

The call parameters

***

### createCallParameters()

> `static` **createCallParameters**(`poolKey`, `sqrtPriceX96`): [`MethodParameters`](../interfaces/MethodParameters.md)

Defined in: [PositionManager.ts:217](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L217)

Public methods to encode method parameters for different actions on the PositionManager contract

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `poolKey` | [`PoolKey`](../overview.md#poolkey) |
| `sqrtPriceX96` | `BigintIsh` |

#### Returns

[`MethodParameters`](../interfaces/MethodParameters.md)

***

### encodeERC721Permit()

> `static` **encodeERC721Permit**(`spender`, `tokenId`, `deadline`, `nonce`, `signature`): `string`

Defined in: [PositionManager.ts:435](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L435)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `spender` | `string` |
| `tokenId` | `BigintIsh` |
| `deadline` | `BigintIsh` |
| `nonce` | `BigintIsh` |
| `signature` | `string` |

#### Returns

`string`

***

### encodeModifyLiquidities()

> `static` **encodeModifyLiquidities**(`unlockData`, `deadline`): `string`

Defined in: [PositionManager.ts:421](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L421)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `unlockData` | `string` |
| `deadline` | `BigintIsh` |

#### Returns

`string`

***

### encodePermitBatch()

> `static` **encodePermitBatch**(`owner`, `permitBatch`, `signature`): `string`

Defined in: [PositionManager.ts:426](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L426)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `owner` | `string` |
| `permitBatch` | [`AllowanceTransferPermitBatch`](../interfaces/AllowanceTransferPermitBatch.md) |
| `signature` | `string` |

#### Returns

`string`

***

### getPermitData()

> `static` **getPermitData**(`permit`, `positionManagerAddress`, `chainId`): [`NFTPermitData`](../interfaces/NFTPermitData.md)

Defined in: [PositionManager.ts:452](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L452)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `permit` | [`NFTPermitValues`](../interfaces/NFTPermitValues.md) |
| `positionManagerAddress` | `string` |
| `chainId` | `number` |

#### Returns

[`NFTPermitData`](../interfaces/NFTPermitData.md)

***

### removeCallParameters()

> `static` **removeCallParameters**(`position`, `options`): [`MethodParameters`](../interfaces/MethodParameters.md)

Defined in: [PositionManager.ts:314](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L314)

Produces the calldata for completely or partially exiting a position

#### Parameters

| Parameter | Type | Description |
| ------ | ------ | ------ |
| `position` | [`Position`](Position.md) | The position to exit |
| `options` | [`RemoveLiquidityOptions`](../overview.md#removeliquidityoptions) | Additional information necessary for generating the calldata |

#### Returns

[`MethodParameters`](../interfaces/MethodParameters.md)

The call parameters
</file>

<file path="docs/sdk/v4/reference/classes/V4PositionPlanner.md">
[@uniswap/v4-sdk](../overview.md) / V4PositionPlanner

Defined in: [utils/v4PositionPlanner.ts:8](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4PositionPlanner.ts#L8)

## Extends

- [`V4Planner`](V4Planner.md)

## Constructors

### new V4PositionPlanner()

> **new V4PositionPlanner**(): [`V4PositionPlanner`](V4PositionPlanner.md)

Defined in: [utils/v4Planner.ts:171](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L171)

#### Returns

[`V4PositionPlanner`](V4PositionPlanner.md)

#### Inherited from

[`V4Planner`](V4Planner.md).[`constructor`](V4Planner.md#constructors)

## Properties

### actions

> **actions**: `string`

Defined in: [utils/v4Planner.ts:168](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L168)

#### Inherited from

[`V4Planner`](V4Planner.md).[`actions`](V4Planner.md#actions)

***

### params

> **params**: `string`[]

Defined in: [utils/v4Planner.ts:169](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L169)

#### Inherited from

[`V4Planner`](V4Planner.md).[`params`](V4Planner.md#params)

## Methods

### addAction()

> **addAction**(`type`, `parameters`): [`V4Planner`](V4Planner.md)

Defined in: [utils/v4Planner.ts:176](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L176)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `type` | [`Actions`](../enumerations/Actions.md) |
| `parameters` | `any`[] |

#### Returns

[`V4Planner`](V4Planner.md)

#### Inherited from

[`V4Planner`](V4Planner.md).[`addAction`](V4Planner.md#addaction)

***

### addBurn()

> **addBurn**(`tokenId`, `amount0Min`, `amount1Min`, `hookData`): `void`

Defined in: [utils/v4PositionPlanner.ts:58](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4PositionPlanner.ts#L58)

#### Parameters

| Parameter | Type | Default value |
| ------ | ------ | ------ |
| `tokenId` | `BigintIsh` | `undefined` |
| `amount0Min` | `BigintIsh` | `undefined` |
| `amount1Min` | `BigintIsh` | `undefined` |
| `hookData` | `string` | `EMPTY_BYTES` |

#### Returns

`void`

***

### addDecrease()

> **addDecrease**(`tokenId`, `liquidity`, `amount0Min`, `amount1Min`, `hookData`): `void`

Defined in: [utils/v4PositionPlanner.ts:46](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4PositionPlanner.ts#L46)

#### Parameters

| Parameter | Type | Default value |
| ------ | ------ | ------ |
| `tokenId` | `BigintIsh` | `undefined` |
| `liquidity` | `BigintIsh` | `undefined` |
| `amount0Min` | `BigintIsh` | `undefined` |
| `amount1Min` | `BigintIsh` | `undefined` |
| `hookData` | `string` | `EMPTY_BYTES` |

#### Returns

`void`

***

### addIncrease()

> **addIncrease**(`tokenId`, `liquidity`, `amount0Max`, `amount1Max`, `hookData`): `void`

Defined in: [utils/v4PositionPlanner.ts:34](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4PositionPlanner.ts#L34)

#### Parameters

| Parameter | Type | Default value |
| ------ | ------ | ------ |
| `tokenId` | `BigintIsh` | `undefined` |
| `liquidity` | `BigintIsh` | `undefined` |
| `amount0Max` | `BigintIsh` | `undefined` |
| `amount1Max` | `BigintIsh` | `undefined` |
| `hookData` | `string` | `EMPTY_BYTES` |

#### Returns

`void`

***

### addMint()

> **addMint**(`pool`, `tickLower`, `tickUpper`, `liquidity`, `amount0Max`, `amount1Max`, `owner`, `hookData`): `void`

Defined in: [utils/v4PositionPlanner.ts:10](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4PositionPlanner.ts#L10)

#### Parameters

| Parameter | Type | Default value |
| ------ | ------ | ------ |
| `pool` | [`Pool`](Pool.md) | `undefined` |
| `tickLower` | `number` | `undefined` |
| `tickUpper` | `number` | `undefined` |
| `liquidity` | `BigintIsh` | `undefined` |
| `amount0Max` | `BigintIsh` | `undefined` |
| `amount1Max` | `BigintIsh` | `undefined` |
| `owner` | `string` | `undefined` |
| `hookData` | `string` | `EMPTY_BYTES` |

#### Returns

`void`

***

### addSettle()

> **addSettle**(`currency`, `payerIsUser`, `amount`?): [`V4Planner`](V4Planner.md)

Defined in: [utils/v4Planner.ts:213](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L213)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `currency` | `Currency` |
| `payerIsUser` | `boolean` |
| `amount`? | `BigNumber` |

#### Returns

[`V4Planner`](V4Planner.md)

#### Inherited from

[`V4Planner`](V4Planner.md).[`addSettle`](V4Planner.md#addsettle)

***

### addSettlePair()

> **addSettlePair**(`currency0`, `currency1`): `void`

Defined in: [utils/v4PositionPlanner.ts:64](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4PositionPlanner.ts#L64)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `currency0` | `Currency` |
| `currency1` | `Currency` |

#### Returns

`void`

***

### addSweep()

> **addSweep**(`currency`, `to`): `void`

Defined in: [utils/v4PositionPlanner.ts:76](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4PositionPlanner.ts#L76)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `currency` | `Currency` |
| `to` | `string` |

#### Returns

`void`

***

### addTake()

> **addTake**(`currency`, `recipient`, `amount`?): [`V4Planner`](V4Planner.md)

Defined in: [utils/v4Planner.ts:218](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L218)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `currency` | `Currency` |
| `recipient` | `string` |
| `amount`? | `BigNumber` |

#### Returns

[`V4Planner`](V4Planner.md)

#### Inherited from

[`V4Planner`](V4Planner.md).[`addTake`](V4Planner.md#addtake)

***

### addTakePair()

> **addTakePair**(`currency0`, `currency1`, `recipient`): `void`

Defined in: [utils/v4PositionPlanner.ts:70](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4PositionPlanner.ts#L70)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `currency0` | `Currency` |
| `currency1` | `Currency` |
| `recipient` | `string` |

#### Returns

`void`

***

### addTrade()

> **addTrade**(`trade`, `slippageTolerance`?): [`V4Planner`](V4Planner.md)

Defined in: [utils/v4Planner.ts:183](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L183)

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `trade` | [`Trade`](Trade.md)\<`Currency`, `Currency`, `TradeType`\> |
| `slippageTolerance`? | `Percent` |

#### Returns

[`V4Planner`](V4Planner.md)

#### Inherited from

[`V4Planner`](V4Planner.md).[`addTrade`](V4Planner.md#addtrade)

***

### finalize()

> **finalize**(): `string`

Defined in: [utils/v4Planner.ts:224](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L224)

#### Returns

`string`

#### Inherited from

[`V4Planner`](V4Planner.md).[`finalize`](V4Planner.md#finalize)
</file>

<file path="docs/sdk/v4/reference/enumerations/Actions.md">
[@uniswap/v4-sdk](../overview.md) / Actions

Defined in: [utils/v4Planner.ts:14](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L14)

Actions

## Description

Constants that define what action to perform
Not all actions are supported yet.

## Enumeration Members

### BURN_POSITION

> **BURN_POSITION**: `3`

Defined in: [utils/v4Planner.ts:20](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L20)

***

### CLOSE_CURRENCY

> **CLOSE_CURRENCY**: `18`

Defined in: [utils/v4Planner.ts:43](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L43)

***

### DECREASE_LIQUIDITY

> **DECREASE_LIQUIDITY**: `1`

Defined in: [utils/v4Planner.ts:18](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L18)

***

### INCREASE_LIQUIDITY

> **INCREASE_LIQUIDITY**: `0`

Defined in: [utils/v4Planner.ts:17](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L17)

***

### MINT_POSITION

> **MINT_POSITION**: `2`

Defined in: [utils/v4Planner.ts:19](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L19)

***

### SETTLE

> **SETTLE**: `11`

Defined in: [utils/v4Planner.ts:34](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L34)

***

### SETTLE_ALL

> **SETTLE_ALL**: `12`

Defined in: [utils/v4Planner.ts:35](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L35)

***

### SETTLE_PAIR

> **SETTLE_PAIR**: `13`

Defined in: [utils/v4Planner.ts:36](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L36)

***

### SWAP_EXACT_IN

> **SWAP_EXACT_IN**: `7`

Defined in: [utils/v4Planner.ts:28](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L28)

***

### SWAP_EXACT_IN_SINGLE

> **SWAP_EXACT_IN_SINGLE**: `6`

Defined in: [utils/v4Planner.ts:27](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L27)

***

### SWAP_EXACT_OUT

> **SWAP_EXACT_OUT**: `9`

Defined in: [utils/v4Planner.ts:30](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L30)

***

### SWAP_EXACT_OUT_SINGLE

> **SWAP_EXACT_OUT_SINGLE**: `8`

Defined in: [utils/v4Planner.ts:29](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L29)

***

### SWEEP

> **SWEEP**: `20`

Defined in: [utils/v4Planner.ts:45](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L45)

***

### TAKE

> **TAKE**: `14`

Defined in: [utils/v4Planner.ts:38](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L38)

***

### TAKE_ALL

> **TAKE_ALL**: `15`

Defined in: [utils/v4Planner.ts:39](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L39)

***

### TAKE_PAIR

> **TAKE_PAIR**: `17`

Defined in: [utils/v4Planner.ts:41](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L41)

***

### TAKE_PORTION

> **TAKE_PORTION**: `16`

Defined in: [utils/v4Planner.ts:40](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L40)
</file>

<file path="docs/sdk/v4/reference/enumerations/HookOptions.md">
[@uniswap/v4-sdk](../overview.md) / HookOptions

Defined in: [utils/hook.ts:6](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L6)

## Enumeration Members

### AfterAddLiquidity

> **AfterAddLiquidity**: `"afterAddLiquidity"`

Defined in: [utils/hook.ts:17](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L17)

***

### AfterAddLiquidityReturnsDelta

> **AfterAddLiquidityReturnsDelta**: `"afterAddLiquidityReturnsDelta"`

Defined in: [utils/hook.ts:8](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L8)

***

### AfterDonate

> **AfterDonate**: `"afterDonate"`

Defined in: [utils/hook.ts:11](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L11)

***

### AfterInitialize

> **AfterInitialize**: `"afterInitialize"`

Defined in: [utils/hook.ts:19](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L19)

***

### AfterRemoveLiquidity

> **AfterRemoveLiquidity**: `"afterRemoveLiquidity"`

Defined in: [utils/hook.ts:15](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L15)

***

### AfterRemoveLiquidityReturnsDelta

> **AfterRemoveLiquidityReturnsDelta**: `"afterRemoveLiquidityReturnsDelta"`

Defined in: [utils/hook.ts:7](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L7)

***

### AfterSwap

> **AfterSwap**: `"afterSwap"`

Defined in: [utils/hook.ts:13](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L13)

***

### AfterSwapReturnsDelta

> **AfterSwapReturnsDelta**: `"afterSwapReturnsDelta"`

Defined in: [utils/hook.ts:9](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L9)

***

### BeforeAddLiquidity

> **BeforeAddLiquidity**: `"beforeAddLiquidity"`

Defined in: [utils/hook.ts:18](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L18)

***

### BeforeDonate

> **BeforeDonate**: `"beforeDonate"`

Defined in: [utils/hook.ts:12](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L12)

***

### BeforeInitialize

> **BeforeInitialize**: `"beforeInitialize"`

Defined in: [utils/hook.ts:20](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L20)

***

### BeforeRemoveLiquidity

> **BeforeRemoveLiquidity**: `"beforeRemoveLiquidity"`

Defined in: [utils/hook.ts:16](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L16)

***

### BeforeSwap

> **BeforeSwap**: `"beforeSwap"`

Defined in: [utils/hook.ts:14](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L14)

***

### BeforeSwapReturnsDelta

> **BeforeSwapReturnsDelta**: `"beforeSwapReturnsDelta"`

Defined in: [utils/hook.ts:10](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L10)
</file>

<file path="docs/sdk/v4/reference/enumerations/Subparser.md">
[@uniswap/v4-sdk](../overview.md) / Subparser

Defined in: [utils/v4Planner.ts:52](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L52)

## Enumeration Members

### PoolKey

> **PoolKey**: `4`

Defined in: [utils/v4Planner.ts:57](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L57)

***

### V4SwapExactIn

> **V4SwapExactIn**: `1`

Defined in: [utils/v4Planner.ts:54](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L54)

***

### V4SwapExactInSingle

> **V4SwapExactInSingle**: `0`

Defined in: [utils/v4Planner.ts:53](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L53)

***

### V4SwapExactOut

> **V4SwapExactOut**: `3`

Defined in: [utils/v4Planner.ts:56](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L56)

***

### V4SwapExactOutSingle

> **V4SwapExactOutSingle**: `2`

Defined in: [utils/v4Planner.ts:55](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L55)
</file>

<file path="docs/sdk/v4/reference/interfaces/AllowanceTransferPermitBatch.md">
[@uniswap/v4-sdk](../overview.md) / AllowanceTransferPermitBatch

Defined in: [PositionManager.ts:146](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L146)

## Properties

### details

> **details**: [`PermitDetails`](PermitDetails.md)[]

Defined in: [PositionManager.ts:147](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L147)

***

### sigDeadline

> **sigDeadline**: `BigintIsh`

Defined in: [PositionManager.ts:149](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L149)

***

### spender

> **spender**: `string`

Defined in: [PositionManager.ts:148](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L148)
</file>

<file path="docs/sdk/v4/reference/interfaces/AllowanceTransferPermitSingle.md">
[@uniswap/v4-sdk](../overview.md) / AllowanceTransferPermitSingle

Defined in: [PositionManager.ts:140](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L140)

## Properties

### details

> **details**: [`PermitDetails`](PermitDetails.md)

Defined in: [PositionManager.ts:141](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L141)

***

### sigDeadline

> **sigDeadline**: `BigintIsh`

Defined in: [PositionManager.ts:143](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L143)

***

### spender

> **spender**: `string`

Defined in: [PositionManager.ts:142](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L142)
</file>

<file path="docs/sdk/v4/reference/interfaces/BatchPermitOptions.md">
[@uniswap/v4-sdk](../overview.md) / BatchPermitOptions

Defined in: [PositionManager.ts:152](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L152)

## Properties

### owner

> **owner**: `string`

Defined in: [PositionManager.ts:153](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L153)

***

### permitBatch

> **permitBatch**: [`AllowanceTransferPermitBatch`](AllowanceTransferPermitBatch.md)

Defined in: [PositionManager.ts:154](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L154)

***

### signature

> **signature**: `string`

Defined in: [PositionManager.ts:155](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L155)
</file>

<file path="docs/sdk/v4/reference/interfaces/BestTradeOptions.md">
[@uniswap/v4-sdk](../overview.md) / BestTradeOptions

Defined in: [entities/trade.ts:47](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L47)

## Properties

### maxHops?

> `optional` **maxHops**: `number`

Defined in: [entities/trade.ts:51](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L51)

***

### maxNumResults?

> `optional` **maxNumResults**: `number`

Defined in: [entities/trade.ts:49](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L49)
</file>

<file path="docs/sdk/v4/reference/interfaces/CollectSpecificOptions.md">
[@uniswap/v4-sdk](../overview.md) / CollectSpecificOptions

Defined in: [PositionManager.ts:104](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L104)

## Properties

### recipient

> **recipient**: `string`

Defined in: [PositionManager.ts:113](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L113)

The account that should receive the tokens.

***

### tokenId

> **tokenId**: `BigintIsh`

Defined in: [PositionManager.ts:108](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L108)

Indicates the ID of the position to collect for.
</file>

<file path="docs/sdk/v4/reference/interfaces/CommonAddLiquidityOptions.md">
[@uniswap/v4-sdk](../overview.md) / CommonAddLiquidityOptions

Defined in: [PositionManager.ts:72](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L72)

Options for producing the calldata to add liquidity.

## Properties

### batchPermit?

> `optional` **batchPermit**: [`BatchPermitOptions`](BatchPermitOptions.md)

Defined in: [PositionManager.ts:81](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L81)

The optional permit2 batch permit parameters for spending token0 and token1

***

### useNative?

> `optional` **useNative**: `NativeCurrency`

Defined in: [PositionManager.ts:76](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L76)

Whether to spend ether. If true, one of the currencies must be the NATIVE currency.
</file>

<file path="docs/sdk/v4/reference/interfaces/CommonOptions.md">
[@uniswap/v4-sdk](../overview.md) / CommonOptions

Defined in: [PositionManager.ts:24](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L24)

## Properties

### deadline

> **deadline**: `BigintIsh`

Defined in: [PositionManager.ts:37](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L37)

When the transaction expires, in epoch seconds.

***

### hookData?

> `optional` **hookData**: `string`

Defined in: [PositionManager.ts:32](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L32)

Optional data to pass to hooks

***

### slippageTolerance

> **slippageTolerance**: `Percent`

Defined in: [PositionManager.ts:28](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L28)

How much the pool price is allowed to move from the specified action.
</file>

<file path="docs/sdk/v4/reference/interfaces/MethodParameters.md">
[@uniswap/v4-sdk](../overview.md) / MethodParameters

Defined in: [utils/calldata.ts:7](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/calldata.ts#L7)

Generated method parameters for executing a call.

## Properties

### calldata

> **calldata**: `string`

Defined in: [utils/calldata.ts:11](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/calldata.ts#L11)

The hex encoded calldata to perform the given operation

***

### value

> **value**: `string`

Defined in: [utils/calldata.ts:15](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/calldata.ts#L15)

The amount of ether (wei) to send in hex.
</file>

<file path="docs/sdk/v4/reference/interfaces/MintSpecificOptions.md">
[@uniswap/v4-sdk](../overview.md) / MintSpecificOptions

Defined in: [PositionManager.ts:47](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L47)

## Properties

### createPool?

> `optional` **createPool**: `boolean`

Defined in: [PositionManager.ts:56](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L56)

Creates pool if not initialized before mint.

***

### migrate?

> `optional` **migrate**: `boolean`

Defined in: [PositionManager.ts:66](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L66)

Whether the mint is part of a migration from V3 to V4.

***

### recipient

> **recipient**: `string`

Defined in: [PositionManager.ts:51](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L51)

The account that should receive the minted NFT.

***

### sqrtPriceX96?

> `optional` **sqrtPriceX96**: `BigintIsh`

Defined in: [PositionManager.ts:61](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L61)

Initial price to set on the pool if creating
</file>

<file path="docs/sdk/v4/reference/interfaces/ModifyPositionSpecificOptions.md">
[@uniswap/v4-sdk](../overview.md) / ModifyPositionSpecificOptions

Defined in: [PositionManager.ts:40](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L40)

## Properties

### tokenId

> **tokenId**: `BigintIsh`

Defined in: [PositionManager.ts:44](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L44)

Indicates the ID of the position to increase liquidity for.
</file>

<file path="docs/sdk/v4/reference/interfaces/NFTPermitData.md">
[@uniswap/v4-sdk](../overview.md) / NFTPermitData

Defined in: [PositionManager.ts:178](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L178)

## Properties

### domain

> **domain**: `TypedDataDomain`

Defined in: [PositionManager.ts:179](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L179)

***

### types

> **types**: `Record`\<`string`, `TypedDataField`[]\>

Defined in: [PositionManager.ts:180](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L180)

***

### values

> **values**: [`NFTPermitValues`](NFTPermitValues.md)

Defined in: [PositionManager.ts:181](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L181)
</file>

<file path="docs/sdk/v4/reference/interfaces/NFTPermitOptions.md">
[@uniswap/v4-sdk](../overview.md) / NFTPermitOptions

Defined in: [PositionManager.ts:174](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L174)

## Extends

- [`NFTPermitValues`](NFTPermitValues.md)

## Properties

### deadline

> **deadline**: `BigintIsh`

Defined in: [PositionManager.ts:170](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L170)

#### Inherited from

[`NFTPermitValues`](NFTPermitValues.md).[`deadline`](NFTPermitValues.md#deadline)

***

### nonce

> **nonce**: `BigintIsh`

Defined in: [PositionManager.ts:171](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L171)

#### Inherited from

[`NFTPermitValues`](NFTPermitValues.md).[`nonce`](NFTPermitValues.md#nonce)

***

### signature

> **signature**: `string`

Defined in: [PositionManager.ts:175](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L175)

***

### spender

> **spender**: `string`

Defined in: [PositionManager.ts:168](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L168)

#### Inherited from

[`NFTPermitValues`](NFTPermitValues.md).[`spender`](NFTPermitValues.md#spender)

***

### tokenId

> **tokenId**: `BigintIsh`

Defined in: [PositionManager.ts:169](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L169)

#### Inherited from

[`NFTPermitValues`](NFTPermitValues.md).[`tokenId`](NFTPermitValues.md#tokenid)
</file>

<file path="docs/sdk/v4/reference/interfaces/NFTPermitValues.md">
[@uniswap/v4-sdk](../overview.md) / NFTPermitValues

Defined in: [PositionManager.ts:167](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L167)

## Extended by

- [`NFTPermitOptions`](NFTPermitOptions.md)

## Properties

### deadline

> **deadline**: `BigintIsh`

Defined in: [PositionManager.ts:170](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L170)

***

### nonce

> **nonce**: `BigintIsh`

Defined in: [PositionManager.ts:171](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L171)

***

### spender

> **spender**: `string`

Defined in: [PositionManager.ts:168](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L168)

***

### tokenId

> **tokenId**: `BigintIsh`

Defined in: [PositionManager.ts:169](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L169)
</file>

<file path="docs/sdk/v4/reference/interfaces/PermitDetails.md">
[@uniswap/v4-sdk](../overview.md) / PermitDetails

Defined in: [PositionManager.ts:133](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L133)

## Properties

### amount

> **amount**: `BigintIsh`

Defined in: [PositionManager.ts:135](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L135)

***

### expiration

> **expiration**: `BigintIsh`

Defined in: [PositionManager.ts:136](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L136)

***

### nonce

> **nonce**: `BigintIsh`

Defined in: [PositionManager.ts:137](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L137)

***

### token

> **token**: `string`

Defined in: [PositionManager.ts:134](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L134)
</file>

<file path="docs/sdk/v4/reference/interfaces/RemoveLiquiditySpecificOptions.md">
[@uniswap/v4-sdk](../overview.md) / RemoveLiquiditySpecificOptions

Defined in: [PositionManager.ts:87](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L87)

Options for producing the calldata to exit a position.

## Properties

### burnToken?

> `optional` **burnToken**: `boolean`

Defined in: [PositionManager.ts:96](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L96)

Whether the NFT should be burned if the entire position is being exited, by default false.

***

### liquidityPercentage

> **liquidityPercentage**: `Percent`

Defined in: [PositionManager.ts:91](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L91)

The percentage of position liquidity to exit.

***

### permit?

> `optional` **permit**: [`NFTPermitOptions`](NFTPermitOptions.md)

Defined in: [PositionManager.ts:101](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L101)

The optional permit of the token ID being exited, in case the exit transaction is being sent by an account that does not own the NFT
</file>

<file path="docs/sdk/v4/reference/interfaces/TransferOptions.md">
[@uniswap/v4-sdk](../overview.md) / TransferOptions

Defined in: [PositionManager.ts:116](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L116)

## Properties

### recipient

> **recipient**: `string`

Defined in: [PositionManager.ts:125](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L125)

The account that should receive the NFT.

***

### sender

> **sender**: `string`

Defined in: [PositionManager.ts:120](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L120)

The account sending the NFT.

***

### tokenId

> **tokenId**: `BigintIsh`

Defined in: [PositionManager.ts:130](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L130)

The id of the token being sent.
</file>

<file path="docs/sdk/v4/reference/_category_.json">
{
  "label": "Technical Reference",
  "position": 3,
  "collapsed": true
}
</file>

<file path="docs/sdk/v4/reference/overview.md">
---
id: overview
sidebar_position: 1
title: Overview
---

## Enumerations

- [Actions](enumerations/Actions.md)
- [HookOptions](enumerations/HookOptions.md)
- [Subparser](enumerations/Subparser.md)

## Classes

- [Hook](classes/Hook.md)
- [Pool](classes/Pool.md)
- [Position](classes/Position.md)
- [Route](classes/Route.md)
- [Trade](classes/Trade.md)
- [V4BaseActionsParser](classes/V4BaseActionsParser.md)
- [V4Planner](classes/V4Planner.md)
- [V4PositionManager](classes/V4PositionManager.md)
- [V4PositionPlanner](classes/V4PositionPlanner.md)

## Interfaces

- [AllowanceTransferPermitBatch](interfaces/AllowanceTransferPermitBatch.md)
- [AllowanceTransferPermitSingle](interfaces/AllowanceTransferPermitSingle.md)
- [BatchPermitOptions](interfaces/BatchPermitOptions.md)
- [BestTradeOptions](interfaces/BestTradeOptions.md)
- [CollectSpecificOptions](interfaces/CollectSpecificOptions.md)
- [CommonAddLiquidityOptions](interfaces/CommonAddLiquidityOptions.md)
- [CommonOptions](interfaces/CommonOptions.md)
- [MethodParameters](interfaces/MethodParameters.md)
- [MintSpecificOptions](interfaces/MintSpecificOptions.md)
- [ModifyPositionSpecificOptions](interfaces/ModifyPositionSpecificOptions.md)
- [NFTPermitData](interfaces/NFTPermitData.md)
- [NFTPermitOptions](interfaces/NFTPermitOptions.md)
- [NFTPermitValues](interfaces/NFTPermitValues.md)
- [PermitDetails](interfaces/PermitDetails.md)
- [RemoveLiquiditySpecificOptions](interfaces/RemoveLiquiditySpecificOptions.md)
- [TransferOptions](interfaces/TransferOptions.md)

## Type Aliases

### AddLiquidityOptions

> **AddLiquidityOptions**: [`MintOptions`](overview.md#mintoptions) | [`IncreaseLiquidityOptions`](overview.md#increaseliquidityoptions)

Defined in: [PositionManager.ts:187](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L187)

---

### CollectOptions

> **CollectOptions**: [`CommonOptions`](interfaces/CommonOptions.md) & [`CollectSpecificOptions`](interfaces/CollectSpecificOptions.md)

Defined in: [PositionManager.ts:191](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L191)

---

### HookPermissions

> **HookPermissions**: `{ [key in HookOptions]: boolean }`

Defined in: [utils/hook.ts:4](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L4)

---

### IncreaseLiquidityOptions

> **IncreaseLiquidityOptions**: [`CommonOptions`](interfaces/CommonOptions.md) & [`CommonAddLiquidityOptions`](interfaces/CommonAddLiquidityOptions.md) & [`ModifyPositionSpecificOptions`](interfaces/ModifyPositionSpecificOptions.md)

Defined in: [PositionManager.ts:185](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L185)

---

### MintOptions

> **MintOptions**: [`CommonOptions`](interfaces/CommonOptions.md) & [`CommonAddLiquidityOptions`](interfaces/CommonAddLiquidityOptions.md) & [`MintSpecificOptions`](interfaces/MintSpecificOptions.md)

Defined in: [PositionManager.ts:184](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L184)

---

### Param

> **Param**: `object`

Defined in: [utils/v4BaseActionsParser.ts:6](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4BaseActionsParser.ts#L6)

#### Type declaration

##### name

> `readonly` **name**: `string`

##### value

> `readonly` **value**: `any`

---

### ParamType

> **ParamType**: `object`

Defined in: [utils/v4Planner.ts:60](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L60)

#### Type declaration

##### name

> `readonly` **name**: `string`

##### subparser?

> `readonly` `optional` **subparser**: [`Subparser`](enumerations/Subparser.md)

##### type

> `readonly` **type**: `string`

---

### PathKey

> **PathKey**: `object`

Defined in: [utils/encodeRouteToPath.ts:5](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/encodeRouteToPath.ts#L5)

#### Type declaration

##### fee

> **fee**: `number`

##### hookData

> **hookData**: `string`

##### hooks

> **hooks**: `string`

##### intermediateCurrency

> **intermediateCurrency**: `string`

##### tickSpacing

> **tickSpacing**: `number`

---

### PoolKey

> **PoolKey**: `object`

Defined in: [entities/pool.ts:22](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L22)

#### Type declaration

##### currency0

> **currency0**: `string`

##### currency1

> **currency1**: `string`

##### fee

> **fee**: `number`

##### hooks

> **hooks**: `string`

##### tickSpacing

> **tickSpacing**: `number`

---

### RemoveLiquidityOptions

> **RemoveLiquidityOptions**: [`CommonOptions`](interfaces/CommonOptions.md) & [`RemoveLiquiditySpecificOptions`](interfaces/RemoveLiquiditySpecificOptions.md) & [`ModifyPositionSpecificOptions`](interfaces/ModifyPositionSpecificOptions.md)

Defined in: [PositionManager.ts:189](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/PositionManager.ts#L189)

---

### SwapExactIn

> **SwapExactIn**: `object`

Defined in: [utils/v4BaseActionsParser.ts:29](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4BaseActionsParser.ts#L29)

#### Type declaration

##### amountIn

> `readonly` **amountIn**: `string`

##### amountOutMinimum

> `readonly` **amountOutMinimum**: `string`

##### currencyIn

> `readonly` **currencyIn**: `string`

##### path

> `readonly` **path**: readonly [`PathKey`](overview.md#pathkey)[]

---

### SwapExactInSingle

> **SwapExactInSingle**: `object`

Defined in: [utils/v4BaseActionsParser.ts:21](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4BaseActionsParser.ts#L21)

#### Type declaration

##### amountIn

> `readonly` **amountIn**: `string`

##### amountOutMinimum

> `readonly` **amountOutMinimum**: `string`

##### hookData

> `readonly` **hookData**: `string`

##### poolKey

> `readonly` **poolKey**: [`PoolKey`](overview.md#poolkey)

##### zeroForOne

> `readonly` **zeroForOne**: `boolean`

---

### SwapExactOut

> **SwapExactOut**: `object`

Defined in: [utils/v4BaseActionsParser.ts:44](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4BaseActionsParser.ts#L44)

#### Type declaration

##### amountInMaximum

> `readonly` **amountInMaximum**: `string`

##### amountOut

> `readonly` **amountOut**: `string`

##### currencyOut

> `readonly` **currencyOut**: `string`

##### path

> `readonly` **path**: readonly [`PathKey`](overview.md#pathkey)[]

---

### SwapExactOutSingle

> **SwapExactOutSingle**: `object`

Defined in: [utils/v4BaseActionsParser.ts:36](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4BaseActionsParser.ts#L36)

#### Type declaration

##### amountInMaximum

> `readonly` **amountInMaximum**: `string`

##### amountOut

> `readonly` **amountOut**: `string`

##### hookData

> `readonly` **hookData**: `string`

##### poolKey

> `readonly` **poolKey**: [`PoolKey`](overview.md#poolkey)

##### zeroForOne

> `readonly` **zeroForOne**: `boolean`

---

### V4RouterAction

> **V4RouterAction**: `object`

Defined in: [utils/v4BaseActionsParser.ts:11](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4BaseActionsParser.ts#L11)

#### Type declaration

##### actionName

> `readonly` **actionName**: `string`

##### actionType

> `readonly` **actionType**: [`Actions`](enumerations/Actions.md)

##### params

> `readonly` **params**: readonly [`Param`](overview.md#param)[]

---

### V4RouterCall

> **V4RouterCall**: `object`

Defined in: [utils/v4BaseActionsParser.ts:17](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4BaseActionsParser.ts#L17)

#### Type declaration

##### actions

> `readonly` **actions**: readonly [`V4RouterAction`](overview.md#v4routeraction)[]

## Variables

### DYNAMIC_FEE_FLAG

> `const` **DYNAMIC_FEE_FLAG**: `8388608` = `0x800000`

Defined in: [entities/pool.ts:19](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/pool.ts#L19)

---

### hookFlagIndex

> `const` **hookFlagIndex**: `object`

Defined in: [utils/hook.ts:23](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/hook.ts#L23)

#### Type declaration

##### afterAddLiquidity

> **afterAddLiquidity**: `number` = `10`

##### afterAddLiquidityReturnsDelta

> **afterAddLiquidityReturnsDelta**: `number` = `1`

##### afterDonate

> **afterDonate**: `number` = `4`

##### afterInitialize

> **afterInitialize**: `number` = `12`

##### afterRemoveLiquidity

> **afterRemoveLiquidity**: `number` = `8`

##### afterRemoveLiquidityReturnsDelta

> **afterRemoveLiquidityReturnsDelta**: `number` = `0`

##### afterSwap

> **afterSwap**: `number` = `6`

##### afterSwapReturnsDelta

> **afterSwapReturnsDelta**: `number` = `2`

##### beforeAddLiquidity

> **beforeAddLiquidity**: `number` = `11`

##### beforeDonate

> **beforeDonate**: `number` = `5`

##### beforeInitialize

> **beforeInitialize**: `number` = `13`

##### beforeRemoveLiquidity

> **beforeRemoveLiquidity**: `number` = `9`

##### beforeSwap

> **beforeSwap**: `number` = `7`

##### beforeSwapReturnsDelta

> **beforeSwapReturnsDelta**: `number` = `3`

---

### V4_BASE_ACTIONS_ABI_DEFINITION

> `const` **V4_BASE_ACTIONS_ABI_DEFINITION**: `{ [key in Actions]: readonly ParamType[] }`

Defined in: [utils/v4Planner.ts:82](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/v4Planner.ts#L82)

## Functions

### amountWithPathCurrency()

> **amountWithPathCurrency**(`amount`, `pool`): `CurrencyAmount`\<`Currency`\>

Defined in: [utils/pathCurrency.ts:4](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/pathCurrency.ts#L4)

#### Parameters

| Parameter | Type                         |
| --------- | ---------------------------- |
| `amount`  | `CurrencyAmount`\<`Currency`\> |
| `pool`    | [`Pool`](classes/Pool.md)    |

#### Returns

`CurrencyAmount`\<`Currency`\>

---

### encodeRouteToPath()

> **encodeRouteToPath**(`route`, `exactOutput`?): [`PathKey`](overview.md#pathkey)[]

Defined in: [utils/encodeRouteToPath.ts:13](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/encodeRouteToPath.ts#L13)

#### Parameters

| Parameter      | Type                                                |
| -------------- | --------------------------------------------------- |
| `route`        | [`Route`](classes/Route.md)\<`Currency`, `Currency`\> |
| `exactOutput`? | `boolean`                                           |

#### Returns

[`PathKey`](overview.md#pathkey)[]

---

### getPathCurrency()

> **getPathCurrency**(`currency`, `pool`): `Currency`

Defined in: [utils/pathCurrency.ts:12](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/pathCurrency.ts#L12)

#### Parameters

| Parameter  | Type                      |
| ---------- | ------------------------- |
| `currency` | `Currency`                |
| `pool`     | [`Pool`](classes/Pool.md) |

#### Returns

`Currency`

---

### priceToClosestTick()

> **priceToClosestTick**(`price`): `number`

Defined in: [utils/priceTickConversions.ts:35](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/priceTickConversions.ts#L35)

Returns the first tick for which the given price is greater than or equal to the tick price

#### Parameters

| Parameter | Type                            | Description                                                                                                                                                                      |
| --------- | ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `price`   | `Price`\<`Currency`, `Currency`\> | for which to return the closest tick that represents a price less than or equal to the input price, i.e. the price of the returned tick is less than or equal to the input price |

#### Returns

`number`

---

### sortsBefore()

> **sortsBefore**(`currencyA`, `currencyB`): `boolean`

Defined in: [utils/sortsBefore.ts:3](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/sortsBefore.ts#L3)

#### Parameters

| Parameter   | Type       |
| ----------- | ---------- |
| `currencyA` | `Currency` |
| `currencyB` | `Currency` |

#### Returns

`boolean`

---

### tickToPrice()

> **tickToPrice**(`baseCurrency`, `quoteCurrency`, `tick`): `Price`\<`Currency`, `Currency`\>

Defined in: [utils/priceTickConversions.ts:20](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/priceTickConversions.ts#L20)

Returns a price object corresponding to the input tick and the base/quote token
Inputs must be tokens because the address order is used to interpret the price represented by the tick

#### Parameters

| Parameter       | Type       | Description                            |
| --------------- | ---------- | -------------------------------------- |
| `baseCurrency`  | `Currency` | -                                      |
| `quoteCurrency` | `Currency` | -                                      |
| `tick`          | `number`   | the tick for which to return the price |

#### Returns

`Price`\<`Currency`, `Currency`\>

---

### toAddress()

> **toAddress**(`currency`): `string`

Defined in: [utils/currencyMap.ts:7](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/currencyMap.ts#L7)

#### Parameters

| Parameter  | Type       |
| ---------- | ---------- |
| `currency` | `Currency` |

#### Returns

`string`

---

### toHex()

> **toHex**(`bigintIsh`): `string`

Defined in: [utils/calldata.ts:23](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/utils/calldata.ts#L23)

Converts a big int to a hex string

#### Parameters

| Parameter   | Type        | Description |
| ----------- | ----------- | ----------- |
| `bigintIsh` | `BigintIsh` |             |

#### Returns

`string`

The hex encoded calldata

---

### tradeComparator()

> **tradeComparator**\<`TInput`, `TOutput`, `TTradeType`\>(`a`, `b`): `number`

Defined in: [entities/trade.ts:17](https://github.com/Uniswap/sdks/blob/9cf6edb2df79338ae58f7ea7ca979c35a8a9bd56/sdks/v4-sdk/src/entities/trade.ts#L17)

Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them

#### Type Parameters

| Type Parameter                     | Description                                        |
| ---------------------------------- | -------------------------------------------------- |
| `TInput` _extends_ `Currency`      | The input currency, either Ether or an ERC-20      |
| `TOutput` _extends_ `Currency`     | The output currency, either Ether or an ERC-20     |
| `TTradeType` _extends_ `TradeType` | The trade type, either exact input or exact output |

#### Parameters

| Parameter | Type                                                           | Description                 |
| --------- | -------------------------------------------------------------- | --------------------------- |
| `a`       | [`Trade`](classes/Trade.md)\<`TInput`, `TOutput`, `TTradeType`\> | The first trade to compare  |
| `b`       | [`Trade`](classes/Trade.md)\<`TInput`, `TOutput`, `TTradeType`\> | The second trade to compare |

#### Returns

`number`

A sorted ordering for two neighboring elements in a trade array
</file>

<file path="docs/sdk/v4/_category_.json">
{
  "label": "v4 SDK",
  "position": 1,
  "collapsed": false
}
</file>

<file path="docs/sdk/v4/overview.md">
---
id: overview
sidebar_position: 1
title: Overview
---

# The Uniswap v4 SDK

> **Welcome to the v4 Uniswap SDK!**

The Uniswap v4 SDK provides abstractions to assist you with interacting with the Uniswap v4 smart contracts in a Typescript/Javascript environment (e.g. websites, node scripts). It makes use of the [**Core SDK**](../core/overview.md) to gain access to abstractions that are common amongst the Uniswap SDKs. With the SDK, you can add/remove liquidity, collect fees like what you will usually do with v3 SDK, but more with the extra functionalities from hooks introduced in v4!

For complete documentation of the SDK's offerings, see the [**Technical Reference**](./reference/overview.md).

## Installation

To interact with the v4 SDK we recommend installing through npm:

```bash
npm i --save @uniswap/v4-sdk
npm i --save @uniswap/sdk-core
```

## What's Different in v4

The Uniswap v4 SDK introduces some major changes that fundamentally alter how developers interact with Uniswap. Understanding these key differences is essential for successful v4 development.

## Key Changes

### Universal Router Requirement for Swapping
**What changed**: v3 allowed direct calls to the v3 Swap Router contract. v4 requires all swapping operations to go through the Universal Router.

**Why**: v4's singleton PoolManager architecture and flash accounting system require a different interaction pattern. The v4Planner batches operations and encodes them for the Universal Router - you cannot make direct swap calls.

**Key differences**:
- All swaps must be "planned" using v4Planner, even single swaps
- Operations use new patterns: SETTLE (pay tokens) and TAKE (receive tokens)
- Enables efficient multi-step operations and cross-protocol routes

**Impact**: This enables more efficient multi-step operations in a single transaction.

### StateView Contract Introduction
**Why it exists**: v4 uses a singleton PoolManager that tracks all pools in one contract, unlike v3's separate pool contracts. 

**What it means**: The StateView contract wraps the PoolManager's state reading functions with a dedicated view-only interface. Instead of calling the PoolManager directly for state queries, you use StateView for cleaner, more organized access to pool data like slot0, tick info, liquidity, and position information.

**Impact**: Provides a dedicated, organized interface for off-chain clients to read pool state data.

### Position Fetching Changed
**What changed**: v3 allowed easy enumeration of user positions on-chain. v4 provides no way to get all of a user's position IDs directly from the contracts. Additionally, position information is packed into a single uint256 value for efficiency, requiring decoding to extract individual fields like liquidity, fee growth, and tick ranges.

**Why it's different**: This design choice means position enumeration must happen off-chain through event indexing.

**Impact**: Applications must choose and implement indexing solutions to know which positions a user owns.

### Fee Collection Behavior Changed
**What changed**: v3 had an explicit `collect()` function for fee collection. v4 has no standalone collect function - fees are automatically collected and distributed when you modify positions.

**New pattern**: 
- Fees automatically roll over when increasing/decreasing liquidity
- To collect fees without modifying position size, you must modify the position with zero change (e.g., `modifyLiquidity(positionId, 0)`)
- StateView contract must be used to query the fee growth inside in order to calculate the exact amount of fees owed 

**Impact**: Fee collection logic must be redesigned around position modifications rather than explicit collect() calls.

### Quick Comparison

| Feature | v3 | v4 |
|---------|----|----|
| Swapping | Direct router calls | Universal Router |
| Pool State | Individual pool contracts | StateView contract |
| Position Discovery | On-chain enumeration | Off-chain indexing |
| Fee Collection | Explicit collect() | Automatic on modification |

### What This Means for Developers

### Migration Requirements
1. **Restructure all swaps** to use Universal Router with v4Planner
2. **Build position indexing systems** using event logs and subgraphs for position discovery
3. **Redesign fee collection logic** to use position modifications instead of explicit collect() calls
4. **Implement StateView integration** for all pool state queries instead of direct PoolManager calls

### Development Impact
- **Universal Router**: All swaps must be batched, but enables complex multi-step operations
- **Position tracking**: Requires additional infrastructure
- **Fee collection**: Simpler in some cases (automatic), more complex in others (zero-change modifications)
- **StateView**: Cleaner interface for state queries

## Learning Path

To get started with v4 SDK development, follow these guides based on the key changes:

### 1. Swapping
Learn how to restructure swaps using Universal Router integration.

**Guides**: 

- [Getting a Quote](/sdk/v4/guides/swaps/quoting)
- [Executing a Single-Hop Swap](/sdk/v4/guides/swaps/single-hop-swapping)
- [Executing Multi-Hop Swaps](/sdk/v4/guides/swaps/multi-hop-swapping)

### 2. Position Management (Off-chain Indexing + Fee Collection)
Understand position tracking systems and the new automatic fee collection patterns.

**Guides**:

- [Minting a Position](/sdk/v4/guides/liquidity/position-minting)
- [Fetching Positions](/sdk/v4/guides/liquidity/position-fetching)
- [Collecting Fees](/sdk/v4/guides/liquidity/collect-fees)
- [Adding and Removing Liquidity](/sdk/v4/guides/liquidity/add-remove-liquidity)

### 3. Advanced Features (StateView + Pool Creation)
Explore efficient state queries and pool creation with the new architecture.

**Guides**:

- [Fetching Pool Data](/sdk/v4/guides/advanced/pool-data)
- [Create Pool](/sdk/v4/guides/advanced/create-pool)

## Developer Links

- [**v4 SDK GitHub Repo**](https://github.com/Uniswap/sdks/tree/main/sdks/v4-sdk)
- [**Core SDK GitHub Repo**](https://github.com/Uniswap/sdk-core)
- [**v4 SDK NPM Package**](https://www.npmjs.com/package/@uniswap/v4-sdk)

[![Unit Tests](https://github.com/Uniswap/uniswap-v3-sdk/workflows/Unit%20Tests/badge.svg)](https://github.com/Uniswap/sdks/actions?query=workflow%3A%22%22Code+Quality+Checks%22%22++)
[![Lint](https://github.com/Uniswap/uniswap-v3-sdk/workflows/Lint/badge.svg)](https://github.com/Uniswap/sdks/actions?query=workflow%3A%22%22Code+Quality+Checks%22%22++)
[![npm version](https://img.shields.io/npm/v/@uniswap/v4-sdk/latest.svg)](https://www.npmjs.com/package/@uniswap/v4-sdk/v/latest)
[![npm bundle size (scoped version)](https://img.shields.io/bundlephobia/minzip/@uniswap/v4-sdk/latest.svg)](https://bundlephobia.com/result?p=@uniswap/v4-sdk@latest)
[![Discord](https://img.shields.io/badge/discord-join%20chat-blue.svg)](https://discord.com/channels/597638925346930701/607978109089611786)
</file>

<file path="docs/sdk/web3-react/guides/_category_.json">
{
  "label": "Guides",
  "position": 2,
  "collapsed": false
}
</file>

<file path="docs/sdk/web3-react/guides/connect-wallet.md">
---
id: connect-wallet
title: Connecting to Wallets
sidebar_position: 1
---     

## Introduction

This guide will cover how to connect wallets with `web3-react`. It is based on the [`web3-react` example](https://github.com/Uniswap/examples/tree/main/web3-react) found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/blob/main/web3-react/README.md) and follow the setup instructions.


In this example we will walk through setting up `web3-react` and connecting the most popular browser-injected connector, [MetaMask](https://metamask.io/), using [@web3-react/metamask](https://www.npmjs.com/package/@web3-react/metamask).


The input parameters to this guide are the chains that we want our app to be able to connect to and their RPC URLs.

The guide will **cover**:

1. Creating a `web3-react` `Web3ReactProvider`
2. Building a `web3-react` `InjectedConnector`
3. Connecting and disconnecting the application to the connector

At the end of the guide, we should be able to connect and disconnect your dApp to a MetaMask connector.

For this guide, the following `web3-react` packages are used:

- [`@web3-react/core`](https://www.npmjs.com/package/@web3-react/core)
- [`@web3-react/types`](https://www.npmjs.com/package/@web3-react/types)
- [`@web3-react/metamask`](https://www.npmjs.com/package/@web3-react/metamask)

:::info
This guide uses `web3-react` version 8, which is a beta version.
:::

These will be automatically installed by following the example's [README](https://github.com/Uniswap/examples/blob/main/web3-react/README.md).

The core code of this guide can be found in [Web3ContextProvider](https://github.com/Uniswap/examples/blob/main/web3-react/src/libs/components/Web3ContextProvider.tsx) and [InjectedConnector](https://github.com/Uniswap/examples/blob/main/web3-react/src/libs/injected.ts).

## Creating a `Web3ReactProvider`

To be able to interact with the methods that `web3-react` offers, we first need to setup a `Web3ReactProvider` and wrap our application in it. `web3-react` uses a [React `Context`](https://reactjs.org/docs/context.html) to allow us to use the exposed hooks without additional configuration. 

To start, we create a React component called `Web3ContextProvider` in order to wrap the logic of configuring the `Web3ReactProvider`. In this component, we first import  `Web3ReactProvider` from [@web3-react/core](https://www.npmjs.com/package/@web3-react/core).

The component receives just one prop which is the `children` to which it will be providing the `Context`:

```typescript reference title="Defining the Web3React component" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/Web3ContextProvider.tsx#L24
```

We then implement the component by rendering the imported `Web3ReactProvider` with the `children` within that:


```typescript reference title="Implementing the component" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/Web3ContextProvider.tsx#L30-L34
```

Note that we map our list of [`Connections`](https://github.com/Uniswap/examples/blob/856dbb002e7f38120554ef226f4309c96ce6ea79/web3-react/src/libs/connections.ts#L10) to a *tuple* of the `connector` and `hooks` of the connection. The third element of a `Connection` refers to the [type](https://github.com/Uniswap/examples/blob/06980acc8f6d484b719d2c60f5bfe9d766cb95d6/web3-react/src/libs/connections.ts#L16) of `Connection` being established, which we will later use to keep track of the actively connected wallet.

Finally, having created the `Web3ContextProvider` component, we can navigate to our [index file](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/index.tsx) and wrap the whole application with it:

```typescript reference title="Wrapping our app with the web3 context" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/7ac3853bc465aecc428a32be584bbeb833b0a63c/web3-react/src/index.tsx#L16-L22
```

## Building an Injected Connector

The only parameter that we provided to the `Web3ReactProvider` component is a list of prioritized connectors, declared as `PRIORITIZED_CONNECTORS`. The prioritization ordering is with regards to which connector we want to be active when more than one connector is connected to our application. The list is defined inside our connectors module: 
```typescript reference title="Creating the prioritized Connectors list" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/connections.ts#L33-L39
```

Each one of those connectors lives within its own file, and they all follow a similar setup pattern. 

An example of a connector in the list is the `InjectedConnector`, which supports wallets that inject an *Ethereum Provider* into the browser window. The most popular example of an injected connector is the *MetaMask* browser extension. To set it up, we import `initializeConnector` function from [core](https://www.npmjs.com/package/@web3-react/core) and the `MetaMask` type from [metamask](https://www.npmjs.com/package/@web3-react/core):

```typescript reference title="Importing Connector dependencies" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/856dbb002e7f38120554ef226f4309c96ce6ea79/web3-react/src/libs/injected.ts#L1-L2
```

We then utilize the templated `initializeConnector` function with `MetaMask` as the type argument:

```typescript reference title="Initializing the MetaMask connector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/injected.ts#L7-L9
```

By passing in `MetaMask` as the type argument, we define the function's required input parameters. In this case, the only parameter we need to pass is an instance of `Metamask`, which receives the `actions` and `onError` parameters. The first parameter defines the actions that `web3-react` performs on its local store for the connector (this usually can be passed through without modification), while the second parameter is the callback invoked when an error occurs.

The return type of the function is a tuple of the initialized `Connector` and the `Hooks` that we can use on it. Using this tuple, we create an instance of a [`Connection`](https://github.com/Uniswap/examples/blob/856dbb002e7f38120554ef226f4309c96ce6ea79/web3-react/src/libs/connections.ts#L10) type, by setting the `type` property to `INJECTED`:


```typescript reference title="Creating a connection instance" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/856dbb002e7f38120554ef226f4309c96ce6ea79/web3-react/src/libs/injected.ts#L16-L20
```

Finally, we return the instance of `Connection` we created, which is added to the list of prioritized connectors. 

:::info
For help on creating the rest of the supported connectors of this examples, please visit our [connectors](./connectors.md) page!
:::


## Connecting and  disconnecting the application to the connector

Having built our `InjectedConnector`, we can now use it in the Context that allows our application to use that connector:

```typescript reference title="Creating the Option component" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/Option.tsx#L5-L11
```

The component receives 5 parameters:
- `isEnabled` determines whether the connector is eligible to be activated
- `isConnected` determines whether the connector is currently active 
- `connectionType` determines the `ConnectionType`
- `onActivate` is called once the component has established a connection 
- `onDeactivate` is called once the component has disconnected

In the case of *MetaMask*, when declaring the `InjectedConnector` we pass the connector-specific arguments:

```typescript reference title="Creating an injected connector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/ConnectionOptions.tsx#L26-L32
```

Then, in the `html` portion of the `Option`, we can figure out whether we want the current `Option`'s action button to be disabled, and whether clicking the button would result in the connector being connected or disconnected:

```typescript reference title="The component user interface" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/Option.tsx#L38-L42
```

Finally, we also have enough information to figure out what action to take when the button is clicked. In the case that the click triggers a connection:

```typescript reference title="On connecting to a Connector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/components/Option.tsx#L38-L42
```

To connect our wallet, all we need to do is to call the `tryActivateConnector` function and pass it the `InjectedConnector`. We then call the `onActivate` callback, which makes the `InjectedConnector` the active connector in our application's state.


`tryActivateConnector` takes as its argument the connector that we want to activate, and attempts to call `activate` on it. If this activation succeeds, it returns the new `ConnectionType`:


```typescript reference title="The implementation of tryActivateConnector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/connections.ts#L90-L92
```


In the case that the click triggers a disconnection:

```typescript reference title="On disconnecting from a Connector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/components/Option.tsx#L29-L36
```


To disconnect, all we need to do is to call `tryDeactivateConnector` and pass in it the `InjectedConnector` we created before. We then call the `onDeactivate` callback, which removes the `InjectedConnector` as the currently active connector from our application's state.

`tryDeactivateConnector` takes as its argument the connector that we want to deactivate, and attempts to call `deactivate` on it. If this deactivation succeeds, it resets the connector's state by calling `resetState` and returns `null`:

```typescript reference title="The implementation of tryDeactivateConnector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/connections.ts#L98-L100
```

## Next Steps

Now that we have gone through connecting and disconnecting from an `InjectedConnector`, we will learn how to [connect and disconnect](./02-connectors.md) from all the different types of connectors that `web3-react` supports.
</file>

<file path="docs/sdk/web3-react/guides/connectors.md">
---
id: connectors
title: Supported Connectors
sidebar_position: 2
---     

## Introduction

This guide will cover how to connect our dApp to all the different connectors that `web3-react` supports. It is based on the [`web3-react` example](https://github.com/Uniswap/examples/tree/main/web3-react), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/blob/main/web3-react/README.md) and follow the setup instructions.


In this example we will cover connecting our dApp to the following connectors:
- Coinbase wallet
- WalletConnect wallet
- Network
- Gnosis safe


:::info
For help on setting up `web3-react` and interacting with a MetaMask wallet, please visit our [connecting to wallets](./01-connect-wallet.md) page!
:::


The input parameters to this guide are the chains that we want our dApp to be able to connect to and their RPC URLs.

The guide will **cover**:

1. Building a Coinbase Wallet connector
2. Building a WalletConnect Wallet connector
3. Building a Network connector
4. Building a Gnosis Safe connector


At the end of the guide, we should be able to connect and disconnect the application to the different connectors listed above.

For this guide, the following `web3-react` packages are used:

- [`@web3-react/core`](https://www.npmjs.com/package/@web3-react/core)
- [`@web3-react/types`](https://www.npmjs.com/package/@web3-react/types)
- [`@web3-react/coinbase-wallet`](https://www.npmjs.com/package/@web3-react/coinbase-wallet)
- [`@web3-react/walletconnect`](https://www.npmjs.com/package/@web3-react/walletconnect)
- [`@web3-react/network`](https://www.npmjs.com/package/@web3-react/network)
- [`@web3-react/gnosis-safe`](https://www.npmjs.com/package/@web3-react/gnosis-safe)

:::info
This guide uses `web3-react` version 8, which is a beta version.
:::

The core code of this guide can be found in the top level of our [examples repository](https://github.com/Uniswap/examples/tree/main/web3-react), under each connectors' name. For example, the code for the Coinbase Wallet connector can be found in the [coinbase file](https://github.com/Uniswap/examples/blob/main/web3-react/src/libs/coinbase.ts).

## Building a Coinbase Wallet connector

The second connector in the list of prioritized connectors that [we provided](./01-connect-wallet.md/#building-an-injected-connector) as a parameter to [`Web3ReactProvider`](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/libs/components/Web3ContextProvider.tsx) is the *Coinbase Wallet* connector:

```typescript reference title="Creating the prioritized Connectors list" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/connections.ts#L33-L39
```

To connect to a *Coinbase Wallet* connector, we first need to install [`@web3-react/coinbase-wallet`](https://www.npmjs.com/package/@web3-react/coinbase-wallet), as well as [`@coinbase/wallet-sdk`](https://github.com/coinbase/coinbase-wallet-sdk). Having installed the packages, we can import the `CoinbaseWallet` class from `@web3-react/coinbase-wallet`, as well as the `initializeConnector` function from the `@web3-react/core` package:

```typescript reference title="Importing the Coinbase Wallet connector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/coinbase.ts#L1-L2
```
We can now build our connector, supplying the required arguments:

```typescript reference title="Initializing the Coinbase Wallet Connector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/coinbase.ts#L8-L19
```

We pass `CoinbaseWallet` as the type argument to `initializeConnector`'s templated parameter. Similar to the case of the `InjectedConnector`, the `CoinbaseWallet` class is a class that extends the `AbstractConnector` class, which is part of the `@web3-react/core` package. The parameter provided to `initializeConnector` is a function that receives an `actions` object, and expects an instance of `CoinbaseWallet` (to match the type argument) to be returned.

We build the new `CoinbaseWallet` instance by passing the `actions` object, an `options` object, and  an `onError` callback. `onError` handles errors that occur during interaction with the connector, and `options` is used to configure the connector. In our case, we pass the `url`, `appName` and `reloadOnDisconnect` options: `url` is the *RPC URL* to connect to that was provided as an argument to the example application, `appName` is the name of our application, and `reloadOnDisconnect` is a `boolean` that indicates whether the application should reload when the user disconnects from the wallet.

After building the connector, we use its two return types, the `Connector` and it's respective hooks, and build a `Connection` object by setting the connection's type as the Coinbase wallet:

```typescript reference title="Building the Coinbase Wallet Connection" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/coinbase.ts#L20-L24
```

Having built the connector, all that remains is to build the user interface and supply it to our [`ConnectionOptions`](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/libs/components/ConnectionOptions.tsx) component, just as we did with the `InjectedConnector`:

```typescript reference title="Building the Coinbase Wallet component" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/ConnectionOptions.tsx#L39-L46
```
## Building a WalletConnect Wallet connector

The third connector in the list of prioritized connectors that we provided to [`Web3ReactProvider`](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/libs/components/Web3ContextProvider.tsx) is the WalletConnect Wallet connector.

To connect to a WalletConnect Wallet connector, we first need to install [`@web3-react/walletconnect`](https://www.npmjs.com/package/@web3-react/walletconnect), as well as [`@walletconnect/ethereum-provider`](https://www.npmjs.com/package/@walletconnect/ethereum-provider). Having installed the packages, we can import the `WalletConnect` class from `@web3-react/walletconnect`, as well as the `initializeConnector` function from`@web3-react/core` package:

```typescript reference title="Importing the WalletConnect Wallet Connector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/wallet-connect.ts#L1-L2
```
We can now build our connector, supplying the required arguments:

```typescript reference title="Initializing the WalletConnect Wallet Connector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/wallet-connect.ts#L8-L17
```

The main difference from the Coinbase Wallet connector lies in the arguments that the `WalletConnect` class requires to be instantiated. `web3-react` knows about this difference, as we passed the type argument `WalletConnect` to `initializeConnector`, thus specializing the type of `AbstractConnector`. In this case, the class receives three arguments, including `actions` and `onError`, identical to those supplied in the Coinbase Wallet connector case. 

The difference lies in the second argument, which is an `options` object. In this case, we are passing the `rpc` parameter, which is an object that maps the chain ID to the RPC URL to connect to. We have already created this [map](https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/constants.ts#L11) in our [`constants`](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/libs/constants.ts) file using our example's parameters. The other option that we are passing is the `qrcode`, which is a `boolean` that indicates whether the QR code should be displayed in the browser. In our case, we are passing `true` as we want to show the QR code.

Having built the connector, we just need to build the user interface to enable user interaction with the connector, and supply it to our `ConnectionOptions`:
    
```typescript reference title="Building the WalletConnect Wallet component" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/ConnectionOptions.tsx#L49-L56
```
## Building a Network connector

The *Network connector*, alongside the *Gnosis Safe connector*, are two of the connectors that we do not surface through our user interface, but instead we connect to them programmatically. In contrast to the previous *Connectors*, these do not come with any pre-built user interface for the user to interact with. We attempt to connect to them **eagerly** in our [`Web3ContextProvider`](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/libs/components/Web3ContextProvider.tsx) component through a hook:
    
```typescript reference title="Hook to connect eagerly" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/81ec93e97b0afded621e177fe5f34fc9f98f80b0/web3-react/src/libs/components/Web3ContextProvider.tsx#L9-L13
```

The `useEagerlyConnect` hook is called in the `Web3ContextProvider` component and attempts to connect to the Network Connector and the Gnosis Safe Connector. The hook is named **eagerly** as it is called in the component's body as [React effect](https://reactjs.org/docs/hooks-effect.html) when the component is first rendered. In the hook implementation we attempt to call `web3-react`'s `connectEagerly` function if it exists on the connector, otherwise we call `activate` otherwise. The `connectEagerly` function attempts to connect our application to the connector, and **fails silently** if it does not succeed: 

```typescript reference title="Connecting eagerly" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/hooks.ts#L15-L19
```

Before eagerly connecting, we first need to initialize the connectors. We start by building the Network connector, and we first need to install [`@web3-react/network`](https://www.npmjs.com/package/@web3-react/network), and import the `Network` class from it. Note how this Connect does not require any package besides its `web3-react` package to function. We also need to import the `initializeConnector` function from `@web3-react/core`:

```typescript reference title="Importing the Network Connector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/network.ts#L1-L2
```
We can now build our connector, supplying the required arguments:

```typescript reference title="Initializing the Network Connector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/network.ts#L8-L15
```

The main difference from the other connectors lies in the arguments that the `Network` class requires to be instantiated. `web3-react` knows about this difference, as we passed the type argument `Network` to `initializeConnector`, thus specializing the type of `AbstractConnector`. In this case, the class receives `actions`, which is identical to that supplied in the rest of the connectors; `urlMap`, which is an object that maps the chain ID to the RPC URL to connect to, which we have already created in our [`constants`](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/libs/constants.ts) file; and `defaultChainId` which is the chain ID to connect to by default.

After building, the connector, we can create a `Connection` instance by supplying it the return value of the `initializeConnector` function, and the `Network` class:

```typescript reference title="Creating a Network connection" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/network.ts#L16-L20
```
All that remains is to return the constructed `Connection` instance.

## Building a Gnosis Safe connector

Similar to the Network connector, we build the Gnosis Safe connector. We start by first installing [`@web3-react/gnosis-safe`](https://www.npmjs.com/package/@web3-react/gnosis-safe), and import the `GnosisSafe` class from it. We also need to import the `initializeConnector` function from `@web3-react/core`:

```typescript reference title="Importing the Gnosis Safe connector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/gnosis.tsx#L1-L2
```

The Gnosis Safe connector is the simplest of them all, as it does not require any additional parameterization other than `actions`:

```typescript reference title="Initializing a Gnosis Safe Connector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/gnosis.tsx#L6-L9
```

Having initialized the connector, we can now build the `Connection` instance and return it:

```typescript reference title="Creating a Gnosis Safe Connection" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/gnosis.tsx#L10-L14
```

## Next steps

Now that we have gone through building all of the different types of supported connectors, we will learn how to [switch chains](03-switch-chains.md).
</file>

<file path="docs/sdk/web3-react/guides/switch-chains.md">
---
id: switch-chains
title: Switching Chains
sidebar_position: 3
---     

## Introduction

This guide will cover how to prompt a wallet that has connected to our dApp to switch chains using `web3-react`. It is based on the [`web3-react` example](https://github.com/Uniswap/examples/tree/main/web3-react), found in the Uniswap code examples [repository](https://github.com/Uniswap/examples). To run this example, check out the examples's [README](https://github.com/Uniswap/examples/blob/main/web3-react/README.md) and follow the setup instructions.


:::info
For help on setting up `web3-react` and interacting with a MetaMask wallet, please visit our [connecting to wallets](./01-connect-wallet.md) page!
:::


The input parameters to this guide are the chains that we want our dApp to be able to connect to and their RPC URLs.

At the end of the guide, we should be able to switch chains on the connected wallet.

For this guide, the following `web3-react` packages are used:

- [`@web3-react/core`](https://www.npmjs.com/package/@web3-react/core)

:::info
This guide uses `web3-react` version 8, which is a beta version.
:::

The core code of this guide can be found in [connections](https://github.com/Uniswap/examples/blob/feat/web3-react/web3-react/src/libs/connections.ts).

## Switching Chains

Having [setup our application](./01-connect-wallet.md) to use `web3-react` and having built out the ability to [connect and disconnect wallets](./02-connectors.md), we can now move on to switching chains.

Switching chains requires two parameters, the `chainId` we want to switch to, and the current `connectionType`:

```typescript reference title="Defining the function" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/connections.ts#L64
```

Given the `ConnectionType`, we can retrieve the actual connector:

```typescript reference title="Retrieving the connector" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/connections.ts#L69
```

Then, depending on the `ConnectionType`, we determine how to switch chains. For the `Network` or `WalletConnect` cases, we call `web3-react`'s `activate` function with the supplied `chainId`:

```typescript reference title="Switching chains for Network and WalletConnect" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/connections.ts#L71-L74
```

The rest of the connectors require us to build an `AddEthereumChainParameter` object and pass it to the `web3-react`'s `activate` function:

```typescript reference title="Switching chains the other Connectors" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/connections.ts#L77-L84
```

The metadata required to build `AddEthereumChainParameter`  are defined in our constants file:
    
```typescript reference title="Defining the chain parameters" referenceLinkText="View on GitHub" customStyling
https://github.com/Uniswap/examples/blob/8c0e36ca8d2ba4718af944094191f39da62a9c5c/web3-react/src/libs/constants.ts#L27-L40
```

## Next steps

Now you know how to support `web3-react`'s most common use cases! Stay tuned for follow up guides.
</file>

<file path="docs/sdk/web3-react/_category_.json">
{
  "label": "web3-react",
  "position": 3,
  "collapsed": true
}
</file>

<file path="docs/sdk/web3-react/overview.md">
---
id: overview
sidebar_position: 1
title: Overview
---
# `web3-react`

> **Welcome to `web3-react`!**

`web3-react` provides abstractions to assist you with connecting your dApp to web3 connectors and exposes methods to interact with those connections. It currently supports connecting to the following wallets:
- Network
- Injected wallets (eg MetaMask)
- Gnosis safe
- Coinbase wallet
- WalletConnect wallet

To begin, we recommend looking at our [guides](./guides/01-connect-wallet.md) which include [runnable examples](https://github.com/Uniswap/examples/tree/main/web3-react) and walkthroughs of core usages. These guides will help you better understand how to use `web3-react` and integrate it into your application.

:::info
This guide uses `web3-react` version 8, which is a beta version.
:::

## Installation

`web3-react` consists of many packages, each providing different functionalities. The [core](https://www.npmjs.com/package/@web3-react/core) package exposes the methods used to interact with web3 connectors, the [types](https://www.npmjs.com/package/@web3-react/types) package declares useful types, while the others are installed to enable interactions with different connectors.

To interact with `web3-react` we recommend installing though npm:

```bash
npm install --save @web3-react/core
```

or yarn:

```bash
yarn add @web3-react/core
```

## Developer Links

- [**`web3-react` on GitHub**](https://github.com/Uniswap/web3-react)

[![npm version](https://img.shields.io/npm/v/@web3-react/core/latest.svg)](https://www.npmjs.com/package/@web3-react/core/v/latest)
[![npm bundle size (scoped version)](https://img.shields.io/bundlephobia/minzip/@web3-react/core/latest.svg)](https://bundlephobia.com/result?p=@web3-react/core@latest)
[![Discord](https://img.shields.io/badge/discord-join%20chat-blue.svg)](https://discord.com/channels/597638925346930701/607978109089611786)
</file>

<file path="docs/universal-router-legacy/overview.md">
---
id: overview
title: Overview
sidebar_position: 1
---

The `UniversalRouter` is an ETH, ERC20, and NFT swap router, that can aggregate trades across protocols to give users access to highly-flexible and personalised transactions. The contract is unowned, and is not upgradeable.

The flexible command style allows us to provide users with:

- Splitting and interleaving of Uniswap trades
- Purchases of NFTs across 8 marketplaces
- Partial fills of trades
- Wrapping and Unwrapping of ETH
- Time-bound, signature controlled token approvals using [Permit2](../contracts/permit2/overview.md)

Transactions are encoded using a string of commands, allowing users to have maximum flexibility over what they want to perform. With all of these features available in a single transaction, the possibilities available to users are endless.

_Note: The `UniversalRouter` uses `Permit2` to remove the need for token approvals being provided directly to the `UniversalRouter`. The `Permit2` documentation can be found [here](../contracts/permit2/overview.md)._
</file>

<file path="docs/universal-router-legacy/technical-reference.md">
---
id: technical-reference
title: Technical Reference
sidebar_position: 2
---

## Functions

Transactions to the `UniversalRouter` all go through the `UniversalRouter.execute` functions:

- `execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)`
- `execute(bytes calldata commands, bytes[] calldata inputs)`

The first of these functions adds the functionality to allow transactions to have a transaction deadline. If the `block.timestamp` is after the `deadline` provided the transaction will revert. After that check, the 2 functions otherwise execute identically.

The `execute` functions work like a simplified VM - they take in a list of commands, and a list of inputs for the commands and execute them in the order specified.

## Command Structure

The first parameter for the function (`bytes calldata commands`) is a list of commands for the contract to execute, in the order they should be executed. Each command is encoded in 1 byte, containing the following split of 8 bits:

| 0   | 1 2 | 3 4 5 6 7 |
| :-- | :-- | :-------- |
| f   | r   | command   |

### `f`

A single bit flag, that signals whether or not the command should be allowed to revert without the whole transaction failing.

- If `f` is `0` aka `false` and the command reverts, then the entire transaction will revert and none of the commands will be executed.
- If `f` is `1` aka `true` and the command reverts, then the transaction will continue, allowing us to achieve partial fills. If using this flag, be careful to include further commands that will remove any funds that could be left unused in the `UniversalRouter` contract.

### `r`

2 unused bits, reserved for future use. Leaving these 2 bits as `0` will save gas, but any value passed into the contract will be ignored. Later versions of the `UniversalRouter` will likely expand the 5 bits used for `command` to use at least 1 of these bits.

### `command`

A 5 bit unique identifier for the command that should be carried out. The values of these commands can be found within [Commands.sol](https://github.com/Uniswap/universal-router/blob/main/contracts/libraries/Commands.sol), or can be viewed in the table below.

The command types that are not defined do not have an assigned command at this moment in time. Providing one of these identifiers will cause the transaction to revert with `InvalidCommandType`.

A complete list of commands can be found in the table below:

| Command | Value                                                                                    |
| :------ | :--------------------------------------------------------------------------------------- |
| `0x00`  | [`V3_SWAP_EXACT_IN`](./02-technical-reference.md#v3_swap_exact_in)                       |
| `0x01`  | [`V3_SWAP_EXACT_OUT`](./02-technical-reference.md#v3_swap_exact_out)                     |
| `0x02`  | [`PERMIT2_TRANSFER_FROM`](./02-technical-reference.md#permit2_transfer_from)             |
| `0x03`  | [`PERMIT2_PERMIT_BATCH`](./02-technical-reference.md#permit2_permit_batch)               |
| `0x04`  | [`SWEEP`](./02-technical-reference.md#sweep)                                             |
| `0x05`  | [`TRANSFER`](./02-technical-reference.md#transfer)                                       |
| `0x06`  | [`PAY_PORTION`](./02-technical-reference.md#pay_portion)                                 |
| `0x07`  |                                                                                          |
| `0x08`  | [`V2_SWAP_EXACT_IN`](./02-technical-reference.md#v2_swap_exact_in)                       |
| `0x09`  | [`V2_SWAP_EXACT_OUT`](./02-technical-reference.md#v2_swap_exact_out)                     |
| `0x0a`  | [`PERMIT2_PERMIT`](./02-technical-reference.md#permit2_permit)                           |
| `0x0b`  | [`WRAP_ETH`](./02-technical-reference.md#wrap_eth)                                       |
| `0x0c`  | [`UNWRAP_WETH`](./02-technical-reference.md#unwrap_weth)                                 |
| `0x0d`  | [`PERMIT2_TRANSFER_FROM_BATCH`](./02-technical-reference.md#permit2_transfer_from_batch) |
| `0x0e`  |                                                                                          |
| `0x0f`  |                                                                                          |
| `0x10`  | [`SEAPORT`](./02-technical-reference.md#seaport)                                         |
| `0x11`  | [`LOOKS_RARE_721`](./02-technical-reference.md#looks_rare_721)                           |
| `0x12`  | [`NFTX`](./02-technical-reference.md#nftx)                                               |
| `0x13`  | [`CRYPTOPUNKS`](./02-technical-reference.md#cryptopunks)                                 |
| `0x14`  | [`LOOKS_RARE_1155`](./02-technical-reference.md#looks_rare_1155)                         |
| `0x15`  | [`OWNER_CHECK_721`](./02-technical-reference.md#owner_check_721)                         |
| `0x16`  | [`OWNER_CHECK_1155`](./02-technical-reference.md#owner_check_1155)                       |
| `0x17`  | [`SWEEP_ERC721`](./02-technical-reference.md#sweep_erc721)                               |
| `0x18`  | [`X2Y2_721`](./02-technical-reference.md#x2y2_721)                                       |
| `0x19`  | [`SUDOSWAP`](./02-technical-reference.md#sudoswap)                                       |
| `0x1a`  | [`NFT20`](./02-technical-reference.md#nft20)                                             |
| `0x1b`  | [`X2Y2_1155`](./02-technical-reference.md#x2y2_1155)                                     |
| `0x1c`  | [`FOUNDATION`](./02-technical-reference.md#foundation)                                   |
| `0x1d`  | [`SWEEP_ERC1155`](./02-technical-reference.md#sweep_erc1155)                             |
| `0x1e`  |                                                                                          |
| `0x1f`  |                                                                                          |

## Command Inputs

The second parameter for the function is an array of bytes strings. Each element in the array is the abi-encoded input that will be used for the respective command.

`commands[i]` is the command that will use `inputs[i]` as its encoded input parameters.

The router uses the command type to know how to decode the encoded input parameters - depending on the command chosen, the required inputs is different.

The input parameters required for each command are outlined below:

### `V3_SWAP_EXACT_IN`

- `address` The recipient of the output of the trade
- `uint256` The amount of input tokens for the trade
- `uint256` The minimum amount of output tokens the user wants
- `bytes` The UniswapV3 encoded path to trade along
- `bool` A flag for whether the input tokens should come from the `msg.sender` (through Permit2) or whether the funds are already in the `UniversalRouter`

### `V3_SWAP_EXACT_OUT`

- `address` The recipient of the output of the trade
- `uint256` The amount of output tokens to receive
- `uint256` The maximum number of input tokens that should be spent
- `bytes` The UniswapV3 encoded path to trade along
- `bool` A flag for whether the input tokens should come from the `msg.sender` (through Permit2) or whether the funds are already in the `UniversalRouter`

### `PERMIT2_TRANSFER_FROM`

- `address` The token to fetch from Permit2
- `address` The recipient of the tokens fetched
- `uint256` The amount of token to fetch

The individual that the tokens are fetched from is always the `msg.sender` of the transaction

### `PERMIT2_PERMIT_BATCH`

- `IAllowanceTransfer.PermitBatch` A `PermitBatch` struct outlining all of the Permit2 permits to execute.
- `bytes` The signature to provide to Permit2

The individual that signed the permits must be the `msg.sender` of the transaction

### `SWEEP`

- `address` The ERC20 token to sweep (or Constants.ETH for ETH)
- `address` The recipient of the sweep
- `uint256` The minimum required tokens to receive from the sweep

### `TRANSFER`

- `address` The ERC20 token to transfer (or Constants.ETH for ETH)
- `address` The recipient of the transfer
- `uint256` The amount to transfer

### `PAY_PORTION`

- `address` The ERC20 token to transfer (or Constants.ETH for ETH)
- `address` The recipient of the transfer
- `uint256` In basis points, the percentage of the contract’s balance to transfer

### `V2_SWAP_EXACT_IN`

- `address` The recipient of the output of the trade
- `uint256` The amount of input tokens for the trade
- `uint256` The minimum amount of output tokens the user wants
- `address[]` The UniswapV2 token path to trade along
- `bool` A flag for whether the input tokens should come from the `msg.sender` (through Permit2) or whether the funds are already in the `UniversalRouter`

### `V2_SWAP_EXACT_OUT`

- `address` The recipient of the output of the trade
- `uint256` The amount of output tokens to receive
- `uint256` The maximum number of input tokens that should be spent
- `address[]` The UniswapV2 token path to trade along
- `bool` A flag for whether the input tokens should come from the `msg.sender` (through Permit2) or whether the funds are already in the `UniversalRouter`

### `PERMIT2_PERMIT`

- `IAllowanceTransfer.PermitSingle` A `PermitSingle` struct outlining the Permit2 permit to execute
- `bytes` The signature to provide to Permit2

The individual that signed the permit must be the `msg.sender` of the transaction

### `WRAP_ETH`

- `address` The recipient of the WETH
- `uint256` The amount of ETH to wrap

### `UNWRAP_WETH`

- `address` The recipient of the ETH
- `uint256` The minimum required ETH to receive from the unwrapping

### `PERMIT2_TRANSFER_FROM_BATCH`

- `IAllowanceTransfer.AllowanceTransferDetails[]` An array of `AllowanceTransferDetails` structs that each describe a Permit2 transfer to perform

### `SEAPORT`

- `uint256` The ETH value to forward to the Seaport contract
- `bytes` The calldata to use to call the Seaport contract

### `LOOKS_RARE_721`

- `uint256` The ETH value to forward to the LooksRare contract
- `bytes` The calldata to use to call the LooksRare contract
- `address` The recipient of the ERC721
- `address` The ERC721 token address
- `uint256` The ID of the ERC721

### `NFTX`

- `uint256` The ETH value to forward to the NFTX contract
- `bytes` The calldata to use to call the NFTX contract

### `CRYPTOPUNKS`

- `uint256` The PunkID to purchase
- `address` The recipient for the cryptopunk
- `uint256` The ETH value to forward to the Cryptopunks contract

### `LOOKS_RARE_1155`

- `uint256` The ETH value to forward to the LooksRare contract
- `bytes` The calldata to use to call the LooksRare contract
- `address` The recipient of the ERC1155
- `address` The ERC1155 token address
- `uint256` The ID of the ERC1155
- `uint256` The amount of the ERC1155 to transfer

### `OWNER_CHECK_721`

- `address` The required owner of the ERC721
- `address` The ERC721 token address
- `uint256` The ID of the ERC721

### `OWNER_CHECK_1155`

- `address` The required owner of the ERC1155
- `address` The ERC721 token address
- `uint256` The ID of the ERC1155
- `uint256` The minimum required amount of the ERC1155

### `SWEEP_ERC721`

- `address` The ERC721 token address to transfer
- `address` The recipient of the transfer
- `uint256` The token ID to transfer

### `X2Y2_721`

- `uint256` The ETH value to forward to the X2Y2 contract
- `bytes` The calldata to use to call the X2Y2 contract
- `address` The recipient of the ERC721
- `address` The ERC721 token address
- `uint256` The ID of the ERC721

### `SUDOSWAP`

- `uint256` The ETH value to forward to the Sudoswap contract
- `bytes` The calldata to use to call the Sudoswap contract

### `NFT20`

- `uint256` The ETH value to forward to the NFT20 contract
- `bytes` The calldata to use to call the NFT20 contract

### `X2Y2_1155`

- `uint256` The ETH value to forward to the X2Y2 contract
- `bytes` The calldata to use to call the X2Y2 contract
- `address` The recipient of the ERC1155
- `address` The ERC1155 token address
- `uint256` The ID of the ERC1155
- `uint256` The amount of the ERC1155 to transfer

### `FOUNDATION`

- `uint256` The ETH value to forward to the Foundation contract
- `bytes` The calldata to use to call the Foundation contract
- `address` The recipient of the ERC721
- `address` The ERC721 token address
- `uint256` The ID of the ERC721

### `SWEEP_ERC1155`

- `address` The ERC1155 token address to sweep
- `address` The recipient of the sweep
- `uint256` The token ID to sweep
- `uint256` The minimum required tokens to receive from the sweep

## Example: Reverting Commands

For a Sudoswap command, that should be _allowed to revert_, the following 8 bit command should be provided:

```markdown
command = 0x80 (10000000) && 0x19 (00011001) = 0x99 (10011001)
```

Take care when working with reverting commands - ensure you have appended commands to deal with funds that could remain in the contract after either outcomes. For example, if the Sudoswap command reverts, a following `SWEEP` can be added to ensure that any ETH that was not spent does not get left in the router.
</file>

</files>
