This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.js, **/*.ts, **/*.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    deploy.yml
    forge.yml
    lint.yml
    test.yml
  CODEOWNERS
audit/
  ABDK_Uniswap_UniversalRouter_v_2_0.pdf
  DRAFT_ABDK_audit_periphery_universal_router.pdf
  DRAFT_Spearbit_audit_UR.pdf
  OpenZeppelin_audit_periphery_universal_router.pdf
  Universal Router 2.1 And V4 Periphery Audit.pdf
contracts/
  base/
    Dispatcher.sol
    Lock.sol
    RouteSigner.sol
  deploy/
    UnsupportedProtocol.sol
  interfaces/
    external/
      IV3SpokePool.sol
    IUniversalRouter.sol
  libraries/
    Commands.sol
    Constants.sol
    Locker.sol
    MaxInputAmount.sol
  modules/
    uniswap/
      v2/
        UniswapV2Library.sol
        V2SwapRouter.sol
      v3/
        BytesLib.sol
        V3Path.sol
        V3SwapRouter.sol
      v4/
        V4SwapRouter.sol
      UniswapImmutables.sol
    ChainedActions.sol
    MigratorImmutables.sol
    Payments.sol
    PaymentsImmutables.sol
    Permit2Payments.sol
    V3ToV4Migrator.sol
  test/
    ExampleModule.sol
    ImportsForTypechain.sol
    MintableERC20.sol
    ReenteringWETH.sol
    TestCustomErrors.sol
  types/
    RouterParameters.sol
  UniversalRouter.sol
script/
  deployParameters/
    DeployArbitrum.s.sol
    DeployArbitrumGoerli.s.sol
    DeployAvalanche.s.sol
    DeployBase.s.sol
    DeployBaseGoerli.s.sol
    DeployBaseSepolia.s.sol
    DeployBlast.s.sol
    DeployBSC.s.sol
    DeployCelo.s.sol
    DeployCeloAlfajores.s.sol
    DeployGoerli.s.sol
    DeployInk.s.sol
    DeployMainnet.s.sol
    DeployOPSepolia.s.sol
    DeployOptimism.s.sol
    DeployOptimismGoerli.s.sol
    DeployPolygon.s.sol
    DeployPolygonMumbai.s.sol
    DeploySepolia.s.sol
    DeploySoneium.s.sol
    DeployUnichain.s.sol
    DeployUnichainSepolia.s.sol
    DeployWorldchain.s.sol
    DeployZora.s.sol
  DeployUniversalRouter.s.sol
test/
  foundry-tests/
    external/
      ChainedActions.fork.t.sol
    mock/
      MockERC20.sol
    uniswapTokens/
      v2DaiWeth.t.sol
      v2MockMock.t.sol
      v2MockWeth.t.sol
      v2WethApe.t.sol
    Locker.t.sol
    MaxInputAmount.t.sol
    RouteSigner.t.sol
    UniswapV2.t.sol
    UniversalRouter.t.sol
  integration-tests/
    gas-tests/
      __snapshots__/
        CheckOwnership.gas.test.ts.snap
        Payments.gas.test.ts.snap
        Uniswap.gas.test.ts.snap
        UniversalRouter.gas.test.ts.snap
        UniversalVSSwapRouter.gas.test.ts.snap
        V3ToV4Migration.gas.test.ts.snap
.env.example
.gitignore
.gitmodules
.nvmrc
.prettierignore
.prettierrc
foundry.lock
foundry.toml
LICENSE
README.md
remappings.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/deploy.yml">
name: Release
on:
  # manual trigger
  workflow_dispatch:

jobs:
  deploy:
    name: release
    runs-on:
      group: npm-deploy
    environment:
      name: release
    permissions:
      id-token: write
      contents: write
    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Setup Node
        uses: actions/setup-node@a0853c24544627f65ddf259abe73b1d18a591444 # v5
        with:
          cache: yarn
          node-version: 20
          registry-url: 'https://registry.npmjs.org'

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@50d5a8956f2e319df19e6b57539d7e2acb9f8c1e # v1.5.0
        with:
          version: v1.4.3

      - name: Install dependencies
        run: |
          yarn install --immutable --immutable-cache
          git submodule update --init --recursive

      - name: Compile
        run: yarn compile

      - name: Install npm
        run: npm install -g npm@11.6.2

      - name: Release
        run: npm publish
</file>

<file path=".github/workflows/forge.yml">
name: Forge Tests

on:
  push:
    branches:
      - main
  pull_request:

env:
  FOUNDRY_PROFILE: ci

jobs:
  check:
    strategy:
      fail-fast: true

    name: Foundry project
    runs-on: ubuntu-latest
    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          submodules: recursive

    # Must Install node modules for forge to reference in remappings
      - uses: actions/setup-node@7c12f8017d5436eb855f1ed4399f037a36fbd9e8 # v2
        with:
          node-version: 18.x
          registry-url: https://registry.npmjs.org

      - name: Install Yarn
        run: npm install -g yarn

      - id: yarn-cache
        run: echo "::set-output name=dir::$(yarn cache dir)"

      - uses: actions/cache@6f8efc29b200d32929f49075959781ed54ec270c # v3.5.0
        with:
          path: ${{ steps.yarn-cache.outputs.dir }}
          key: yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            yarn-
      - name: Install dependencies
        run: yarn install --frozen-lockfile
    # End of node module support

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@50d5a8956f2e319df19e6b57539d7e2acb9f8c1e # v1.5.0
        with:
          version: v1.4.3

      - name: Run Forge build
        run: |
          forge --version
          forge build --sizes
        id: build

      - name: Run Forge tests
        run: |
          forge test --isolate -vvv
        id: test
        env:
          FORK_URL: https://mainnet.infura.io/v3/${{ secrets.INFURA_API_KEY }}
</file>

<file path=".github/workflows/lint.yml">
name: Lint

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  run-linters:
    name: Run linters
    runs-on: ubuntu-latest

    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          submodules: recursive

      - name: Set up node
        uses: actions/setup-node@7c12f8017d5436eb855f1ed4399f037a36fbd9e8 # v2
        with:
          node-version: 18.x
          registry-url: https://registry.npmjs.org

      - name: Install Yarn
        run: npm install -g yarn

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@50d5a8956f2e319df19e6b57539d7e2acb9f8c1e # v1.5.0
        with:
          version: v1.4.3

      - name: Run Forge build
        run: |
          forge --version
          forge build --sizes
        id: build

      - name: Run linter
        run: yarn run lint:check
</file>

<file path=".github/workflows/test.yml">
name: Hardhat Tests

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  integration-tests:
    name: Unit Tests
    runs-on: ubuntu-latest

    steps:
      - uses: bullfrogsec/bullfrog@1831f79cce8ad602eef14d2163873f27081ebfb3 # v0.8.4

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          submodules: recursive

      - uses: actions/setup-node@7c12f8017d5436eb855f1ed4399f037a36fbd9e8 # v2
        with:
          node-version: 18.x
          registry-url: https://registry.npmjs.org

      - name: Install Yarn
        run: npm install -g yarn

      - id: yarn-cache
        run: echo "::set-output name=dir::$(yarn cache dir)"

      - uses: actions/cache@6f8efc29b200d32929f49075959781ed54ec270c # v3.5.0
        with:
          path: ${{ steps.yarn-cache.outputs.dir }}
          key: yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            yarn-

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@50d5a8956f2e319df19e6b57539d7e2acb9f8c1e # v1.5.0
        with:
          version: v1.4.3

      # This is required separately from yarn test because it generates the typechain definitions
      - name: Compile
        run: yarn compile

      - name: Run Integration tests
        run: yarn test:hardhat
        env:
          INFURA_API_KEY: ${{ secrets.INFURA_API_KEY }}
</file>

<file path=".github/CODEOWNERS">
* @uniswap/protocols
</file>

<file path="contracts/base/Dispatcher.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

import {V2SwapRouter} from '../modules/uniswap/v2/V2SwapRouter.sol';
import {V3SwapRouter} from '../modules/uniswap/v3/V3SwapRouter.sol';
import {V4SwapRouter} from '../modules/uniswap/v4/V4SwapRouter.sol';
import {BytesLib} from '../modules/uniswap/v3/BytesLib.sol';
import {Payments} from '../modules/Payments.sol';
import {PaymentsImmutables} from '../modules/PaymentsImmutables.sol';
import {V3ToV4Migrator} from '../modules/V3ToV4Migrator.sol';
import {Commands} from '../libraries/Commands.sol';
import {Lock} from './Lock.sol';
import {ERC20} from 'solmate/src/tokens/ERC20.sol';
import {IAllowanceTransfer} from 'permit2/src/interfaces/IAllowanceTransfer.sol';
import {ActionConstants} from '@uniswap/v4-periphery/src/libraries/ActionConstants.sol';
import {CalldataDecoder} from '@uniswap/v4-periphery/src/libraries/CalldataDecoder.sol';
import {PoolKey} from '@uniswap/v4-core/src/types/PoolKey.sol';
import {IPoolManager} from '@uniswap/v4-core/src/interfaces/IPoolManager.sol';
import {ChainedActions} from '../modules/ChainedActions.sol';

/// @title Decodes and Executes Commands
/// @notice Called by the UniversalRouter contract to efficiently decode and execute a singular command
abstract contract Dispatcher is
    Payments,
    V2SwapRouter,
    V3SwapRouter,
    V4SwapRouter,
    V3ToV4Migrator,
    Lock,
    ChainedActions
{
    using BytesLib for bytes;
    using CalldataDecoder for bytes;

    error InvalidCommandType(uint256 commandType);
    error BalanceTooLow();

    /// @notice Executes encoded commands along with provided inputs.
    /// @param commands A set of concatenated commands, each 1 byte in length
    /// @param inputs An array of byte strings containing abi encoded inputs for each command
    function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;

    /// @notice Public view function to be used instead of msg.sender, as the contract performs self-reentrancy and at
    /// times msg.sender == address(this). Instead msgSender() returns the initiator of the lock
    /// @dev overrides BaseActionsRouter.msgSender in V4Router
    function msgSender() public view override returns (address) {
        return _getLocker();
    }

    /// @notice Decodes and executes the given command with the given inputs
    /// @param commandType The command type to execute
    /// @param inputs The inputs to execute the command with
    /// @dev 2 masks are used to enable use of a nested-if statement in execution for efficiency reasons
    /// @return success True on success of the command, false on failure
    /// @return output The outputs or error messages, if any, from the command
    function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {
        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);

        success = true;

        // 0x00 <= command < 0x21
        if (command < Commands.EXECUTE_SUB_PLAN) {
            // 0x00 <= command < 0x10
            if (command < Commands.V4_SWAP) {
                // 0x00 <= command < 0x08
                if (command < Commands.V2_SWAP_EXACT_IN) {
                    if (command == Commands.V3_SWAP_EXACT_IN) {
                        // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))
                        address recipient;
                        uint256 amountIn;
                        uint256 amountOutMin;
                        bool payerIsUser;
                        assembly {
                            recipient := calldataload(inputs.offset)
                            amountIn := calldataload(add(inputs.offset, 0x20))
                            amountOutMin := calldataload(add(inputs.offset, 0x40))
                            // 0x60 offset is the path, decoded below
                            payerIsUser := calldataload(add(inputs.offset, 0x80))
                        }
                        bytes calldata path = inputs.toBytes(3);
                        address payer = payerIsUser ? msgSender() : address(this);
                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);
                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {
                        // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))
                        address recipient;
                        uint256 amountOut;
                        uint256 amountInMax;
                        bool payerIsUser;
                        assembly {
                            recipient := calldataload(inputs.offset)
                            amountOut := calldataload(add(inputs.offset, 0x20))
                            amountInMax := calldataload(add(inputs.offset, 0x40))
                            // 0x60 offset is the path, decoded below
                            payerIsUser := calldataload(add(inputs.offset, 0x80))
                        }
                        bytes calldata path = inputs.toBytes(3);
                        address payer = payerIsUser ? msgSender() : address(this);
                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);
                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {
                        // equivalent: abi.decode(inputs, (address, address, uint160))
                        address token;
                        address recipient;
                        uint160 amount;
                        assembly {
                            token := calldataload(inputs.offset)
                            recipient := calldataload(add(inputs.offset, 0x20))
                            amount := calldataload(add(inputs.offset, 0x40))
                        }
                        permit2TransferFrom(token, msgSender(), map(recipient), amount);
                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {
                        IAllowanceTransfer.PermitBatch calldata permitBatch;
                        assembly {
                            // this is a variable length struct, so calldataload(inputs.offset) contains the
                            // offset from inputs.offset at which the struct begins
                            permitBatch := add(inputs.offset, calldataload(inputs.offset))
                        }
                        bytes calldata data = inputs.toBytes(1);
                        (success, output) = address(PERMIT2)
                            .call(
                                abi.encodeWithSignature(
                                    'permit(address,((address,uint160,uint48,uint48)[],address,uint256),bytes)',
                                    msgSender(),
                                    permitBatch,
                                    data
                                )
                            );
                    } else if (command == Commands.SWEEP) {
                        // equivalent:  abi.decode(inputs, (address, address, uint256))
                        address token;
                        address recipient;
                        uint160 amountMin;
                        assembly {
                            token := calldataload(inputs.offset)
                            recipient := calldataload(add(inputs.offset, 0x20))
                            amountMin := calldataload(add(inputs.offset, 0x40))
                        }
                        Payments.sweep(token, map(recipient), amountMin);
                    } else if (command == Commands.TRANSFER) {
                        // equivalent:  abi.decode(inputs, (address, address, uint256))
                        address token;
                        address recipient;
                        uint256 value;
                        assembly {
                            token := calldataload(inputs.offset)
                            recipient := calldataload(add(inputs.offset, 0x20))
                            value := calldataload(add(inputs.offset, 0x40))
                        }
                        Payments.pay(token, map(recipient), value);
                    } else if (command == Commands.PAY_PORTION) {
                        // equivalent:  abi.decode(inputs, (address, address, uint256))
                        address token;
                        address recipient;
                        uint256 bips;
                        assembly {
                            token := calldataload(inputs.offset)
                            recipient := calldataload(add(inputs.offset, 0x20))
                            bips := calldataload(add(inputs.offset, 0x40))
                        }
                        Payments.payPortion(token, map(recipient), bips);
                    } else {
                        // placeholder area for command 0x07
                        revert InvalidCommandType(command);
                    }
                } else {
                    // 0x08 <= command < 0x10
                    if (command == Commands.V2_SWAP_EXACT_IN) {
                        // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))
                        address recipient;
                        uint256 amountIn;
                        uint256 amountOutMin;
                        bool payerIsUser;
                        assembly {
                            recipient := calldataload(inputs.offset)
                            amountIn := calldataload(add(inputs.offset, 0x20))
                            amountOutMin := calldataload(add(inputs.offset, 0x40))
                            // 0x60 offset is the path, decoded below
                            payerIsUser := calldataload(add(inputs.offset, 0x80))
                        }
                        address[] calldata path = inputs.toAddressArray(3);
                        address payer = payerIsUser ? msgSender() : address(this);
                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);
                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {
                        // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))
                        address recipient;
                        uint256 amountOut;
                        uint256 amountInMax;
                        bool payerIsUser;
                        assembly {
                            recipient := calldataload(inputs.offset)
                            amountOut := calldataload(add(inputs.offset, 0x20))
                            amountInMax := calldataload(add(inputs.offset, 0x40))
                            // 0x60 offset is the path, decoded below
                            payerIsUser := calldataload(add(inputs.offset, 0x80))
                        }
                        address[] calldata path = inputs.toAddressArray(3);
                        address payer = payerIsUser ? msgSender() : address(this);
                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);
                    } else if (command == Commands.PERMIT2_PERMIT) {
                        // equivalent: abi.decode(inputs, (IAllowanceTransfer.PermitSingle, bytes))
                        IAllowanceTransfer.PermitSingle calldata permitSingle;
                        assembly {
                            permitSingle := inputs.offset
                        }
                        bytes calldata data = inputs.toBytes(6); // PermitSingle takes first 6 slots (0..5)
                        (success, output) = address(PERMIT2)
                            .call(
                                abi.encodeWithSignature(
                                    'permit(address,((address,uint160,uint48,uint48),address,uint256),bytes)',
                                    msgSender(),
                                    permitSingle,
                                    data
                                )
                            );
                    } else if (command == Commands.WRAP_ETH) {
                        // equivalent: abi.decode(inputs, (address, uint256))
                        address recipient;
                        uint256 amount;
                        assembly {
                            recipient := calldataload(inputs.offset)
                            amount := calldataload(add(inputs.offset, 0x20))
                        }
                        Payments.wrapETH(map(recipient), amount);
                    } else if (command == Commands.UNWRAP_WETH) {
                        // equivalent: abi.decode(inputs, (address, uint256))
                        address recipient;
                        uint256 amountMin;
                        assembly {
                            recipient := calldataload(inputs.offset)
                            amountMin := calldataload(add(inputs.offset, 0x20))
                        }
                        Payments.unwrapWETH9(map(recipient), amountMin);
                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {
                        IAllowanceTransfer.AllowanceTransferDetails[] calldata batchDetails;
                        (uint256 length, uint256 offset) = inputs.toLengthOffset(0);
                        assembly {
                            batchDetails.length := length
                            batchDetails.offset := offset
                        }
                        permit2TransferFrom(batchDetails, msgSender());
                    } else if (command == Commands.BALANCE_CHECK_ERC20) {
                        // equivalent: abi.decode(inputs, (address, address, uint256))
                        address owner;
                        address token;
                        uint256 minBalance;
                        assembly {
                            owner := calldataload(inputs.offset)
                            token := calldataload(add(inputs.offset, 0x20))
                            minBalance := calldataload(add(inputs.offset, 0x40))
                        }
                        success = (ERC20(token).balanceOf(owner) >= minBalance);
                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);
                    } else {
                        // placeholder area for command 0x0f
                        revert InvalidCommandType(command);
                    }
                }
            } else {
                // 0x10 <= command < 0x21
                if (command == Commands.V4_SWAP) {
                    // pass the calldata provided to V4SwapRouter._executeActions (defined in BaseActionsRouter)
                    _executeActions(inputs);
                    // This contract MUST be approved to spend the token since its going to be doing the call on the position manager
                } else if (command == Commands.V3_POSITION_MANAGER_PERMIT) {
                    _checkV3PermitCall(inputs);
                    (success, output) = address(V3_POSITION_MANAGER).call(inputs);
                } else if (command == Commands.V3_POSITION_MANAGER_CALL) {
                    _checkV3PositionManagerCall(inputs, msgSender());
                    (success, output) = address(V3_POSITION_MANAGER).call(inputs);
                } else if (command == Commands.V4_INITIALIZE_POOL) {
                    PoolKey calldata poolKey;
                    uint160 sqrtPriceX96;
                    assembly {
                        poolKey := inputs.offset
                        sqrtPriceX96 := calldataload(add(inputs.offset, 0xa0))
                    }
                    (success, output) =
                        address(poolManager).call(abi.encodeCall(IPoolManager.initialize, (poolKey, sqrtPriceX96)));
                } else if (command == Commands.V4_POSITION_MANAGER_CALL) {
                    // should only call modifyLiquidities() to mint
                    _checkV4PositionManagerCall(inputs);
                    (success, output) = address(V4_POSITION_MANAGER).call{value: address(this).balance}(inputs);
                } else {
                    // placeholder area for commands 0x15-0x20
                    revert InvalidCommandType(command);
                }
            }
        } else if (command < Commands.ACROSS_V4_DEPOSIT_V3) {
            // 0x21 <= command
            if (command == Commands.EXECUTE_SUB_PLAN) {
                (bytes calldata _commands, bytes[] calldata _inputs) = inputs.decodeCommandsAndInputs();
                (success, output) = (address(this)).call(abi.encodeCall(Dispatcher.execute, (_commands, _inputs)));
            } else {
                // placeholder area for commands 0x22-0x3f
                revert InvalidCommandType(command);
            }
        } else {
            if (command == Commands.ACROSS_V4_DEPOSIT_V3) {
                _acrossV4DepositV3(inputs);
            } else {
                // placeholder area for commands 0x41-0x5f
                revert InvalidCommandType(command);
            }
        }
    }

    /// @notice Calculates the recipient address for a command
    /// @param recipient The recipient or recipient-flag for the command
    /// @return output The resultant recipient for the command
    function map(address recipient) internal view returns (address) {
        if (recipient == ActionConstants.MSG_SENDER) {
            return msgSender();
        } else if (recipient == ActionConstants.ADDRESS_THIS) {
            return address(this);
        } else {
            return recipient;
        }
    }
}
</file>

<file path="contracts/base/Lock.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

import {Locker} from '../libraries/Locker.sol';

/// @title Lock
/// @notice A contract that provides a reentrancy lock for external calls
contract Lock {
    /// @notice Thrown when attempting to reenter a locked function from an external caller
    error ContractLocked();

    /// @notice Modifier enforcing a reentrancy lock that allows self-reentrancy
    /// @dev If the contract is not locked, use msg.sender as the locker
    modifier isNotLocked() {
        // Apply a reentrancy lock for all external callers
        if (msg.sender != address(this)) {
            if (Locker.isLocked()) revert ContractLocked();
            Locker.set(msg.sender);
            _;
            Locker.set(address(0));
        } else {
            // The contract is allowed to reenter itself, so the lock is not checked
            _;
        }
    }

    /// @notice return the current locker of the contract
    function _getLocker() internal view returns (address) {
        return Locker.get();
    }
}
</file>

<file path="contracts/base/RouteSigner.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

import {EIP712} from '@openzeppelin/contracts/utils/cryptography/EIP712.sol';
import {ECDSA} from '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';

/// @title RouteSigner
/// @notice Contract for managing signed execution context using transient storage
abstract contract RouteSigner is EIP712 {
    /// @notice Transient storage slot for the route signer address
    /// @dev bytes32(uint256(keccak256("RouteSigner")) - 1)
    bytes32 private constant ROUTE_SIGNER_SLOT = 0xd317c76a4357223a1868125ee857a1f31cabfcec288f6cdd0ea8c52b6a71ee31;

    /// @notice Transient storage slot for the route intent
    /// @dev bytes32(uint256(keccak256("RouteIntent")) - 1)
    bytes32 private constant ROUTE_INTENT_SLOT = 0xa42de8dec63499ed8713dc6815ea14006a1f8e80e1664c66e3beb461bb65b0da;

    /// @notice Transient storage slot for the route data
    /// @dev bytes32(uint256(keccak256("RouteData")) - 1)
    bytes32 private constant ROUTE_DATA_SLOT = 0x17350132762f24cc4b86e10621ea1e0b5c33483a51cca86a1b11e7ed029b6eb6;

    /// @notice EIP712 typehash for signed execution
    bytes32 internal constant EXECUTE_SIGNED_TYPEHASH = keccak256(
        'ExecuteSigned(bytes commands,bytes[] inputs,bytes32 intent,bytes32 data,address sender,bytes32 nonce,uint256 deadline)'
    );

    /// @notice Mapping of used nonces for replay protection
    /// @dev Unordered nonces allow parallel execution of signed routes
    mapping(address user => mapping(bytes32 nonce => bool used)) public noncesUsed;

    /// @notice Thrown when a nonce has already been used
    error NonceAlreadyUsed();

    /// @dev Stores the signature context (signer, intent, data) in transient storage
    function _setSignatureContext(
        bytes calldata commands,
        bytes[] calldata inputs,
        bytes32 intent,
        bytes32 data,
        bool verifySender,
        bytes32 nonce,
        bytes calldata signature,
        uint256 deadline
    ) internal returns (address signer) {
        // Hash the inputs array per EIP712: hash each element, concatenate, then hash again
        uint256 inputsLength = inputs.length;
        bytes32[] memory inputHashes = new bytes32[](inputsLength);
        for (uint256 i = 0; i < inputsLength; ++i) {
            inputHashes[i] = keccak256(inputs[i]);
        }
        bytes32 inputsHash = keccak256(abi.encodePacked(inputHashes));

        // Determine sender for signature verification
        address sender = verifySender ? msg.sender : address(0);

        // Construct EIP712 hash
        bytes32 structHash = keccak256(
            abi.encode(EXECUTE_SIGNED_TYPEHASH, keccak256(commands), inputsHash, intent, data, sender, nonce, deadline)
        );
        bytes32 digest = _hashTypedDataV4(structHash);

        // Recover signer
        signer = ECDSA.recover(digest, signature);

        // Check and mark nonce as used (skip if nonce == bytes32(type(uint256).max))
        if (nonce != bytes32(type(uint256).max)) {
            if (noncesUsed[signer][nonce]) revert NonceAlreadyUsed();
            noncesUsed[signer][nonce] = true;
        }

        // Store signer, intent, and data in transient storage
        assembly ('memory-safe') {
            tstore(ROUTE_SIGNER_SLOT, signer)
            tstore(ROUTE_INTENT_SLOT, intent)
            tstore(ROUTE_DATA_SLOT, data)
        }
    }

    /// @dev Clears the signature context from transient storage
    function _resetSignatureContext() internal {
        assembly ('memory-safe') {
            tstore(ROUTE_SIGNER_SLOT, 0)
            tstore(ROUTE_INTENT_SLOT, 0)
            tstore(ROUTE_DATA_SLOT, 0)
        }
    }

    /// @dev Internal function to read signed route context from transient storage
    function _signedRouteContext() internal view returns (address signer, bytes32 intent, bytes32 data) {
        assembly ('memory-safe') {
            signer := tload(ROUTE_SIGNER_SLOT)
            intent := tload(ROUTE_INTENT_SLOT)
            data := tload(ROUTE_DATA_SLOT)
        }
    }
}
</file>

<file path="contracts/deploy/UnsupportedProtocol.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

/// @title Dummy contract that always reverts
/// @notice Used as a placeholder to ensure reverts on attempted calls to protocols unsupported on a given chain
contract UnsupportedProtocol {
    error UnsupportedProtocolError();

    fallback() external {
        revert UnsupportedProtocolError();
    }
}
</file>

<file path="contracts/interfaces/external/IV3SpokePool.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

interface IV3SpokePool {
    function depositV3(
        address depositor,
        address recipient,
        address inputToken,
        address outputToken,
        uint256 inputAmount,
        uint256 outputAmount,
        uint256 destinationChainId,
        address exclusiveRelayer,
        uint32 quoteTimestamp,
        uint32 fillDeadline,
        uint32 exclusivityDeadline,
        bytes calldata message
    ) external payable;
}
</file>

<file path="contracts/interfaces/IUniversalRouter.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

struct AcrossV4DepositV3Params {
    address depositor; // credited depositor
    address recipient; // destination recipient
    address inputToken; // ERC20 on origin (WETH if bridging ETH)
    address outputToken; // ERC20 on destination (or 0x0)
    uint256 inputAmount; // supports ActionConstants.CONTRACT_BALANCE to use contract's entire balance
    uint256 outputAmount;
    uint256 destinationChainId;
    address exclusiveRelayer; // 0x0 if no exclusivity
    uint32 quoteTimestamp;
    uint32 fillDeadline;
    uint32 exclusivityDeadline;
    bytes message;
    bool useNative; // if true, call is payable with value=inputAmount (inputToken must be WETH)
}

interface IUniversalRouter {
    /// @notice Thrown when a required command has failed
    error ExecutionFailed(uint256 commandIndex, bytes message);

    /// @notice Thrown when attempting to send ETH directly to the contract
    error ETHNotAccepted();

    /// @notice Thrown when executing commands with an expired deadline
    error TransactionDeadlinePassed();

    /// @notice Thrown when attempting to execute commands and an incorrect number of inputs are provided
    error LengthMismatch();

    // @notice Thrown when an address that isn't WETH tries to send ETH to the router without calldata
    error InvalidEthSender();

    /// @notice Executes encoded commands along with provided inputs. Reverts if deadline has expired.
    /// @param commands A set of concatenated commands, each 1 byte in length
    /// @param inputs An array of byte strings containing abi encoded inputs for each command
    /// @param deadline The deadline by which the transaction must be executed
    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external payable;

    /// @notice Executes encoded commands with EIP712 signature verification
    /// @param commands A set of concatenated commands, each 1 byte in length
    /// @param inputs An array of byte strings containing abi encoded inputs for each command
    /// @param intent Application-specific intent identifier
    /// @param data Application-specific data
    /// @param verifySender If true, the signature must include msg.sender; if false, uses address(0)
    /// @param nonce Unordered nonce for replay protection. Use bytes32(type(uint256).max) to skip nonce check
    /// @param signature EIP712 signature authorizing the execution
    /// @param deadline The deadline by which the transaction must be executed
    /// @dev The signer, intent, and data are recovered/stored in transient storage for the duration of execution.
    /// All commands (including nested sub-commands via EXECUTE_SUB_PLAN) are covered by the signature.
    /// The signer, intent, and data can be accessed by commands via signedRouteContext().
    /// External reentrancy is prevented by the isNotLocked modifier on execute(). Internal reentrancy via
    /// EXECUTE_SUB_PLAN is safe as those sub-commands are part of the signed message. There is no way to change
    /// the signer mid-execution as executeSigned cannot be called internally.
    function executeSigned(
        bytes calldata commands,
        bytes[] calldata inputs,
        bytes32 intent,
        bytes32 data,
        bool verifySender,
        bytes32 nonce,
        bytes calldata signature,
        uint256 deadline
    ) external payable;

    /// @notice Returns all signed execution context (signer, intent, data) in a single call
    /// @return signer The address that signed the current execution, or address(0) if not in a signed execution
    /// @return intent The intent value from the signed execution, or bytes32(0) if not in a signed execution
    /// @return data The data value from the signed execution, or bytes32(0) if not in a signed execution
    /// @dev This reads from transient storage which is only set during executeSigned().
    /// @dev When consuming this context from a hook, the hook MUST verify that msg.sender is the
    /// UniversalRouter contract. Otherwise, a malicious contract in the execution chain could abuse the
    /// legitimate signed context by calling other contracts with it, causing unintended side effects.
    function signedRouteContext() external view returns (address signer, bytes32 intent, bytes32 data);
}
</file>

<file path="contracts/libraries/Commands.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

/// @title Commands
/// @notice Command Flags used to decode commands
library Commands {
    // Masks to extract certain bits of commands
    bytes1 internal constant FLAG_ALLOW_REVERT = 0x80;
    bytes1 internal constant COMMAND_TYPE_MASK = 0x7f;

    // Command Types. Maximum supported command at this moment is 0x3f.
    // The commands are executed in nested if blocks to minimise gas consumption

    // Command Types where value<=0x07, executed in the first nested-if block
    uint256 constant V3_SWAP_EXACT_IN = 0x00;
    uint256 constant V3_SWAP_EXACT_OUT = 0x01;
    uint256 constant PERMIT2_TRANSFER_FROM = 0x02;
    uint256 constant PERMIT2_PERMIT_BATCH = 0x03;
    uint256 constant SWEEP = 0x04;
    uint256 constant TRANSFER = 0x05;
    uint256 constant PAY_PORTION = 0x06;
    // COMMAND_PLACEHOLDER = 0x07;

    // Command Types where 0x08<=value<=0x0f, executed in the second nested-if block
    uint256 constant V2_SWAP_EXACT_IN = 0x08;
    uint256 constant V2_SWAP_EXACT_OUT = 0x09;
    uint256 constant PERMIT2_PERMIT = 0x0a;
    uint256 constant WRAP_ETH = 0x0b;
    uint256 constant UNWRAP_WETH = 0x0c;
    uint256 constant PERMIT2_TRANSFER_FROM_BATCH = 0x0d;
    uint256 constant BALANCE_CHECK_ERC20 = 0x0e;
    // COMMAND_PLACEHOLDER = 0x0f;

    // Command Types where 0x10<=value<=0x20, executed in the third nested-if block
    uint256 constant V4_SWAP = 0x10;
    uint256 constant V3_POSITION_MANAGER_PERMIT = 0x11;
    uint256 constant V3_POSITION_MANAGER_CALL = 0x12;
    uint256 constant V4_INITIALIZE_POOL = 0x13;
    uint256 constant V4_POSITION_MANAGER_CALL = 0x14;
    // COMMAND_PLACEHOLDER = 0x15 -> 0x20

    // Command Types where 0x21<=value<=0x3f
    uint256 constant EXECUTE_SUB_PLAN = 0x21;
    // COMMAND_PLACEHOLDER for 0x22 to 0x3f

    // Command Types where 0x40<=value<=0x5f
    // Reserved for 3rd party integrations
    uint256 constant ACROSS_V4_DEPOSIT_V3 = 0x40;
}
</file>

<file path="contracts/libraries/Constants.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

/// @title Constant state
/// @notice Constant state used by the Universal Router
library Constants {
    /// @dev Used for identifying cases when a v2 pair has already received input tokens
    uint256 internal constant ALREADY_PAID = 0;

    /// @dev Used as a flag for identifying the transfer of ETH instead of a token
    address internal constant ETH = address(0);

    /// @dev The length of the bytes encoded address
    uint256 internal constant ADDR_SIZE = 20;

    /// @dev The length of the bytes encoded fee
    uint256 internal constant V3_FEE_SIZE = 3;

    /// @dev The offset of a single token address (20) and pool fee (3)
    uint256 internal constant NEXT_V3_POOL_OFFSET = ADDR_SIZE + V3_FEE_SIZE;

    /// @dev The offset of an encoded pool key
    /// Token (20) + Fee (3) + Token (20) = 43
    uint256 internal constant V3_POP_OFFSET = NEXT_V3_POOL_OFFSET + ADDR_SIZE;

    /// @dev The minimum length of an encoding that contains 2 or more pools
    uint256 internal constant MULTIPLE_V3_POOLS_MIN_LENGTH = V3_POP_OFFSET + NEXT_V3_POOL_OFFSET;
}
</file>

<file path="contracts/libraries/Locker.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

/// @notice A library to implement a reentrancy lock in transient storage.
/// @dev Instead of storing a boolean, the locker's address is stored to allow the contract to know who locked the contract
/// TODO: This library can be deleted when we have the transient keyword support in solidity.
library Locker {
    // The slot holding the locker state, transiently. bytes32(uint256(keccak256("Locker")) - 1)
    bytes32 constant LOCKER_SLOT = 0x0e87e1788ebd9ed6a7e63c70a374cd3283e41cad601d21fbe27863899ed4a708;

    function set(address locker) internal {
        // The locker is always msg.sender or address(0) so does not need to be cleaned
        assembly ('memory-safe') {
            tstore(LOCKER_SLOT, locker)
        }
    }

    function get() internal view returns (address locker) {
        assembly ('memory-safe') {
            locker := tload(LOCKER_SLOT)
        }
    }

    function isLocked() internal view returns (bool) {
        return Locker.get() != address(0);
    }
}
</file>

<file path="contracts/libraries/MaxInputAmount.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

/// @notice A library used to store the maximum desired amount of input tokens for exact output swaps; used for checking slippage
library MaxInputAmount {
    // The slot holding the the maximum desired amount of input tokens, transiently. bytes32(uint256(keccak256("MaxAmountIn")) - 1)
    bytes32 constant MAX_AMOUNT_IN_SLOT = 0xaf28d9864a81dfdf71cab65f4e5d79a0cf9b083905fb8971425e6cb581b3f692;

    function set(uint256 maxAmountIn) internal {
        assembly ('memory-safe') {
            tstore(MAX_AMOUNT_IN_SLOT, maxAmountIn)
        }
    }

    function get() internal view returns (uint256 maxAmountIn) {
        assembly ('memory-safe') {
            maxAmountIn := tload(MAX_AMOUNT_IN_SLOT)
        }
    }
}
</file>

<file path="contracts/modules/uniswap/v2/UniswapV2Library.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.8.0;

import {IUniswapV2Pair} from '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';

/// @title Uniswap v2 Helper Library
/// @notice Calculates the recipient address for a command
library UniswapV2Library {
    error InvalidReserves();
    error InvalidPath();

    /// @notice Calculates the v2 address for a pair without making any external calls
    /// @param factory The address of the v2 factory
    /// @param initCodeHash The hash of the pair initcode
    /// @param tokenA One of the tokens in the pair
    /// @param tokenB The other token in the pair
    /// @return pair The resultant v2 pair address
    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)
        internal
        pure
        returns (address pair)
    {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = pairForPreSorted(factory, initCodeHash, token0, token1);
    }

    /// @notice Calculates the v2 address for a pair and the pair's token0
    /// @param factory The address of the v2 factory
    /// @param initCodeHash The hash of the pair initcode
    /// @param tokenA One of the tokens in the pair
    /// @param tokenB The other token in the pair
    /// @return pair The resultant v2 pair address
    /// @return token0 The token considered token0 in this pair
    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)
        internal
        pure
        returns (address pair, address token0)
    {
        address token1;
        (token0, token1) = sortTokens(tokenA, tokenB);
        pair = pairForPreSorted(factory, initCodeHash, token0, token1);
    }

    /// @notice Calculates the v2 address for a pair assuming the input tokens are pre-sorted
    /// @param factory The address of the v2 factory
    /// @param initCodeHash The hash of the pair initcode
    /// @param token0 The pair's token0
    /// @param token1 The pair's token1
    /// @return pair The resultant v2 pair address
    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)
        private
        pure
        returns (address pair)
    {
        pair = address(
            uint160(
                uint256(
                    keccak256(
                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)
                    )
                )
            )
        );
    }

    /// @notice Calculates the v2 address for a pair and fetches the reserves for each token
    /// @param factory The address of the v2 factory
    /// @param initCodeHash The hash of the pair initcode
    /// @param tokenA One of the tokens in the pair
    /// @param tokenB The other token in the pair
    /// @return pair The resultant v2 pair address
    /// @return reserveA The reserves for tokenA
    /// @return reserveB The reserves for tokenB
    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)
        private
        view
        returns (address pair, uint256 reserveA, uint256 reserveB)
    {
        address token0;
        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);
        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }

    /// @notice Given an input asset amount returns the maximum output amount of the other asset
    /// @param amountIn The token input amount
    /// @param reserveIn The reserves available of the input token
    /// @param reserveOut The reserves available of the output token
    /// @return amountOut The output amount of the output token
    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)
        internal
        pure
        returns (uint256 amountOut)
    {
        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();
        uint256 amountInWithFee = amountIn * 997;
        uint256 numerator = amountInWithFee * reserveOut;
        uint256 denominator = reserveIn * 1000 + amountInWithFee;
        amountOut = numerator / denominator;
    }

    /// @notice Returns the input amount needed for a desired output amount in a single-hop trade
    /// @param amountOut The desired output amount
    /// @param reserveIn The reserves available of the input token
    /// @param reserveOut The reserves available of the output token
    /// @return amountIn The input amount of the input token
    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)
        internal
        pure
        returns (uint256 amountIn)
    {
        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();
        uint256 numerator = reserveIn * amountOut * 1000;
        uint256 denominator = (reserveOut - amountOut) * 997;
        amountIn = (numerator / denominator) + 1;
    }

    /// @notice Returns the input amount needed for a desired output amount in a multi-hop trade
    /// @param factory The address of the v2 factory
    /// @param initCodeHash The hash of the pair initcode
    /// @param amountOut The desired output amount
    /// @param path The path of the multi-hop trade
    /// @return amount The input amount of the input token
    /// @return pair The first pair in the trade
    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)
        internal
        view
        returns (uint256 amount, address pair)
    {
        if (path.length < 2) revert InvalidPath();
        amount = amountOut;
        for (uint256 i = path.length - 1; i > 0; i--) {
            uint256 reserveIn;
            uint256 reserveOut;

            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);
            amount = getAmountIn(amount, reserveIn, reserveOut);
        }
    }

    /// @notice Sorts two tokens to return token0 and token1
    /// @param tokenA The first token to sort
    /// @param tokenB The other token to sort
    /// @return token0 The smaller token by address value
    /// @return token1 The larger token by address value
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
    }
}
</file>

<file path="contracts/modules/uniswap/v2/V2SwapRouter.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

import {IUniswapV2Pair} from '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';
import {UniswapV2Library} from './UniswapV2Library.sol';
import {UniswapImmutables} from '../UniswapImmutables.sol';
import {Permit2Payments} from '../../Permit2Payments.sol';
import {Constants} from '../../../libraries/Constants.sol';
import {ERC20} from 'solmate/src/tokens/ERC20.sol';

/// @title Router for Uniswap v2 Trades
abstract contract V2SwapRouter is UniswapImmutables, Permit2Payments {
    error V2TooLittleReceived();
    error V2TooMuchRequested();
    error V2InvalidPath();

    function _v2Swap(address[] calldata path, address recipient, address pair) private {
        unchecked {
            if (path.length < 2) revert V2InvalidPath();

            // cached to save on duplicate operations
            (address token0,) = UniswapV2Library.sortTokens(path[0], path[1]);
            uint256 finalPairIndex = path.length - 1;
            uint256 penultimatePairIndex = finalPairIndex - 1;
            for (uint256 i; i < finalPairIndex; i++) {
                (address input, address output) = (path[i], path[i + 1]);
                (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();
                (uint256 reserveInput, uint256 reserveOutput) =
                    input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
                uint256 amountInput = ERC20(input).balanceOf(pair) - reserveInput;
                uint256 amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);
                (uint256 amount0Out, uint256 amount1Out) =
                    input == token0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));
                address nextPair;
                (nextPair, token0) = i < penultimatePairIndex
                    ? UniswapV2Library.pairAndToken0For(
                        UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, output, path[i + 2]
                    )
                    : (recipient, address(0));
                IUniswapV2Pair(pair).swap(amount0Out, amount1Out, nextPair, new bytes(0));
                pair = nextPair;
            }
        }
    }

    /// @notice Performs a Uniswap v2 exact input swap
    /// @param recipient The recipient of the output tokens
    /// @param amountIn The amount of input tokens for the trade
    /// @param amountOutMinimum The minimum desired amount of output tokens
    /// @param path The path of the trade as an array of token addresses
    /// @param payer The address that will be paying the input
    function v2SwapExactInput(
        address recipient,
        uint256 amountIn,
        uint256 amountOutMinimum,
        address[] calldata path,
        address payer
    ) internal {
        address firstPair = UniswapV2Library.pairFor(
            UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, path[0], path[1]
        );
        if (
            amountIn != Constants.ALREADY_PAID // amountIn of 0 to signal that the pair already has the tokens
        ) {
            payOrPermit2Transfer(path[0], payer, firstPair, amountIn);
        }

        ERC20 tokenOut = ERC20(path[path.length - 1]);
        uint256 balanceBefore = tokenOut.balanceOf(recipient);

        _v2Swap(path, recipient, firstPair);

        uint256 amountOut = tokenOut.balanceOf(recipient) - balanceBefore;
        if (amountOut < amountOutMinimum) revert V2TooLittleReceived();
    }

    /// @notice Performs a Uniswap v2 exact output swap
    /// @param recipient The recipient of the output tokens
    /// @param amountOut The amount of output tokens to receive for the trade
    /// @param amountInMaximum The maximum desired amount of input tokens
    /// @param path The path of the trade as an array of token addresses
    /// @param payer The address that will be paying the input
    function v2SwapExactOutput(
        address recipient,
        uint256 amountOut,
        uint256 amountInMaximum,
        address[] calldata path,
        address payer
    ) internal {
        (uint256 amountIn, address firstPair) = UniswapV2Library.getAmountInMultihop(
            UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, amountOut, path
        );
        if (amountIn > amountInMaximum) revert V2TooMuchRequested();

        payOrPermit2Transfer(path[0], payer, firstPair, amountIn);
        _v2Swap(path, recipient, firstPair);
    }
}
</file>

<file path="contracts/modules/uniswap/v3/BytesLib.sol">
// SPDX-License-Identifier: GPL-3.0-or-later

/// @title Library for Bytes Manipulation
pragma solidity ^0.8.0;

import {Constants} from '../../../libraries/Constants.sol';
import {CalldataDecoder} from '@uniswap/v4-periphery/src/libraries/CalldataDecoder.sol';

library BytesLib {
    using CalldataDecoder for bytes;

    error SliceOutOfBounds();

    /// @notice Returns the address starting at byte 0
    /// @dev length and overflow checks must be carried out before calling
    /// @param _bytes The input bytes string to slice
    /// @return _address The address starting at byte 0
    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {
        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();
        assembly {
            _address := shr(96, calldataload(_bytes.offset))
        }
    }

    /// @notice Returns the pool details starting at byte 0
    /// @dev length and overflow checks must be carried out before calling
    /// @param _bytes The input bytes string to slice
    /// @return token0 The address at byte 0
    /// @return fee The uint24 starting at byte 20
    /// @return token1 The address at byte 23
    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {
        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();
        assembly {
            let firstWord := calldataload(_bytes.offset)
            token0 := shr(96, firstWord)
            fee := and(shr(72, firstWord), 0xffffff)
            token1 := shr(96, calldataload(add(_bytes.offset, 23)))
        }
    }

    /// @notice Decode the `_arg`-th element in `_bytes` as a dynamic array
    /// @dev The decoding of `length` and `offset` is universal,
    /// whereas the type declaration of `res` instructs the compiler how to read it.
    /// @param _bytes The input bytes string to slice
    /// @param _arg The index of the argument to extract
    /// @return length Length of the array
    /// @return offset Pointer to the data part of the array
    function toLengthOffset(bytes calldata _bytes, uint256 _arg)
        internal
        pure
        returns (uint256 length, uint256 offset)
    {
        uint256 relativeOffset;
        assembly {
            // The offset of the `_arg`-th element is `32 * arg`, which stores the offset of the length pointer.
            // shl(5, x) is equivalent to mul(32, x)
            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))
            length := calldataload(lengthPtr)
            offset := add(lengthPtr, 0x20)
            relativeOffset := sub(offset, _bytes.offset)
        }
        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();
    }

    /// @notice Decode the `_arg`-th element in `_bytes` as `address[]`
    /// @param _bytes The input bytes string to extract an address array from
    /// @param _arg The index of the argument to extract
    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {
        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);
        assembly {
            res.length := length
            res.offset := offset
        }
    }

    /// @notice Equivalent to abi.decode(bytes, bytes[])
    /// @param _bytes The input bytes string to extract an parameters from
    function decodeCommandsAndInputs(bytes calldata _bytes) internal pure returns (bytes calldata, bytes[] calldata) {
        return _bytes.decodeActionsRouterParams();
    }
}
</file>

<file path="contracts/modules/uniswap/v3/V3Path.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.6.0;

import {BytesLib} from './BytesLib.sol';
import {Constants} from '../../../libraries/Constants.sol';

/// @title Functions for manipulating path data for multihop swaps
library V3Path {
    using BytesLib for bytes;

    /// @notice Returns true iff the path contains two or more pools
    /// @param path The encoded swap path
    /// @return True if path contains two or more pools, otherwise false
    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {
        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;
    }

    /// @notice Decodes the first pool in path
    /// @param path The bytes encoded swap path
    /// @return tokenA The first token of the given pool
    /// @return fee The fee level of the pool
    /// @return tokenB The second token of the given pool
    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {
        return path.toPool();
    }

    /// @notice Gets the segment corresponding to the first pool in the path
    /// @param path The bytes encoded swap path
    /// @return The segment containing all data necessary to target the first pool in the path
    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {
        return path[:Constants.V3_POP_OFFSET];
    }

    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {
        tokenA = path.toAddress();
    }

    /// @notice Skips a token + fee element
    /// @param path The swap path
    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {
        return path[Constants.NEXT_V3_POOL_OFFSET:];
    }
}
</file>

<file path="contracts/modules/uniswap/v3/V3SwapRouter.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

import {V3Path} from './V3Path.sol';
import {BytesLib} from './BytesLib.sol';
import {SafeCast} from '@uniswap/v3-core/contracts/libraries/SafeCast.sol';
import {IUniswapV3Pool} from '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';
import {IUniswapV3SwapCallback} from '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';
import {ActionConstants} from '@uniswap/v4-periphery/src/libraries/ActionConstants.sol';
import {CalldataDecoder} from '@uniswap/v4-periphery/src/libraries/CalldataDecoder.sol';
import {Permit2Payments} from '../../Permit2Payments.sol';
import {UniswapImmutables} from '../UniswapImmutables.sol';
import {MaxInputAmount} from '../../../libraries/MaxInputAmount.sol';
import {ERC20} from 'solmate/src/tokens/ERC20.sol';

/// @title Router for Uniswap v3 Trades
abstract contract V3SwapRouter is UniswapImmutables, Permit2Payments, IUniswapV3SwapCallback {
    using V3Path for bytes;
    using BytesLib for bytes;
    using CalldataDecoder for bytes;
    using SafeCast for uint256;

    error V3InvalidSwap();
    error V3TooLittleReceived();
    error V3TooMuchRequested();
    error V3InvalidAmountOut();
    error V3InvalidCaller();

    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
    uint160 internal constant MIN_SQRT_RATIO = 4295128739;

    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;

    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {
        if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); // swaps entirely within 0-liquidity regions are not supported
        (, address payer) = abi.decode(data, (bytes, address));
        bytes calldata path = data.toBytes(0);

        // because exact output swaps are executed in reverse order, in this case tokenOut is actually tokenIn
        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();

        if (computePoolAddress(tokenIn, tokenOut, fee) != msg.sender) revert V3InvalidCaller();

        (bool isExactInput, uint256 amountToPay) =
            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));

        if (isExactInput) {
            // Pay the pool (msg.sender)
            payOrPermit2Transfer(tokenIn, payer, msg.sender, amountToPay);
        } else {
            // either initiate the next swap or pay
            if (path.hasMultiplePools()) {
                // this is an intermediate step so the payer is actually this contract
                path = path.skipToken();
                _swap(-amountToPay.toInt256(), msg.sender, path, payer, false);
            } else {
                if (amountToPay > MaxInputAmount.get()) revert V3TooMuchRequested();
                // note that because exact output swaps are executed in reverse order, tokenOut is actually tokenIn
                payOrPermit2Transfer(tokenOut, payer, msg.sender, amountToPay);
            }
        }
    }

    /// @notice Performs a Uniswap v3 exact input swap
    /// @param recipient The recipient of the output tokens
    /// @param amountIn The amount of input tokens for the trade
    /// @param amountOutMinimum The minimum desired amount of output tokens
    /// @param path The path of the trade as a bytes string
    /// @param payer The address that will be paying the input
    function v3SwapExactInput(
        address recipient,
        uint256 amountIn,
        uint256 amountOutMinimum,
        bytes calldata path,
        address payer
    ) internal {
        // use amountIn == ActionConstants.CONTRACT_BALANCE as a flag to swap the entire balance of the contract
        if (amountIn == ActionConstants.CONTRACT_BALANCE) {
            address tokenIn = path.decodeFirstToken();
            amountIn = ERC20(tokenIn).balanceOf(address(this));
        }

        uint256 amountOut;
        while (true) {
            bool hasMultiplePools = path.hasMultiplePools();

            // the outputs of prior swaps become the inputs to subsequent ones
            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(
                amountIn.toInt256(),
                hasMultiplePools ? address(this) : recipient, // for intermediate swaps, this contract custodies
                path.getFirstPool(), // only the first pool is needed
                payer, // for intermediate swaps, this contract custodies
                true
            );

            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));

            // decide whether to continue or terminate
            if (hasMultiplePools) {
                payer = address(this);
                path = path.skipToken();
            } else {
                amountOut = amountIn;
                break;
            }
        }

        if (amountOut < amountOutMinimum) revert V3TooLittleReceived();
    }

    /// @notice Performs a Uniswap v3 exact output swap
    /// @param recipient The recipient of the output tokens
    /// @param amountOut The amount of output tokens to receive for the trade
    /// @param amountInMaximum The maximum desired amount of input tokens
    /// @param path The path of the trade as a bytes string
    /// @param payer The address that will be paying the input
    function v3SwapExactOutput(
        address recipient,
        uint256 amountOut,
        uint256 amountInMaximum,
        bytes calldata path,
        address payer
    ) internal {
        MaxInputAmount.set(amountInMaximum);
        (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) =
            _swap(-amountOut.toInt256(), recipient, path, payer, false);

        uint256 amountOutReceived = zeroForOne ? uint256(-amount1Delta) : uint256(-amount0Delta);

        if (amountOutReceived != amountOut) revert V3InvalidAmountOut();

        MaxInputAmount.set(0);
    }

    /// @dev Performs a single swap for both exactIn and exactOut
    /// For exactIn, `amount` is `amountIn`. For exactOut, `amount` is `-amountOut`
    function _swap(int256 amount, address recipient, bytes calldata path, address payer, bool isExactIn)
        private
        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)
    {
        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();

        zeroForOne = isExactIn ? tokenIn < tokenOut : tokenOut < tokenIn;

        (amount0Delta, amount1Delta) = IUniswapV3Pool(computePoolAddress(tokenIn, tokenOut, fee))
            .swap(
                recipient,
                zeroForOne,
                amount,
                (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),
                abi.encode(path, payer)
            );
    }

    function computePoolAddress(address tokenA, address tokenB, uint24 fee) private view returns (address pool) {
        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);
        pool = address(
            uint160(
                uint256(
                    keccak256(
                        abi.encodePacked(
                            hex'ff',
                            UNISWAP_V3_FACTORY,
                            keccak256(abi.encode(tokenA, tokenB, fee)),
                            UNISWAP_V3_POOL_INIT_CODE_HASH
                        )
                    )
                )
            )
        );
    }
}
</file>

<file path="contracts/modules/uniswap/v4/V4SwapRouter.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

import {UniswapImmutables} from '../UniswapImmutables.sol';
import {Permit2Payments} from '../../Permit2Payments.sol';
import {V4Router} from '@uniswap/v4-periphery/src/V4Router.sol';
import {IPoolManager} from '@uniswap/v4-core/src/interfaces/IPoolManager.sol';
import {Currency} from '@uniswap/v4-core/src/types/Currency.sol';

/// @title Router for Uniswap v4 Trades
abstract contract V4SwapRouter is V4Router, Permit2Payments {
    constructor(address _poolManager) V4Router(IPoolManager(_poolManager)) {}

    function _pay(Currency token, address payer, uint256 amount) internal override {
        payOrPermit2Transfer(Currency.unwrap(token), payer, address(poolManager), amount);
    }
}
</file>

<file path="contracts/modules/uniswap/UniswapImmutables.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

struct UniswapParameters {
    address v2Factory;
    address v3Factory;
    bytes32 pairInitCodeHash;
    bytes32 poolInitCodeHash;
}

contract UniswapImmutables {
    /// @notice The address of UniswapV2Factory
    address internal immutable UNISWAP_V2_FACTORY;

    /// @notice The UniswapV2Pair initcodehash
    bytes32 internal immutable UNISWAP_V2_PAIR_INIT_CODE_HASH;

    /// @notice The address of UniswapV3Factory
    address internal immutable UNISWAP_V3_FACTORY;

    /// @notice The UniswapV3Pool initcodehash
    bytes32 internal immutable UNISWAP_V3_POOL_INIT_CODE_HASH;

    constructor(UniswapParameters memory params) {
        UNISWAP_V2_FACTORY = params.v2Factory;
        UNISWAP_V2_PAIR_INIT_CODE_HASH = params.pairInitCodeHash;
        UNISWAP_V3_FACTORY = params.v3Factory;
        UNISWAP_V3_POOL_INIT_CODE_HASH = params.poolInitCodeHash;
    }
}
</file>

<file path="contracts/modules/ChainedActions.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

import {Payments} from './Payments.sol';
import {IV3SpokePool} from '../interfaces/external/IV3SpokePool.sol';
import {AcrossV4DepositV3Params} from '../interfaces/IUniversalRouter.sol';
import {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import {ActionConstants} from '@uniswap/v4-periphery/src/libraries/ActionConstants.sol';

abstract contract ChainedActions is Payments {
    using SafeERC20 for IERC20;

    IV3SpokePool public immutable SPOKE_POOL;

    constructor(address spokePool) {
        SPOKE_POOL = IV3SpokePool(spokePool);
    }

    function _acrossV4DepositV3(bytes calldata input) internal {
        AcrossV4DepositV3Params memory params = abi.decode(input, (AcrossV4DepositV3Params));

        uint256 inputAmount = params.inputAmount;
        uint256 callValue = 0;

        // Resolve sentinel value for inputAmount
        if (inputAmount == ActionConstants.CONTRACT_BALANCE) {
            if (params.useNative) {
                inputAmount = address(this).balance;
            } else {
                inputAmount = IERC20(params.inputToken).balanceOf(address(this));
            }
        }

        if (params.useNative) {
            // Require ETH path to use WETH as inputToken per Across docs.
            // Router must currently hold ETH equal to inputAmount.
            callValue = inputAmount;
        } else {
            // Approve SpokePool to pull ERC20 from router
            IERC20(params.inputToken).forceApprove(address(SPOKE_POOL), inputAmount);
        }

        SPOKE_POOL.depositV3{value: callValue}(
            params.depositor,
            params.recipient,
            params.inputToken,
            params.outputToken,
            inputAmount,
            params.outputAmount,
            params.destinationChainId,
            params.exclusiveRelayer,
            params.quoteTimestamp,
            params.fillDeadline,
            params.exclusivityDeadline,
            params.message
        );
    }
}
</file>

<file path="contracts/modules/MigratorImmutables.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

import {INonfungiblePositionManager} from '@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol';
import {IPositionManager} from '@uniswap/v4-periphery/src/interfaces/IPositionManager.sol';
import {IPoolManager} from '@uniswap/v4-core/src/interfaces/IPoolManager.sol';

struct MigratorParameters {
    address v3PositionManager;
    address v4PositionManager;
}

/// @title Migrator Immutables
/// @notice Immutable state for liquidity-migration contracts
contract MigratorImmutables {
    /// @notice v3 PositionManager address
    INonfungiblePositionManager public immutable V3_POSITION_MANAGER;
    /// @notice v4 PositionManager address
    IPositionManager public immutable V4_POSITION_MANAGER;

    constructor(MigratorParameters memory params) {
        V3_POSITION_MANAGER = INonfungiblePositionManager(params.v3PositionManager);
        V4_POSITION_MANAGER = IPositionManager(params.v4PositionManager);
    }
}
</file>

<file path="contracts/modules/Payments.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

import {Constants} from '../libraries/Constants.sol';
import {ActionConstants} from '@uniswap/v4-periphery/src/libraries/ActionConstants.sol';
import {BipsLibrary} from '@uniswap/v4-periphery/src/libraries/BipsLibrary.sol';
import {PaymentsImmutables} from '../modules/PaymentsImmutables.sol';
import {SafeTransferLib} from 'solmate/src/utils/SafeTransferLib.sol';
import {ERC20} from 'solmate/src/tokens/ERC20.sol';

/// @title Payments contract
/// @notice Performs various operations around the payment of ETH and tokens
abstract contract Payments is PaymentsImmutables {
    using SafeTransferLib for ERC20;
    using SafeTransferLib for address;
    using BipsLibrary for uint256;

    error InsufficientToken();
    error InsufficientETH();

    /// @notice Pays an amount of ETH or ERC20 to a recipient
    /// @param token The token to pay (can be ETH using Constants.ETH)
    /// @param recipient The address that will receive the payment
    /// @param value The amount to pay
    function pay(address token, address recipient, uint256 value) internal {
        if (token == Constants.ETH) {
            recipient.safeTransferETH(value);
        } else {
            if (value == ActionConstants.CONTRACT_BALANCE) {
                value = ERC20(token).balanceOf(address(this));
            }

            ERC20(token).safeTransfer(recipient, value);
        }
    }

    /// @notice Pays a proportion of the contract's ETH or ERC20 to a recipient
    /// @param token The token to pay (can be ETH using Constants.ETH)
    /// @param recipient The address that will receive payment
    /// @param bips Portion in bips of whole balance of the contract
    function payPortion(address token, address recipient, uint256 bips) internal {
        if (token == Constants.ETH) {
            uint256 balance = address(this).balance;
            uint256 amount = balance.calculatePortion(bips);
            recipient.safeTransferETH(amount);
        } else {
            uint256 balance = ERC20(token).balanceOf(address(this));
            uint256 amount = balance.calculatePortion(bips);
            ERC20(token).safeTransfer(recipient, amount);
        }
    }

    /// @notice Sweeps all of the contract's ERC20 or ETH to an address
    /// @param token The token to sweep (can be ETH using Constants.ETH)
    /// @param recipient The address that will receive payment
    /// @param amountMinimum The minimum desired amount
    function sweep(address token, address recipient, uint256 amountMinimum) internal {
        uint256 balance;
        if (token == Constants.ETH) {
            balance = address(this).balance;
            if (balance < amountMinimum) revert InsufficientETH();
            if (balance > 0) recipient.safeTransferETH(balance);
        } else {
            balance = ERC20(token).balanceOf(address(this));
            if (balance < amountMinimum) revert InsufficientToken();
            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);
        }
    }

    /// @notice Wraps an amount of ETH into WETH
    /// @param recipient The recipient of the WETH
    /// @param amount The amount to wrap (can be CONTRACT_BALANCE)
    function wrapETH(address recipient, uint256 amount) internal {
        if (amount == ActionConstants.CONTRACT_BALANCE) {
            amount = address(this).balance;
        } else if (amount > address(this).balance) {
            revert InsufficientETH();
        }
        if (amount > 0) {
            WETH9.deposit{value: amount}();
            if (recipient != address(this)) {
                WETH9.transfer(recipient, amount);
            }
        }
    }

    /// @notice Unwraps all of the contract's WETH into ETH
    /// @param recipient The recipient of the ETH
    /// @param amountMinimum The minimum amount of ETH desired
    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {
        uint256 value = WETH9.balanceOf(address(this));
        if (value < amountMinimum) {
            revert InsufficientETH();
        }
        if (value > 0) {
            WETH9.withdraw(value);
            if (recipient != address(this)) {
                recipient.safeTransferETH(value);
            }
        }
    }
}
</file>

<file path="contracts/modules/PaymentsImmutables.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

import {IWETH9} from '@uniswap/v4-periphery/src/interfaces/external/IWETH9.sol';
import {IPermit2} from 'permit2/src/interfaces/IPermit2.sol';

struct PaymentsParameters {
    address permit2;
    address weth9;
}

contract PaymentsImmutables {
    /// @notice WETH9 address
    IWETH9 internal immutable WETH9;

    /// @notice Permit2 address
    IPermit2 internal immutable PERMIT2;

    constructor(PaymentsParameters memory params) {
        WETH9 = IWETH9(params.weth9);
        PERMIT2 = IPermit2(params.permit2);
    }
}
</file>

<file path="contracts/modules/Permit2Payments.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

import {IAllowanceTransfer} from 'permit2/src/interfaces/IAllowanceTransfer.sol';
import {SafeCast160} from 'permit2/src/libraries/SafeCast160.sol';
import {Payments} from './Payments.sol';

/// @title Payments through Permit2
/// @notice Performs interactions with Permit2 to transfer tokens
abstract contract Permit2Payments is Payments {
    using SafeCast160 for uint256;

    error FromAddressIsNotOwner();

    /// @notice Performs a transferFrom on Permit2
    /// @param token The token to transfer
    /// @param from The address to transfer from
    /// @param to The recipient of the transfer
    /// @param amount The amount to transfer
    function permit2TransferFrom(address token, address from, address to, uint160 amount) internal {
        PERMIT2.transferFrom(from, to, amount, token);
    }

    /// @notice Performs a batch transferFrom on Permit2
    /// @param batchDetails An array detailing each of the transfers that should occur
    /// @param owner The address that should be the owner of all transfers
    function permit2TransferFrom(IAllowanceTransfer.AllowanceTransferDetails[] calldata batchDetails, address owner)
        internal
    {
        uint256 batchLength = batchDetails.length;
        for (uint256 i = 0; i < batchLength; ++i) {
            if (batchDetails[i].from != owner) revert FromAddressIsNotOwner();
        }
        PERMIT2.transferFrom(batchDetails);
    }

    /// @notice Either performs a regular payment or transferFrom on Permit2, depending on the payer address
    /// @param token The token to transfer
    /// @param payer The address to pay for the transfer
    /// @param recipient The recipient of the transfer
    /// @param amount The amount to transfer
    function payOrPermit2Transfer(address token, address payer, address recipient, uint256 amount) internal {
        if (payer == address(this)) pay(token, recipient, amount);
        else permit2TransferFrom(token, payer, recipient, amount.toUint160());
    }
}
</file>

<file path="contracts/modules/V3ToV4Migrator.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

import {MigratorImmutables} from '../modules/MigratorImmutables.sol';
import {INonfungiblePositionManager} from '@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol';
import {Actions} from '@uniswap/v4-periphery/src/libraries/Actions.sol';
import {IERC721Permit} from '@uniswap/v3-periphery/contracts/interfaces/IERC721Permit.sol';
import {CalldataDecoder} from '@uniswap/v4-periphery/src/libraries/CalldataDecoder.sol';

/// @title V3 to V4 Migrator
/// @notice A contract that migrates liquidity from Uniswap V3 to V4
abstract contract V3ToV4Migrator is MigratorImmutables {
    using CalldataDecoder for bytes;

    error InvalidAction(bytes4 action);
    error OnlyMintAllowed();
    error NotAuthorizedForToken(uint256 tokenId);

    /// @dev validate if an action is decreaseLiquidity, collect, or burn
    function _isValidAction(bytes4 selector) private pure returns (bool) {
        return selector == INonfungiblePositionManager.decreaseLiquidity.selector
            || selector == INonfungiblePositionManager.collect.selector
            || selector == INonfungiblePositionManager.burn.selector;
    }

    /// @dev the caller is authorized for the token if its the owner, spender, or operator
    function _isAuthorizedForToken(address caller, uint256 tokenId) private view returns (bool) {
        address owner = V3_POSITION_MANAGER.ownerOf(tokenId);
        return caller == owner || V3_POSITION_MANAGER.getApproved(tokenId) == caller
            || V3_POSITION_MANAGER.isApprovedForAll(owner, caller);
    }

    /// @dev check that a call is to the ERC721 permit function
    function _checkV3PermitCall(bytes calldata inputs) internal pure {
        bytes4 selector;
        assembly {
            selector := calldataload(inputs.offset)
        }

        if (selector != IERC721Permit.permit.selector) {
            revert InvalidAction(selector);
        }
    }

    /// @dev check that the v3 position manager call is a safe call
    function _checkV3PositionManagerCall(bytes calldata inputs, address caller) internal view {
        bytes4 selector;
        assembly {
            selector := calldataload(inputs.offset)
        }

        if (!_isValidAction(selector)) {
            revert InvalidAction(selector);
        }

        uint256 tokenId;
        assembly {
            // tokenId is always the first parameter in the valid actions
            tokenId := calldataload(add(inputs.offset, 0x04))
        }
        // If any other address that is not the owner wants to call this function, it also needs to be approved (in addition to this contract)
        // This can be done in 2 ways:
        //    1. This contract is permitted for the specific token and the caller is approved for ALL of the owner's tokens
        //    2. This contract is permitted for ALL of the owner's tokens and the caller is permitted for the specific token
        if (!_isAuthorizedForToken(caller, tokenId)) {
            revert NotAuthorizedForToken(tokenId);
        }
    }

    /// @dev check that the v4 position manager call is a safe call
    /// of the position-altering Actions, we only allow Actions.MINT
    /// this is because, if a user could be tricked into approving the UniversalRouter for
    /// their position, an attacker could take their fees, or drain their entire position
    function _checkV4PositionManagerCall(bytes calldata inputs) internal view {
        bytes4 selector;
        assembly {
            selector := calldataload(inputs.offset)
        }
        if (selector != V4_POSITION_MANAGER.modifyLiquidities.selector) {
            revert InvalidAction(selector);
        }

        // slice is `abi.encode(bytes unlockData, uint256 deadline)`
        bytes calldata slice = inputs[4:];
        // the first bytes(0) extracts the unlockData parameter from modifyLiquidities
        // unlockData = `abi.encode(bytes actions, bytes[] params)`
        // the second bytes(0) extracts the actions parameter from unlockData
        bytes calldata actions = slice.toBytes(0).toBytes(0);

        uint256 numActions = actions.length;

        for (uint256 actionIndex = 0; actionIndex < numActions; actionIndex++) {
            uint256 action = uint8(actions[actionIndex]);

            if (
                action == Actions.INCREASE_LIQUIDITY || action == Actions.DECREASE_LIQUIDITY
                    || action == Actions.BURN_POSITION
            ) {
                revert OnlyMintAllowed();
            }
        }
    }
}
</file>

<file path="contracts/test/ExampleModule.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

contract ExampleModule {
    event ExampleModuleEvent(string message);

    error CauseRevert();

    function logEvent() public {
        emit ExampleModuleEvent('testEvent');
    }

    function causeRevert() public pure {
        revert CauseRevert();
    }
}
</file>

<file path="contracts/test/ImportsForTypechain.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.17;

import {PositionManager} from '@uniswap/v4-periphery/src/PositionManager.sol';
import {PoolManager} from '@uniswap/v4-core/src/PoolManager.sol';
import {ERC721} from 'solmate/src/tokens/ERC721.sol';
import {ERC6909} from '@uniswap/v4-core/src/ERC6909.sol';

// this contract only exists to pull PositionManager and PoolManager into the hardhat build pipeline
// so that typechain artifacts are generated for it
abstract contract ImportsForTypechain is PositionManager, PoolManager {
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC6909, ERC721) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}
</file>

<file path="contracts/test/MintableERC20.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.15;

import {ERC20} from 'solmate/src/tokens/ERC20.sol';

contract MintableERC20 is ERC20 {
    constructor(uint256 amountToMint) ERC20('test', 'TEST', 18) {
        mint(msg.sender, amountToMint);
    }

    function mint(address to, uint256 amount) public {
        balanceOf[to] += amount;
        totalSupply += amount;
    }
}
</file>

<file path="contracts/test/ReenteringWETH.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.15;

import {ERC20} from 'solmate/src/tokens/ERC20.sol';

contract ReenteringWETH is ERC20 {
    error NotAllowedReenter();

    address universalRouter;
    bytes data;

    constructor() ERC20('ReenteringWETH', 'RW', 18) {}

    function setParameters(address _universalRouter, bytes memory _data) external {
        universalRouter = _universalRouter;
        data = _data;
    }

    function deposit() public payable {
        (bool success,) = universalRouter.call(data);
        if (!success) revert NotAllowedReenter();
    }
}
</file>

<file path="contracts/test/TestCustomErrors.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

contract TestCustomErrors {
    // adding so that hardhat knows this custom signature selector for external contracts
    error InvalidSignature();
    error UnsafeCast();
}
</file>

<file path="contracts/types/RouterParameters.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

struct RouterParameters {
    // Payment parameters
    address permit2;
    address weth9;
    // Uniswap swapping parameters
    address v2Factory;
    address v3Factory;
    bytes32 pairInitCodeHash;
    bytes32 poolInitCodeHash;
    address v4PoolManager;
    // Uniswap v3->v4 migration parameters
    address v3NFTPositionManager;
    address v4PositionManager;
    // Across parameters
    address spokePool;
}
</file>

<file path="contracts/UniversalRouter.sol">
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

// Command implementations
import {Dispatcher} from './base/Dispatcher.sol';
import {RouteSigner} from './base/RouteSigner.sol';
import {RouterParameters} from './types/RouterParameters.sol';
import {PaymentsImmutables, PaymentsParameters} from './modules/PaymentsImmutables.sol';
import {UniswapImmutables, UniswapParameters} from './modules/uniswap/UniswapImmutables.sol';
import {V4SwapRouter} from './modules/uniswap/v4/V4SwapRouter.sol';
import {Commands} from './libraries/Commands.sol';
import {IUniversalRouter} from './interfaces/IUniversalRouter.sol';
import {MigratorImmutables, MigratorParameters} from './modules/MigratorImmutables.sol';
import {EIP712} from '@openzeppelin/contracts/utils/cryptography/EIP712.sol';
import {ChainedActions} from './modules/ChainedActions.sol';

contract UniversalRouter is IUniversalRouter, ChainedActions, RouteSigner, Dispatcher {
    constructor(RouterParameters memory params)
        UniswapImmutables(UniswapParameters(
                params.v2Factory, params.v3Factory, params.pairInitCodeHash, params.poolInitCodeHash
            ))
        V4SwapRouter(params.v4PoolManager)
        PaymentsImmutables(PaymentsParameters(params.permit2, params.weth9))
        MigratorImmutables(MigratorParameters(params.v3NFTPositionManager, params.v4PositionManager))
        ChainedActions(params.spokePool)
        EIP712('UniversalRouter', '2')
    {}

    modifier checkDeadline(uint256 deadline) {
        if (block.timestamp > deadline) revert TransactionDeadlinePassed();
        _;
    }

    /// @notice To receive ETH from WETH
    receive() external payable {
        if (msg.sender != address(WETH9) && msg.sender != address(poolManager)) revert InvalidEthSender();
    }

    /// @inheritdoc IUniversalRouter
    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)
        external
        payable
        checkDeadline(deadline)
    {
        execute(commands, inputs);
    }

    /// @inheritdoc IUniversalRouter
    function executeSigned(
        bytes calldata commands,
        bytes[] calldata inputs,
        bytes32 intent,
        bytes32 data,
        bool verifySender,
        bytes32 nonce,
        bytes calldata signature,
        uint256 deadline
    ) external payable checkDeadline(deadline) {
        // Set signature context and verify
        _setSignatureContext(commands, inputs, intent, data, verifySender, nonce, signature, deadline);

        // Execute commands
        execute(commands, inputs);

        // Clear signature context
        _resetSignatureContext();
    }

    /// @inheritdoc Dispatcher
    function execute(bytes calldata commands, bytes[] calldata inputs) public payable override isNotLocked {
        bool success;
        bytes memory output;
        uint256 numCommands = commands.length;
        if (inputs.length != numCommands) revert LengthMismatch();

        // loop through all given commands, execute them and pass along outputs as defined
        for (uint256 commandIndex = 0; commandIndex < numCommands; commandIndex++) {
            bytes1 command = commands[commandIndex];

            bytes calldata input = inputs[commandIndex];

            (success, output) = dispatch(command, input);

            if (!success && successRequired(command)) {
                revert ExecutionFailed({commandIndex: commandIndex, message: output});
            }
        }
    }

    /// @inheritdoc IUniversalRouter
    function signedRouteContext() external view returns (address signer, bytes32 intent, bytes32 data) {
        return _signedRouteContext();
    }

    function successRequired(bytes1 command) internal pure returns (bool) {
        return command & Commands.FLAG_ALLOW_REVERT == 0;
    }
}
</file>

<file path="script/deployParameters/DeployArbitrum.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployArbitrum is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1,
            v2Factory: 0xf1D7CC64Fb4452F05c498126312eBE29f30Fbcf9,
            v3Factory: 0x1F98431c8aD98523631AE4a59f267346ea31F984,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0x360E68faCcca8cA495c1B759Fd9EEe466db9FB32,
            v3NFTPositionManager: 0xC36442b4a4522E871399CD717aBDD847Ab11FE88,
            v4PositionManager: 0xd88F38F930b7952f2DB2432Cb002E7abbF3dD869,
            spokePool: 0xe35e9842fceaCA96570B734083f4a58e8F7C5f2A
        });

        unsupported = 0xEf1c6E67703c7BD7107eed8303Fbe6EC2554BF6B;
    }
}
</file>

<file path="script/deployParameters/DeployArbitrumGoerli.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployArbitrumGoerli is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3,
            v2Factory: UNSUPPORTED_PROTOCOL,
            v3Factory: 0x4893376342d5D7b3e31d4184c08b265e5aB2A3f6,
            pairInitCodeHash: BYTES32_ZERO,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: address(0),
            v3NFTPositionManager: address(0),
            v4PositionManager: address(0),
            spokePool: address(0)
        });

        unsupported = 0x5302086A3a25d473aAbBd0356eFf8Dd811a4d89B;
    }
}
</file>

<file path="script/deployParameters/DeployAvalanche.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployAvalanche is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7,
            v2Factory: 0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C,
            v3Factory: 0x740b1c1de25031C31FF4fC9A62f554A55cdC1baD,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0x06380C0e0912312B5150364B9DC4542BA0DbBc85,
            v3NFTPositionManager: 0x655C406EBFa14EE2006250925e54ec43AD184f8B,
            v4PositionManager: 0xB74b1F14d2754AcfcbBe1a221023a5cf50Ab8ACD,
            spokePool: address(0)
        });

        unsupported = 0x5302086A3a25d473aAbBd0356eFf8Dd811a4d89B;
    }
}
</file>

<file path="script/deployParameters/DeployBase.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployBase is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x4200000000000000000000000000000000000006,
            v2Factory: 0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6,
            v3Factory: 0x33128a8fC17869897dcE68Ed026d694621f6FDfD,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0x498581fF718922c3f8e6A244956aF099B2652b2b,
            v3NFTPositionManager: 0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1,
            v4PositionManager: 0x7C5f5A4bBd8fD63184577525326123B519429bDc,
            spokePool: 0x09aea4b2242abC8bb4BB78D537A67a245A7bEC64
        });

        unsupported = 0x9E18Efb3BE848940b0C92D300504Fb08C287FE85;
    }
}
</file>

<file path="script/deployParameters/DeployBaseGoerli.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployBaseGoerli is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x44D627f900da8AdaC7561bD73aA745F132450798,
            v2Factory: UNSUPPORTED_PROTOCOL,
            v3Factory: 0x9323c1d6D800ed51Bd7C6B216cfBec678B7d0BC2,
            pairInitCodeHash: BYTES32_ZERO,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: address(0),
            v3NFTPositionManager: address(0),
            v4PositionManager: address(0),
            spokePool: address(0)
        });

        unsupported = 0x7B46ee9BaB49bd5b37117494689A035b0F187B59;
    }
}
</file>

<file path="script/deployParameters/DeployBaseSepolia.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployBaseSepolia is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x4200000000000000000000000000000000000006,
            v2Factory: 0x7Ae58f10f7849cA6F5fB71b7f45CB416c9204b1e,
            v3Factory: 0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0xf7F5aB3DcA35e17dE187b459159BC643853B3c67,
            v3NFTPositionManager: 0x27F971cb582BF9E50F397e4d29a5C7A34f11faA2,
            v4PositionManager: 0x0B32f74f8365d535783949E014B7754047B64e31,
            spokePool: 0x82B564983aE7274c86695917BBf8C99ECb6F0F8F
        });

        unsupported = 0x76870DEbef0BE25589A5CddCe9B1D99276C73B4e;
    }
}
</file>

<file path="script/deployParameters/DeployBlast.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployBlast is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x4300000000000000000000000000000000000004,
            v2Factory: 0x5C346464d33F90bABaf70dB6388507CC889C1070,
            v3Factory: 0x792edAdE80af5fC680d96a2eD80A44247D2Cf6Fd,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0x1631559198A9e474033433b2958daBC135ab6446,
            v3NFTPositionManager: 0xB218e4f7cF0533d4696fDfC419A0023D33345F28,
            v4PositionManager: 0x4AD2F4CcA2682cBB5B950d660dD458a1D3f1bAaD,
            spokePool: 0x2D509190Ed0172ba588407D4c2df918F955Cc6E1
        });

        unsupported = 0x5ab1B56FB16238dB874258FB7847EFe248eb8496;
    }
}
</file>

<file path="script/deployParameters/DeployBSC.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployBSC is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c,
            v2Factory: 0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6,
            v3Factory: 0xdB1d10011AD0Ff90774D0C6Bb92e5C5c8b4461F7,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0x28e2Ea090877bF75740558f6BFB36A5ffeE9e9dF,
            v3NFTPositionManager: 0x7b8A01B39D58278b5DE7e48c8449c9f4F5170613,
            v4PositionManager: 0x7A4a5c919aE2541AeD11041A1AEeE68f1287f95b,
            spokePool: 0x4e8E101924eDE233C13e2D8622DC8aED2872d505
        });

        unsupported = 0x5302086A3a25d473aAbBd0356eFf8Dd811a4d89B;
    }
}
</file>

<file path="script/deployParameters/DeployCelo.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployCelo is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: UNSUPPORTED_PROTOCOL,
            v2Factory: 0x79a530c8e2fA8748B7B40dd3629C0520c2cCf03f,
            v3Factory: 0xAfE208a311B21f13EF87E33A90049fC17A7acDEc,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: address(0),
            v3NFTPositionManager: 0x3d79EdAaBC0EaB6F08ED885C05Fc0B014290D95A,
            v4PositionManager: address(0),
            spokePool: address(0)
        });

        unsupported = 0x5Dc88340E1c5c6366864Ee415d6034cadd1A9897;
    }
}
</file>

<file path="script/deployParameters/DeployCeloAlfajores.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployCeloAlfajores is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: UNSUPPORTED_PROTOCOL,
            v2Factory: UNSUPPORTED_PROTOCOL,
            v3Factory: 0xAfE208a311B21f13EF87E33A90049fC17A7acDEc,
            pairInitCodeHash: BYTES32_ZERO,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: address(0),
            v3NFTPositionManager: address(0),
            v4PositionManager: address(0),
            spokePool: address(0)
        });

        unsupported = 0x5302086A3a25d473aAbBd0356eFf8Dd811a4d89B;
    }
}
</file>

<file path="script/deployParameters/DeployGoerli.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployGoerli is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6,
            v2Factory: 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f,
            v3Factory: 0x1F98431c8aD98523631AE4a59f267346ea31F984,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: address(0),
            v3NFTPositionManager: address(0),
            v4PositionManager: address(0),
            spokePool: address(0)
        });

        unsupported = 0x5302086A3a25d473aAbBd0356eFf8Dd811a4d89B;
    }
}
</file>

<file path="script/deployParameters/DeployInk.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployInk is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x4200000000000000000000000000000000000006,
            v2Factory: 0xfe57A6BA1951F69aE2Ed4abe23e0f095DF500C04,
            v3Factory: 0x640887A9ba3A9C53Ed27D0F7e8246A4F933f3424,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0x360E68faCcca8cA495c1B759Fd9EEe466db9FB32,
            v3NFTPositionManager: 0xC0836E5B058BBE22ae2266e1AC488A1A0fD8DCE8,
            v4PositionManager: 0x1b35d13a2E2528f192637F14B05f0Dc0e7dEB566,
            spokePool: 0xeF684C38F94F48775959ECf2012D7E864ffb9dd4
        });
    }
}
</file>

<file path="script/deployParameters/DeployMainnet.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployMainnet is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,
            v2Factory: 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f,
            v3Factory: 0x1F98431c8aD98523631AE4a59f267346ea31F984,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: address(0),
            v3NFTPositionManager: 0xC36442b4a4522E871399CD717aBDD847Ab11FE88,
            v4PositionManager: address(0),
            spokePool: 0x5c7BCd6E7De5423a257D81B442095A1a6ced35C5
        });

        unsupported = 0x76D631990d505E4e5b432EEDB852A60897824D68;
    }
}
</file>

<file path="script/deployParameters/DeployOPSepolia.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployOPSepolia is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x4200000000000000000000000000000000000006,
            v2Factory: UNSUPPORTED_PROTOCOL,
            v3Factory: 0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24,
            pairInitCodeHash: BYTES32_ZERO,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0xf7F5aB3DcA35e17dE187b459159BC643853B3c67,
            v3NFTPositionManager: 0x27F971cb582BF9E50F397e4d29a5C7A34f11faA2,
            v4PositionManager: 0x0B32f74f8365d535783949E014B7754047B64e31,
            spokePool: 0x4e8E101924eDE233C13e2D8622DC8aED2872d505
        });

        unsupported = 0xFC885F37F5A9FA8159c8dBb907fc1b0C2fB31323;
    }
}
</file>

<file path="script/deployParameters/DeployOptimism.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployOptimism is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x4200000000000000000000000000000000000006,
            v2Factory: 0x0c3c1c532F1e39EdF36BE9Fe0bE1410313E074Bf,
            v3Factory: 0x1F98431c8aD98523631AE4a59f267346ea31F984,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0x9a13F98Cb987694C9F086b1F5eB990EeA8264Ec3,
            v3NFTPositionManager: 0xC36442b4a4522E871399CD717aBDD847Ab11FE88,
            v4PositionManager: 0x3C3Ea4B57a46241e54610e5f022E5c45859A1017,
            spokePool: 0x6f26Bf09B1C792e3228e5467807a900A503c0281
        });

        unsupported = 0x40d51104Da22E3e77b683894E7e3E12e8FC61E65;
    }
}
</file>

<file path="script/deployParameters/DeployOptimismGoerli.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployOptimismGoerli is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x4200000000000000000000000000000000000006,
            v2Factory: UNSUPPORTED_PROTOCOL,
            v3Factory: 0xB656dA17129e7EB733A557f4EBc57B76CFbB5d10,
            pairInitCodeHash: BYTES32_ZERO,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: address(0),
            v3NFTPositionManager: address(0),
            v4PositionManager: address(0),
            spokePool: address(0)
        });

        unsupported = 0x5302086A3a25d473aAbBd0356eFf8Dd811a4d89B;
    }
}
</file>

<file path="script/deployParameters/DeployPolygon.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployPolygon is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270,
            v2Factory: 0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C,
            v3Factory: 0x1F98431c8aD98523631AE4a59f267346ea31F984,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0x67366782805870060151383F4BbFF9daB53e5cD6,
            v3NFTPositionManager: 0xC36442b4a4522E871399CD717aBDD847Ab11FE88,
            v4PositionManager: 0x1Ec2eBf4F37E7363FDfe3551602425af0B3ceef9,
            spokePool: 0x9295ee1d8C5b022Be115A2AD3c30C72E34e7F096
        });

        unsupported = 0xEf1c6E67703c7BD7107eed8303Fbe6EC2554BF6B;
    }
}
</file>

<file path="script/deployParameters/DeployPolygonMumbai.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployPolygonMumbai is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889,
            v2Factory: UNSUPPORTED_PROTOCOL,
            v3Factory: 0x1F98431c8aD98523631AE4a59f267346ea31F984,
            pairInitCodeHash: BYTES32_ZERO,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: address(0),
            v3NFTPositionManager: 0xC36442b4a4522E871399CD717aBDD847Ab11FE88,
            v4PositionManager: address(0),
            spokePool: address(0)
        });

        unsupported = 0x5302086A3a25d473aAbBd0356eFf8Dd811a4d89B;
    }
}
</file>

<file path="script/deployParameters/DeploySepolia.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeploySepolia is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14,
            v2Factory: 0xB7f907f7A9eBC822a80BD25E224be42Ce0A698A0,
            v3Factory: 0x0227628f3F023bb0B980b67D528571c95c6DaC1c,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0xD24d4e867FDA1238B5Fa035Fa8aB731d41c4A3ed,
            v3NFTPositionManager: 0x1238536071E1c677A632429e3655c799b22cDA52,
            v4PositionManager: 0xc9BAAaAE1C3CA0263336f0a05C1969706Df8338A,
            spokePool: 0x5ef6C01E11889d86803e0B23e3cB3F9E9d97B662
        });

        unsupported = 0x5302086A3a25d473aAbBd0356eFf8Dd811a4d89B;
    }
}
</file>

<file path="script/deployParameters/DeploySoneium.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeploySoneium is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x4200000000000000000000000000000000000006,
            v2Factory: UNSUPPORTED_PROTOCOL,
            v3Factory: UNSUPPORTED_PROTOCOL,
            pairInitCodeHash: BYTES32_ZERO,
            poolInitCodeHash: BYTES32_ZERO,
            v4PoolManager: 0x360E68faCcca8cA495c1B759Fd9EEe466db9FB32,
            v3NFTPositionManager: 0x8702463e73f74d0b6765aBceb314Ef07aCb92650,
            v4PositionManager: 0x1b35d13a2E2528f192637F14B05f0Dc0e7dEB566,
            spokePool: 0x3baD7AD0728f9917d1Bf08af5782dCbD516cDd96
        });

        unsupported = 0x8702463e73f74d0b6765aBceb314Ef07aCb92650;
    }
}
</file>

<file path="script/deployParameters/DeployUnichain.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployUnichain is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x4200000000000000000000000000000000000006,
            v2Factory: 0x1F98400000000000000000000000000000000002,
            v3Factory: 0x1F98400000000000000000000000000000000003,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0x1F98400000000000000000000000000000000004,
            v3NFTPositionManager: 0x943e6e07a7E8E791dAFC44083e54041D743C46E9,
            v4PositionManager: 0x4529A01c7A0410167c5740C487A8DE60232617bf,
            spokePool: 0x09aea4b2242abC8bb4BB78D537A67a245A7bEC64
        });
    }
}
</file>

<file path="script/deployParameters/DeployUnichainSepolia.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployUnichainSepolia is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x4200000000000000000000000000000000000006,
            v2Factory: 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f,
            v3Factory: 0x1F98431c8aD98523631AE4a59f267346ea31F984,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0x9cB26A7183B2F4515945Dc52CB4195B0d2D06C95,
            v3NFTPositionManager: 0xB7F724d6dDDFd008eFf5cc2834edDE5F9eF0d075,
            v4PositionManager: 0x12A98709BB5D0641D61458f85dcAFbE17AC2d05c,
            spokePool: 0x6999526e507Cc3b03b180BbE05E1Ff938259A874
        });
    }
}
</file>

<file path="script/deployParameters/DeployWorldchain.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployWorldchain is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x4200000000000000000000000000000000000006,
            v2Factory: 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f,
            v3Factory: 0x7a5028BDa40e7B173C278C5342087826455ea25a,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0xb1860D529182ac3BC1F51Fa2ABd56662b7D13f33,
            v3NFTPositionManager: 0xec12a9F9a09f50550686363766Cc153D03c27b5e,
            v4PositionManager: 0xC585E0f504613b5fBf874F21Af14c65260fB41fA,
            spokePool: 0x09aea4b2242abC8bb4BB78D537A67a245A7bEC64
        });
    }
}
</file>

<file path="script/deployParameters/DeployZora.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {DeployUniversalRouter} from '../DeployUniversalRouter.s.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';

contract DeployZora is DeployUniversalRouter {
    function setUp() public override {
        params = RouterParameters({
            permit2: 0x000000000022D473030F116dDEE9F6B43aC78BA3,
            weth9: 0x4200000000000000000000000000000000000006,
            v2Factory: 0x0F797dC7efaEA995bB916f268D919d0a1950eE3C,
            v3Factory: 0x7145F8aeef1f6510E92164038E1B6F8cB2c42Cbb,
            pairInitCodeHash: 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f,
            poolInitCodeHash: 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54,
            v4PoolManager: 0x0575338e4C17006aE181B47900A84404247CA30f,
            v3NFTPositionManager: 0xbC91e8DfA3fF18De43853372A3d7dfe585137D78,
            v4PositionManager: 0xf66C7b99e2040f0D9b326B3b7c152E9663543D63,
            spokePool: 0x13fDac9F9b4777705db45291bbFF3c972c6d1d97
        });
    }
}
</file>

<file path="script/DeployUniversalRouter.s.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import 'forge-std/console2.sol';
import 'forge-std/Script.sol';
import {RouterParameters} from 'contracts/types/RouterParameters.sol';
import {UnsupportedProtocol} from 'contracts/deploy/UnsupportedProtocol.sol';
import {UniversalRouter} from 'contracts/UniversalRouter.sol';

bytes32 constant SALT = bytes32(uint256(0x00000000000000000000000000000000000000005eb67581652632000a6cbedf));

abstract contract DeployUniversalRouter is Script {
    RouterParameters internal params;
    address internal unsupported;

    address constant UNSUPPORTED_PROTOCOL = address(0);
    bytes32 constant BYTES32_ZERO = bytes32(0);

    error Permit2NotDeployed();

    // set values for params and unsupported
    function setUp() public virtual;

    function run() external returns (UniversalRouter router) {
        vm.startBroadcast();

        // deploy permit2 if it isnt yet deployed
        if (params.permit2 == address(0)) revert Permit2NotDeployed();

        // only deploy unsupported if this chain doesn't already have one
        if (unsupported == address(0)) {
            unsupported = address(new UnsupportedProtocol());
            console2.log('UnsupportedProtocol deployed:', unsupported);
        }

        params = RouterParameters({
            permit2: mapUnsupported(params.permit2),
            weth9: mapUnsupported(params.weth9),
            v2Factory: mapUnsupported(params.v2Factory),
            v3Factory: mapUnsupported(params.v3Factory),
            pairInitCodeHash: params.pairInitCodeHash,
            poolInitCodeHash: params.poolInitCodeHash,
            v4PoolManager: mapUnsupported(params.v4PoolManager),
            v3NFTPositionManager: mapUnsupported(params.v3NFTPositionManager),
            v4PositionManager: mapUnsupported(params.v4PositionManager),
            spokePool: mapUnsupported(params.spokePool)
        });

        logParams();

        router = new UniversalRouter(params);
        console2.log('Universal Router Deployed:', address(router));
        vm.stopBroadcast();
    }

    function logParams() internal view {
        console2.log('permit2:', params.permit2);
        console2.log('weth9:', params.weth9);
        console2.log('v2Factory:', params.v2Factory);
        console2.log('v3Factory:', params.v3Factory);
        console2.log('v4PoolManager:', params.v4PoolManager);
        console2.log('v3NFTPositionManager:', params.v3NFTPositionManager);
        console2.log('v4PositionManager:', params.v4PositionManager);
    }

    function mapUnsupported(address protocol) internal view returns (address) {
        return protocol == address(0) ? unsupported : protocol;
    }
}
</file>

<file path="test/foundry-tests/external/ChainedActions.fork.t.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test, console2} from 'forge-std/Test.sol';
import {RouterParameters} from '../../../contracts/types/RouterParameters.sol';
import {UniversalRouter, Commands} from '../../../contracts/UniversalRouter.sol';
import {AcrossV4DepositV3Params} from '../../../contracts/interfaces/IUniversalRouter.sol';
import {IWETH9} from '@uniswap/v4-periphery/src/interfaces/external/IWETH9.sol';
import {ActionConstants} from '@uniswap/v4-periphery/src/libraries/ActionConstants.sol';

contract ChainedActionsFork is Test {
    address constant ACROSS_SPOKE_POOL = 0x5c7BCd6E7De5423a257D81B442095A1a6ced35C5;
    IWETH9 constant WETH9 = IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    address constant WETH_UNICHAIN = 0x4200000000000000000000000000000000000006;

    UniversalRouter router;
    bool forked;

    function setUp() public {
        try vm.envString('INFURA_API_KEY') returns (string memory) {
            console2.log('Forked Ethereum mainnet');
            // Fork mainnet at a specific block for consistency
            vm.createSelectFork(vm.rpcUrl('mainnet'), 23_000_000);

            RouterParameters memory params = RouterParameters({
                permit2: address(0),
                weth9: address(0),
                v2Factory: address(0),
                v3Factory: address(0),
                pairInitCodeHash: bytes32(0),
                poolInitCodeHash: bytes32(0),
                v4PoolManager: address(0),
                v3NFTPositionManager: address(0),
                v4PositionManager: address(0),
                spokePool: ACROSS_SPOKE_POOL
            });
            router = new UniversalRouter(params);

            WETH9.deposit{value: 1 ether}();

            forked = true;
        } catch {
            console2.log(
                'Skipping forked tests, no infura key found. Add INFURA_API_KEY env var to .env to run forked tests.'
            );
        }
    }

    modifier onlyForked() {
        if (forked) {
            console2.log('running forked test');
            _;
            return;
        }
        console2.log('skipping forked test');
    }

    function test_depositERC20() public onlyForked {
        uint256 balanceBefore = WETH9.balanceOf(ACROSS_SPOKE_POOL);
        WETH9.transfer(address(router), 1 ether);
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.ACROSS_V4_DEPOSIT_V3)));
        AcrossV4DepositV3Params memory params = AcrossV4DepositV3Params({
            depositor: address(this),
            recipient: address(this),
            inputToken: address(WETH9),
            outputToken: WETH_UNICHAIN,
            inputAmount: 1 ether,
            outputAmount: 1 ether,
            destinationChainId: 130,
            exclusiveRelayer: address(0),
            quoteTimestamp: uint32(block.timestamp),
            fillDeadline: uint32(block.timestamp + 1 hours),
            exclusivityDeadline: 0,
            message: bytes(''),
            useNative: false
        });
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(params);
        router.execute(commands, inputs, block.timestamp);
        assertEq(WETH9.balanceOf(address(router)), 0);
        assertEq(WETH9.balanceOf(ACROSS_SPOKE_POOL), balanceBefore + 1 ether);
    }

    function test_depositNative() public onlyForked {
        uint256 routerBalanceBefore = address(router).balance;
        // ETH is wrapped as WETH9
        uint256 spokePoolBalanceBefore = WETH9.balanceOf(ACROSS_SPOKE_POOL);
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.ACROSS_V4_DEPOSIT_V3)));
        AcrossV4DepositV3Params memory params = AcrossV4DepositV3Params({
            depositor: address(this),
            recipient: address(this),
            inputToken: address(WETH9),
            outputToken: WETH_UNICHAIN,
            inputAmount: 1 ether,
            outputAmount: 1 ether,
            destinationChainId: 130,
            exclusiveRelayer: address(0),
            quoteTimestamp: uint32(block.timestamp),
            fillDeadline: uint32(block.timestamp + 1 hours),
            exclusivityDeadline: 0,
            message: bytes(''),
            useNative: true
        });
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(params);
        router.execute{value: 1 ether}(commands, inputs, block.timestamp);
        assertEq(address(router).balance, routerBalanceBefore);
        assertEq(WETH9.balanceOf(ACROSS_SPOKE_POOL), spokePoolBalanceBefore + 1 ether);
    }

    function test_depositERC20WithContractBalance() public onlyForked {
        uint256 balanceBefore = WETH9.balanceOf(ACROSS_SPOKE_POOL);
        WETH9.transfer(address(router), 1 ether);
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.ACROSS_V4_DEPOSIT_V3)));
        AcrossV4DepositV3Params memory params = AcrossV4DepositV3Params({
            depositor: address(this),
            recipient: address(this),
            inputToken: address(WETH9),
            outputToken: WETH_UNICHAIN,
            inputAmount: ActionConstants.CONTRACT_BALANCE,
            outputAmount: 1 ether,
            destinationChainId: 130,
            exclusiveRelayer: address(0),
            quoteTimestamp: uint32(block.timestamp),
            fillDeadline: uint32(block.timestamp + 1 hours),
            exclusivityDeadline: 0,
            message: bytes(''),
            useNative: false
        });
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(params);
        router.execute(commands, inputs, block.timestamp);
        assertEq(WETH9.balanceOf(address(router)), 0);
        assertEq(WETH9.balanceOf(ACROSS_SPOKE_POOL), balanceBefore + 1 ether);
    }

    function test_depositNativeWithContractBalance() public onlyForked {
        uint256 routerBalanceBefore = address(router).balance;
        uint256 totalDepositAmount = routerBalanceBefore + 1 ether;
        // ETH is wrapped as WETH9
        uint256 spokePoolBalanceBefore = WETH9.balanceOf(ACROSS_SPOKE_POOL);
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.ACROSS_V4_DEPOSIT_V3)));
        AcrossV4DepositV3Params memory params = AcrossV4DepositV3Params({
            depositor: address(this),
            recipient: address(this),
            inputToken: address(WETH9),
            outputToken: WETH_UNICHAIN,
            inputAmount: ActionConstants.CONTRACT_BALANCE,
            outputAmount: totalDepositAmount,
            destinationChainId: 130,
            exclusiveRelayer: address(0),
            quoteTimestamp: uint32(block.timestamp),
            fillDeadline: uint32(block.timestamp + 1 hours),
            exclusivityDeadline: 0,
            message: bytes(''),
            useNative: true
        });
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(params);
        router.execute{value: 1 ether}(commands, inputs, block.timestamp);
        assertEq(address(router).balance, 0);
        assertEq(WETH9.balanceOf(ACROSS_SPOKE_POOL), spokePoolBalanceBefore + totalDepositAmount);
    }
}
</file>

<file path="test/foundry-tests/mock/MockERC20.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {ERC20} from 'solmate/src/tokens/ERC20.sol';

contract MockERC20 is ERC20 {
    constructor() ERC20('TEST', 'test', 18) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}
</file>

<file path="test/foundry-tests/uniswapTokens/v2DaiWeth.t.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import 'forge-std/Test.sol';
import {ERC20} from 'solmate/src/tokens/ERC20.sol';
import {UniswapV2Test} from '../UniswapV2.t.sol';

contract V2DaiWeth is UniswapV2Test {
    ERC20 constant DAI = ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);

    function token0() internal pure override returns (address) {
        return address(WETH9);
    }

    function token1() internal pure override returns (address) {
        return address(DAI);
    }
}
</file>

<file path="test/foundry-tests/uniswapTokens/v2MockMock.t.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import 'forge-std/Test.sol';
import {MockERC20} from '../mock/MockERC20.sol';
import {UniswapV2Test} from '../UniswapV2.t.sol';

contract V2MockMock is UniswapV2Test {
    MockERC20 mockA;
    MockERC20 mockB;

    function setUpTokens() internal override {
        mockA = new MockERC20();
        mockB = new MockERC20();
    }

    function token0() internal view override returns (address) {
        return address(mockA);
    }

    function token1() internal view override returns (address) {
        return address(mockB);
    }
}
</file>

<file path="test/foundry-tests/uniswapTokens/v2MockWeth.t.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import 'forge-std/Test.sol';
import {MockERC20} from '../mock/MockERC20.sol';
import {UniswapV2Test} from '../UniswapV2.t.sol';

contract V2MockWeth is UniswapV2Test {
    MockERC20 mock;

    function setUpTokens() internal override {
        mock = new MockERC20();
    }

    function token0() internal pure override returns (address) {
        return address(WETH9);
    }

    function token1() internal view override returns (address) {
        return address(mock);
    }
}
</file>

<file path="test/foundry-tests/uniswapTokens/v2WethApe.t.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import 'forge-std/Test.sol';
import {ERC20} from 'solmate/src/tokens/ERC20.sol';
import {UniswapV2Test} from '../UniswapV2.t.sol';

contract V2WethApe is UniswapV2Test {
    ERC20 constant APE = ERC20(0x4d224452801ACEd8B2F0aebE155379bb5D594381);

    function token0() internal pure override returns (address) {
        return address(APE);
    }

    function token1() internal pure override returns (address) {
        return address(WETH9);
    }
}
</file>

<file path="test/foundry-tests/Locker.t.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import 'forge-std/Test.sol';
import {Locker} from '../../contracts/libraries/Locker.sol';

contract LockerTest is Test {
    function test_fuzz_set_get(address locker1, address locker2, address locker3) public {
        assertEq(Locker.get(), address(0));

        Locker.set(locker1);
        assertEq(Locker.get(), locker1);

        Locker.set(locker2);
        assertEq(Locker.get(), locker2);

        Locker.set(locker3);
        assertEq(Locker.get(), locker3);

        Locker.set(address(0));
        assertEq(Locker.get(), address(0));
    }

    function test_fuzz_isLocked(address locker) public {
        assertEq(Locker.get(), address(0));
        assertEq(Locker.isLocked(), false);

        Locker.set(locker);
        // the contract is locked when the locker is not address(0)
        assertEq(Locker.isLocked(), locker != address(0));

        Locker.set(address(0));
        assertEq(Locker.isLocked(), false);
    }

    function test_lockerSlot() public {
        bytes32 expectedSlot = bytes32(uint256(keccak256('Locker')) - 1);
        assertEq(expectedSlot, Locker.LOCKER_SLOT);
    }
}
</file>

<file path="test/foundry-tests/MaxInputAmount.t.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import 'forge-std/Test.sol';
import {MaxInputAmount} from '../../contracts/libraries/MaxInputAmount.sol';

contract MaxInputAmountTest is Test {
    function test_fuzz_maxAmtIn_set_get(uint256 value1, uint256 value2, uint256 value3) public {
        assertEq(MaxInputAmount.get(), 0);

        MaxInputAmount.set(value1);
        assertEq(MaxInputAmount.get(), value1);

        MaxInputAmount.set(value2);
        assertEq(MaxInputAmount.get(), value2);

        MaxInputAmount.set(value3);
        assertEq(MaxInputAmount.get(), value3);

        MaxInputAmount.set(0);
        assertEq(MaxInputAmount.get(), 0);
    }

    function test_maxAmtInSlot() public {
        bytes32 expectedSlot = bytes32(uint256(keccak256('MaxAmountIn')) - 1);
        assertEq(expectedSlot, MaxInputAmount.MAX_AMOUNT_IN_SLOT);
    }
}
</file>

<file path="test/foundry-tests/RouteSigner.t.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import 'forge-std/Test.sol';
import {UniversalRouter} from '../../contracts/UniversalRouter.sol';
import {RouteSigner} from '../../contracts/base/RouteSigner.sol';
import {IUniversalRouter} from '../../contracts/interfaces/IUniversalRouter.sol';
import {Lock} from '../../contracts/base/Lock.sol';
import {Constants} from '../../contracts/libraries/Constants.sol';
import {Commands} from '../../contracts/libraries/Commands.sol';
import {RouterParameters} from '../../contracts/types/RouterParameters.sol';

contract ContextCapture {
    UniversalRouter public router;
    address public capturedSigner;
    bytes32 public capturedIntent;
    bytes32 public capturedData;

    constructor(UniversalRouter _router) {
        router = _router;
    }

    // This function will be called during execution and will try to read the signed context
    function captureContext() external payable {
        (capturedSigner, capturedIntent, capturedData) = router.signedRouteContext();
    }

    receive() external payable {
        // Capture context when receiving ETH
        (capturedSigner, capturedIntent, capturedData) = router.signedRouteContext();
    }
}

contract ReentrantMaliciousContract {
    UniversalRouter public router;

    constructor(UniversalRouter _router) {
        router = _router;
    }

    receive() external payable {
        // Try to reenter executeSigned with arbitrary params
        // This should revert due to isNotLocked modifier
        bytes memory commands = abi.encodePacked(bytes1(0x00));
        bytes[] memory inputs = new bytes[](0);

        router.executeSigned{value: 0}(
            commands, inputs, bytes32(0), bytes32(0), false, bytes32(0), hex'', block.timestamp + 1000
        );
    }
}

contract RouteSignerTest is Test {
    uint256 constant AMOUNT = 10 ** 18;

    UniversalRouter router;
    ContextCapture capturer;

    // Signer for EIP712 signatures
    address signer;
    uint256 signerPrivateKey;

    function setUp() public {
        RouterParameters memory params = RouterParameters({
            permit2: address(0),
            weth9: address(0),
            v2Factory: address(0),
            v3Factory: address(0),
            pairInitCodeHash: bytes32(0),
            poolInitCodeHash: bytes32(0),
            v4PoolManager: address(0),
            v3NFTPositionManager: address(0),
            v4PositionManager: address(0),
            spokePool: address(0)
        });
        router = new UniversalRouter(params);
        capturer = new ContextCapture(router);

        (signer, signerPrivateKey) = makeAddrAndKey('signer');
    }

    function getDomainSeparator() internal view returns (bytes32) {
        return getDomainSeparatorFor(router);
    }

    function getDomainSeparatorFor(UniversalRouter _router) internal view returns (bytes32) {
        return keccak256(
            abi.encode(
                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
                keccak256(bytes('UniversalRouter')),
                keccak256(bytes('2')),
                block.chainid,
                address(_router)
            )
        );
    }

    function signExecution(
        bytes memory commands,
        bytes[] memory inputs,
        bytes32 intent,
        bytes32 data,
        address sender,
        bytes32 nonce,
        uint256 deadline
    ) internal view returns (bytes memory signature) {
        bytes32 EXECUTE_SIGNED_TYPEHASH = keccak256(
            'ExecuteSigned(bytes commands,bytes[] inputs,bytes32 intent,bytes32 data,address sender,bytes32 nonce,uint256 deadline)'
        );

        // Hash inputs array per EIP712
        bytes32[] memory inputHashes = new bytes32[](inputs.length);
        for (uint256 i = 0; i < inputs.length; i++) {
            inputHashes[i] = keccak256(inputs[i]);
        }
        bytes32 inputsHash = keccak256(abi.encodePacked(inputHashes));

        // Create struct hash
        bytes32 structHash = keccak256(
            abi.encode(EXECUTE_SIGNED_TYPEHASH, keccak256(commands), inputsHash, intent, data, sender, nonce, deadline)
        );

        // Get domain separator
        bytes32 domainSeparator = getDomainSeparator();

        // Create digest
        bytes32 digest = keccak256(abi.encodePacked('\x19\x01', domainSeparator, structHash));

        // Sign
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, digest);
        signature = abi.encodePacked(r, s, v);
    }

    function testExecuteSigned() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT);

        bytes32 intent = keccak256('intent');
        bytes32 data = keccak256('data');
        bytes32 nonce = keccak256('nonce1');
        uint256 deadline = block.timestamp + 1000;

        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), nonce, deadline);

        router.executeSigned{value: AMOUNT}(commands, inputs, intent, data, true, nonce, signature, deadline);

        // Verify context was captured correctly during execution
        address expectedSigner = signer;
        assertEq(capturer.capturedSigner(), expectedSigner, 'Signer mismatch during execution');
        assertEq(capturer.capturedIntent(), intent, 'Intent mismatch during execution');
        assertEq(capturer.capturedData(), data, 'Data mismatch during execution');

        // Verify nonce was marked as used
        assertTrue(router.noncesUsed(expectedSigner, nonce), 'Nonce should be marked as used');

        // Verify context was cleared after execution
        (address storedSigner, bytes32 storedIntent, bytes32 storedData) = router.signedRouteContext();
        assertEq(storedSigner, address(0), 'Signer should be cleared after execution');
        assertEq(storedIntent, bytes32(0), 'Intent should be cleared after execution');
        assertEq(storedData, bytes32(0), 'Data should be cleared after execution');
    }

    function testExecuteSignedWrongSender() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT);

        bytes32 intent = keccak256('intent');
        bytes32 data = keccak256('data');
        bytes32 nonce = keccak256('nonce2');
        uint256 deadline = block.timestamp + 1000;

        // Sign with address(this) as sender
        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), nonce, deadline);

        // Try to call from a different address
        address alice = makeAddr('alice');
        vm.deal(alice, AMOUNT);
        vm.prank(alice);

        // Won't revert but will recover wrong signer
        router.executeSigned{value: AMOUNT}(commands, inputs, intent, data, true, nonce, signature, deadline);

        // Verify the recovered signer is NOT the expected signer
        address expectedSigner = signer;
        assertTrue(capturer.capturedSigner() != expectedSigner, 'Signer should not match when called from wrong sender');

        // But intent and data should still be stored correctly
        assertEq(capturer.capturedIntent(), intent, 'Intent should match');
        assertEq(capturer.capturedData(), data, 'Data should match');
    }

    function testExecuteSignedNoSenderVerification() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT);

        bytes32 intent = keccak256('intent');
        bytes32 data = keccak256('data');
        bytes32 nonce = keccak256('nonce3');
        uint256 deadline = block.timestamp + 1000;

        // Sign with address(0) as sender (no sender verification)
        bytes memory signature = signExecution(commands, inputs, intent, data, address(0), nonce, deadline);

        // Call from a different address
        address bob = makeAddr('bob');
        vm.deal(bob, AMOUNT);
        vm.prank(bob);

        router.executeSigned{value: AMOUNT}(commands, inputs, intent, data, false, nonce, signature, deadline);

        // Verify context was captured correctly during execution
        address expectedSigner = signer;
        assertEq(capturer.capturedSigner(), expectedSigner, 'Signer mismatch during execution');
        assertEq(capturer.capturedIntent(), intent, 'Intent mismatch during execution');
        assertEq(capturer.capturedData(), data, 'Data mismatch during execution');
    }

    function testExecuteSignedMultipleCommands() public {
        // Create 3 transfer commands
        bytes memory commands = abi.encodePacked(
            bytes1(uint8(Commands.TRANSFER)), bytes1(uint8(Commands.TRANSFER)), bytes1(uint8(Commands.TRANSFER))
        );

        address recipient1 = makeAddr('recipient1');
        address recipient2 = makeAddr('recipient2');

        bytes[] memory inputs = new bytes[](3);
        inputs[0] = abi.encode(Constants.ETH, recipient1, AMOUNT / 3);
        inputs[1] = abi.encode(Constants.ETH, address(capturer), AMOUNT / 3); // This will trigger receive() and capture context
        inputs[2] = abi.encode(Constants.ETH, recipient2, AMOUNT / 3);

        bytes32 intent = keccak256('multi-command-intent');
        bytes32 data = keccak256('multi-command-data');
        bytes32 nonce = keccak256('nonce4');
        uint256 deadline = block.timestamp + 1000;

        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), nonce, deadline);

        router.executeSigned{value: AMOUNT}(commands, inputs, intent, data, true, nonce, signature, deadline);

        // Verify context was captured correctly during execution (from the second command)
        address expectedSigner = signer;
        assertEq(capturer.capturedSigner(), expectedSigner, 'Signer mismatch during multi-command execution');
        assertEq(capturer.capturedIntent(), intent, 'Intent mismatch during multi-command execution');
        assertEq(capturer.capturedData(), data, 'Data mismatch during multi-command execution');

        // Verify all transfers happened
        assertEq(recipient1.balance, AMOUNT / 3, 'Recipient1 should have received ETH');
        assertEq(recipient2.balance, AMOUNT / 3, 'Recipient2 should have received ETH');

        // Verify context was cleared after execution
        (address storedSigner, bytes32 storedIntent, bytes32 storedData) = router.signedRouteContext();
        assertEq(storedSigner, address(0), 'Signer should be cleared after execution');
        assertEq(storedIntent, bytes32(0), 'Intent should be cleared after execution');
        assertEq(storedData, bytes32(0), 'Data should be cleared after execution');
    }

    function testNonceReplayProtection() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT);

        bytes32 intent = keccak256('intent');
        bytes32 data = keccak256('data');
        bytes32 nonce = keccak256('replay-nonce');
        uint256 deadline = block.timestamp + 1000;

        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), nonce, deadline);

        // First execution should succeed
        router.executeSigned{value: AMOUNT}(commands, inputs, intent, data, true, nonce, signature, deadline);

        // Second execution with same nonce should revert
        vm.expectRevert(RouteSigner.NonceAlreadyUsed.selector);
        router.executeSigned{value: AMOUNT}(commands, inputs, intent, data, true, nonce, signature, deadline);
    }

    function testOptionalNonce() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT);

        bytes32 intent = keccak256('intent');
        bytes32 data = keccak256('data');
        bytes32 optionalNonce = bytes32(type(uint256).max); // Sentinel value to skip nonce check
        uint256 deadline = block.timestamp + 1000;

        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), optionalNonce, deadline);

        address expectedSigner = signer;

        // First execution should succeed
        router.executeSigned{value: AMOUNT}(commands, inputs, intent, data, true, optionalNonce, signature, deadline);

        // Verify nonce was NOT marked as used
        assertFalse(router.noncesUsed(expectedSigner, optionalNonce), 'Optional nonce should not be marked as used');

        // Second execution with same signature should also succeed (no replay protection)
        router.executeSigned{value: AMOUNT}(commands, inputs, intent, data, true, optionalNonce, signature, deadline);
    }

    function testExpiredDeadline() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT);

        bytes32 intent = keccak256('intent');
        bytes32 data = keccak256('data');
        bytes32 nonce = keccak256('deadline-nonce');
        uint256 deadline = block.timestamp - 1; // Deadline in the past

        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), nonce, deadline);

        // Should revert with TransactionDeadlinePassed
        vm.expectRevert(IUniversalRouter.TransactionDeadlinePassed.selector);
        router.executeSigned{value: AMOUNT}(commands, inputs, intent, data, true, nonce, signature, deadline);
    }

    function testInvalidSignature() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT);

        bytes32 intent = keccak256('intent');
        bytes32 data = keccak256('data');
        bytes32 nonce = keccak256('invalid-sig-nonce');
        uint256 deadline = block.timestamp + 1000;

        // Create a completely invalid signature
        bytes memory invalidSignature = abi.encodePacked(bytes32(uint256(1)), bytes32(uint256(2)), uint8(27));

        router.executeSigned{value: AMOUNT}(commands, inputs, intent, data, false, nonce, invalidSignature, deadline);

        // Verify the recovered signer is NOT the expected signer
        address expectedSigner = signer;
        assertTrue(capturer.capturedSigner() != expectedSigner, 'Invalid signature should recover different signer');
    }

    function testTamperedCommands() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));

        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT);

        bytes32 intent = keccak256('intent');
        bytes32 data = keccak256('data');
        bytes32 nonce = keccak256('tampered-commands-nonce');
        uint256 deadline = block.timestamp + 1000;

        // Sign with original commands
        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), nonce, deadline);

        // Tamper with commands - use TRANSFER with allow revert flag
        bytes memory tamperedCommands =
            abi.encodePacked(bytes1(uint8(Commands.TRANSFER) | uint8(Commands.FLAG_ALLOW_REVERT)));

        router.executeSigned{value: AMOUNT}(tamperedCommands, inputs, intent, data, false, nonce, signature, deadline);

        // Verify the recovered signer is NOT the expected signer
        address expectedSigner = signer;
        assertTrue(capturer.capturedSigner() != expectedSigner, 'Tampered commands should recover different signer');
    }

    function testTamperedInputs() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));

        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT);

        bytes32 intent = keccak256('intent');
        bytes32 data = keccak256('data');
        bytes32 nonce = keccak256('tampered-inputs-nonce');
        uint256 deadline = block.timestamp + 1000;

        // Sign with original inputs
        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), nonce, deadline);

        // Tamper with inputs - change recipient
        address differentRecipient = makeAddr('differentRecipient');
        bytes[] memory tamperedInputs = new bytes[](1);
        tamperedInputs[0] = abi.encode(Constants.ETH, differentRecipient, AMOUNT);

        router.executeSigned{value: AMOUNT}(commands, tamperedInputs, intent, data, false, nonce, signature, deadline);

        // Verify the recovered signer is NOT the expected signer
        address expectedSigner = signer;
        assertTrue(capturer.capturedSigner() != expectedSigner, 'Tampered inputs should recover different signer');
    }

    function testTamperedIntent() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT);

        bytes32 intent = keccak256('intent');
        bytes32 data = keccak256('data');
        bytes32 nonce = keccak256('tampered-intent-nonce');
        uint256 deadline = block.timestamp + 1000;

        // Sign with original intent
        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), nonce, deadline);

        // Tamper with intent
        bytes32 tamperedIntent = keccak256('different-intent');

        router.executeSigned{value: AMOUNT}(commands, inputs, tamperedIntent, data, false, nonce, signature, deadline);

        // Verify the recovered signer is NOT the expected signer
        address expectedSigner = signer;
        assertTrue(capturer.capturedSigner() != expectedSigner, 'Tampered intent should recover different signer');
    }

    function testTamperedData() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT);

        bytes32 intent = keccak256('intent');
        bytes32 data = keccak256('data');
        bytes32 nonce = keccak256('tampered-data-nonce');
        uint256 deadline = block.timestamp + 1000;

        // Sign with original data
        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), nonce, deadline);

        // Tamper with data
        bytes32 tamperedData = keccak256('different-data');

        router.executeSigned{value: AMOUNT}(commands, inputs, intent, tamperedData, false, nonce, signature, deadline);

        // Verify the recovered signer is NOT the expected signer
        address expectedSigner = signer;
        assertTrue(capturer.capturedSigner() != expectedSigner, 'Tampered data should recover different signer');
    }

    function testTamperedNonce() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT);

        bytes32 intent = keccak256('intent');
        bytes32 data = keccak256('data');
        bytes32 nonce = keccak256('original-nonce');
        uint256 deadline = block.timestamp + 1000;

        // Sign with original nonce
        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), nonce, deadline);

        // Tamper with nonce
        bytes32 tamperedNonce = keccak256('tampered-nonce');

        router.executeSigned{value: AMOUNT}(commands, inputs, intent, data, false, tamperedNonce, signature, deadline);

        // Verify the recovered signer is NOT the expected signer
        address expectedSigner = signer;
        assertTrue(capturer.capturedSigner() != expectedSigner, 'Tampered nonce should recover different signer');
    }

    function testWrongDeadlineMismatch() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT);

        bytes32 intent = keccak256('intent');
        bytes32 data = keccak256('data');
        bytes32 nonce = keccak256('deadline-mismatch-nonce');
        uint256 deadline = block.timestamp + 1000;

        // Sign with one deadline
        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), nonce, deadline);

        // Call with different deadline
        uint256 differentDeadline = block.timestamp + 2000;

        router.executeSigned{value: AMOUNT}(commands, inputs, intent, data, false, nonce, signature, differentDeadline);

        // Verify the recovered signer is NOT the expected signer
        address expectedSigner = signer;
        assertTrue(capturer.capturedSigner() != expectedSigner, 'Wrong deadline should recover different signer');
    }

    function testRegularExecuteHasNoContext() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT);

        // Execute using regular execute() (not executeSigned)
        router.execute{value: AMOUNT}(commands, inputs, block.timestamp + 1000);

        // Verify no context was captured during execution
        assertEq(capturer.capturedSigner(), address(0), 'Signer should be zero during regular execute');
        assertEq(capturer.capturedIntent(), bytes32(0), 'Intent should be zero during regular execute');
        assertEq(capturer.capturedData(), bytes32(0), 'Data should be zero during regular execute');

        // Verify context is still zero after execution
        (address storedSigner, bytes32 storedIntent, bytes32 storedData) = router.signedRouteContext();
        assertEq(storedSigner, address(0), 'Signer should be zero after regular execute');
        assertEq(storedIntent, bytes32(0), 'Intent should be zero after regular execute');
        assertEq(storedData, bytes32(0), 'Data should be zero after regular execute');
    }

    function testNestedExecuteSubPlanPreservesContext() public {
        // Create a sub-plan that transfers to the capturer contract (which will capture context)
        bytes memory subCommands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory subInputs = new bytes[](1);
        subInputs[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT / 2);

        // Create main commands with EXECUTE_SUB_PLAN
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.EXECUTE_SUB_PLAN)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(subCommands, subInputs);

        bytes32 intent = keccak256('nested-intent');
        bytes32 data = keccak256('nested-data');
        bytes32 nonce = keccak256('nested-nonce');
        uint256 deadline = block.timestamp + 1000;

        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), nonce, deadline);

        router.executeSigned{value: AMOUNT}(commands, inputs, intent, data, true, nonce, signature, deadline);

        // Verify context was preserved during nested execution
        address expectedSigner = signer;
        assertEq(capturer.capturedSigner(), expectedSigner, 'Signer should be preserved in nested execution');
        assertEq(capturer.capturedIntent(), intent, 'Intent should be preserved in nested execution');
        assertEq(capturer.capturedData(), data, 'Data should be preserved in nested execution');

        // Verify context was cleared after execution
        (address storedSigner, bytes32 storedIntent, bytes32 storedData) = router.signedRouteContext();
        assertEq(storedSigner, address(0), 'Signer should be cleared after execution');
        assertEq(storedIntent, bytes32(0), 'Intent should be cleared after execution');
        assertEq(storedData, bytes32(0), 'Data should be cleared after execution');
    }

    function testContextNotLeakedBetweenTransactions() public {
        // First transaction - signed execution
        bytes memory commands1 = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs1 = new bytes[](1);
        inputs1[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT / 2);

        bytes32 intent1 = keccak256('intent1');
        bytes32 data1 = keccak256('data1');
        bytes32 nonce1 = keccak256('nonce-tx1');
        uint256 deadline1 = block.timestamp + 1000;

        bytes memory signature1 = signExecution(commands1, inputs1, intent1, data1, address(this), nonce1, deadline1);

        router.executeSigned{value: AMOUNT / 2}(commands1, inputs1, intent1, data1, true, nonce1, signature1, deadline1);

        // Verify first transaction context
        address expectedSigner = signer;
        assertEq(capturer.capturedSigner(), expectedSigner, 'First transaction should capture signer');
        assertEq(capturer.capturedIntent(), intent1, 'First transaction should capture intent1');
        assertEq(capturer.capturedData(), data1, 'First transaction should capture data1');

        // Verify context was cleared after first transaction
        (address storedSigner, bytes32 storedIntent, bytes32 storedData) = router.signedRouteContext();
        assertEq(storedSigner, address(0), 'Context should be cleared between transactions');
        assertEq(storedIntent, bytes32(0), 'Intent should be cleared between transactions');
        assertEq(storedData, bytes32(0), 'Data should be cleared between transactions');

        // Second transaction - different signed execution
        bytes memory commands2 = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs2 = new bytes[](1);
        inputs2[0] = abi.encode(Constants.ETH, address(capturer), AMOUNT / 2);

        bytes32 intent2 = keccak256('intent2');
        bytes32 data2 = keccak256('data2');
        bytes32 nonce2 = keccak256('nonce-tx2');
        uint256 deadline2 = block.timestamp + 1000;

        bytes memory signature2 = signExecution(commands2, inputs2, intent2, data2, address(this), nonce2, deadline2);

        router.executeSigned{value: AMOUNT / 2}(commands2, inputs2, intent2, data2, true, nonce2, signature2, deadline2);

        // Verify second transaction has its own context (not leaked from first)
        assertEq(capturer.capturedSigner(), expectedSigner, 'Second transaction should capture signer');
        assertEq(capturer.capturedIntent(), intent2, 'Second transaction should capture intent2 (not intent1)');
        assertEq(capturer.capturedData(), data2, 'Second transaction should capture data2 (not data1)');

        // Verify context was cleared after second transaction
        (storedSigner, storedIntent, storedData) = router.signedRouteContext();
        assertEq(storedSigner, address(0), 'Context should be cleared after second transaction');
        assertEq(storedIntent, bytes32(0), 'Intent should be cleared after second transaction');
        assertEq(storedData, bytes32(0), 'Data should be cleared after second transaction');
    }

    function testDifferentContractAddresses() public {
        // Deploy a second router
        RouterParameters memory params = RouterParameters({
            permit2: address(0),
            weth9: address(0),
            v2Factory: address(0),
            v3Factory: address(0),
            pairInitCodeHash: bytes32(0),
            poolInitCodeHash: bytes32(0),
            v4PoolManager: address(0),
            v3NFTPositionManager: address(0),
            v4PositionManager: address(0),
            spokePool: address(0)
        });
        UniversalRouter router2 = new UniversalRouter(params);

        // Deploy a context capture contract for router2
        ContextCapture capturer2 = new ContextCapture(router2);

        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(capturer2), AMOUNT);

        bytes32 intent = keccak256('intent');
        bytes32 data = keccak256('data');
        bytes32 nonce = keccak256('different-contract-nonce');
        uint256 deadline = block.timestamp + 1000;

        // Sign for router1 (uses router1's address in domain separator)
        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), nonce, deadline);

        // Try to execute on router2 with signature for router1
        router2.executeSigned{value: AMOUNT}(commands, inputs, intent, data, false, nonce, signature, deadline);

        // Verify the recovered signer is NOT the expected signer (because domain separator is different)
        address expectedSigner = signer;
        assertTrue(capturer2.capturedSigner() != expectedSigner, 'Signature should not be valid for different contract');
    }

    function testReentrantMaliciousContract() public {
        // Deploy malicious contract
        ReentrantMaliciousContract malicious = new ReentrantMaliciousContract(router);

        // Create commands that transfer to the malicious contract
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.TRANSFER)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, address(malicious), AMOUNT);

        bytes32 intent = keccak256('reentry-intent');
        bytes32 data = keccak256('reentry-data');
        bytes32 nonce = keccak256('reentry-nonce');
        uint256 deadline = block.timestamp + 1000;

        bytes memory signature = signExecution(commands, inputs, intent, data, address(this), nonce, deadline);

        // Expect revert - malicious contract's reentry attempt will fail and cause ETH transfer to fail
        // (The reentry fails due to invalid signature, which happens before isNotLocked check)
        vm.expectRevert('ETH_TRANSFER_FAILED');
        router.executeSigned{value: AMOUNT}(commands, inputs, intent, data, true, nonce, signature, deadline);
    }
}
</file>

<file path="test/foundry-tests/UniswapV2.t.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import 'forge-std/Test.sol';
import {IPermit2} from 'permit2/src/interfaces/IPermit2.sol';
import {ERC20} from 'solmate/src/tokens/ERC20.sol';
import {IUniswapV2Factory} from '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';
import {IUniswapV2Pair} from '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';
import {UniversalRouter} from '../../contracts/UniversalRouter.sol';
import {Payments} from '../../contracts/modules/Payments.sol';
import {ActionConstants} from '@uniswap/v4-periphery/src/libraries/ActionConstants.sol';
import {Commands} from '../../contracts/libraries/Commands.sol';
import {RouterParameters} from '../../contracts/types/RouterParameters.sol';

abstract contract UniswapV2Test is Test {
    address constant RECIPIENT = address(10);
    uint256 constant AMOUNT = 1 ether;
    uint256 constant BALANCE = 100000 ether;
    IUniswapV2Factory constant FACTORY = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);
    ERC20 constant WETH9 = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IPermit2 constant PERMIT2 = IPermit2(0x000000000022D473030F116dDEE9F6B43aC78BA3);
    address constant FROM = address(1234);

    UniversalRouter router;

    function setUp() public virtual {
        vm.createSelectFork(vm.envString('FORK_URL'), 20010000);
        setUpTokens();

        RouterParameters memory params = RouterParameters({
            permit2: address(PERMIT2),
            weth9: address(WETH9),
            v2Factory: address(FACTORY),
            v3Factory: address(0),
            pairInitCodeHash: bytes32(0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f),
            poolInitCodeHash: bytes32(0),
            v4PoolManager: address(0),
            v3NFTPositionManager: address(0),
            v4PositionManager: address(0),
            spokePool: address(0)
        });
        router = new UniversalRouter(params);

        // pair doesn't exist, make a mock one
        if (FACTORY.getPair(token0(), token1()) == address(0)) {
            address pair = FACTORY.createPair(token0(), token1());
            deal(token0(), pair, 100 ether);
            deal(token1(), pair, 100 ether);
            IUniswapV2Pair(pair).sync();
        }

        vm.startPrank(FROM);
        deal(FROM, BALANCE);
        deal(token0(), FROM, BALANCE);
        deal(token1(), FROM, BALANCE);
        ERC20(token0()).approve(address(PERMIT2), type(uint256).max);
        ERC20(token1()).approve(address(PERMIT2), type(uint256).max);
        PERMIT2.approve(token0(), address(router), type(uint160).max, type(uint48).max);
        PERMIT2.approve(token1(), address(router), type(uint160).max, type(uint48).max);
    }

    function testExactInput0For1() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.V2_SWAP_EXACT_IN)));
        address[] memory path = new address[](2);
        path[0] = token0();
        path[1] = token1();
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(ActionConstants.MSG_SENDER, AMOUNT, 0, path, true);

        router.execute(commands, inputs);
        assertEq(ERC20(token0()).balanceOf(FROM), BALANCE - AMOUNT);
        assertGt(ERC20(token1()).balanceOf(FROM), BALANCE);
    }

    function testExactInput1For0() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.V2_SWAP_EXACT_IN)));
        address[] memory path = new address[](2);
        path[0] = token1();
        path[1] = token0();
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(ActionConstants.MSG_SENDER, AMOUNT, 0, path, true);

        router.execute(commands, inputs);
        assertEq(ERC20(token1()).balanceOf(FROM), BALANCE - AMOUNT);
        assertGt(ERC20(token0()).balanceOf(FROM), BALANCE);
    }

    function testExactInput0For1FromRouter() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.V2_SWAP_EXACT_IN)));
        deal(token0(), address(router), AMOUNT);
        address[] memory path = new address[](2);
        path[0] = token0();
        path[1] = token1();
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(ActionConstants.MSG_SENDER, AMOUNT, 0, path, false);

        router.execute(commands, inputs);
        assertGt(ERC20(token1()).balanceOf(FROM), BALANCE);
    }

    function testExactInput1For0FromRouter() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.V2_SWAP_EXACT_IN)));
        deal(token1(), address(router), AMOUNT);
        address[] memory path = new address[](2);
        path[0] = token1();
        path[1] = token0();
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(ActionConstants.MSG_SENDER, AMOUNT, 0, path, false);

        router.execute(commands, inputs);
        assertGt(ERC20(token0()).balanceOf(FROM), BALANCE);
    }

    function testExactOutput0For1() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.V2_SWAP_EXACT_OUT)));
        address[] memory path = new address[](2);
        path[0] = token0();
        path[1] = token1();
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(ActionConstants.MSG_SENDER, AMOUNT, type(uint256).max, path, true);

        router.execute(commands, inputs);
        assertLt(ERC20(token0()).balanceOf(FROM), BALANCE);
        assertGe(ERC20(token1()).balanceOf(FROM), BALANCE + AMOUNT);
    }

    function testExactOutput1For0() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.V2_SWAP_EXACT_OUT)));
        address[] memory path = new address[](2);
        path[0] = token1();
        path[1] = token0();
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(ActionConstants.MSG_SENDER, AMOUNT, type(uint256).max, path, true);

        router.execute(commands, inputs);
        assertLt(ERC20(token1()).balanceOf(FROM), BALANCE);
        assertGe(ERC20(token0()).balanceOf(FROM), BALANCE + AMOUNT);
    }

    function testExactOutput0For1FromRouter() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.V2_SWAP_EXACT_OUT)));
        deal(token0(), address(router), BALANCE);
        address[] memory path = new address[](2);
        path[0] = token0();
        path[1] = token1();
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(ActionConstants.MSG_SENDER, AMOUNT, type(uint256).max, path, false);

        router.execute(commands, inputs);
        assertGe(ERC20(token1()).balanceOf(FROM), BALANCE + AMOUNT);
    }

    function testExactOutput1For0FromRouter() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.V2_SWAP_EXACT_OUT)));
        deal(token1(), address(router), BALANCE);
        address[] memory path = new address[](2);
        path[0] = token1();
        path[1] = token0();
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(ActionConstants.MSG_SENDER, AMOUNT, type(uint256).max, path, false);

        router.execute(commands, inputs);
        assertGe(ERC20(token0()).balanceOf(FROM), BALANCE + AMOUNT);
    }

    function token0() internal virtual returns (address);
    function token1() internal virtual returns (address);

    function setUpTokens() internal virtual {}
}
</file>

<file path="test/foundry-tests/UniversalRouter.t.sol">
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import 'forge-std/Test.sol';
import {UniversalRouter} from '../../contracts/UniversalRouter.sol';
import {Payments} from '../../contracts/modules/Payments.sol';
import {Constants} from '../../contracts/libraries/Constants.sol';
import {Commands} from '../../contracts/libraries/Commands.sol';
import {MockERC20} from './mock/MockERC20.sol';
import {ExampleModule} from '../../contracts/test/ExampleModule.sol';
import {RouterParameters} from '../../contracts/types/RouterParameters.sol';
import {ERC20} from 'solmate/src/tokens/ERC20.sol';
import 'permit2/src/interfaces/IAllowanceTransfer.sol';
import {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';

contract UniversalRouterTest is Test {
    address constant RECIPIENT = address(1234);
    uint256 constant AMOUNT = 10 ** 18;

    UniversalRouter router;
    ExampleModule testModule;
    MockERC20 erc20;

    function setUp() public {
        RouterParameters memory params = RouterParameters({
            permit2: address(0),
            weth9: address(0),
            v2Factory: address(0),
            v3Factory: address(0),
            pairInitCodeHash: bytes32(0),
            poolInitCodeHash: bytes32(0),
            v4PoolManager: address(0),
            v3NFTPositionManager: address(0),
            v4PositionManager: address(0),
            spokePool: address(0)
        });
        router = new UniversalRouter(params);
        testModule = new ExampleModule();
        erc20 = new MockERC20();
    }

    event ExampleModuleEvent(string message);

    function testCallModule() public {
        uint256 bytecodeSize;
        address theRouter = address(router);
        assembly {
            bytecodeSize := extcodesize(theRouter)
        }
        emit log_uint(bytecodeSize);
    }

    function testSweepToken() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.SWEEP)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(address(erc20), RECIPIENT, AMOUNT);

        erc20.mint(address(router), AMOUNT);
        assertEq(erc20.balanceOf(RECIPIENT), 0);

        router.execute(commands, inputs);

        assertEq(erc20.balanceOf(RECIPIENT), AMOUNT);
    }

    function testSweepTokenInsufficientOutput() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.SWEEP)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(address(erc20), RECIPIENT, AMOUNT + 1);

        erc20.mint(address(router), AMOUNT);
        assertEq(erc20.balanceOf(RECIPIENT), 0);

        vm.expectRevert(Payments.InsufficientToken.selector);
        router.execute(commands, inputs);
    }

    function testSweepETH() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.SWEEP)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, RECIPIENT, AMOUNT);

        assertEq(RECIPIENT.balance, 0);

        router.execute{value: AMOUNT}(commands, inputs);

        assertEq(RECIPIENT.balance, AMOUNT);
    }

    function testSweepETHInsufficientOutput() public {
        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.SWEEP)));
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(Constants.ETH, RECIPIENT, AMOUNT + 1);

        erc20.mint(address(router), AMOUNT);

        vm.expectRevert(Payments.InsufficientETH.selector);
        router.execute(commands, inputs);
    }
}
</file>

<file path="test/integration-tests/gas-tests/__snapshots__/CheckOwnership.gas.test.ts.snap">
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Check Ownership Gas gas: balance check ERC20 1`] = `
Object {
  "calldataByteLength": 356,
  "gasUsed": 38007,
}
`;
</file>

<file path="test/integration-tests/gas-tests/__snapshots__/Payments.gas.test.ts.snap">
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Payments Gas Tests Individual Command Tests gas: SWEEP with ERC20 1`] = `
Object {
  "calldataByteLength": 356,
  "gasUsed": 37301,
}
`;

exports[`Payments Gas Tests Individual Command Tests gas: SWEEP_WITH_FEE 1`] = `
Object {
  "calldataByteLength": 516,
  "gasUsed": 66117,
}
`;

exports[`Payments Gas Tests Individual Command Tests gas: TRANSFER with ERC20 1`] = `
Object {
  "calldataByteLength": 356,
  "gasUsed": 36319,
}
`;

exports[`Payments Gas Tests Individual Command Tests gas: TRANSFER with ETH 1`] = `
Object {
  "calldataByteLength": 356,
  "gasUsed": 31872,
}
`;

exports[`Payments Gas Tests Individual Command Tests gas: UNWRAP_WETH 1`] = `
Object {
  "calldataByteLength": 324,
  "gasUsed": 44938,
}
`;

exports[`Payments Gas Tests Individual Command Tests gas: UNWRAP_WETH_WITH_FEE 1`] = `
Object {
  "calldataByteLength": 644,
  "gasUsed": 51501,
}
`;

exports[`Payments Gas Tests Individual Command Tests gas: WRAP_ETH 1`] = `
Object {
  "calldataByteLength": 324,
  "gasUsed": 53716,
}
`;
</file>

<file path="test/integration-tests/gas-tests/__snapshots__/Uniswap.gas.test.ts.snap">
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Batch reverts gas: 2 sub-plans, both fail but the transaction succeeds 1`] = `
Object {
  "calldataByteLength": 1764,
  "gasUsed": 273531,
}
`;

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Batch reverts gas: 2 sub-plans, neither fails 1`] = `
Object {
  "calldataByteLength": 1764,
  "gasUsed": 249218,
}
`;

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Batch reverts gas: 2 sub-plans, second sub plan fails 1`] = `
Object {
  "calldataByteLength": 1764,
  "gasUsed": 249218,
}
`;

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Batch reverts gas: 2 sub-plans, the first fails 1`] = `
Object {
  "calldataByteLength": 1764,
  "gasUsed": 273531,
}
`;

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Interleaving routes gas: V2, then V3 1`] = `
Object {
  "calldataByteLength": 836,
  "gasUsed": 191332,
}
`;

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Interleaving routes gas: V3, then V2 1`] = `
Object {
  "calldataByteLength": 836,
  "gasUsed": 178869,
}
`;

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Split routes gas: ERC20 --> ERC20 split V2 and V2 different routes, different input tokens, each two hop, with batch permit 1`] = `
Object {
  "calldataByteLength": 1540,
  "gasUsed": 299714,
}
`;

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Split routes gas: ERC20 --> ERC20 split V2 and V2 different routes, each two hop, with explicit permit 1`] = `
Object {
  "calldataByteLength": 1220,
  "gasUsed": 310403,
}
`;

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Split routes gas: ERC20 --> ERC20 split V2 and V2 different routes, each two hop, with explicit permit transfer from batch 1`] = `
Object {
  "calldataByteLength": 1284,
  "gasUsed": 311659,
}
`;

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Split routes gas: ERC20 --> ERC20 split V2 and V2 different routes, each two hop, without explicit permit 1`] = `
Object {
  "calldataByteLength": 900,
  "gasUsed": 306723,
}
`;

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Split routes gas: ERC20 --> ERC20 split V2 and V3, one hop 1`] = `
Object {
  "calldataByteLength": 996,
  "gasUsed": 178918,
}
`;

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Split routes gas: ERC20 --> ERC20 split V2 and V3, one hop, ADDRESS_THIS flag 1`] = `
Object {
  "calldataByteLength": 996,
  "gasUsed": 178693,
}
`;

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Split routes gas: ERC20 --> ETH split V2 and V3, exactOut, one hop 1`] = `
Object {
  "calldataByteLength": 964,
  "gasUsed": 194232,
}
`;

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Split routes gas: ERC20 --> ETH split V2 and V3, one hop 1`] = `
Object {
  "calldataByteLength": 964,
  "gasUsed": 186862,
}
`;

exports[`Uniswap Gas Tests Mixing V2 and V3 with Universal Router. Split routes gas: ETH --> ERC20 split V2 and V3, one hop 1`] = `
Object {
  "calldataByteLength": 1124,
  "gasUsed": 193755,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Router02. gas: ERC20 --> ERC20 exactIn, one trade, one hop 1`] = `
Object {
  "calldataByteLength": 420,
  "gasUsed": 121407,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Router02. gas: ERC20 --> ERC20 exactIn, one trade, two hops 1`] = `
Object {
  "calldataByteLength": 452,
  "gasUsed": 189985,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Router02. gas: ERC20 --> ERC20 exactOut, one trade, one hop 1`] = `
Object {
  "calldataByteLength": 420,
  "gasUsed": 122001,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Router02. gas: ERC20 --> ETH exactOut ETH, one trade, one hop 1`] = `
Object {
  "calldataByteLength": 580,
  "gasUsed": 122933,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Router02. gas: ETH --> ERC20 exactIn, one trade, one hop 1`] = `
Object {
  "calldataByteLength": 420,
  "gasUsed": 124889,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Universal Router. ERC20 --> ERC20 gas: exactIn trade, where an output fee is taken 1`] = `
Object {
  "calldataByteLength": 836,
  "gasUsed": 127798,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Universal Router. ERC20 --> ERC20 gas: exactIn, one trade, one hop 1`] = `
Object {
  "calldataByteLength": 516,
  "gasUsed": 107767,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Universal Router. ERC20 --> ERC20 gas: exactIn, one trade, three hops 1`] = `
Object {
  "calldataByteLength": 580,
  "gasUsed": 243074,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Universal Router. ERC20 --> ERC20 gas: exactIn, one trade, three hops, no deadline 1`] = `
Object {
  "calldataByteLength": 548,
  "gasUsed": 242816,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Universal Router. ERC20 --> ERC20 gas: exactIn, one trade, two hops 1`] = `
Object {
  "calldataByteLength": 548,
  "gasUsed": 175466,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Universal Router. ERC20 --> ERC20 gas: exactIn, one trade, two hops, MSG_SENDER flag 1`] = `
Object {
  "calldataByteLength": 548,
  "gasUsed": 175466,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Universal Router. ERC20 --> ERC20 gas: exactOut, one trade, one hop 1`] = `
Object {
  "calldataByteLength": 516,
  "gasUsed": 107355,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Universal Router. ERC20 --> ERC20 gas: exactOut, one trade, three hops 1`] = `
Object {
  "calldataByteLength": 580,
  "gasUsed": 248413,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Universal Router. ERC20 --> ERC20 gas: exactOut, one trade, two hops 1`] = `
Object {
  "calldataByteLength": 548,
  "gasUsed": 177957,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Universal Router. ERC20 --> ETH gas: exactIn, one trade, one hop 1`] = `
Object {
  "calldataByteLength": 644,
  "gasUsed": 124213,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Universal Router. ERC20 --> ETH gas: exactOut, one trade, one hop 1`] = `
Object {
  "calldataByteLength": 804,
  "gasUsed": 129151,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Universal Router. ERC20 --> ETH gas: exactOut, with ETH fee 1`] = `
Object {
  "calldataByteLength": 964,
  "gasUsed": 137185,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Universal Router. ETH --> ERC20 gas: exactIn, one trade, one hop 1`] = `
Object {
  "calldataByteLength": 644,
  "gasUsed": 107744,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV2 with Universal Router. ETH --> ERC20 gas: exactOut, one trade, one hop 1`] = `
Object {
  "calldataByteLength": 772,
  "gasUsed": 126268,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Router02. gas: ERC20 --> ERC20 exactIn, one trade, one hop 1`] = `
Object {
  "calldataByteLength": 420,
  "gasUsed": 104144,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Router02. gas: ERC20 --> ERC20 exactIn, one trade, three hops 1`] = `
Object {
  "calldataByteLength": 484,
  "gasUsed": 265954,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Router02. gas: ERC20 --> ERC20 exactIn, one trade, two hops 1`] = `
Object {
  "calldataByteLength": 484,
  "gasUsed": 185123,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Router02. gas: ERC20 --> ERC20 exactOut, one trade, one hop 1`] = `
Object {
  "calldataByteLength": 420,
  "gasUsed": 113677,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Router02. gas: ERC20 --> ERC20 exactOut, one trade, three hops 1`] = `
Object {
  "calldataByteLength": 484,
  "gasUsed": 256480,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Router02. gas: ERC20 --> ERC20 exactOut, one trade, two hops 1`] = `
Object {
  "calldataByteLength": 484,
  "gasUsed": 176659,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Universal Router. ERC20 --> ERC20 gas: exactIn, one trade, one hop 1`] = `
Object {
  "calldataByteLength": 516,
  "gasUsed": 106693,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Universal Router. ERC20 --> ERC20 gas: exactIn, one trade, three hops 1`] = `
Object {
  "calldataByteLength": 548,
  "gasUsed": 256740,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Universal Router. ERC20 --> ERC20 gas: exactIn, one trade, two hops 1`] = `
Object {
  "calldataByteLength": 548,
  "gasUsed": 179102,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Universal Router. ERC20 --> ERC20 gas: exactOut, one trade, one hop 1`] = `
Object {
  "calldataByteLength": 516,
  "gasUsed": 114182,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Universal Router. ERC20 --> ERC20 gas: exactOut, one trade, three hops 1`] = `
Object {
  "calldataByteLength": 548,
  "gasUsed": 251696,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Universal Router. ERC20 --> ERC20 gas: exactOut, one trade, two hops 1`] = `
Object {
  "calldataByteLength": 548,
  "gasUsed": 174643,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Universal Router. ERC20 --> ETH gas: exactIn swap 1`] = `
Object {
  "calldataByteLength": 644,
  "gasUsed": 123187,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Universal Router. ERC20 --> ETH gas: exactOut swap 1`] = `
Object {
  "calldataByteLength": 644,
  "gasUsed": 130748,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Universal Router. ETH --> ERC20 gas: exactIn swap 1`] = `
Object {
  "calldataByteLength": 644,
  "gasUsed": 216591,
}
`;

exports[`Uniswap Gas Tests Trade on UniswapV3 with Universal Router. ETH --> ERC20 gas: exactOut swap 1`] = `
Object {
  "calldataByteLength": 772,
  "gasUsed": 125977,
}
`;
</file>

<file path="test/integration-tests/gas-tests/__snapshots__/UniversalRouter.gas.test.ts.snap">
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`UniversalRouter Gas Tests gas: bytecode size 1`] = `18469`;
</file>

<file path="test/integration-tests/gas-tests/__snapshots__/UniversalVSSwapRouter.gas.test.ts.snap">
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Uniswap UX Tests gas: Approvals Cost for infinite approval of permit2/swaprouter02 contract 1`] = `
Object {
  "calldataByteLength": 68,
  "gasUsed": 55846,
}
`;

exports[`Uniswap UX Tests gas: Comparisons Casual Swapper - 3 swaps Permit2 Max Approval Swap 1`] = `1115454`;

exports[`Uniswap UX Tests gas: Comparisons Casual Swapper - 3 swaps Permit2 Sign Per Swap 1`] = `1150159`;

exports[`Uniswap UX Tests gas: Comparisons Casual Swapper - 3 swaps SwapRouter02 1`] = `1124979`;

exports[`Uniswap UX Tests gas: Comparisons Frequent Swapper - 10 swaps Permit2 Max Approval Swap 1`] = `3114152`;

exports[`Uniswap UX Tests gas: Comparisons Frequent Swapper - 10 swaps Permit2 Sign Per Swap 1`] = `3269019`;

exports[`Uniswap UX Tests gas: Comparisons Frequent Swapper - 10 swaps SwapRouter02 1`] = `3195011`;

exports[`Uniswap UX Tests gas: Comparisons Frequent Swapper across 3 swap router versions - 15 swaps across 3 versions Permit2 Max Approval Swap 1`] = `4146229`;

exports[`Uniswap UX Tests gas: Comparisons Frequent Swapper across 3 swap router versions - 15 swaps across 3 versions Permit2 Sign Per Swap 1`] = `4352007`;

exports[`Uniswap UX Tests gas: Comparisons Frequent Swapper across 3 swap router versions - 15 swaps across 3 versions SwapRouter02 1`] = `4282374`;

exports[`Uniswap UX Tests gas: Comparisons One Time Swapper - Complex Swap Permit2 Max Approval Swap 1`] = `513474`;

exports[`Uniswap UX Tests gas: Comparisons One Time Swapper - Complex Swap Permit2 Sign Per Swap 1`] = `513792`;

exports[`Uniswap UX Tests gas: Comparisons One Time Swapper - Complex Swap SwapRouter02 1`] = `500008`;

exports[`Uniswap UX Tests gas: Comparisons One Time Swapper - Simple Swap Permit2 Max Approval Swap 1`] = `301777`;

exports[`Uniswap UX Tests gas: Comparisons One Time Swapper - Simple Swap Permit2 Sign Per Swap 1`] = `301713`;

exports[`Uniswap UX Tests gas: Comparisons One Time Swapper - Simple Swap SwapRouter02 1`] = `270033`;
</file>

<file path="test/integration-tests/gas-tests/__snapshots__/V3ToV4Migration.gas.test.ts.snap">
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`V3 to V4 Migration Gas Tests V3 Commands burn gas: erc721permit + decreaseLiquidity + collect + burn 1`] = `
Object {
  "calldataByteLength": 1092,
  "gasUsed": 256864,
}
`;

exports[`V3 to V4 Migration Gas Tests V3 Commands collect gas: erc721permit + decreaseLiquidity + collect 1`] = `
Object {
  "calldataByteLength": 964,
  "gasUsed": 224512,
}
`;

exports[`V3 to V4 Migration Gas Tests V3 Commands decrease liquidity gas: erc721permit + decreaseLiquidity 1`] = `
Object {
  "calldataByteLength": 740,
  "gasUsed": 202607,
}
`;

exports[`V3 to V4 Migration Gas Tests V3 Commands erc721permit gas: erc721permit 1`] = `
Object {
  "calldataByteLength": 484,
  "gasUsed": 66280,
}
`;

exports[`V3 to V4 Migration Gas Tests V4 Commands initialize pool gas: initialize a pool 1`] = `
Object {
  "calldataByteLength": 452,
  "gasUsed": 59163,
}
`;

exports[`V3 to V4 Migration Gas Tests V4 Commands mint gas: migrate and mint 1`] = `
Object {
  "calldataByteLength": 2500,
  "gasUsed": 597216,
}
`;

exports[`V3 to V4 Migration Gas Tests V4 Commands mint gas: migrate weth position into eth position with forwarding 1`] = `
Object {
  "calldataByteLength": 2788,
  "gasUsed": 574445,
}
`;

exports[`V3 to V4 Migration Gas Tests V4 Commands mint gas: mint 1`] = `
Object {
  "calldataByteLength": 1604,
  "gasUsed": 443107,
}
`;
</file>

<file path=".env.example">
INFURA_API_KEY=
</file>

<file path=".gitignore">
# Compiler files
cache/
cache_hardhat/
out/

# Ignores development broadcast logs
!/broadcast
/broadcast/*
/broadcast/*/31337/

node_modules
.env
coverage
coverage.json
typechain
typechain-types

#Hardhat files
cache
artifacts

# Yarn files
.yarn/
.yarnrc.yml
</file>

<file path=".gitmodules">
[submodule "lib/forge-std"]
	path = lib/forge-std
	url = https://github.com/foundry-rs/forge-std
[submodule "lib/solmate"]
	path = lib/solmate
	url = https://github.com/transmissions11/solmate
[submodule "lib/permit2"]
	path = lib/permit2
	url = https://github.com/Uniswap/permit2
[submodule "lib/v3-periphery"]
	path = lib/v3-periphery
	url = https://github.com/uniswap/v3-periphery
[submodule "lib/v4-periphery"]
	path = lib/v4-periphery
	url = https://github.com/Uniswap/v4-periphery
	branch = main
</file>

<file path=".nvmrc">
v16
</file>

<file path=".prettierignore">
lib
typechain
cache
artifacts
broadcast
out
openzeppelin-contracts
permit2
solmate
cache_hardhat
</file>

<file path=".prettierrc">
{
  "semi": false,
  "singleQuote": true,
  "printWidth": 120
}
</file>

<file path="foundry.lock">
{
  "lib/forge-std": {
    "rev": "73d44ec7d124e3831bc5f832267889ffb6f9bc3f"
  },
  "lib/permit2": {
    "rev": "cc56ad0f3439c502c246fc5cfcc3db92bb8b7219"
  },
  "lib/solmate": {
    "rev": "8d910d876f51c3b2585c9109409d601f600e68e1"
  },
  "lib/v3-periphery": {
    "rev": "b325bb0905d922ae61fcc7df85ee802e8df5e96c"
  },
  "lib/v4-periphery": {
    "branch": {
      "name": "main",
      "rev": "3779387e5d296f39df543d23524b050f89a62917"
    }
  }
}
</file>

<file path="foundry.toml">
[profile.default]
src = 'contracts'
out = 'out'
libs = ['lib']
via_ir = true
solc_version = '0.8.26'
evm_version = "cancun"

optimizer_runs = 4444
fs_permissions = [{ access = "read", path = "./script/deployParameters/"}]

additional_compiler_profiles = [
  { name = "manager", via_ir = true, optimizer_runs = 30000 },
]

compilation_restrictions = [
  { paths = "lib/v4-periphery/src/PositionManager.sol", optimizer_runs = 30000 },
]

[lint]
lint_on_build = false

[fmt]
line_length = 120
quote_style = 'single'

[profile.lite.optimizer_details.yulDetails]
optimizerSteps = ''

[rpc_endpoints]
sepolia = "https://rpc.sepolia.org"
unichain_sepolia = "https://sepolia.unichain.org"
base_sepolia = "https://sepolia.base.org"
op_sepolia = "https://sepolia.optimism.io"
mainnet = "https://mainnet.infura.io/v3/${INFURA_API_KEY}"

# See more config options https://github.com/foundry-rs/foundry/tree/master/config
</file>

<file path="LICENSE">
GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
</file>

<file path="README.md">
# Universal Router

Please read the [Contributions](https://github.com/Uniswap/universal-router#contributions) section before submitting a Pull Request.

To see the commit of the smart contracts that was used in the latest deployment, see branch `deployed-commit`. To see the addresses of this latest deployment on each network, see folder `deploy-addresses`.

## High-Level Overview

The Universal Router is a ERC20 and NFT swap router that allows users greater flexibility when performing trades across multiple token types.

Our flexible command style allows us to provide users with:

- Splitting and interleaving of Uniswap trades
- Purchases of NFTs across 8 marketplaces
- Partial fills of trades
- Wrapping and Unwrapping of ETH
- Time-bound, signature controlled token approvals using [Permit2](https://github.com/Uniswap/permit2)

Transactions are encoded using a string of commands, allowing users to have maximum flexibility over what they want to perform. With all of these features available in a single transaction, the possibilities available to users are endless

## Contract Overview

The Universal Router codebase consists of the `UniversalRouter` contract, and all of its dependencies. The purpose of the `UniversalRouter` is to allow users to unify Uniswap ERC20 swaps (on V2 and V3) with NFT purchases across 8 marketplaces, in a single transaction.

`UniversalRouter` integrates with [Permit2](https://github.com/Uniswap/permit2), to enable users to have more safety, flexibility, and control over their ERC20 token approvals.

### UniversalRouter command encoding

Calls to `UniversalRouter.execute`, the entrypoint to the contracts, provide 2 main parameters:

- `bytes commands`: A bytes string. Each individual byte represents 1 command that the transaction will execute.
- `bytes[] inputs`: An array of bytes strings. Each element in the array is the encoded parameters for a command.

`commands[i]` is the command that will use `inputs[i]` as its encoded input parameters.

Through function overloading there is also an optional third parameter for the `execute` function:

- `uint256 deadline`: The timestamp deadline by which this transaction must be executed. Transactions executed after this specified deadline will revert.

#### How the command byte is structured

Each command is a `bytes1` containing the following 8 bits:

```
 0 1 2 3 4 5 6 7

fr|  command  

```

- `f` is a single bit flag, that signals whether or not the command should be allowed to revert. If `f` is `false`, and the command reverts, then the entire transaction will revert. If `f` is `true` and the command reverts then the transaction will continue, allowing us to achieve partial fills. If using this flag, be careful to include further commands that will remove any funds that could be left unused in the `UniversalRouter` contract.

- `r` is one bit of reserved space. This will allow us to increase the space used for commands, or add new flags in future.

- `command` is a 6 bit unique identifier for the command that should be carried out. The values of these commands can be found within Commands.sol, or can be viewed in the table below.

```
   
    0x00   V3_SWAP_EXACT_IN             
   
    0x01   V3_SWAP_EXACT_OUT            
   
    0x02   PERMIT2_TRANSFER_FROM        
   
    0x03   PERMIT2_PERMIT_BATCH         
   
    0x04   SWEEP                        
   
    0x05   TRANSFER                     
   
    0x06   PAY_PORTION                  
   
    0x07   -------                      
   
    0x08   V2_SWAP_EXACT_IN             
   
    0x09   V2_SWAP_EXACT_OUT            
   
    0x0a   PERMIT2_PERMIT               
   
    0x0b   WRAP_ETH                     
   
    0x0c   UNWRAP_WETH                  
   
    0x0d   PERMIT2_TRANSFER_FROM_BATCH  
   
    0x0e-  -------                      
    0x20                                
   
    0x21   EXECUTE_SUB_PLAN             
   
    0x22-  -------                      
    0x3f                                
   
```

Note that some of the commands in the middle of the series are unused. These gaps allowed us to create gas-efficiencies when selecting which command to execute.

#### How the input bytes are structures

Each input bytes string is merely the abi encoding of a set of parameters. Depending on the command chosen, the input bytes string will be different. For example:

The inputs for `V3_SWAP_EXACT_IN` is the encoding of 5 parameters:

- `address` The recipient of the output of the trade
- `uint256` The amount of input tokens for the trade
- `uint256` The minimum amount of output tokens the user wants
- `bytes` The UniswapV3 path you want to trade along
- `bool` A flag for whether the input funds should come from the caller (through Permit2) or whether the funds are already in the UniversalRouter

Whereas in contrast `CRYPTOPUNKS` has just 3 parameters encoded:

- `uint256` The ID of the punk you wish to purchase
- `address` The recipient of the punk
- `uint256` The amount of ETH to pay for the punk

Encoding parameters in a bytes string in this way gives us maximum flexiblity to be able to support many commands which require different datatypes in a gas-efficient way.

For a more detailed breakdown of which parameters you should provide for each command take a look at the `Dispatcher.dispatch` function, or alternatively at the `ABI_DEFINITION` mapping in `planner.ts`.

Developer documentation to give a detailed explanation of the inputs for every command will be coming soon!

## Usage

### To Compile and Run Tests

1. Clone the repository with all submodules

Clone the repository with:
```
git clone --recurse-submodules https://github.com/Uniswap/universal-router.git
```

2. Create `.env` file with api key

```
INFURA_API_KEY='xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
```

3. Run yarn commands to compile and test

### To Run Hardhat Tests

```console
yarn install
yarn compile
yarn test
```

If you run into an issue on `yarn compile` where it cannot find the dependencies in the lib folder try to clone all the submodules with:
```
git submodule update --init --recursive
```

#### To Update Hardhat Gas Snapshots

```console
yarn test:gas
```

### To Run Forge Tests

```console
forge install
forge build
forge test
```
## Integrating

1. Install the latest version of `@uniswap/universal-router` package.
2. Add git submodules for contracts that aren't a node package. Make sure there's an empty `.gitmodules` file. Then run:
    ```bash
      git submodule add https://github.com/transmissions11/solmate
      git submodule add https://github.com/Uniswap/permit2
    ```
3. You should now be able to import contracts from universal-router and compile.

## Contributions
Before you submit your PR, run all of the following and commit the changes:
```bash
# make sure all tests pass this will also update gas snapshots
yarn test:all

# lint code
yarn prettier:fix
```

If you are only concerned with investigating gas diffs, you can run this command to only run gas tests
```bash
yarn test:gas
```

### To Deploy

Fill out parameters in `script/deployParameters/Deploy<network>.s.sol`

```console
forge script --broadcast \
--rpc-url <RPC-URL> \
--private-key <PRIVATE_KEY> \
--sig 'run()' \
script/deployParameters/Deploy<network>.s.sol:Deploy<network>
```

### To Deploy and Verify

```console
forge script --broadcast \
--rpc-url <RPC-URL> \
--private-key <PRIVATE-KEY> \
--sig 'run()' \
script/deployParameters/Deploy<network>.s.sol:Deploy<network> \
--etherscan-api-key <ETHERSCAN-API-KEY> \
--verify
```

#### To Deploy Permit2 Alongside UniversalRouter

Fill out parameters in `scripts/deployParameters/<network>.json`

```console
forge script --broadcast \
--rpc-url <RPC-URL> \
--private-key <PRIVATE_KEY> \
--sig 'runAndDeployPermit2(string)' \
script/deployParameters/DeployUniversalRouter.s.sol:DeployUniversalRouter \
<pathToJSON>
```
</file>

<file path="remappings.txt">
solmate/=lib/solmate/
permit2/=lib/permit2/
forge-std/=lib/forge-std/src/
@uniswap/v3-core/=node_modules/@uniswap/v3-core/
@uniswap/v2-core/=node_modules/@uniswap/v2-core/
@uniswap/v3-periphery/=lib/v3-periphery/
@uniswap/v4-periphery/=lib/v4-periphery/
</file>

</files>
